use crate::prelude::*;
RT_STRUCT! { struct Color {
    A: u8, R: u8, G: u8, B: u8,
}}
DEFINE_IID!(IID_IColorHelper, 423427047, 26055, 17728, 173, 8, 98, 131, 186, 118, 135, 154);
RT_INTERFACE!{interface IColorHelper(IColorHelperVtbl): IInspectable(IInspectableVtbl) [IID_IColorHelper] {
    
}}
RT_CLASS!{class ColorHelper: IColorHelper}
impl RtActivatable<IColorHelperStatics> for ColorHelper {}
impl RtActivatable<IColorHelperStatics2> for ColorHelper {}
impl ColorHelper {
    #[inline] pub fn from_argb(a: u8, r: u8, g: u8, b: u8) -> Result<Color> {
        <Self as RtActivatable<IColorHelperStatics>>::get_activation_factory().from_argb(a, r, g, b)
    }
    #[inline] pub fn to_display_name(color: Color) -> Result<HString> {
        <Self as RtActivatable<IColorHelperStatics2>>::get_activation_factory().to_display_name(color)
    }
}
DEFINE_CLSID!(ColorHelper(&[87,105,110,100,111,119,115,46,85,73,46,67,111,108,111,114,72,101,108,112,101,114,0]) [CLSID_ColorHelper]);
DEFINE_IID!(IID_IColorHelperStatics, 2231688170, 64362, 16708, 166, 194, 51, 73, 156, 146, 132, 245);
RT_INTERFACE!{static interface IColorHelperStatics(IColorHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IColorHelperStatics] {
    fn FromArgb(&self, a: u8, r: u8, g: u8, b: u8, out: *mut Color) -> HRESULT
}}
impl IColorHelperStatics {
    #[inline] pub fn from_argb(&self, a: u8, r: u8, g: u8, b: u8) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FromArgb)(self as *const _ as *mut _, a, r, g, b, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IColorHelperStatics2, 618245890, 28336, 19348, 133, 92, 252, 240, 129, 141, 154, 22);
RT_INTERFACE!{static interface IColorHelperStatics2(IColorHelperStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IColorHelperStatics2] {
    fn ToDisplayName(&self, color: Color, out: *mut HSTRING) -> HRESULT
}}
impl IColorHelperStatics2 {
    #[inline] pub fn to_display_name(&self, color: Color) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ToDisplayName)(self as *const _ as *mut _, color, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IColors, 2609681190, 19622, 19685, 137, 148, 158, 255, 101, 202, 189, 204);
RT_INTERFACE!{interface IColors(IColorsVtbl): IInspectable(IInspectableVtbl) [IID_IColors] {
    
}}
RT_CLASS!{class Colors: IColors}
impl RtActivatable<IColorsStatics> for Colors {}
impl Colors {
    #[inline] pub fn get_alice_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_alice_blue()
    }
    #[inline] pub fn get_antique_white() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_antique_white()
    }
    #[inline] pub fn get_aqua() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_aqua()
    }
    #[inline] pub fn get_aquamarine() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_aquamarine()
    }
    #[inline] pub fn get_azure() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_azure()
    }
    #[inline] pub fn get_beige() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_beige()
    }
    #[inline] pub fn get_bisque() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_bisque()
    }
    #[inline] pub fn get_black() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_black()
    }
    #[inline] pub fn get_blanched_almond() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_blanched_almond()
    }
    #[inline] pub fn get_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_blue()
    }
    #[inline] pub fn get_blue_violet() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_blue_violet()
    }
    #[inline] pub fn get_brown() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_brown()
    }
    #[inline] pub fn get_burly_wood() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_burly_wood()
    }
    #[inline] pub fn get_cadet_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_cadet_blue()
    }
    #[inline] pub fn get_chartreuse() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_chartreuse()
    }
    #[inline] pub fn get_chocolate() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_chocolate()
    }
    #[inline] pub fn get_coral() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_coral()
    }
    #[inline] pub fn get_cornflower_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_cornflower_blue()
    }
    #[inline] pub fn get_cornsilk() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_cornsilk()
    }
    #[inline] pub fn get_crimson() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_crimson()
    }
    #[inline] pub fn get_cyan() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_cyan()
    }
    #[inline] pub fn get_dark_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_blue()
    }
    #[inline] pub fn get_dark_cyan() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_cyan()
    }
    #[inline] pub fn get_dark_goldenrod() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_goldenrod()
    }
    #[inline] pub fn get_dark_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_gray()
    }
    #[inline] pub fn get_dark_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_green()
    }
    #[inline] pub fn get_dark_khaki() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_khaki()
    }
    #[inline] pub fn get_dark_magenta() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_magenta()
    }
    #[inline] pub fn get_dark_olive_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_olive_green()
    }
    #[inline] pub fn get_dark_orange() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_orange()
    }
    #[inline] pub fn get_dark_orchid() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_orchid()
    }
    #[inline] pub fn get_dark_red() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_red()
    }
    #[inline] pub fn get_dark_salmon() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_salmon()
    }
    #[inline] pub fn get_dark_sea_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_sea_green()
    }
    #[inline] pub fn get_dark_slate_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_slate_blue()
    }
    #[inline] pub fn get_dark_slate_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_slate_gray()
    }
    #[inline] pub fn get_dark_turquoise() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_turquoise()
    }
    #[inline] pub fn get_dark_violet() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dark_violet()
    }
    #[inline] pub fn get_deep_pink() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_deep_pink()
    }
    #[inline] pub fn get_deep_sky_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_deep_sky_blue()
    }
    #[inline] pub fn get_dim_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dim_gray()
    }
    #[inline] pub fn get_dodger_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_dodger_blue()
    }
    #[inline] pub fn get_firebrick() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_firebrick()
    }
    #[inline] pub fn get_floral_white() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_floral_white()
    }
    #[inline] pub fn get_forest_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_forest_green()
    }
    #[inline] pub fn get_fuchsia() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_fuchsia()
    }
    #[inline] pub fn get_gainsboro() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_gainsboro()
    }
    #[inline] pub fn get_ghost_white() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_ghost_white()
    }
    #[inline] pub fn get_gold() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_gold()
    }
    #[inline] pub fn get_goldenrod() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_goldenrod()
    }
    #[inline] pub fn get_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_gray()
    }
    #[inline] pub fn get_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_green()
    }
    #[inline] pub fn get_green_yellow() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_green_yellow()
    }
    #[inline] pub fn get_honeydew() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_honeydew()
    }
    #[inline] pub fn get_hot_pink() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_hot_pink()
    }
    #[inline] pub fn get_indian_red() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_indian_red()
    }
    #[inline] pub fn get_indigo() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_indigo()
    }
    #[inline] pub fn get_ivory() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_ivory()
    }
    #[inline] pub fn get_khaki() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_khaki()
    }
    #[inline] pub fn get_lavender() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_lavender()
    }
    #[inline] pub fn get_lavender_blush() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_lavender_blush()
    }
    #[inline] pub fn get_lawn_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_lawn_green()
    }
    #[inline] pub fn get_lemon_chiffon() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_lemon_chiffon()
    }
    #[inline] pub fn get_light_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_blue()
    }
    #[inline] pub fn get_light_coral() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_coral()
    }
    #[inline] pub fn get_light_cyan() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_cyan()
    }
    #[inline] pub fn get_light_goldenrod_yellow() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_goldenrod_yellow()
    }
    #[inline] pub fn get_light_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_green()
    }
    #[inline] pub fn get_light_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_gray()
    }
    #[inline] pub fn get_light_pink() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_pink()
    }
    #[inline] pub fn get_light_salmon() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_salmon()
    }
    #[inline] pub fn get_light_sea_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_sea_green()
    }
    #[inline] pub fn get_light_sky_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_sky_blue()
    }
    #[inline] pub fn get_light_slate_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_slate_gray()
    }
    #[inline] pub fn get_light_steel_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_steel_blue()
    }
    #[inline] pub fn get_light_yellow() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_light_yellow()
    }
    #[inline] pub fn get_lime() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_lime()
    }
    #[inline] pub fn get_lime_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_lime_green()
    }
    #[inline] pub fn get_linen() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_linen()
    }
    #[inline] pub fn get_magenta() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_magenta()
    }
    #[inline] pub fn get_maroon() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_maroon()
    }
    #[inline] pub fn get_medium_aquamarine() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_aquamarine()
    }
    #[inline] pub fn get_medium_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_blue()
    }
    #[inline] pub fn get_medium_orchid() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_orchid()
    }
    #[inline] pub fn get_medium_purple() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_purple()
    }
    #[inline] pub fn get_medium_sea_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_sea_green()
    }
    #[inline] pub fn get_medium_slate_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_slate_blue()
    }
    #[inline] pub fn get_medium_spring_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_spring_green()
    }
    #[inline] pub fn get_medium_turquoise() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_turquoise()
    }
    #[inline] pub fn get_medium_violet_red() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_medium_violet_red()
    }
    #[inline] pub fn get_midnight_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_midnight_blue()
    }
    #[inline] pub fn get_mint_cream() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_mint_cream()
    }
    #[inline] pub fn get_misty_rose() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_misty_rose()
    }
    #[inline] pub fn get_moccasin() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_moccasin()
    }
    #[inline] pub fn get_navajo_white() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_navajo_white()
    }
    #[inline] pub fn get_navy() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_navy()
    }
    #[inline] pub fn get_old_lace() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_old_lace()
    }
    #[inline] pub fn get_olive() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_olive()
    }
    #[inline] pub fn get_olive_drab() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_olive_drab()
    }
    #[inline] pub fn get_orange() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_orange()
    }
    #[inline] pub fn get_orange_red() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_orange_red()
    }
    #[inline] pub fn get_orchid() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_orchid()
    }
    #[inline] pub fn get_pale_goldenrod() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_pale_goldenrod()
    }
    #[inline] pub fn get_pale_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_pale_green()
    }
    #[inline] pub fn get_pale_turquoise() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_pale_turquoise()
    }
    #[inline] pub fn get_pale_violet_red() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_pale_violet_red()
    }
    #[inline] pub fn get_papaya_whip() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_papaya_whip()
    }
    #[inline] pub fn get_peach_puff() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_peach_puff()
    }
    #[inline] pub fn get_peru() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_peru()
    }
    #[inline] pub fn get_pink() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_pink()
    }
    #[inline] pub fn get_plum() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_plum()
    }
    #[inline] pub fn get_powder_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_powder_blue()
    }
    #[inline] pub fn get_purple() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_purple()
    }
    #[inline] pub fn get_red() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_red()
    }
    #[inline] pub fn get_rosy_brown() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_rosy_brown()
    }
    #[inline] pub fn get_royal_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_royal_blue()
    }
    #[inline] pub fn get_saddle_brown() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_saddle_brown()
    }
    #[inline] pub fn get_salmon() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_salmon()
    }
    #[inline] pub fn get_sandy_brown() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_sandy_brown()
    }
    #[inline] pub fn get_sea_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_sea_green()
    }
    #[inline] pub fn get_sea_shell() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_sea_shell()
    }
    #[inline] pub fn get_sienna() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_sienna()
    }
    #[inline] pub fn get_silver() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_silver()
    }
    #[inline] pub fn get_sky_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_sky_blue()
    }
    #[inline] pub fn get_slate_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_slate_blue()
    }
    #[inline] pub fn get_slate_gray() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_slate_gray()
    }
    #[inline] pub fn get_snow() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_snow()
    }
    #[inline] pub fn get_spring_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_spring_green()
    }
    #[inline] pub fn get_steel_blue() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_steel_blue()
    }
    #[inline] pub fn get_tan() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_tan()
    }
    #[inline] pub fn get_teal() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_teal()
    }
    #[inline] pub fn get_thistle() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_thistle()
    }
    #[inline] pub fn get_tomato() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_tomato()
    }
    #[inline] pub fn get_transparent() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_transparent()
    }
    #[inline] pub fn get_turquoise() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_turquoise()
    }
    #[inline] pub fn get_violet() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_violet()
    }
    #[inline] pub fn get_wheat() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_wheat()
    }
    #[inline] pub fn get_white() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_white()
    }
    #[inline] pub fn get_white_smoke() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_white_smoke()
    }
    #[inline] pub fn get_yellow() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_yellow()
    }
    #[inline] pub fn get_yellow_green() -> Result<Color> {
        <Self as RtActivatable<IColorsStatics>>::get_activation_factory().get_yellow_green()
    }
}
DEFINE_CLSID!(Colors(&[87,105,110,100,111,119,115,46,85,73,46,67,111,108,111,114,115,0]) [CLSID_Colors]);
DEFINE_IID!(IID_IColorsStatics, 3488951812, 52390, 17940, 161, 126, 117, 73, 16, 200, 74, 153);
RT_INTERFACE!{static interface IColorsStatics(IColorsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IColorsStatics] {
    fn get_AliceBlue(&self, out: *mut Color) -> HRESULT,
    fn get_AntiqueWhite(&self, out: *mut Color) -> HRESULT,
    fn get_Aqua(&self, out: *mut Color) -> HRESULT,
    fn get_Aquamarine(&self, out: *mut Color) -> HRESULT,
    fn get_Azure(&self, out: *mut Color) -> HRESULT,
    fn get_Beige(&self, out: *mut Color) -> HRESULT,
    fn get_Bisque(&self, out: *mut Color) -> HRESULT,
    fn get_Black(&self, out: *mut Color) -> HRESULT,
    fn get_BlanchedAlmond(&self, out: *mut Color) -> HRESULT,
    fn get_Blue(&self, out: *mut Color) -> HRESULT,
    fn get_BlueViolet(&self, out: *mut Color) -> HRESULT,
    fn get_Brown(&self, out: *mut Color) -> HRESULT,
    fn get_BurlyWood(&self, out: *mut Color) -> HRESULT,
    fn get_CadetBlue(&self, out: *mut Color) -> HRESULT,
    fn get_Chartreuse(&self, out: *mut Color) -> HRESULT,
    fn get_Chocolate(&self, out: *mut Color) -> HRESULT,
    fn get_Coral(&self, out: *mut Color) -> HRESULT,
    fn get_CornflowerBlue(&self, out: *mut Color) -> HRESULT,
    fn get_Cornsilk(&self, out: *mut Color) -> HRESULT,
    fn get_Crimson(&self, out: *mut Color) -> HRESULT,
    fn get_Cyan(&self, out: *mut Color) -> HRESULT,
    fn get_DarkBlue(&self, out: *mut Color) -> HRESULT,
    fn get_DarkCyan(&self, out: *mut Color) -> HRESULT,
    fn get_DarkGoldenrod(&self, out: *mut Color) -> HRESULT,
    fn get_DarkGray(&self, out: *mut Color) -> HRESULT,
    fn get_DarkGreen(&self, out: *mut Color) -> HRESULT,
    fn get_DarkKhaki(&self, out: *mut Color) -> HRESULT,
    fn get_DarkMagenta(&self, out: *mut Color) -> HRESULT,
    fn get_DarkOliveGreen(&self, out: *mut Color) -> HRESULT,
    fn get_DarkOrange(&self, out: *mut Color) -> HRESULT,
    fn get_DarkOrchid(&self, out: *mut Color) -> HRESULT,
    fn get_DarkRed(&self, out: *mut Color) -> HRESULT,
    fn get_DarkSalmon(&self, out: *mut Color) -> HRESULT,
    fn get_DarkSeaGreen(&self, out: *mut Color) -> HRESULT,
    fn get_DarkSlateBlue(&self, out: *mut Color) -> HRESULT,
    fn get_DarkSlateGray(&self, out: *mut Color) -> HRESULT,
    fn get_DarkTurquoise(&self, out: *mut Color) -> HRESULT,
    fn get_DarkViolet(&self, out: *mut Color) -> HRESULT,
    fn get_DeepPink(&self, out: *mut Color) -> HRESULT,
    fn get_DeepSkyBlue(&self, out: *mut Color) -> HRESULT,
    fn get_DimGray(&self, out: *mut Color) -> HRESULT,
    fn get_DodgerBlue(&self, out: *mut Color) -> HRESULT,
    fn get_Firebrick(&self, out: *mut Color) -> HRESULT,
    fn get_FloralWhite(&self, out: *mut Color) -> HRESULT,
    fn get_ForestGreen(&self, out: *mut Color) -> HRESULT,
    fn get_Fuchsia(&self, out: *mut Color) -> HRESULT,
    fn get_Gainsboro(&self, out: *mut Color) -> HRESULT,
    fn get_GhostWhite(&self, out: *mut Color) -> HRESULT,
    fn get_Gold(&self, out: *mut Color) -> HRESULT,
    fn get_Goldenrod(&self, out: *mut Color) -> HRESULT,
    fn get_Gray(&self, out: *mut Color) -> HRESULT,
    fn get_Green(&self, out: *mut Color) -> HRESULT,
    fn get_GreenYellow(&self, out: *mut Color) -> HRESULT,
    fn get_Honeydew(&self, out: *mut Color) -> HRESULT,
    fn get_HotPink(&self, out: *mut Color) -> HRESULT,
    fn get_IndianRed(&self, out: *mut Color) -> HRESULT,
    fn get_Indigo(&self, out: *mut Color) -> HRESULT,
    fn get_Ivory(&self, out: *mut Color) -> HRESULT,
    fn get_Khaki(&self, out: *mut Color) -> HRESULT,
    fn get_Lavender(&self, out: *mut Color) -> HRESULT,
    fn get_LavenderBlush(&self, out: *mut Color) -> HRESULT,
    fn get_LawnGreen(&self, out: *mut Color) -> HRESULT,
    fn get_LemonChiffon(&self, out: *mut Color) -> HRESULT,
    fn get_LightBlue(&self, out: *mut Color) -> HRESULT,
    fn get_LightCoral(&self, out: *mut Color) -> HRESULT,
    fn get_LightCyan(&self, out: *mut Color) -> HRESULT,
    fn get_LightGoldenrodYellow(&self, out: *mut Color) -> HRESULT,
    fn get_LightGreen(&self, out: *mut Color) -> HRESULT,
    fn get_LightGray(&self, out: *mut Color) -> HRESULT,
    fn get_LightPink(&self, out: *mut Color) -> HRESULT,
    fn get_LightSalmon(&self, out: *mut Color) -> HRESULT,
    fn get_LightSeaGreen(&self, out: *mut Color) -> HRESULT,
    fn get_LightSkyBlue(&self, out: *mut Color) -> HRESULT,
    fn get_LightSlateGray(&self, out: *mut Color) -> HRESULT,
    fn get_LightSteelBlue(&self, out: *mut Color) -> HRESULT,
    fn get_LightYellow(&self, out: *mut Color) -> HRESULT,
    fn get_Lime(&self, out: *mut Color) -> HRESULT,
    fn get_LimeGreen(&self, out: *mut Color) -> HRESULT,
    fn get_Linen(&self, out: *mut Color) -> HRESULT,
    fn get_Magenta(&self, out: *mut Color) -> HRESULT,
    fn get_Maroon(&self, out: *mut Color) -> HRESULT,
    fn get_MediumAquamarine(&self, out: *mut Color) -> HRESULT,
    fn get_MediumBlue(&self, out: *mut Color) -> HRESULT,
    fn get_MediumOrchid(&self, out: *mut Color) -> HRESULT,
    fn get_MediumPurple(&self, out: *mut Color) -> HRESULT,
    fn get_MediumSeaGreen(&self, out: *mut Color) -> HRESULT,
    fn get_MediumSlateBlue(&self, out: *mut Color) -> HRESULT,
    fn get_MediumSpringGreen(&self, out: *mut Color) -> HRESULT,
    fn get_MediumTurquoise(&self, out: *mut Color) -> HRESULT,
    fn get_MediumVioletRed(&self, out: *mut Color) -> HRESULT,
    fn get_MidnightBlue(&self, out: *mut Color) -> HRESULT,
    fn get_MintCream(&self, out: *mut Color) -> HRESULT,
    fn get_MistyRose(&self, out: *mut Color) -> HRESULT,
    fn get_Moccasin(&self, out: *mut Color) -> HRESULT,
    fn get_NavajoWhite(&self, out: *mut Color) -> HRESULT,
    fn get_Navy(&self, out: *mut Color) -> HRESULT,
    fn get_OldLace(&self, out: *mut Color) -> HRESULT,
    fn get_Olive(&self, out: *mut Color) -> HRESULT,
    fn get_OliveDrab(&self, out: *mut Color) -> HRESULT,
    fn get_Orange(&self, out: *mut Color) -> HRESULT,
    fn get_OrangeRed(&self, out: *mut Color) -> HRESULT,
    fn get_Orchid(&self, out: *mut Color) -> HRESULT,
    fn get_PaleGoldenrod(&self, out: *mut Color) -> HRESULT,
    fn get_PaleGreen(&self, out: *mut Color) -> HRESULT,
    fn get_PaleTurquoise(&self, out: *mut Color) -> HRESULT,
    fn get_PaleVioletRed(&self, out: *mut Color) -> HRESULT,
    fn get_PapayaWhip(&self, out: *mut Color) -> HRESULT,
    fn get_PeachPuff(&self, out: *mut Color) -> HRESULT,
    fn get_Peru(&self, out: *mut Color) -> HRESULT,
    fn get_Pink(&self, out: *mut Color) -> HRESULT,
    fn get_Plum(&self, out: *mut Color) -> HRESULT,
    fn get_PowderBlue(&self, out: *mut Color) -> HRESULT,
    fn get_Purple(&self, out: *mut Color) -> HRESULT,
    fn get_Red(&self, out: *mut Color) -> HRESULT,
    fn get_RosyBrown(&self, out: *mut Color) -> HRESULT,
    fn get_RoyalBlue(&self, out: *mut Color) -> HRESULT,
    fn get_SaddleBrown(&self, out: *mut Color) -> HRESULT,
    fn get_Salmon(&self, out: *mut Color) -> HRESULT,
    fn get_SandyBrown(&self, out: *mut Color) -> HRESULT,
    fn get_SeaGreen(&self, out: *mut Color) -> HRESULT,
    fn get_SeaShell(&self, out: *mut Color) -> HRESULT,
    fn get_Sienna(&self, out: *mut Color) -> HRESULT,
    fn get_Silver(&self, out: *mut Color) -> HRESULT,
    fn get_SkyBlue(&self, out: *mut Color) -> HRESULT,
    fn get_SlateBlue(&self, out: *mut Color) -> HRESULT,
    fn get_SlateGray(&self, out: *mut Color) -> HRESULT,
    fn get_Snow(&self, out: *mut Color) -> HRESULT,
    fn get_SpringGreen(&self, out: *mut Color) -> HRESULT,
    fn get_SteelBlue(&self, out: *mut Color) -> HRESULT,
    fn get_Tan(&self, out: *mut Color) -> HRESULT,
    fn get_Teal(&self, out: *mut Color) -> HRESULT,
    fn get_Thistle(&self, out: *mut Color) -> HRESULT,
    fn get_Tomato(&self, out: *mut Color) -> HRESULT,
    fn get_Transparent(&self, out: *mut Color) -> HRESULT,
    fn get_Turquoise(&self, out: *mut Color) -> HRESULT,
    fn get_Violet(&self, out: *mut Color) -> HRESULT,
    fn get_Wheat(&self, out: *mut Color) -> HRESULT,
    fn get_White(&self, out: *mut Color) -> HRESULT,
    fn get_WhiteSmoke(&self, out: *mut Color) -> HRESULT,
    fn get_Yellow(&self, out: *mut Color) -> HRESULT,
    fn get_YellowGreen(&self, out: *mut Color) -> HRESULT
}}
impl IColorsStatics {
    #[inline] pub fn get_alice_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AliceBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_antique_white(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AntiqueWhite)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aqua(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Aqua)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aquamarine(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Aquamarine)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_azure(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Azure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_beige(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Beige)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bisque(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bisque)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_black(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Black)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blanched_almond(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BlanchedAlmond)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Blue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blue_violet(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BlueViolet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_brown(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Brown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_burly_wood(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BurlyWood)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cadet_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CadetBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_chartreuse(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Chartreuse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_chocolate(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Chocolate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_coral(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Coral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cornflower_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornflowerBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cornsilk(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cornsilk)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_crimson(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Crimson)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cyan(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cyan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_cyan(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkCyan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_goldenrod(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkGoldenrod)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkGray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_khaki(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkKhaki)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_magenta(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkMagenta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_olive_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkOliveGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_orange(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkOrange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_orchid(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkOrchid)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_red(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkRed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_salmon(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkSalmon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_sea_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkSeaGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_slate_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkSlateBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_slate_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkSlateGray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_turquoise(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkTurquoise)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dark_violet(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DarkViolet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deep_pink(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeepPink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deep_sky_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeepSkyBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dim_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DimGray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dodger_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DodgerBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_firebrick(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Firebrick)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_floral_white(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FloralWhite)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_forest_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForestGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_fuchsia(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Fuchsia)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gainsboro(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Gainsboro)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ghost_white(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GhostWhite)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gold(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Gold)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_goldenrod(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Goldenrod)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Gray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Green)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_green_yellow(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GreenYellow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_honeydew(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Honeydew)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hot_pink(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HotPink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_indian_red(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IndianRed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_indigo(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Indigo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ivory(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Ivory)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_khaki(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Khaki)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lavender(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Lavender)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lavender_blush(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LavenderBlush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lawn_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LawnGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lemon_chiffon(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LemonChiffon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_coral(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightCoral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_cyan(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightCyan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_goldenrod_yellow(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightGoldenrodYellow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightGray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_pink(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightPink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_salmon(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightSalmon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_sea_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightSeaGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_sky_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightSkyBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_slate_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightSlateGray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_steel_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightSteelBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light_yellow(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LightYellow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lime(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Lime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lime_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LimeGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_linen(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Linen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magenta(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Magenta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_maroon(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Maroon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_aquamarine(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumAquamarine)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_orchid(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumOrchid)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_purple(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumPurple)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_sea_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumSeaGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_slate_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumSlateBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_spring_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumSpringGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_turquoise(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumTurquoise)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium_violet_red(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MediumVioletRed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_midnight_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MidnightBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mint_cream(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MintCream)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_misty_rose(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MistyRose)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_moccasin(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Moccasin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_navajo_white(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NavajoWhite)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_navy(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Navy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_old_lace(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OldLace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_olive(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Olive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_olive_drab(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OliveDrab)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orange(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orange_red(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OrangeRed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orchid(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orchid)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pale_goldenrod(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PaleGoldenrod)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pale_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PaleGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pale_turquoise(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PaleTurquoise)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pale_violet_red(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PaleVioletRed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_papaya_whip(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PapayaWhip)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_peach_puff(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PeachPuff)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_peru(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Peru)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pink(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_plum(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Plum)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_powder_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PowderBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_purple(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Purple)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Red)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rosy_brown(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RosyBrown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_royal_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RoyalBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_saddle_brown(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SaddleBrown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_salmon(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Salmon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sandy_brown(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SandyBrown)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sea_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SeaGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sea_shell(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SeaShell)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sienna(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Sienna)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_silver(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Silver)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sky_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SkyBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_slate_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SlateBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_slate_gray(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SlateGray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_snow(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Snow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_spring_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpringGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_steel_blue(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SteelBlue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tan(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Tan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_teal(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Teal)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thistle(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Thistle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tomato(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Tomato)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transparent(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Transparent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_turquoise(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Turquoise)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_violet(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Violet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_wheat(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Wheat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_white(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_White)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_white_smoke(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WhiteSmoke)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_yellow(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Yellow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_yellow_green(&self) -> Result<Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_YellowGreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
pub mod accessibility { // Windows.UI.Accessibility
use crate::prelude::*;
DEFINE_IID!(IID_IScreenReaderPositionChangedEventArgs, 1434367461, 21712, 23757, 159, 197, 237, 51, 53, 127, 138, 159);
RT_INTERFACE!{interface IScreenReaderPositionChangedEventArgs(IScreenReaderPositionChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IScreenReaderPositionChangedEventArgs] {
    fn get_ScreenPositionInRawPixels(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_IsReadingText(&self, out: *mut bool) -> HRESULT
}}
impl IScreenReaderPositionChangedEventArgs {
    #[inline] pub fn get_screen_position_in_raw_pixels(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScreenPositionInRawPixels)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_reading_text(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadingText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ScreenReaderPositionChangedEventArgs: IScreenReaderPositionChangedEventArgs}
DEFINE_IID!(IID_IScreenReaderService, 424104999, 60096, 20691, 189, 217, 155, 72, 122, 34, 98, 86);
RT_INTERFACE!{interface IScreenReaderService(IScreenReaderServiceVtbl): IInspectable(IInspectableVtbl) [IID_IScreenReaderService] {
    fn get_CurrentScreenReaderPosition(&self, out: *mut *mut ScreenReaderPositionChangedEventArgs) -> HRESULT,
    fn add_ScreenReaderPositionChanged(&self, handler: *mut foundation::TypedEventHandler<ScreenReaderService, ScreenReaderPositionChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScreenReaderPositionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IScreenReaderService {
    #[inline] pub fn get_current_screen_reader_position(&self) -> Result<Option<ComPtr<ScreenReaderPositionChangedEventArgs>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentScreenReaderPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_screen_reader_position_changed(&self, handler: &foundation::TypedEventHandler<ScreenReaderService, ScreenReaderPositionChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ScreenReaderPositionChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_screen_reader_position_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ScreenReaderPositionChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ScreenReaderService: IScreenReaderService}
impl RtActivatable<IActivationFactory> for ScreenReaderService {}
DEFINE_CLSID!(ScreenReaderService(&[87,105,110,100,111,119,115,46,85,73,46,65,99,99,101,115,115,105,98,105,108,105,116,121,46,83,99,114,101,101,110,82,101,97,100,101,114,83,101,114,118,105,99,101,0]) [CLSID_ScreenReaderService]);
} // Windows.UI.Accessibility
pub mod applicationsettings { // Windows.UI.ApplicationSettings
use crate::prelude::*;
DEFINE_IID!(IID_IAccountsSettingsPane, 2179634220, 20233, 17414, 165, 56, 131, 141, 155, 20, 183, 230);
RT_INTERFACE!{interface IAccountsSettingsPane(IAccountsSettingsPaneVtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPane] {
    fn add_AccountCommandsRequested(&self, handler: *mut foundation::TypedEventHandler<AccountsSettingsPane, AccountsSettingsPaneCommandsRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccountCommandsRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAccountsSettingsPane {
    #[inline] pub fn add_account_commands_requested(&self, handler: &foundation::TypedEventHandler<AccountsSettingsPane, AccountsSettingsPaneCommandsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AccountCommandsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_account_commands_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_AccountCommandsRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AccountsSettingsPane: IAccountsSettingsPane}
impl RtActivatable<IAccountsSettingsPaneStatics> for AccountsSettingsPane {}
impl RtActivatable<IAccountsSettingsPaneStatics2> for AccountsSettingsPane {}
impl RtActivatable<IAccountsSettingsPaneStatics3> for AccountsSettingsPane {}
impl AccountsSettingsPane {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<AccountsSettingsPane>>> {
        <Self as RtActivatable<IAccountsSettingsPaneStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn show() -> Result<()> {
        <Self as RtActivatable<IAccountsSettingsPaneStatics>>::get_activation_factory().show()
    }
    #[inline] pub fn show_manage_accounts_async() -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IAccountsSettingsPaneStatics2>>::get_activation_factory().show_manage_accounts_async()
    }
    #[inline] pub fn show_add_account_async() -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IAccountsSettingsPaneStatics2>>::get_activation_factory().show_add_account_async()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn show_manage_accounts_for_user_async(user: &super::super::system::User) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IAccountsSettingsPaneStatics3>>::get_activation_factory().show_manage_accounts_for_user_async(user)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn show_add_account_for_user_async(user: &super::super::system::User) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IAccountsSettingsPaneStatics3>>::get_activation_factory().show_add_account_for_user_async(user)
    }
}
DEFINE_CLSID!(AccountsSettingsPane(&[87,105,110,100,111,119,115,46,85,73,46,65,112,112,108,105,99,97,116,105,111,110,83,101,116,116,105,110,103,115,46,65,99,99,111,117,110,116,115,83,101,116,116,105,110,103,115,80,97,110,101,0]) [CLSID_AccountsSettingsPane]);
DEFINE_IID!(IID_IAccountsSettingsPaneCommandsRequestedEventArgs, 996720793, 56089, 17872, 154, 191, 149, 211, 119, 60, 147, 48);
RT_INTERFACE!{interface IAccountsSettingsPaneCommandsRequestedEventArgs(IAccountsSettingsPaneCommandsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPaneCommandsRequestedEventArgs] {
    fn get_WebAccountProviderCommands(&self, out: *mut *mut foundation::collections::IVector<WebAccountProviderCommand>) -> HRESULT,
    fn get_WebAccountCommands(&self, out: *mut *mut foundation::collections::IVector<WebAccountCommand>) -> HRESULT,
    fn get_CredentialCommands(&self, out: *mut *mut foundation::collections::IVector<CredentialCommand>) -> HRESULT,
    fn get_Commands(&self, out: *mut *mut foundation::collections::IVector<SettingsCommand>) -> HRESULT,
    fn get_HeaderText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_HeaderText(&self, value: HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut AccountsSettingsPaneEventDeferral) -> HRESULT
}}
impl IAccountsSettingsPaneCommandsRequestedEventArgs {
    #[inline] pub fn get_web_account_provider_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<WebAccountProviderCommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebAccountProviderCommands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_web_account_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<WebAccountCommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebAccountCommands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_credential_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<CredentialCommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CredentialCommands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<SettingsCommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Commands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_header_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_header_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_HeaderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<AccountsSettingsPaneEventDeferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AccountsSettingsPaneCommandsRequestedEventArgs: IAccountsSettingsPaneCommandsRequestedEventArgs}
DEFINE_IID!(IID_IAccountsSettingsPaneCommandsRequestedEventArgs2, 909081517, 20023, 18791, 140, 64, 231, 142, 231, 161, 229, 187);
RT_INTERFACE!{interface IAccountsSettingsPaneCommandsRequestedEventArgs2(IAccountsSettingsPaneCommandsRequestedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPaneCommandsRequestedEventArgs2] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IAccountsSettingsPaneCommandsRequestedEventArgs2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<ComPtr<super::super::system::User>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccountsSettingsPaneEventDeferral, 3421658431, 58810, 16623, 147, 218, 101, 224, 150, 229, 251, 4);
RT_INTERFACE!{interface IAccountsSettingsPaneEventDeferral(IAccountsSettingsPaneEventDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPaneEventDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IAccountsSettingsPaneEventDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AccountsSettingsPaneEventDeferral: IAccountsSettingsPaneEventDeferral}
DEFINE_IID!(IID_IAccountsSettingsPaneStatics, 1444907872, 45292, 16720, 168, 220, 32, 142, 228, 75, 6, 138);
RT_INTERFACE!{static interface IAccountsSettingsPaneStatics(IAccountsSettingsPaneStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPaneStatics] {
    fn GetForCurrentView(&self, out: *mut *mut AccountsSettingsPane) -> HRESULT,
    fn Show(&self) -> HRESULT
}}
impl IAccountsSettingsPaneStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<AccountsSettingsPane>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn show(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Show)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccountsSettingsPaneStatics2, 3525179330, 52749, 18511, 184, 232, 232, 35, 194, 21, 118, 94);
RT_INTERFACE!{static interface IAccountsSettingsPaneStatics2(IAccountsSettingsPaneStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPaneStatics2] {
    fn ShowManageAccountsAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ShowAddAccountAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl IAccountsSettingsPaneStatics2 {
    #[inline] pub fn show_manage_accounts_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowManageAccountsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_add_account_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAccountAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccountsSettingsPaneStatics3, 138478680, 41658, 19567, 180, 172, 72, 245, 20, 51, 18, 22);
RT_INTERFACE!{static interface IAccountsSettingsPaneStatics3(IAccountsSettingsPaneStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAccountsSettingsPaneStatics3] {
    #[cfg(feature="windows-system")] fn ShowManageAccountsForUserAsync(&self, user: *mut super::super::system::User, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    #[cfg(feature="windows-system")] fn ShowAddAccountForUserAsync(&self, user: *mut super::super::system::User, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl IAccountsSettingsPaneStatics3 {
    #[cfg(feature="windows-system")] #[inline] pub fn show_manage_accounts_for_user_async(&self, user: &super::super::system::User) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowManageAccountsForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn show_add_account_for_user_async(&self, user: &super::super::system::User) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAccountForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICredentialCommand, 2784388582, 24899, 19066, 169, 113, 176, 23, 186, 151, 140, 226);
RT_INTERFACE!{interface ICredentialCommand(ICredentialCommandVtbl): IInspectable(IInspectableVtbl) [IID_ICredentialCommand] {
    #[cfg(not(feature="windows-security"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PasswordCredential(&self, out: *mut *mut super::super::security::credentials::PasswordCredential) -> HRESULT,
    fn get_CredentialDeleted(&self, out: *mut *mut CredentialCommandCredentialDeletedHandler) -> HRESULT
}}
impl ICredentialCommand {
    #[cfg(feature="windows-security")] #[inline] pub fn get_password_credential(&self) -> Result<Option<ComPtr<super::super::security::credentials::PasswordCredential>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PasswordCredential)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_credential_deleted(&self) -> Result<Option<ComPtr<CredentialCommandCredentialDeletedHandler>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CredentialDeleted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CredentialCommand: ICredentialCommand}
impl RtActivatable<ICredentialCommandFactory> for CredentialCommand {}
impl CredentialCommand {
    #[cfg(feature="windows-security")] #[inline] pub fn create_credential_command(passwordCredential: &super::super::security::credentials::PasswordCredential) -> Result<ComPtr<CredentialCommand>> {
        <Self as RtActivatable<ICredentialCommandFactory>>::get_activation_factory().create_credential_command(passwordCredential)
    }
    #[cfg(feature="windows-security")] #[inline] pub fn create_credential_command_with_handler(passwordCredential: &super::super::security::credentials::PasswordCredential, deleted: &CredentialCommandCredentialDeletedHandler) -> Result<ComPtr<CredentialCommand>> {
        <Self as RtActivatable<ICredentialCommandFactory>>::get_activation_factory().create_credential_command_with_handler(passwordCredential, deleted)
    }
}
DEFINE_CLSID!(CredentialCommand(&[87,105,110,100,111,119,115,46,85,73,46,65,112,112,108,105,99,97,116,105,111,110,83,101,116,116,105,110,103,115,46,67,114,101,100,101,110,116,105,97,108,67,111,109,109,97,110,100,0]) [CLSID_CredentialCommand]);
DEFINE_IID!(IID_CredentialCommandCredentialDeletedHandler, 1640030597, 2423, 18040, 180, 226, 152, 114, 122, 251, 238, 217);
RT_DELEGATE!{delegate CredentialCommandCredentialDeletedHandler(CredentialCommandCredentialDeletedHandlerVtbl, CredentialCommandCredentialDeletedHandlerImpl) [IID_CredentialCommandCredentialDeletedHandler] {
    fn Invoke(&self, command: *mut CredentialCommand) -> HRESULT
}}
impl CredentialCommandCredentialDeletedHandler {
    #[inline] pub fn invoke(&self, command: &CredentialCommand) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, command as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICredentialCommandFactory, 669551639, 48190, 19328, 148, 149, 78, 215, 32, 228, 138, 145);
RT_INTERFACE!{static interface ICredentialCommandFactory(ICredentialCommandFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICredentialCommandFactory] {
    #[cfg(feature="windows-security")] fn CreateCredentialCommand(&self, passwordCredential: *mut super::super::security::credentials::PasswordCredential, out: *mut *mut CredentialCommand) -> HRESULT,
    #[cfg(feature="windows-security")] fn CreateCredentialCommandWithHandler(&self, passwordCredential: *mut super::super::security::credentials::PasswordCredential, deleted: *mut CredentialCommandCredentialDeletedHandler, out: *mut *mut CredentialCommand) -> HRESULT
}}
impl ICredentialCommandFactory {
    #[cfg(feature="windows-security")] #[inline] pub fn create_credential_command(&self, passwordCredential: &super::super::security::credentials::PasswordCredential) -> Result<ComPtr<CredentialCommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCredentialCommand)(self as *const _ as *mut _, passwordCredential as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn create_credential_command_with_handler(&self, passwordCredential: &super::super::security::credentials::PasswordCredential, deleted: &CredentialCommandCredentialDeletedHandler) -> Result<ComPtr<CredentialCommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCredentialCommandWithHandler)(self as *const _ as *mut _, passwordCredential as *const _ as *mut _, deleted as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SettingsCommand: super::popups::IUICommand}
impl RtActivatable<ISettingsCommandFactory> for SettingsCommand {}
impl RtActivatable<ISettingsCommandStatics> for SettingsCommand {}
impl SettingsCommand {
    #[inline] pub fn create_settings_command(settingsCommandId: &IInspectable, label: &HStringArg, handler: &super::popups::UICommandInvokedHandler) -> Result<ComPtr<SettingsCommand>> {
        <Self as RtActivatable<ISettingsCommandFactory>>::get_activation_factory().create_settings_command(settingsCommandId, label, handler)
    }
    #[inline] pub fn get_accounts_command() -> Result<Option<ComPtr<SettingsCommand>>> {
        <Self as RtActivatable<ISettingsCommandStatics>>::get_activation_factory().get_accounts_command()
    }
}
DEFINE_CLSID!(SettingsCommand(&[87,105,110,100,111,119,115,46,85,73,46,65,112,112,108,105,99,97,116,105,111,110,83,101,116,116,105,110,103,115,46,83,101,116,116,105,110,103,115,67,111,109,109,97,110,100,0]) [CLSID_SettingsCommand]);
DEFINE_IID!(IID_ISettingsCommandFactory, 1759599411, 7299, 17210, 170, 90, 206, 238, 165, 189, 71, 100);
RT_INTERFACE!{static interface ISettingsCommandFactory(ISettingsCommandFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsCommandFactory] {
    fn CreateSettingsCommand(&self, settingsCommandId: *mut IInspectable, label: HSTRING, handler: *mut super::popups::UICommandInvokedHandler, out: *mut *mut SettingsCommand) -> HRESULT
}}
impl ISettingsCommandFactory {
    #[inline] pub fn create_settings_command(&self, settingsCommandId: &IInspectable, label: &HStringArg, handler: &super::popups::UICommandInvokedHandler) -> Result<ComPtr<SettingsCommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSettingsCommand)(self as *const _ as *mut _, settingsCommandId as *const _ as *mut _, label.get(), handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISettingsCommandStatics, 1956309332, 12137, 19223, 138, 186, 208, 92, 229, 119, 142, 70);
RT_INTERFACE!{static interface ISettingsCommandStatics(ISettingsCommandStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsCommandStatics] {
    fn get_AccountsCommand(&self, out: *mut *mut SettingsCommand) -> HRESULT
}}
impl ISettingsCommandStatics {
    #[inline] pub fn get_accounts_command(&self) -> Result<Option<ComPtr<SettingsCommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccountsCommand)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SettingsEdgeLocation: i32 {
    Right = 0, Left = 1,
}}
DEFINE_IID!(IID_ISettingsPane, 2983004466, 17776, 19561, 141, 56, 137, 68, 101, 97, 172, 224);
RT_INTERFACE!{interface ISettingsPane(ISettingsPaneVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsPane] {
    fn add_CommandsRequested(&self, handler: *mut foundation::TypedEventHandler<SettingsPane, SettingsPaneCommandsRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CommandsRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISettingsPane {
    #[inline] pub fn add_commands_requested(&self, handler: &foundation::TypedEventHandler<SettingsPane, SettingsPaneCommandsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CommandsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_commands_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CommandsRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SettingsPane: ISettingsPane}
impl RtActivatable<ISettingsPaneStatics> for SettingsPane {}
impl SettingsPane {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<SettingsPane>>> {
        <Self as RtActivatable<ISettingsPaneStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn show() -> Result<()> {
        <Self as RtActivatable<ISettingsPaneStatics>>::get_activation_factory().show()
    }
    #[inline] pub fn get_edge() -> Result<SettingsEdgeLocation> {
        <Self as RtActivatable<ISettingsPaneStatics>>::get_activation_factory().get_edge()
    }
}
DEFINE_CLSID!(SettingsPane(&[87,105,110,100,111,119,115,46,85,73,46,65,112,112,108,105,99,97,116,105,111,110,83,101,116,116,105,110,103,115,46,83,101,116,116,105,110,103,115,80,97,110,101,0]) [CLSID_SettingsPane]);
DEFINE_IID!(IID_ISettingsPaneCommandsRequest, 1155474350, 23918, 16488, 161, 104, 244, 118, 67, 24, 33, 20);
RT_INTERFACE!{interface ISettingsPaneCommandsRequest(ISettingsPaneCommandsRequestVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsPaneCommandsRequest] {
    fn get_ApplicationCommands(&self, out: *mut *mut foundation::collections::IVector<SettingsCommand>) -> HRESULT
}}
impl ISettingsPaneCommandsRequest {
    #[inline] pub fn get_application_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<SettingsCommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationCommands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SettingsPaneCommandsRequest: ISettingsPaneCommandsRequest}
DEFINE_IID!(IID_ISettingsPaneCommandsRequestedEventArgs, 543120676, 6984, 17961, 166, 202, 47, 223, 237, 175, 183, 93);
RT_INTERFACE!{interface ISettingsPaneCommandsRequestedEventArgs(ISettingsPaneCommandsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsPaneCommandsRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut SettingsPaneCommandsRequest) -> HRESULT
}}
impl ISettingsPaneCommandsRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<SettingsPaneCommandsRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SettingsPaneCommandsRequestedEventArgs: ISettingsPaneCommandsRequestedEventArgs}
DEFINE_IID!(IID_ISettingsPaneStatics, 476730053, 65305, 18203, 186, 107, 248, 243, 86, 148, 173, 154);
RT_INTERFACE!{static interface ISettingsPaneStatics(ISettingsPaneStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISettingsPaneStatics] {
    fn GetForCurrentView(&self, out: *mut *mut SettingsPane) -> HRESULT,
    fn Show(&self) -> HRESULT,
    fn get_Edge(&self, out: *mut SettingsEdgeLocation) -> HRESULT
}}
impl ISettingsPaneStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<SettingsPane>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn show(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Show)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_edge(&self) -> Result<SettingsEdgeLocation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Edge)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SupportedWebAccountActions: u32 {
    None = 0, Reconnect = 1, Remove = 2, ViewDetails = 4, Manage = 8, More = 16,
}}
RT_ENUM! { enum WebAccountAction: i32 {
    Reconnect = 0, Remove = 1, ViewDetails = 2, Manage = 3, More = 4,
}}
DEFINE_IID!(IID_IWebAccountCommand, 3399717784, 40186, 16966, 176, 196, 169, 19, 163, 137, 101, 65);
RT_INTERFACE!{interface IWebAccountCommand(IWebAccountCommandVtbl): IInspectable(IInspectableVtbl) [IID_IWebAccountCommand] {
    #[cfg(not(feature="windows-security"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-security")] fn get_WebAccount(&self, out: *mut *mut super::super::security::credentials::WebAccount) -> HRESULT,
    fn get_Invoked(&self, out: *mut *mut WebAccountCommandInvokedHandler) -> HRESULT,
    fn get_Actions(&self, out: *mut SupportedWebAccountActions) -> HRESULT
}}
impl IWebAccountCommand {
    #[cfg(feature="windows-security")] #[inline] pub fn get_web_account(&self) -> Result<Option<ComPtr<super::super::security::credentials::WebAccount>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebAccount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_invoked(&self) -> Result<Option<ComPtr<WebAccountCommandInvokedHandler>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Invoked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_actions(&self) -> Result<SupportedWebAccountActions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Actions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WebAccountCommand: IWebAccountCommand}
impl RtActivatable<IWebAccountCommandFactory> for WebAccountCommand {}
impl WebAccountCommand {
    #[cfg(feature="windows-security")] #[inline] pub fn create_web_account_command(webAccount: &super::super::security::credentials::WebAccount, invoked: &WebAccountCommandInvokedHandler, actions: SupportedWebAccountActions) -> Result<ComPtr<WebAccountCommand>> {
        <Self as RtActivatable<IWebAccountCommandFactory>>::get_activation_factory().create_web_account_command(webAccount, invoked, actions)
    }
}
DEFINE_CLSID!(WebAccountCommand(&[87,105,110,100,111,119,115,46,85,73,46,65,112,112,108,105,99,97,116,105,111,110,83,101,116,116,105,110,103,115,46,87,101,98,65,99,99,111,117,110,116,67,111,109,109,97,110,100,0]) [CLSID_WebAccountCommand]);
DEFINE_IID!(IID_IWebAccountCommandFactory, 3215379967, 12077, 17141, 129, 222, 29, 86, 186, 252, 73, 109);
RT_INTERFACE!{static interface IWebAccountCommandFactory(IWebAccountCommandFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWebAccountCommandFactory] {
    #[cfg(feature="windows-security")] fn CreateWebAccountCommand(&self, webAccount: *mut super::super::security::credentials::WebAccount, invoked: *mut WebAccountCommandInvokedHandler, actions: SupportedWebAccountActions, out: *mut *mut WebAccountCommand) -> HRESULT
}}
impl IWebAccountCommandFactory {
    #[cfg(feature="windows-security")] #[inline] pub fn create_web_account_command(&self, webAccount: &super::super::security::credentials::WebAccount, invoked: &WebAccountCommandInvokedHandler, actions: SupportedWebAccountActions) -> Result<ComPtr<WebAccountCommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWebAccountCommand)(self as *const _ as *mut _, webAccount as *const _ as *mut _, invoked as *const _ as *mut _, actions, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_WebAccountCommandInvokedHandler, 518448217, 5893, 19098, 181, 153, 160, 195, 214, 146, 25, 115);
RT_DELEGATE!{delegate WebAccountCommandInvokedHandler(WebAccountCommandInvokedHandlerVtbl, WebAccountCommandInvokedHandlerImpl) [IID_WebAccountCommandInvokedHandler] {
    fn Invoke(&self, command: *mut WebAccountCommand, args: *mut WebAccountInvokedArgs) -> HRESULT
}}
impl WebAccountCommandInvokedHandler {
    #[inline] pub fn invoke(&self, command: &WebAccountCommand, args: &WebAccountInvokedArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, command as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWebAccountInvokedArgs, 3886795840, 41432, 19549, 154, 127, 29, 52, 178, 249, 10, 210);
RT_INTERFACE!{interface IWebAccountInvokedArgs(IWebAccountInvokedArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebAccountInvokedArgs] {
    fn get_Action(&self, out: *mut WebAccountAction) -> HRESULT
}}
impl IWebAccountInvokedArgs {
    #[inline] pub fn get_action(&self) -> Result<WebAccountAction> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Action)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WebAccountInvokedArgs: IWebAccountInvokedArgs}
DEFINE_IID!(IID_IWebAccountProviderCommand, 3600539034, 41126, 20123, 136, 220, 199, 30, 117, 122, 53, 1);
RT_INTERFACE!{interface IWebAccountProviderCommand(IWebAccountProviderCommandVtbl): IInspectable(IInspectableVtbl) [IID_IWebAccountProviderCommand] {
    #[cfg(not(feature="windows-security"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-security")] fn get_WebAccountProvider(&self, out: *mut *mut super::super::security::credentials::WebAccountProvider) -> HRESULT,
    fn get_Invoked(&self, out: *mut *mut WebAccountProviderCommandInvokedHandler) -> HRESULT
}}
impl IWebAccountProviderCommand {
    #[cfg(feature="windows-security")] #[inline] pub fn get_web_account_provider(&self) -> Result<Option<ComPtr<super::super::security::credentials::WebAccountProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebAccountProvider)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_invoked(&self) -> Result<Option<ComPtr<WebAccountProviderCommandInvokedHandler>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Invoked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WebAccountProviderCommand: IWebAccountProviderCommand}
impl RtActivatable<IWebAccountProviderCommandFactory> for WebAccountProviderCommand {}
impl WebAccountProviderCommand {
    #[cfg(feature="windows-security")] #[inline] pub fn create_web_account_provider_command(webAccountProvider: &super::super::security::credentials::WebAccountProvider, invoked: &WebAccountProviderCommandInvokedHandler) -> Result<ComPtr<WebAccountProviderCommand>> {
        <Self as RtActivatable<IWebAccountProviderCommandFactory>>::get_activation_factory().create_web_account_provider_command(webAccountProvider, invoked)
    }
}
DEFINE_CLSID!(WebAccountProviderCommand(&[87,105,110,100,111,119,115,46,85,73,46,65,112,112,108,105,99,97,116,105,111,110,83,101,116,116,105,110,103,115,46,87,101,98,65,99,99,111,117,110,116,80,114,111,118,105,100,101,114,67,111,109,109,97,110,100,0]) [CLSID_WebAccountProviderCommand]);
DEFINE_IID!(IID_IWebAccountProviderCommandFactory, 3580201499, 45430, 18294, 132, 105, 169, 211, 255, 11, 63, 89);
RT_INTERFACE!{static interface IWebAccountProviderCommandFactory(IWebAccountProviderCommandFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWebAccountProviderCommandFactory] {
    #[cfg(feature="windows-security")] fn CreateWebAccountProviderCommand(&self, webAccountProvider: *mut super::super::security::credentials::WebAccountProvider, invoked: *mut WebAccountProviderCommandInvokedHandler, out: *mut *mut WebAccountProviderCommand) -> HRESULT
}}
impl IWebAccountProviderCommandFactory {
    #[cfg(feature="windows-security")] #[inline] pub fn create_web_account_provider_command(&self, webAccountProvider: &super::super::security::credentials::WebAccountProvider, invoked: &WebAccountProviderCommandInvokedHandler) -> Result<ComPtr<WebAccountProviderCommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWebAccountProviderCommand)(self as *const _ as *mut _, webAccountProvider as *const _ as *mut _, invoked as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_WebAccountProviderCommandInvokedHandler, 3084801319, 19599, 17117, 132, 218, 94, 196, 147, 171, 219, 154);
RT_DELEGATE!{delegate WebAccountProviderCommandInvokedHandler(WebAccountProviderCommandInvokedHandlerVtbl, WebAccountProviderCommandInvokedHandlerImpl) [IID_WebAccountProviderCommandInvokedHandler] {
    fn Invoke(&self, command: *mut WebAccountProviderCommand) -> HRESULT
}}
impl WebAccountProviderCommandInvokedHandler {
    #[inline] pub fn invoke(&self, command: &WebAccountProviderCommand) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, command as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
} // Windows.UI.ApplicationSettings
pub mod composition { // Windows.UI.Composition
use crate::prelude::*;
DEFINE_IID!(IID_IAmbientLight, 2759930017, 47044, 18167, 185, 191, 218, 244, 58, 68, 230, 238);
RT_INTERFACE!{interface IAmbientLight(IAmbientLightVtbl): IInspectable(IInspectableVtbl) [IID_IAmbientLight] {
    fn get_Color(&self, out: *mut super::Color) -> HRESULT,
    fn put_Color(&self, value: super::Color) -> HRESULT
}}
impl IAmbientLight {
    #[inline] pub fn get_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AmbientLight: IAmbientLight}
DEFINE_IID!(IID_IAmbientLight2, 996452031, 24471, 19604, 134, 229, 4, 45, 211, 134, 178, 125);
RT_INTERFACE!{interface IAmbientLight2(IAmbientLight2Vtbl): IInspectable(IInspectableVtbl) [IID_IAmbientLight2] {
    fn get_Intensity(&self, out: *mut f32) -> HRESULT,
    fn put_Intensity(&self, value: f32) -> HRESULT
}}
impl IAmbientLight2 {
    #[inline] pub fn get_intensity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Intensity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_intensity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Intensity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAnimationController, 3375689682, 1826, 20319, 164, 226, 149, 16, 243, 212, 59, 247);
RT_INTERFACE!{interface IAnimationController(IAnimationControllerVtbl): IInspectable(IInspectableVtbl) [IID_IAnimationController] {
    fn get_PlaybackRate(&self, out: *mut f32) -> HRESULT,
    fn put_PlaybackRate(&self, value: f32) -> HRESULT,
    fn get_Progress(&self, out: *mut f32) -> HRESULT,
    fn put_Progress(&self, value: f32) -> HRESULT,
    fn get_ProgressBehavior(&self, out: *mut AnimationControllerProgressBehavior) -> HRESULT,
    fn put_ProgressBehavior(&self, value: AnimationControllerProgressBehavior) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn Resume(&self) -> HRESULT
}}
impl IAnimationController {
    #[inline] pub fn get_playback_rate(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_playback_rate(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PlaybackRate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_progress(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_progress(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Progress)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_progress_behavior(&self) -> Result<AnimationControllerProgressBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProgressBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_progress_behavior(&self, value: AnimationControllerProgressBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ProgressBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Pause)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn resume(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Resume)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AnimationController: IAnimationController}
impl RtActivatable<IAnimationControllerStatics> for AnimationController {}
impl AnimationController {
    #[inline] pub fn get_max_playback_rate() -> Result<f32> {
        <Self as RtActivatable<IAnimationControllerStatics>>::get_activation_factory().get_max_playback_rate()
    }
    #[inline] pub fn get_min_playback_rate() -> Result<f32> {
        <Self as RtActivatable<IAnimationControllerStatics>>::get_activation_factory().get_min_playback_rate()
    }
}
DEFINE_CLSID!(AnimationController(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,65,110,105,109,97,116,105,111,110,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_AnimationController]);
RT_ENUM! { enum AnimationControllerProgressBehavior: i32 {
    Default = 0, IncludesDelayTime = 1,
}}
DEFINE_IID!(IID_IAnimationControllerStatics, 3876676831, 25883, 18432, 185, 229, 106, 59, 207, 237, 51, 101);
RT_INTERFACE!{static interface IAnimationControllerStatics(IAnimationControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAnimationControllerStatics] {
    fn get_MaxPlaybackRate(&self, out: *mut f32) -> HRESULT,
    fn get_MinPlaybackRate(&self, out: *mut f32) -> HRESULT
}}
impl IAnimationControllerStatics {
    #[inline] pub fn get_max_playback_rate(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxPlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_playback_rate(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinPlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AnimationDelayBehavior: i32 {
    SetInitialValueAfterDelay = 0, SetInitialValueBeforeDelay = 1,
}}
RT_ENUM! { enum AnimationDirection: i32 {
    Normal = 0, Reverse = 1, Alternate = 2, AlternateReverse = 3,
}}
RT_ENUM! { enum AnimationIterationBehavior: i32 {
    Count = 0, Forever = 1,
}}
DEFINE_IID!(IID_IAnimationObject, 3876855306, 1208, 20421, 164, 220, 25, 83, 146, 229, 120, 7);
RT_INTERFACE!{interface IAnimationObject(IAnimationObjectVtbl): IInspectable(IInspectableVtbl) [IID_IAnimationObject] {
    fn PopulatePropertyInfo(&self, propertyName: HSTRING, propertyInfo: *mut AnimationPropertyInfo) -> HRESULT
}}
impl IAnimationObject {
    #[inline] pub fn populate_property_info(&self, propertyName: &HStringArg, propertyInfo: &AnimationPropertyInfo) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).PopulatePropertyInfo)(self as *const _ as *mut _, propertyName.get(), propertyInfo as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum AnimationPropertyAccessMode: i32 {
    None = 0, ReadOnly = 1, WriteOnly = 2, ReadWrite = 3,
}}
DEFINE_IID!(IID_IAnimationPropertyInfo, 4101074693, 60791, 20028, 179, 40, 92, 57, 133, 179, 115, 143);
RT_INTERFACE!{interface IAnimationPropertyInfo(IAnimationPropertyInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAnimationPropertyInfo] {
    fn get_AccessMode(&self, out: *mut AnimationPropertyAccessMode) -> HRESULT,
    fn put_AccessMode(&self, value: AnimationPropertyAccessMode) -> HRESULT
}}
impl IAnimationPropertyInfo {
    #[inline] pub fn get_access_mode(&self) -> Result<AnimationPropertyAccessMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AccessMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_access_mode(&self, value: AnimationPropertyAccessMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AccessMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AnimationPropertyInfo: IAnimationPropertyInfo}
RT_ENUM! { enum AnimationStopBehavior: i32 {
    LeaveCurrentValue = 0, SetToInitialValue = 1, SetToFinalValue = 2,
}}
DEFINE_IID!(IID_IBooleanKeyFrameAnimation, 2514631176, 53748, 18802, 151, 112, 62, 254, 104, 216, 46, 20);
RT_INTERFACE!{interface IBooleanKeyFrameAnimation(IBooleanKeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IBooleanKeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: bool) -> HRESULT
}}
impl IBooleanKeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BooleanKeyFrameAnimation: IBooleanKeyFrameAnimation}
DEFINE_IID!(IID_IBounceScalarNaturalMotionAnimation, 3131248076, 42547, 17944, 155, 6, 127, 124, 114, 200, 124, 255);
RT_INTERFACE!{interface IBounceScalarNaturalMotionAnimation(IBounceScalarNaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IBounceScalarNaturalMotionAnimation] {
    fn get_Acceleration(&self, out: *mut f32) -> HRESULT,
    fn put_Acceleration(&self, value: f32) -> HRESULT,
    fn get_Restitution(&self, out: *mut f32) -> HRESULT,
    fn put_Restitution(&self, value: f32) -> HRESULT
}}
impl IBounceScalarNaturalMotionAnimation {
    #[inline] pub fn get_acceleration(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Acceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_acceleration(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Acceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_restitution(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Restitution)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_restitution(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Restitution)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BounceScalarNaturalMotionAnimation: IBounceScalarNaturalMotionAnimation}
DEFINE_IID!(IID_IBounceVector2NaturalMotionAnimation, 3660857750, 8532, 19260, 136, 170, 71, 54, 18, 4, 236, 205);
RT_INTERFACE!{interface IBounceVector2NaturalMotionAnimation(IBounceVector2NaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IBounceVector2NaturalMotionAnimation] {
    fn get_Acceleration(&self, out: *mut f32) -> HRESULT,
    fn put_Acceleration(&self, value: f32) -> HRESULT,
    fn get_Restitution(&self, out: *mut f32) -> HRESULT,
    fn put_Restitution(&self, value: f32) -> HRESULT
}}
impl IBounceVector2NaturalMotionAnimation {
    #[inline] pub fn get_acceleration(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Acceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_acceleration(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Acceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_restitution(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Restitution)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_restitution(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Restitution)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BounceVector2NaturalMotionAnimation: IBounceVector2NaturalMotionAnimation}
DEFINE_IID!(IID_IBounceVector3NaturalMotionAnimation, 1205517361, 4307, 17688, 134, 241, 9, 202, 247, 66, 209, 19);
RT_INTERFACE!{interface IBounceVector3NaturalMotionAnimation(IBounceVector3NaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IBounceVector3NaturalMotionAnimation] {
    fn get_Acceleration(&self, out: *mut f32) -> HRESULT,
    fn put_Acceleration(&self, value: f32) -> HRESULT,
    fn get_Restitution(&self, out: *mut f32) -> HRESULT,
    fn put_Restitution(&self, value: f32) -> HRESULT
}}
impl IBounceVector3NaturalMotionAnimation {
    #[inline] pub fn get_acceleration(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Acceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_acceleration(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Acceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_restitution(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Restitution)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_restitution(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Restitution)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BounceVector3NaturalMotionAnimation: IBounceVector3NaturalMotionAnimation}
DEFINE_IID!(IID_IColorKeyFrameAnimation, 2477635049, 36357, 17811, 132, 163, 220, 161, 82, 120, 30, 86);
RT_INTERFACE!{interface IColorKeyFrameAnimation(IColorKeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IColorKeyFrameAnimation] {
    fn get_InterpolationColorSpace(&self, out: *mut CompositionColorSpace) -> HRESULT,
    fn put_InterpolationColorSpace(&self, value: CompositionColorSpace) -> HRESULT,
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: super::Color) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: super::Color, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IColorKeyFrameAnimation {
    #[inline] pub fn get_interpolation_color_space(&self) -> Result<CompositionColorSpace> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InterpolationColorSpace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_interpolation_color_space(&self, value: CompositionColorSpace) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InterpolationColorSpace)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: super::Color, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ColorKeyFrameAnimation: IColorKeyFrameAnimation}
DEFINE_IID!(IID_ICompositionAnimation, 1179405356, 7338, 16481, 155, 64, 225, 63, 222, 21, 3, 202);
RT_INTERFACE!{interface ICompositionAnimation(ICompositionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimation] {
    fn ClearAllParameters(&self) -> HRESULT,
    fn ClearParameter(&self, key: HSTRING) -> HRESULT,
    fn SetColorParameter(&self, key: HSTRING, value: super::Color) -> HRESULT,
    fn SetMatrix3x2Parameter(&self, key: HSTRING, value: foundation::numerics::Matrix3x2) -> HRESULT,
    fn SetMatrix4x4Parameter(&self, key: HSTRING, value: foundation::numerics::Matrix4x4) -> HRESULT,
    fn SetQuaternionParameter(&self, key: HSTRING, value: foundation::numerics::Quaternion) -> HRESULT,
    fn SetReferenceParameter(&self, key: HSTRING, compositionObject: *mut CompositionObject) -> HRESULT,
    fn SetScalarParameter(&self, key: HSTRING, value: f32) -> HRESULT,
    fn SetVector2Parameter(&self, key: HSTRING, value: foundation::numerics::Vector2) -> HRESULT,
    fn SetVector3Parameter(&self, key: HSTRING, value: foundation::numerics::Vector3) -> HRESULT,
    fn SetVector4Parameter(&self, key: HSTRING, value: foundation::numerics::Vector4) -> HRESULT
}}
impl ICompositionAnimation {
    #[inline] pub fn clear_all_parameters(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearAllParameters)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_parameter(&self, key: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearParameter)(self as *const _ as *mut _, key.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_color_parameter(&self, key: &HStringArg, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetColorParameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_matrix3x2_parameter(&self, key: &HStringArg, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetMatrix3x2Parameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_matrix4x4_parameter(&self, key: &HStringArg, value: foundation::numerics::Matrix4x4) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetMatrix4x4Parameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_quaternion_parameter(&self, key: &HStringArg, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetQuaternionParameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_reference_parameter(&self, key: &HStringArg, compositionObject: &CompositionObject) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetReferenceParameter)(self as *const _ as *mut _, key.get(), compositionObject as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_scalar_parameter(&self, key: &HStringArg, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetScalarParameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_vector2_parameter(&self, key: &HStringArg, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetVector2Parameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_vector3_parameter(&self, key: &HStringArg, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetVector3Parameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_vector4_parameter(&self, key: &HStringArg, value: foundation::numerics::Vector4) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetVector4Parameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionAnimation: ICompositionAnimation}
DEFINE_IID!(IID_ICompositionAnimation2, 916152382, 43023, 18760, 147, 227, 237, 35, 251, 56, 198, 203);
RT_INTERFACE!{interface ICompositionAnimation2(ICompositionAnimation2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimation2] {
    fn SetBooleanParameter(&self, key: HSTRING, value: bool) -> HRESULT,
    fn get_Target(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Target(&self, value: HSTRING) -> HRESULT
}}
impl ICompositionAnimation2 {
    #[inline] pub fn set_boolean_parameter(&self, key: &HStringArg, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetBooleanParameter)(self as *const _ as *mut _, key.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_target(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Target)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_target(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Target)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionAnimation3, 3575513869, 32164, 19415, 188, 45, 244, 81, 117, 41, 244, 58);
RT_INTERFACE!{interface ICompositionAnimation3(ICompositionAnimation3Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimation3] {
    fn get_InitialValueExpressions(&self, out: *mut *mut InitialValueExpressionCollection) -> HRESULT
}}
impl ICompositionAnimation3 {
    #[inline] pub fn get_initial_value_expressions(&self) -> Result<Option<ComPtr<InitialValueExpressionCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialValueExpressions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionAnimation4, 1996568510, 30396, 20003, 191, 237, 254, 156, 194, 15, 110, 201);
RT_INTERFACE!{interface ICompositionAnimation4(ICompositionAnimation4Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimation4] {
    fn SetExpressionReferenceParameter(&self, parameterName: HSTRING, source: *mut IAnimationObject) -> HRESULT
}}
impl ICompositionAnimation4 {
    #[inline] pub fn set_expression_reference_parameter(&self, parameterName: &HStringArg, source: &IAnimationObject) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetExpressionReferenceParameter)(self as *const _ as *mut _, parameterName.get(), source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionAnimationBase, 472656281, 59416, 18643, 166, 221, 215, 140, 130, 248, 172, 233);
RT_INTERFACE!{interface ICompositionAnimationBase(ICompositionAnimationBaseVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimationBase] {
    
}}
DEFINE_IID!(IID_ICompositionAnimationFactory, 284607739, 28241, 19493, 187, 211, 88, 106, 155, 236, 62, 244);
RT_INTERFACE!{interface ICompositionAnimationFactory(ICompositionAnimationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimationFactory] {
    
}}
DEFINE_IID!(IID_ICompositionAnimationGroup, 1585236236, 52500, 19975, 138, 85, 199, 37, 39, 170, 189, 172);
RT_INTERFACE!{interface ICompositionAnimationGroup(ICompositionAnimationGroupVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionAnimationGroup] {
    fn get_Count(&self, out: *mut i32) -> HRESULT,
    fn Add(&self, value: *mut CompositionAnimation) -> HRESULT,
    fn Remove(&self, value: *mut CompositionAnimation) -> HRESULT,
    fn RemoveAll(&self) -> HRESULT
}}
impl ICompositionAnimationGroup {
    #[inline] pub fn get_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Count)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add(&self, value: &CompositionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Add)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove(&self, value: &CompositionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Remove)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionAnimationGroup: ICompositionAnimationGroup}
DEFINE_IID!(IID_ICompositionBackdropBrush, 3316428376, 14488, 18846, 141, 127, 34, 78, 145, 40, 106, 93);
RT_INTERFACE!{interface ICompositionBackdropBrush(ICompositionBackdropBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionBackdropBrush] {
    
}}
RT_CLASS!{class CompositionBackdropBrush: ICompositionBackdropBrush}
RT_ENUM! { enum CompositionBackfaceVisibility: i32 {
    Inherit = 0, Visible = 1, Hidden = 2,
}}
DEFINE_IID!(IID_ICompositionBatchCompletedEventArgs, 218159824, 37988, 17674, 165, 98, 46, 38, 152, 176, 168, 18);
RT_INTERFACE!{interface ICompositionBatchCompletedEventArgs(ICompositionBatchCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionBatchCompletedEventArgs] {
    
}}
RT_CLASS!{class CompositionBatchCompletedEventArgs: ICompositionBatchCompletedEventArgs}
RT_ENUM! { enum CompositionBatchTypes: u32 {
    None = 0, Animation = 1, Effect = 2, InfiniteAnimation = 4, AllAnimations = 5,
}}
RT_ENUM! { enum CompositionBitmapInterpolationMode: i32 {
    NearestNeighbor = 0, Linear = 1,
}}
RT_ENUM! { enum CompositionBorderMode: i32 {
    Inherit = 0, Soft = 1, Hard = 2,
}}
DEFINE_IID!(IID_ICompositionBrush, 2869786120, 12480, 16617, 181, 104, 182, 10, 107, 209, 251, 70);
RT_INTERFACE!{interface ICompositionBrush(ICompositionBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionBrush] {
    
}}
RT_CLASS!{class CompositionBrush: ICompositionBrush}
DEFINE_IID!(IID_ICompositionBrushFactory, 3662936908, 18000, 18372, 173, 118, 118, 83, 121, 96, 126, 214);
RT_INTERFACE!{interface ICompositionBrushFactory(ICompositionBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionBrushFactory] {
    
}}
DEFINE_IID!(IID_ICompositionCapabilities, 2186491198, 46359, 18620, 177, 232, 75, 53, 97, 162, 225, 129);
RT_INTERFACE!{interface ICompositionCapabilities(ICompositionCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionCapabilities] {
    fn AreEffectsSupported(&self, out: *mut bool) -> HRESULT,
    fn AreEffectsFast(&self, out: *mut bool) -> HRESULT,
    fn add_Changed(&self, handler: *mut foundation::TypedEventHandler<CompositionCapabilities, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Changed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompositionCapabilities {
    #[inline] pub fn are_effects_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).AreEffectsSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn are_effects_fast(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).AreEffectsFast)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_changed(&self, handler: &foundation::TypedEventHandler<CompositionCapabilities, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Changed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Changed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionCapabilities: ICompositionCapabilities}
impl RtActivatable<ICompositionCapabilitiesStatics> for CompositionCapabilities {}
impl CompositionCapabilities {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<CompositionCapabilities>>> {
        <Self as RtActivatable<ICompositionCapabilitiesStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(CompositionCapabilities(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,67,111,109,112,111,115,105,116,105,111,110,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_CompositionCapabilities]);
DEFINE_IID!(IID_ICompositionCapabilitiesStatics, 4156008558, 25622, 18917, 141, 223, 175, 233, 73, 226, 5, 98);
RT_INTERFACE!{static interface ICompositionCapabilitiesStatics(ICompositionCapabilitiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionCapabilitiesStatics] {
    fn GetForCurrentView(&self, out: *mut *mut CompositionCapabilities) -> HRESULT
}}
impl ICompositionCapabilitiesStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<CompositionCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionClip, 483207762, 53191, 19150, 153, 131, 20, 107, 184, 235, 106, 60);
RT_INTERFACE!{interface ICompositionClip(ICompositionClipVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionClip] {
    
}}
RT_CLASS!{class CompositionClip: ICompositionClip}
DEFINE_IID!(IID_ICompositionClip2, 1486086249, 13590, 16609, 137, 224, 91, 169, 36, 146, 114, 53);
RT_INTERFACE!{interface ICompositionClip2(ICompositionClip2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionClip2] {
    fn get_AnchorPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_AnchorPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_CenterPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_CenterPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_RotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngle(&self, value: f32) -> HRESULT,
    fn get_RotationAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_Scale(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Scale(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_TransformMatrix(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_TransformMatrix(&self, value: foundation::numerics::Matrix3x2) -> HRESULT
}}
impl ICompositionClip2 {
    #[inline] pub fn get_anchor_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnchorPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_anchor_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AnchorPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_center_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_center_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CenterPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Scale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transform_matrix(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransformMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transform_matrix(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TransformMatrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionClipFactory, 3108523183, 8391, 19181, 172, 74, 156, 120, 186, 19, 2, 207);
RT_INTERFACE!{interface ICompositionClipFactory(ICompositionClipFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionClipFactory] {
    
}}
DEFINE_IID!(IID_ICompositionColorBrush, 723930206, 48949, 18481, 134, 66, 207, 112, 194, 15, 255, 47);
RT_INTERFACE!{interface ICompositionColorBrush(ICompositionColorBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionColorBrush] {
    fn get_Color(&self, out: *mut super::Color) -> HRESULT,
    fn put_Color(&self, value: super::Color) -> HRESULT
}}
impl ICompositionColorBrush {
    #[inline] pub fn get_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionColorBrush: ICompositionColorBrush}
DEFINE_IID!(IID_ICompositionColorGradientStop, 1862322834, 51201, 20033, 154, 143, 165, 62, 32, 245, 119, 120);
RT_INTERFACE!{interface ICompositionColorGradientStop(ICompositionColorGradientStopVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionColorGradientStop] {
    fn get_Color(&self, out: *mut super::Color) -> HRESULT,
    fn put_Color(&self, value: super::Color) -> HRESULT,
    fn get_Offset(&self, out: *mut f32) -> HRESULT,
    fn put_Offset(&self, value: f32) -> HRESULT
}}
impl ICompositionColorGradientStop {
    #[inline] pub fn get_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionColorGradientStop: ICompositionColorGradientStop}
DEFINE_IID!(IID_ICompositionColorGradientStopCollection, 2669486316, 31492, 19229, 144, 188, 159, 163, 44, 12, 253, 38);
RT_INTERFACE!{interface ICompositionColorGradientStopCollection(ICompositionColorGradientStopCollectionVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionColorGradientStopCollection] {
    
}}
RT_CLASS!{class CompositionColorGradientStopCollection: ICompositionColorGradientStopCollection}
RT_ENUM! { enum CompositionColorSpace: i32 {
    Auto = 0, Hsl = 1, Rgb = 2, HslLinear = 3, RgbLinear = 4,
}}
DEFINE_IID!(IID_ICompositionCommitBatch, 218159824, 51719, 17408, 140, 142, 203, 93, 176, 133, 89, 204);
RT_INTERFACE!{interface ICompositionCommitBatch(ICompositionCommitBatchVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionCommitBatch] {
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_IsEnded(&self, out: *mut bool) -> HRESULT,
    fn add_Completed(&self, handler: *mut foundation::TypedEventHandler<IInspectable, CompositionBatchCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompositionCommitBatch {
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_ended(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnded)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_completed(&self, handler: &foundation::TypedEventHandler<IInspectable, CompositionBatchCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionCommitBatch: ICompositionCommitBatch}
RT_ENUM! { enum CompositionCompositeMode: i32 {
    Inherit = 0, SourceOver = 1, DestinationInvert = 2, MinBlend = 3,
}}
DEFINE_IID!(IID_ICompositionContainerShape, 1331594651, 11867, 17576, 152, 44, 170, 15, 105, 193, 96, 89);
RT_INTERFACE!{interface ICompositionContainerShape(ICompositionContainerShapeVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionContainerShape] {
    fn get_Shapes(&self, out: *mut *mut CompositionShapeCollection) -> HRESULT
}}
impl ICompositionContainerShape {
    #[inline] pub fn get_shapes(&self) -> Result<Option<ComPtr<CompositionShapeCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Shapes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionContainerShape: ICompositionContainerShape}
DEFINE_IID!(IID_ICompositionDrawingSurface, 2707866368, 64208, 19729, 158, 103, 228, 51, 22, 47, 244, 158);
RT_INTERFACE!{interface ICompositionDrawingSurface(ICompositionDrawingSurfaceVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionDrawingSurface] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_AlphaMode(&self, out: *mut super::super::graphics::directx::DirectXAlphaMode) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_PixelFormat(&self, out: *mut super::super::graphics::directx::DirectXPixelFormat) -> HRESULT,
    fn get_Size(&self, out: *mut foundation::Size) -> HRESULT
}}
impl ICompositionDrawingSurface {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_alpha_mode(&self) -> Result<super::super::graphics::directx::DirectXAlphaMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AlphaMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_pixel_format(&self) -> Result<super::super::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PixelFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionDrawingSurface: ICompositionDrawingSurface}
DEFINE_IID!(IID_ICompositionDrawingSurface2, 4207995019, 58196, 17640, 142, 61, 196, 136, 13, 90, 33, 63);
RT_INTERFACE!{interface ICompositionDrawingSurface2(ICompositionDrawingSurface2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionDrawingSurface2] {
    #[cfg(feature="windows-graphics")] fn get_SizeInt32(&self, out: *mut super::super::graphics::SizeInt32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn Resize(&self, sizePixels: super::super::graphics::SizeInt32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn Scroll(&self, offset: super::super::graphics::PointInt32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn ScrollRect(&self, offset: super::super::graphics::PointInt32, scrollRect: super::super::graphics::RectInt32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn ScrollWithClip(&self, offset: super::super::graphics::PointInt32, clipRect: super::super::graphics::RectInt32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn ScrollRectWithClip(&self, offset: super::super::graphics::PointInt32, clipRect: super::super::graphics::RectInt32, scrollRect: super::super::graphics::RectInt32) -> HRESULT
}}
impl ICompositionDrawingSurface2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_size_int32(&self) -> Result<super::super::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SizeInt32)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn resize(&self, sizePixels: super::super::graphics::SizeInt32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Resize)(self as *const _ as *mut _, sizePixels);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn scroll(&self, offset: super::super::graphics::PointInt32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Scroll)(self as *const _ as *mut _, offset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn scroll_rect(&self, offset: super::super::graphics::PointInt32, scrollRect: super::super::graphics::RectInt32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ScrollRect)(self as *const _ as *mut _, offset, scrollRect);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn scroll_with_clip(&self, offset: super::super::graphics::PointInt32, clipRect: super::super::graphics::RectInt32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ScrollWithClip)(self as *const _ as *mut _, offset, clipRect);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn scroll_rect_with_clip(&self, offset: super::super::graphics::PointInt32, clipRect: super::super::graphics::RectInt32, scrollRect: super::super::graphics::RectInt32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ScrollRectWithClip)(self as *const _ as *mut _, offset, clipRect, scrollRect);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionDrawingSurfaceFactory, 2492968970, 12589, 18105, 157, 179, 65, 47, 215, 148, 100, 200);
RT_INTERFACE!{interface ICompositionDrawingSurfaceFactory(ICompositionDrawingSurfaceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionDrawingSurfaceFactory] {
    
}}
RT_ENUM! { enum CompositionDropShadowSourcePolicy: i32 {
    Default = 0, InheritFromVisualContent = 1,
}}
DEFINE_IID!(IID_ICompositionEasingFunction, 1363534678, 49017, 20136, 140, 194, 107, 91, 71, 46, 108, 154);
RT_INTERFACE!{interface ICompositionEasingFunction(ICompositionEasingFunctionVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEasingFunction] {
    
}}
RT_CLASS!{class CompositionEasingFunction: ICompositionEasingFunction}
DEFINE_IID!(IID_ICompositionEasingFunctionFactory, 1619265396, 15776, 18761, 130, 0, 114, 6, 192, 1, 144, 160);
RT_INTERFACE!{interface ICompositionEasingFunctionFactory(ICompositionEasingFunctionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEasingFunctionFactory] {
    
}}
DEFINE_IID!(IID_ICompositionEffectBrush, 3212802398, 33740, 17599, 164, 71, 62, 60, 7, 23, 137, 236);
RT_INTERFACE!{interface ICompositionEffectBrush(ICompositionEffectBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEffectBrush] {
    fn GetSourceParameter(&self, name: HSTRING, out: *mut *mut CompositionBrush) -> HRESULT,
    fn SetSourceParameter(&self, name: HSTRING, source: *mut CompositionBrush) -> HRESULT
}}
impl ICompositionEffectBrush {
    #[inline] pub fn get_source_parameter(&self, name: &HStringArg) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSourceParameter)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source_parameter(&self, name: &HStringArg, source: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetSourceParameter)(self as *const _ as *mut _, name.get(), source as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionEffectBrush: ICompositionEffectBrush}
DEFINE_IID!(IID_ICompositionEffectFactory, 3193316527, 47742, 17680, 152, 80, 65, 192, 180, 255, 116, 223);
RT_INTERFACE!{interface ICompositionEffectFactory(ICompositionEffectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEffectFactory] {
    fn CreateBrush(&self, out: *mut *mut CompositionEffectBrush) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_LoadStatus(&self, out: *mut CompositionEffectFactoryLoadStatus) -> HRESULT
}}
impl ICompositionEffectFactory {
    #[inline] pub fn create_brush(&self) -> Result<Option<ComPtr<CompositionEffectBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendedError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_load_status(&self) -> Result<CompositionEffectFactoryLoadStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LoadStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionEffectFactory: ICompositionEffectFactory}
RT_ENUM! { enum CompositionEffectFactoryLoadStatus: i32 {
    Success = 0, EffectTooComplex = 1, Pending = 2, Other = -1,
}}
DEFINE_IID!(IID_ICompositionEffectSourceParameter, 2240459066, 12946, 20046, 179, 187, 43, 108, 101, 68, 166, 238);
RT_INTERFACE!{interface ICompositionEffectSourceParameter(ICompositionEffectSourceParameterVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEffectSourceParameter] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICompositionEffectSourceParameter {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionEffectSourceParameter: ICompositionEffectSourceParameter}
impl RtActivatable<ICompositionEffectSourceParameterFactory> for CompositionEffectSourceParameter {}
impl CompositionEffectSourceParameter {
    #[inline] pub fn create(name: &HStringArg) -> Result<ComPtr<CompositionEffectSourceParameter>> {
        <Self as RtActivatable<ICompositionEffectSourceParameterFactory>>::get_activation_factory().create(name)
    }
}
DEFINE_CLSID!(CompositionEffectSourceParameter(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,67,111,109,112,111,115,105,116,105,111,110,69,102,102,101,99,116,83,111,117,114,99,101,80,97,114,97,109,101,116,101,114,0]) [CLSID_CompositionEffectSourceParameter]);
DEFINE_IID!(IID_ICompositionEffectSourceParameterFactory, 3017405046, 43939, 18212, 172, 243, 208, 57, 116, 100, 219, 28);
RT_INTERFACE!{static interface ICompositionEffectSourceParameterFactory(ICompositionEffectSourceParameterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEffectSourceParameterFactory] {
    fn Create(&self, name: HSTRING, out: *mut *mut CompositionEffectSourceParameter) -> HRESULT
}}
impl ICompositionEffectSourceParameterFactory {
    #[inline] pub fn create(&self, name: &HStringArg) -> Result<ComPtr<CompositionEffectSourceParameter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionEllipseGeometry, 1208088708, 63149, 19347, 175, 169, 137, 123, 100, 229, 123, 31);
RT_INTERFACE!{interface ICompositionEllipseGeometry(ICompositionEllipseGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionEllipseGeometry] {
    fn get_Center(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Center(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Radius(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Radius(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl ICompositionEllipseGeometry {
    #[inline] pub fn get_center(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Center)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_center(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Center)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_radius(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Radius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_radius(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Radius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionEllipseGeometry: ICompositionEllipseGeometry}
DEFINE_IID!(IID_ICompositionGeometricClip, 3359683969, 33225, 17476, 162, 193, 204, 174, 206, 58, 80, 229);
RT_INTERFACE!{interface ICompositionGeometricClip(ICompositionGeometricClipVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGeometricClip] {
    fn get_Geometry(&self, out: *mut *mut CompositionGeometry) -> HRESULT,
    fn put_Geometry(&self, value: *mut CompositionGeometry) -> HRESULT,
    fn get_ViewBox(&self, out: *mut *mut CompositionViewBox) -> HRESULT,
    fn put_ViewBox(&self, value: *mut CompositionViewBox) -> HRESULT
}}
impl ICompositionGeometricClip {
    #[inline] pub fn get_geometry(&self) -> Result<Option<ComPtr<CompositionGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Geometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_geometry(&self, value: &CompositionGeometry) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Geometry)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_view_box(&self) -> Result<Option<ComPtr<CompositionViewBox>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewBox)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_view_box(&self, value: &CompositionViewBox) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ViewBox)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionGeometricClip: ICompositionGeometricClip}
DEFINE_IID!(IID_ICompositionGeometry, 3917816188, 27159, 16903, 171, 216, 95, 211, 221, 97, 42, 157);
RT_INTERFACE!{interface ICompositionGeometry(ICompositionGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGeometry] {
    fn get_TrimEnd(&self, out: *mut f32) -> HRESULT,
    fn put_TrimEnd(&self, value: f32) -> HRESULT,
    fn get_TrimOffset(&self, out: *mut f32) -> HRESULT,
    fn put_TrimOffset(&self, value: f32) -> HRESULT,
    fn get_TrimStart(&self, out: *mut f32) -> HRESULT,
    fn put_TrimStart(&self, value: f32) -> HRESULT
}}
impl ICompositionGeometry {
    #[inline] pub fn get_trim_end(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TrimEnd)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_end(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TrimEnd)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trim_offset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TrimOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_offset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TrimOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_trim_start(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TrimStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_trim_start(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TrimStart)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionGeometry: ICompositionGeometry}
DEFINE_IID!(IID_ICompositionGeometryFactory, 3221143521, 35877, 18443, 159, 86, 254, 214, 178, 136, 5, 93);
RT_INTERFACE!{interface ICompositionGeometryFactory(ICompositionGeometryFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGeometryFactory] {
    
}}
RT_ENUM! { enum CompositionGetValueStatus: i32 {
    Succeeded = 0, TypeMismatch = 1, NotFound = 2,
}}
DEFINE_IID!(IID_ICompositionGradientBrush, 496437728, 65478, 19470, 169, 171, 52, 20, 77, 76, 144, 152);
RT_INTERFACE!{interface ICompositionGradientBrush(ICompositionGradientBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGradientBrush] {
    fn get_AnchorPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_AnchorPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_CenterPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_CenterPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_ColorStops(&self, out: *mut *mut CompositionColorGradientStopCollection) -> HRESULT,
    fn get_ExtendMode(&self, out: *mut CompositionGradientExtendMode) -> HRESULT,
    fn put_ExtendMode(&self, value: CompositionGradientExtendMode) -> HRESULT,
    fn get_InterpolationSpace(&self, out: *mut CompositionColorSpace) -> HRESULT,
    fn put_InterpolationSpace(&self, value: CompositionColorSpace) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_RotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngle(&self, value: f32) -> HRESULT,
    fn get_RotationAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_Scale(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Scale(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_TransformMatrix(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_TransformMatrix(&self, value: foundation::numerics::Matrix3x2) -> HRESULT
}}
impl ICompositionGradientBrush {
    #[inline] pub fn get_anchor_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnchorPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_anchor_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AnchorPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_center_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_center_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CenterPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_color_stops(&self) -> Result<Option<ComPtr<CompositionColorGradientStopCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ColorStops)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_extend_mode(&self) -> Result<CompositionGradientExtendMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_extend_mode(&self, value: CompositionGradientExtendMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExtendMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_interpolation_space(&self) -> Result<CompositionColorSpace> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InterpolationSpace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_interpolation_space(&self, value: CompositionColorSpace) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InterpolationSpace)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Scale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transform_matrix(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransformMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transform_matrix(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TransformMatrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionGradientBrush: ICompositionGradientBrush}
DEFINE_IID!(IID_ICompositionGradientBrush2, 2308822433, 46279, 19251, 161, 182, 38, 74, 221, 194, 109, 16);
RT_INTERFACE!{interface ICompositionGradientBrush2(ICompositionGradientBrush2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGradientBrush2] {
    fn get_MappingMode(&self, out: *mut CompositionMappingMode) -> HRESULT,
    fn put_MappingMode(&self, value: CompositionMappingMode) -> HRESULT
}}
impl ICompositionGradientBrush2 {
    #[inline] pub fn get_mapping_mode(&self) -> Result<CompositionMappingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MappingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mapping_mode(&self, value: CompositionMappingMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MappingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionGradientBrushFactory, 1456956887, 61833, 18633, 156, 141, 148, 218, 241, 190, 192, 16);
RT_INTERFACE!{interface ICompositionGradientBrushFactory(ICompositionGradientBrushFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGradientBrushFactory] {
    
}}
RT_ENUM! { enum CompositionGradientExtendMode: i32 {
    Clamp = 0, Wrap = 1, Mirror = 2,
}}
DEFINE_IID!(IID_ICompositionGraphicsDevice, 4213360353, 32930, 18023, 153, 54, 219, 234, 246, 238, 254, 149);
RT_INTERFACE!{interface ICompositionGraphicsDevice(ICompositionGraphicsDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGraphicsDevice] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn CreateDrawingSurface(&self, sizePixels: foundation::Size, pixelFormat: super::super::graphics::directx::DirectXPixelFormat, alphaMode: super::super::graphics::directx::DirectXAlphaMode, out: *mut *mut CompositionDrawingSurface) -> HRESULT,
    fn add_RenderingDeviceReplaced(&self, handler: *mut foundation::TypedEventHandler<CompositionGraphicsDevice, RenderingDeviceReplacedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RenderingDeviceReplaced(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompositionGraphicsDevice {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_drawing_surface(&self, sizePixels: foundation::Size, pixelFormat: super::super::graphics::directx::DirectXPixelFormat, alphaMode: super::super::graphics::directx::DirectXAlphaMode) -> Result<Option<ComPtr<CompositionDrawingSurface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDrawingSurface)(self as *const _ as *mut _, sizePixels, pixelFormat, alphaMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_rendering_device_replaced(&self, handler: &foundation::TypedEventHandler<CompositionGraphicsDevice, RenderingDeviceReplacedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RenderingDeviceReplaced)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_rendering_device_replaced(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_RenderingDeviceReplaced)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionGraphicsDevice: ICompositionGraphicsDevice}
DEFINE_IID!(IID_ICompositionGraphicsDevice2, 263765494, 49392, 19404, 159, 184, 8, 73, 130, 73, 13, 125);
RT_INTERFACE!{interface ICompositionGraphicsDevice2(ICompositionGraphicsDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionGraphicsDevice2] {
    #[cfg(feature="windows-graphics")] fn CreateDrawingSurface2(&self, sizePixels: super::super::graphics::SizeInt32, pixelFormat: super::super::graphics::directx::DirectXPixelFormat, alphaMode: super::super::graphics::directx::DirectXAlphaMode, out: *mut *mut CompositionDrawingSurface) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateVirtualDrawingSurface(&self, sizePixels: super::super::graphics::SizeInt32, pixelFormat: super::super::graphics::directx::DirectXPixelFormat, alphaMode: super::super::graphics::directx::DirectXAlphaMode, out: *mut *mut CompositionVirtualDrawingSurface) -> HRESULT
}}
impl ICompositionGraphicsDevice2 {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_drawing_surface2(&self, sizePixels: super::super::graphics::SizeInt32, pixelFormat: super::super::graphics::directx::DirectXPixelFormat, alphaMode: super::super::graphics::directx::DirectXAlphaMode) -> Result<Option<ComPtr<CompositionDrawingSurface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDrawingSurface2)(self as *const _ as *mut _, sizePixels, pixelFormat, alphaMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_virtual_drawing_surface(&self, sizePixels: super::super::graphics::SizeInt32, pixelFormat: super::super::graphics::directx::DirectXPixelFormat, alphaMode: super::super::graphics::directx::DirectXAlphaMode) -> Result<Option<ComPtr<CompositionVirtualDrawingSurface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateVirtualDrawingSurface)(self as *const _ as *mut _, sizePixels, pixelFormat, alphaMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionLight, 1101453250, 11869, 19393, 176, 158, 143, 10, 3, 227, 216, 211);
RT_INTERFACE!{interface ICompositionLight(ICompositionLightVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionLight] {
    fn get_Targets(&self, out: *mut *mut VisualUnorderedCollection) -> HRESULT
}}
impl ICompositionLight {
    #[inline] pub fn get_targets(&self) -> Result<Option<ComPtr<VisualUnorderedCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Targets)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionLight: ICompositionLight}
DEFINE_IID!(IID_ICompositionLight2, 2814171762, 62301, 16989, 155, 152, 35, 244, 32, 95, 102, 105);
RT_INTERFACE!{interface ICompositionLight2(ICompositionLight2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionLight2] {
    fn get_ExclusionsFromTargets(&self, out: *mut *mut VisualUnorderedCollection) -> HRESULT
}}
impl ICompositionLight2 {
    #[inline] pub fn get_exclusions_from_targets(&self) -> Result<Option<ComPtr<VisualUnorderedCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExclusionsFromTargets)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionLight3, 1259012324, 57095, 18777, 183, 164, 79, 126, 66, 51, 248, 56);
RT_INTERFACE!{interface ICompositionLight3(ICompositionLight3Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionLight3] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT
}}
impl ICompositionLight3 {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionLightFactory, 110949126, 55868, 19268, 131, 138, 94, 3, 213, 26, 206, 85);
RT_INTERFACE!{interface ICompositionLightFactory(ICompositionLightFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionLightFactory] {
    
}}
DEFINE_IID!(IID_ICompositionLinearGradientBrush, 2554053913, 43483, 16700, 162, 216, 42, 144, 86, 252, 82, 94);
RT_INTERFACE!{interface ICompositionLinearGradientBrush(ICompositionLinearGradientBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionLinearGradientBrush] {
    fn get_EndPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_EndPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_StartPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_StartPoint(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl ICompositionLinearGradientBrush {
    #[inline] pub fn get_end_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EndPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_end_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_EndPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StartPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionLinearGradientBrush: ICompositionLinearGradientBrush}
DEFINE_IID!(IID_ICompositionLineGeometry, 3715503524, 3226, 19303, 141, 206, 68, 10, 91, 249, 205, 236);
RT_INTERFACE!{interface ICompositionLineGeometry(ICompositionLineGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionLineGeometry] {
    fn get_Start(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Start(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_End(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_End(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl ICompositionLineGeometry {
    #[inline] pub fn get_start(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Start)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Start)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_End)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_end(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_End)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionLineGeometry: ICompositionLineGeometry}
RT_ENUM! { enum CompositionMappingMode: i32 {
    Absolute = 0, Relative = 1,
}}
DEFINE_IID!(IID_ICompositionMaskBrush, 1378676894, 48747, 20289, 190, 73, 249, 34, 109, 71, 27, 74);
RT_INTERFACE!{interface ICompositionMaskBrush(ICompositionMaskBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionMaskBrush] {
    fn get_Mask(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_Mask(&self, value: *mut CompositionBrush) -> HRESULT,
    fn get_Source(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_Source(&self, value: *mut CompositionBrush) -> HRESULT
}}
impl ICompositionMaskBrush {
    #[inline] pub fn get_mask(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Mask)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_mask(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Mask)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionMaskBrush: ICompositionMaskBrush}
DEFINE_IID!(IID_ICompositionNineGridBrush, 4065416420, 48268, 19431, 184, 15, 134, 133, 184, 60, 1, 134);
RT_INTERFACE!{interface ICompositionNineGridBrush(ICompositionNineGridBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionNineGridBrush] {
    fn get_BottomInset(&self, out: *mut f32) -> HRESULT,
    fn put_BottomInset(&self, value: f32) -> HRESULT,
    fn get_BottomInsetScale(&self, out: *mut f32) -> HRESULT,
    fn put_BottomInsetScale(&self, value: f32) -> HRESULT,
    fn get_IsCenterHollow(&self, out: *mut bool) -> HRESULT,
    fn put_IsCenterHollow(&self, value: bool) -> HRESULT,
    fn get_LeftInset(&self, out: *mut f32) -> HRESULT,
    fn put_LeftInset(&self, value: f32) -> HRESULT,
    fn get_LeftInsetScale(&self, out: *mut f32) -> HRESULT,
    fn put_LeftInsetScale(&self, value: f32) -> HRESULT,
    fn get_RightInset(&self, out: *mut f32) -> HRESULT,
    fn put_RightInset(&self, value: f32) -> HRESULT,
    fn get_RightInsetScale(&self, out: *mut f32) -> HRESULT,
    fn put_RightInsetScale(&self, value: f32) -> HRESULT,
    fn get_Source(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_Source(&self, value: *mut CompositionBrush) -> HRESULT,
    fn get_TopInset(&self, out: *mut f32) -> HRESULT,
    fn put_TopInset(&self, value: f32) -> HRESULT,
    fn get_TopInsetScale(&self, out: *mut f32) -> HRESULT,
    fn put_TopInsetScale(&self, value: f32) -> HRESULT,
    fn SetInsets(&self, inset: f32) -> HRESULT,
    fn SetInsetsWithValues(&self, left: f32, top: f32, right: f32, bottom: f32) -> HRESULT,
    fn SetInsetScales(&self, scale: f32) -> HRESULT,
    fn SetInsetScalesWithValues(&self, left: f32, top: f32, right: f32, bottom: f32) -> HRESULT
}}
impl ICompositionNineGridBrush {
    #[inline] pub fn get_bottom_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BottomInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bottom_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BottomInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bottom_inset_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BottomInsetScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bottom_inset_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BottomInsetScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_center_hollow(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCenterHollow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_center_hollow(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsCenterHollow)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_inset_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftInsetScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_inset_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftInsetScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_inset_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightInsetScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_inset_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightInsetScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_top_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TopInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_top_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TopInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_top_inset_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TopInsetScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_top_inset_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TopInsetScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_insets(&self, inset: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetInsets)(self as *const _ as *mut _, inset);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_insets_with_values(&self, left: f32, top: f32, right: f32, bottom: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetInsetsWithValues)(self as *const _ as *mut _, left, top, right, bottom);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_inset_scales(&self, scale: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetInsetScales)(self as *const _ as *mut _, scale);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_inset_scales_with_values(&self, left: f32, top: f32, right: f32, bottom: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetInsetScalesWithValues)(self as *const _ as *mut _, left, top, right, bottom);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionNineGridBrush: ICompositionNineGridBrush}
DEFINE_IID!(IID_ICompositionObject, 3165957445, 30217, 17744, 147, 79, 22, 0, 42, 104, 253, 237);
RT_INTERFACE!{interface ICompositionObject(ICompositionObjectVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionObject] {
    fn get_Compositor(&self, out: *mut *mut Compositor) -> HRESULT,
    fn get_Dispatcher(&self, out: *mut *mut super::core::CoreDispatcher) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut CompositionPropertySet) -> HRESULT,
    fn StartAnimation(&self, propertyName: HSTRING, animation: *mut CompositionAnimation) -> HRESULT,
    fn StopAnimation(&self, propertyName: HSTRING) -> HRESULT
}}
impl ICompositionObject {
    #[inline] pub fn get_compositor(&self) -> Result<Option<ComPtr<Compositor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Compositor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dispatcher(&self) -> Result<Option<ComPtr<super::core::CoreDispatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<CompositionPropertySet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_animation(&self, propertyName: &HStringArg, animation: &CompositionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartAnimation)(self as *const _ as *mut _, propertyName.get(), animation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_animation(&self, propertyName: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StopAnimation)(self as *const _ as *mut _, propertyName.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionObject: ICompositionObject}
impl RtActivatable<ICompositionObjectStatics> for CompositionObject {}
impl CompositionObject {
    #[inline] pub fn start_animation_with_ianimationobject(target: &IAnimationObject, propertyName: &HStringArg, animation: &CompositionAnimation) -> Result<()> {
        <Self as RtActivatable<ICompositionObjectStatics>>::get_activation_factory().start_animation_with_ianimationobject(target, propertyName, animation)
    }
    #[inline] pub fn start_animation_group_with_ianimationobject(target: &IAnimationObject, animation: &ICompositionAnimationBase) -> Result<()> {
        <Self as RtActivatable<ICompositionObjectStatics>>::get_activation_factory().start_animation_group_with_ianimationobject(target, animation)
    }
}
DEFINE_CLSID!(CompositionObject(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,67,111,109,112,111,115,105,116,105,111,110,79,98,106,101,99,116,0]) [CLSID_CompositionObject]);
DEFINE_IID!(IID_ICompositionObject2, 4018622113, 23807, 19304, 158, 48, 161, 81, 157, 8, 186, 3);
RT_INTERFACE!{interface ICompositionObject2(ICompositionObject2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionObject2] {
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Comment(&self, value: HSTRING) -> HRESULT,
    fn get_ImplicitAnimations(&self, out: *mut *mut ImplicitAnimationCollection) -> HRESULT,
    fn put_ImplicitAnimations(&self, value: *mut ImplicitAnimationCollection) -> HRESULT,
    fn StartAnimationGroup(&self, value: *mut ICompositionAnimationBase) -> HRESULT,
    fn StopAnimationGroup(&self, value: *mut ICompositionAnimationBase) -> HRESULT
}}
impl ICompositionObject2 {
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_comment(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Comment)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_implicit_animations(&self) -> Result<Option<ComPtr<ImplicitAnimationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImplicitAnimations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_implicit_animations(&self, value: &ImplicitAnimationCollection) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ImplicitAnimations)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_animation_group(&self, value: &ICompositionAnimationBase) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartAnimationGroup)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_animation_group(&self, value: &ICompositionAnimationBase) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StopAnimationGroup)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionObject3, 1271036197, 56013, 19698, 152, 177, 152, 107, 118, 231, 235, 230);
RT_INTERFACE!{interface ICompositionObject3(ICompositionObject3Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionObject3] {
    #[cfg(feature="windows-system")] fn get_DispatcherQueue(&self, out: *mut *mut super::super::system::DispatcherQueue) -> HRESULT
}}
impl ICompositionObject3 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_dispatcher_queue(&self) -> Result<Option<ComPtr<super::super::system::DispatcherQueue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DispatcherQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionObject4, 196311116, 13419, 19068, 150, 107, 115, 16, 150, 101, 83, 213);
RT_INTERFACE!{interface ICompositionObject4(ICompositionObject4Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionObject4] {
    fn TryGetAnimationController(&self, propertyName: HSTRING, out: *mut *mut AnimationController) -> HRESULT
}}
impl ICompositionObject4 {
    #[inline] pub fn try_get_animation_controller(&self, propertyName: &HStringArg) -> Result<Option<ComPtr<AnimationController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetAnimationController)(self as *const _ as *mut _, propertyName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionObjectFactory, 1361075294, 21898, 20266, 141, 57, 55, 191, 225, 226, 13, 221);
RT_INTERFACE!{interface ICompositionObjectFactory(ICompositionObjectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionObjectFactory] {
    
}}
DEFINE_IID!(IID_ICompositionObjectStatics, 3253536047, 7074, 17594, 169, 4, 106, 136, 42, 10, 90, 219);
RT_INTERFACE!{static interface ICompositionObjectStatics(ICompositionObjectStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionObjectStatics] {
    fn StartAnimationWithIAnimationObject(&self, target: *mut IAnimationObject, propertyName: HSTRING, animation: *mut CompositionAnimation) -> HRESULT,
    fn StartAnimationGroupWithIAnimationObject(&self, target: *mut IAnimationObject, animation: *mut ICompositionAnimationBase) -> HRESULT
}}
impl ICompositionObjectStatics {
    #[inline] pub fn start_animation_with_ianimationobject(&self, target: &IAnimationObject, propertyName: &HStringArg, animation: &CompositionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartAnimationWithIAnimationObject)(self as *const _ as *mut _, target as *const _ as *mut _, propertyName.get(), animation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_animation_group_with_ianimationobject(&self, target: &IAnimationObject, animation: &ICompositionAnimationBase) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartAnimationGroupWithIAnimationObject)(self as *const _ as *mut _, target as *const _ as *mut _, animation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionPath, 1725570399, 11792, 20258, 138, 6, 10, 129, 81, 145, 158, 96);
RT_INTERFACE!{interface ICompositionPath(ICompositionPathVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionPath] {
    
}}
RT_CLASS!{class CompositionPath: ICompositionPath}
impl RtActivatable<ICompositionPathFactory> for CompositionPath {}
impl CompositionPath {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(source: &super::super::graphics::IGeometrySource2D) -> Result<ComPtr<CompositionPath>> {
        <Self as RtActivatable<ICompositionPathFactory>>::get_activation_factory().create(source)
    }
}
DEFINE_CLSID!(CompositionPath(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,67,111,109,112,111,115,105,116,105,111,110,80,97,116,104,0]) [CLSID_CompositionPath]);
DEFINE_IID!(IID_ICompositionPathFactory, 2619247722, 3891, 18257, 148, 55, 235, 63, 185, 211, 171, 7);
RT_INTERFACE!{static interface ICompositionPathFactory(ICompositionPathFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionPathFactory] {
    #[cfg(feature="windows-graphics")] fn Create(&self, source: *mut super::super::graphics::IGeometrySource2D, out: *mut *mut CompositionPath) -> HRESULT
}}
impl ICompositionPathFactory {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(&self, source: &super::super::graphics::IGeometrySource2D) -> Result<ComPtr<CompositionPath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, source as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionPathGeometry, 191512958, 11383, 19491, 175, 94, 99, 4, 193, 71, 187, 97);
RT_INTERFACE!{interface ICompositionPathGeometry(ICompositionPathGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionPathGeometry] {
    fn get_Path(&self, out: *mut *mut CompositionPath) -> HRESULT,
    fn put_Path(&self, value: *mut CompositionPath) -> HRESULT
}}
impl ICompositionPathGeometry {
    #[inline] pub fn get_path(&self) -> Result<Option<ComPtr<CompositionPath>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Path)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_path(&self, value: &CompositionPath) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Path)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionPathGeometry: ICompositionPathGeometry}
DEFINE_IID!(IID_ICompositionPropertySet, 3386298882, 24423, 17491, 145, 23, 158, 173, 212, 48, 211, 194);
RT_INTERFACE!{interface ICompositionPropertySet(ICompositionPropertySetVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionPropertySet] {
    fn InsertColor(&self, propertyName: HSTRING, value: super::Color) -> HRESULT,
    fn InsertMatrix3x2(&self, propertyName: HSTRING, value: foundation::numerics::Matrix3x2) -> HRESULT,
    fn InsertMatrix4x4(&self, propertyName: HSTRING, value: foundation::numerics::Matrix4x4) -> HRESULT,
    fn InsertQuaternion(&self, propertyName: HSTRING, value: foundation::numerics::Quaternion) -> HRESULT,
    fn InsertScalar(&self, propertyName: HSTRING, value: f32) -> HRESULT,
    fn InsertVector2(&self, propertyName: HSTRING, value: foundation::numerics::Vector2) -> HRESULT,
    fn InsertVector3(&self, propertyName: HSTRING, value: foundation::numerics::Vector3) -> HRESULT,
    fn InsertVector4(&self, propertyName: HSTRING, value: foundation::numerics::Vector4) -> HRESULT,
    fn TryGetColor(&self, propertyName: HSTRING, value: *mut super::Color, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetMatrix3x2(&self, propertyName: HSTRING, value: *mut foundation::numerics::Matrix3x2, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetMatrix4x4(&self, propertyName: HSTRING, value: *mut foundation::numerics::Matrix4x4, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetQuaternion(&self, propertyName: HSTRING, value: *mut foundation::numerics::Quaternion, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetScalar(&self, propertyName: HSTRING, value: *mut f32, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetVector2(&self, propertyName: HSTRING, value: *mut foundation::numerics::Vector2, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetVector3(&self, propertyName: HSTRING, value: *mut foundation::numerics::Vector3, out: *mut CompositionGetValueStatus) -> HRESULT,
    fn TryGetVector4(&self, propertyName: HSTRING, value: *mut foundation::numerics::Vector4, out: *mut CompositionGetValueStatus) -> HRESULT
}}
impl ICompositionPropertySet {
    #[inline] pub fn insert_color(&self, propertyName: &HStringArg, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertColor)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_matrix3x2(&self, propertyName: &HStringArg, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertMatrix3x2)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_matrix4x4(&self, propertyName: &HStringArg, value: foundation::numerics::Matrix4x4) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertMatrix4x4)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_quaternion(&self, propertyName: &HStringArg, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertQuaternion)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_scalar(&self, propertyName: &HStringArg, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertScalar)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_vector2(&self, propertyName: &HStringArg, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertVector2)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_vector3(&self, propertyName: &HStringArg, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertVector3)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_vector4(&self, propertyName: &HStringArg, value: foundation::numerics::Vector4) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertVector4)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_get_color(&self, propertyName: &HStringArg) -> Result<(super::Color, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetColor)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_matrix3x2(&self, propertyName: &HStringArg) -> Result<(foundation::numerics::Matrix3x2, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetMatrix3x2)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_matrix4x4(&self, propertyName: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetMatrix4x4)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_quaternion(&self, propertyName: &HStringArg) -> Result<(foundation::numerics::Quaternion, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetQuaternion)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_scalar(&self, propertyName: &HStringArg) -> Result<(f32, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetScalar)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_vector2(&self, propertyName: &HStringArg) -> Result<(foundation::numerics::Vector2, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetVector2)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_vector3(&self, propertyName: &HStringArg) -> Result<(foundation::numerics::Vector3, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetVector3)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_vector4(&self, propertyName: &HStringArg) -> Result<(foundation::numerics::Vector4, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetVector4)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionPropertySet: ICompositionPropertySet}
DEFINE_IID!(IID_ICompositionPropertySet2, 3732960030, 41489, 17493, 136, 128, 125, 15, 63, 106, 68, 253);
RT_INTERFACE!{interface ICompositionPropertySet2(ICompositionPropertySet2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionPropertySet2] {
    fn InsertBoolean(&self, propertyName: HSTRING, value: bool) -> HRESULT,
    fn TryGetBoolean(&self, propertyName: HSTRING, value: *mut bool, out: *mut CompositionGetValueStatus) -> HRESULT
}}
impl ICompositionPropertySet2 {
    #[inline] pub fn insert_boolean(&self, propertyName: &HStringArg, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertBoolean)(self as *const _ as *mut _, propertyName.get(), value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_get_boolean(&self, propertyName: &HStringArg) -> Result<(bool, CompositionGetValueStatus)> { unsafe { 
        let mut value = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryGetBoolean)(self as *const _ as *mut _, propertyName.get(), &mut value, &mut out);
        if hr == S_OK { Ok((value, out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionRectangleGeometry, 215290920, 21334, 16966, 174, 207, 122, 11, 118, 151, 84, 0);
RT_INTERFACE!{interface ICompositionRectangleGeometry(ICompositionRectangleGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionRectangleGeometry] {
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Size(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Size(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl ICompositionRectangleGeometry {
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_size(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionRectangleGeometry: ICompositionRectangleGeometry}
DEFINE_IID!(IID_ICompositionRoundedRectangleGeometry, 2272315426, 7504, 19339, 176, 19, 124, 154, 14, 70, 147, 95);
RT_INTERFACE!{interface ICompositionRoundedRectangleGeometry(ICompositionRoundedRectangleGeometryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionRoundedRectangleGeometry] {
    fn get_CornerRadius(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_CornerRadius(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Size(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Size(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl ICompositionRoundedRectangleGeometry {
    #[inline] pub fn get_corner_radius(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CornerRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_corner_radius(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CornerRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_size(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionRoundedRectangleGeometry: ICompositionRoundedRectangleGeometry}
DEFINE_IID!(IID_ICompositionScopedBatch, 218159824, 64263, 18173, 140, 114, 98, 128, 209, 163, 209, 221);
RT_INTERFACE!{interface ICompositionScopedBatch(ICompositionScopedBatchVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionScopedBatch] {
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_IsEnded(&self, out: *mut bool) -> HRESULT,
    fn End(&self) -> HRESULT,
    fn Resume(&self) -> HRESULT,
    fn Suspend(&self) -> HRESULT,
    fn add_Completed(&self, handler: *mut foundation::TypedEventHandler<IInspectable, CompositionBatchCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompositionScopedBatch {
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_ended(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnded)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn end(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).End)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn resume(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Resume)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn suspend(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Suspend)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_completed(&self, handler: &foundation::TypedEventHandler<IInspectable, CompositionBatchCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionScopedBatch: ICompositionScopedBatch}
DEFINE_IID!(IID_ICompositionShadow, 849236706, 17205, 18892, 177, 74, 55, 120, 45, 16, 240, 196);
RT_INTERFACE!{interface ICompositionShadow(ICompositionShadowVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionShadow] {
    
}}
RT_CLASS!{class CompositionShadow: ICompositionShadow}
DEFINE_IID!(IID_ICompositionShadowFactory, 572475695, 56506, 19345, 153, 158, 29, 194, 23, 160, 21, 48);
RT_INTERFACE!{interface ICompositionShadowFactory(ICompositionShadowFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionShadowFactory] {
    
}}
DEFINE_IID!(IID_ICompositionShape, 3028083447, 39560, 17092, 158, 135, 46, 80, 12, 168, 104, 140);
RT_INTERFACE!{interface ICompositionShape(ICompositionShapeVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionShape] {
    fn get_CenterPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_CenterPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_RotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngle(&self, value: f32) -> HRESULT,
    fn get_RotationAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_Scale(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Scale(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_TransformMatrix(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_TransformMatrix(&self, value: foundation::numerics::Matrix3x2) -> HRESULT
}}
impl ICompositionShape {
    #[inline] pub fn get_center_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_center_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CenterPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Scale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transform_matrix(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransformMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transform_matrix(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TransformMatrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionShape: ICompositionShape}
RT_CLASS!{class CompositionShapeCollection: foundation::collections::IVector<CompositionShape>}
DEFINE_IID!(IID_ICompositionShapeFactory, 503068368, 45146, 17647, 130, 176, 18, 17, 139, 205, 76, 208);
RT_INTERFACE!{interface ICompositionShapeFactory(ICompositionShapeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionShapeFactory] {
    
}}
DEFINE_IID!(IID_ICompositionSpriteShape, 1075536315, 7, 17251, 177, 243, 107, 204, 0, 63, 184, 62);
RT_INTERFACE!{interface ICompositionSpriteShape(ICompositionSpriteShapeVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionSpriteShape] {
    fn get_FillBrush(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_FillBrush(&self, value: *mut CompositionBrush) -> HRESULT,
    fn get_Geometry(&self, out: *mut *mut CompositionGeometry) -> HRESULT,
    fn put_Geometry(&self, value: *mut CompositionGeometry) -> HRESULT,
    fn get_IsStrokeNonScaling(&self, out: *mut bool) -> HRESULT,
    fn put_IsStrokeNonScaling(&self, value: bool) -> HRESULT,
    fn get_StrokeBrush(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_StrokeBrush(&self, value: *mut CompositionBrush) -> HRESULT,
    fn get_StrokeDashArray(&self, out: *mut *mut CompositionStrokeDashArray) -> HRESULT,
    fn get_StrokeDashCap(&self, out: *mut CompositionStrokeCap) -> HRESULT,
    fn put_StrokeDashCap(&self, value: CompositionStrokeCap) -> HRESULT,
    fn get_StrokeDashOffset(&self, out: *mut f32) -> HRESULT,
    fn put_StrokeDashOffset(&self, value: f32) -> HRESULT,
    fn get_StrokeEndCap(&self, out: *mut CompositionStrokeCap) -> HRESULT,
    fn put_StrokeEndCap(&self, value: CompositionStrokeCap) -> HRESULT,
    fn get_StrokeLineJoin(&self, out: *mut CompositionStrokeLineJoin) -> HRESULT,
    fn put_StrokeLineJoin(&self, value: CompositionStrokeLineJoin) -> HRESULT,
    fn get_StrokeMiterLimit(&self, out: *mut f32) -> HRESULT,
    fn put_StrokeMiterLimit(&self, value: f32) -> HRESULT,
    fn get_StrokeStartCap(&self, out: *mut CompositionStrokeCap) -> HRESULT,
    fn put_StrokeStartCap(&self, value: CompositionStrokeCap) -> HRESULT,
    fn get_StrokeThickness(&self, out: *mut f32) -> HRESULT,
    fn put_StrokeThickness(&self, value: f32) -> HRESULT
}}
impl ICompositionSpriteShape {
    #[inline] pub fn get_fill_brush(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FillBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_fill_brush(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FillBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_geometry(&self) -> Result<Option<ComPtr<CompositionGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Geometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_geometry(&self, value: &CompositionGeometry) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Geometry)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stroke_non_scaling(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsStrokeNonScaling)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_stroke_non_scaling(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsStrokeNonScaling)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_brush(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_brush(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeBrush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_dash_array(&self) -> Result<Option<ComPtr<CompositionStrokeDashArray>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDashArray)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_dash_cap(&self) -> Result<CompositionStrokeCap> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeDashCap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_dash_cap(&self, value: CompositionStrokeCap) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeDashCap)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_dash_offset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeDashOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_dash_offset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeDashOffset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_end_cap(&self) -> Result<CompositionStrokeCap> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeEndCap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_end_cap(&self, value: CompositionStrokeCap) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeEndCap)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_line_join(&self) -> Result<CompositionStrokeLineJoin> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeLineJoin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_line_join(&self, value: CompositionStrokeLineJoin) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeLineJoin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_miter_limit(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeMiterLimit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_miter_limit(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeMiterLimit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_start_cap(&self) -> Result<CompositionStrokeCap> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeStartCap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_start_cap(&self, value: CompositionStrokeCap) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeStartCap)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_thickness(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StrokeThickness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_thickness(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeThickness)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionSpriteShape: ICompositionSpriteShape}
RT_ENUM! { enum CompositionStretch: i32 {
    None = 0, Fill = 1, Uniform = 2, UniformToFill = 3,
}}
RT_ENUM! { enum CompositionStrokeCap: i32 {
    Flat = 0, Square = 1, Round = 2, Triangle = 3,
}}
RT_CLASS!{class CompositionStrokeDashArray: foundation::collections::IVector<f32>}
RT_ENUM! { enum CompositionStrokeLineJoin: i32 {
    Miter = 0, Bevel = 1, Round = 2, MiterOrBevel = 3,
}}
DEFINE_IID!(IID_ICompositionSurface, 354898957, 17095, 18342, 164, 8, 102, 143, 121, 169, 13, 251);
RT_INTERFACE!{interface ICompositionSurface(ICompositionSurfaceVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionSurface] {
    
}}
DEFINE_IID!(IID_ICompositionSurfaceBrush, 2902551929, 7756, 19469, 156, 41, 131, 51, 140, 135, 193, 98);
RT_INTERFACE!{interface ICompositionSurfaceBrush(ICompositionSurfaceBrushVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionSurfaceBrush] {
    fn get_BitmapInterpolationMode(&self, out: *mut CompositionBitmapInterpolationMode) -> HRESULT,
    fn put_BitmapInterpolationMode(&self, value: CompositionBitmapInterpolationMode) -> HRESULT,
    fn get_HorizontalAlignmentRatio(&self, out: *mut f32) -> HRESULT,
    fn put_HorizontalAlignmentRatio(&self, value: f32) -> HRESULT,
    fn get_Stretch(&self, out: *mut CompositionStretch) -> HRESULT,
    fn put_Stretch(&self, value: CompositionStretch) -> HRESULT,
    fn get_Surface(&self, out: *mut *mut ICompositionSurface) -> HRESULT,
    fn put_Surface(&self, value: *mut ICompositionSurface) -> HRESULT,
    fn get_VerticalAlignmentRatio(&self, out: *mut f32) -> HRESULT,
    fn put_VerticalAlignmentRatio(&self, value: f32) -> HRESULT
}}
impl ICompositionSurfaceBrush {
    #[inline] pub fn get_bitmap_interpolation_mode(&self) -> Result<CompositionBitmapInterpolationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BitmapInterpolationMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bitmap_interpolation_mode(&self, value: CompositionBitmapInterpolationMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BitmapInterpolationMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_alignment_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalAlignmentRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_horizontal_alignment_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_HorizontalAlignmentRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stretch(&self) -> Result<CompositionStretch> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stretch(&self, value: CompositionStretch) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_surface(&self) -> Result<Option<ComPtr<ICompositionSurface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Surface)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_surface(&self, value: &ICompositionSurface) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Surface)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_alignment_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalAlignmentRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_vertical_alignment_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_VerticalAlignmentRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionSurfaceBrush: ICompositionSurfaceBrush}
DEFINE_IID!(IID_ICompositionSurfaceBrush2, 3530650837, 25845, 18066, 157, 199, 113, 182, 29, 126, 88, 128);
RT_INTERFACE!{interface ICompositionSurfaceBrush2(ICompositionSurfaceBrush2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositionSurfaceBrush2] {
    fn get_AnchorPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_AnchorPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_CenterPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_CenterPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_RotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngle(&self, value: f32) -> HRESULT,
    fn get_RotationAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_Scale(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Scale(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_TransformMatrix(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_TransformMatrix(&self, value: foundation::numerics::Matrix3x2) -> HRESULT
}}
impl ICompositionSurfaceBrush2 {
    #[inline] pub fn get_anchor_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnchorPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_anchor_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AnchorPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_center_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_center_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CenterPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Scale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transform_matrix(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransformMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transform_matrix(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TransformMatrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionTarget, 2713626810, 55078, 18019, 129, 41, 107, 94, 121, 39, 255, 166);
RT_INTERFACE!{interface ICompositionTarget(ICompositionTargetVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionTarget] {
    fn get_Root(&self, out: *mut *mut Visual) -> HRESULT,
    fn put_Root(&self, value: *mut Visual) -> HRESULT
}}
impl ICompositionTarget {
    #[inline] pub fn get_root(&self) -> Result<Option<ComPtr<Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Root)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_root(&self, value: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Root)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionTarget: ICompositionTarget}
DEFINE_IID!(IID_ICompositionTargetFactory, 2479725867, 34070, 19220, 168, 206, 244, 158, 33, 25, 236, 66);
RT_INTERFACE!{interface ICompositionTargetFactory(ICompositionTargetFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionTargetFactory] {
    
}}
DEFINE_IID!(IID_ICompositionViewBox, 3024142087, 1679, 17719, 132, 198, 78, 203, 224, 25, 225, 244);
RT_INTERFACE!{interface ICompositionViewBox(ICompositionViewBoxVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionViewBox] {
    fn get_HorizontalAlignmentRatio(&self, out: *mut f32) -> HRESULT,
    fn put_HorizontalAlignmentRatio(&self, value: f32) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Size(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Size(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_Stretch(&self, out: *mut CompositionStretch) -> HRESULT,
    fn put_Stretch(&self, value: CompositionStretch) -> HRESULT,
    fn get_VerticalAlignmentRatio(&self, out: *mut f32) -> HRESULT,
    fn put_VerticalAlignmentRatio(&self, value: f32) -> HRESULT
}}
impl ICompositionViewBox {
    #[inline] pub fn get_horizontal_alignment_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HorizontalAlignmentRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_horizontal_alignment_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_HorizontalAlignmentRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_size(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stretch(&self) -> Result<CompositionStretch> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Stretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stretch(&self, value: CompositionStretch) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Stretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_alignment_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VerticalAlignmentRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_vertical_alignment_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_VerticalAlignmentRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionViewBox: ICompositionViewBox}
DEFINE_IID!(IID_ICompositionVirtualDrawingSurface, 2848163035, 34624, 20372, 139, 157, 182, 133, 33, 231, 134, 61);
RT_INTERFACE!{interface ICompositionVirtualDrawingSurface(ICompositionVirtualDrawingSurfaceVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionVirtualDrawingSurface] {
    #[cfg(feature="windows-graphics")] fn Trim(&self, rectsSize: u32, rects: *mut super::super::graphics::RectInt32) -> HRESULT
}}
impl ICompositionVirtualDrawingSurface {
    #[cfg(feature="windows-graphics")] #[inline] pub fn trim(&self, rects: &[super::super::graphics::RectInt32]) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Trim)(self as *const _ as *mut _, rects.len() as u32, rects.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionVirtualDrawingSurface: ICompositionVirtualDrawingSurface}
DEFINE_IID!(IID_ICompositionVirtualDrawingSurfaceFactory, 1734742124, 54635, 19017, 177, 223, 80, 118, 160, 98, 7, 104);
RT_INTERFACE!{interface ICompositionVirtualDrawingSurfaceFactory(ICompositionVirtualDrawingSurfaceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionVirtualDrawingSurfaceFactory] {
    
}}
DEFINE_IID!(IID_ICompositor, 3020147280, 32652, 20099, 152, 95, 204, 69, 6, 0, 54, 216);
RT_INTERFACE!{interface ICompositor(ICompositorVtbl): IInspectable(IInspectableVtbl) [IID_ICompositor] {
    fn CreateColorKeyFrameAnimation(&self, out: *mut *mut ColorKeyFrameAnimation) -> HRESULT,
    fn CreateColorBrush(&self, out: *mut *mut CompositionColorBrush) -> HRESULT,
    fn CreateColorBrushWithColor(&self, color: super::Color, out: *mut *mut CompositionColorBrush) -> HRESULT,
    fn CreateContainerVisual(&self, out: *mut *mut ContainerVisual) -> HRESULT,
    fn CreateCubicBezierEasingFunction(&self, controlPoint1: foundation::numerics::Vector2, controlPoint2: foundation::numerics::Vector2, out: *mut *mut CubicBezierEasingFunction) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn CreateEffectFactory(&self, graphicsEffect: *mut super::super::graphics::effects::IGraphicsEffect, out: *mut *mut CompositionEffectFactory) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-graphics")] fn CreateEffectFactoryWithProperties(&self, graphicsEffect: *mut super::super::graphics::effects::IGraphicsEffect, animatableProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut CompositionEffectFactory) -> HRESULT,
    fn CreateExpressionAnimation(&self, out: *mut *mut ExpressionAnimation) -> HRESULT,
    fn CreateExpressionAnimationWithExpression(&self, expression: HSTRING, out: *mut *mut ExpressionAnimation) -> HRESULT,
    fn CreateInsetClip(&self, out: *mut *mut InsetClip) -> HRESULT,
    fn CreateInsetClipWithInsets(&self, leftInset: f32, topInset: f32, rightInset: f32, bottomInset: f32, out: *mut *mut InsetClip) -> HRESULT,
    fn CreateLinearEasingFunction(&self, out: *mut *mut LinearEasingFunction) -> HRESULT,
    fn CreatePropertySet(&self, out: *mut *mut CompositionPropertySet) -> HRESULT,
    fn CreateQuaternionKeyFrameAnimation(&self, out: *mut *mut QuaternionKeyFrameAnimation) -> HRESULT,
    fn CreateScalarKeyFrameAnimation(&self, out: *mut *mut ScalarKeyFrameAnimation) -> HRESULT,
    fn CreateScopedBatch(&self, batchType: CompositionBatchTypes, out: *mut *mut CompositionScopedBatch) -> HRESULT,
    fn CreateSpriteVisual(&self, out: *mut *mut SpriteVisual) -> HRESULT,
    fn CreateSurfaceBrush(&self, out: *mut *mut CompositionSurfaceBrush) -> HRESULT,
    fn CreateSurfaceBrushWithSurface(&self, surface: *mut ICompositionSurface, out: *mut *mut CompositionSurfaceBrush) -> HRESULT,
    fn CreateTargetForCurrentView(&self, out: *mut *mut CompositionTarget) -> HRESULT,
    fn CreateVector2KeyFrameAnimation(&self, out: *mut *mut Vector2KeyFrameAnimation) -> HRESULT,
    fn CreateVector3KeyFrameAnimation(&self, out: *mut *mut Vector3KeyFrameAnimation) -> HRESULT,
    fn CreateVector4KeyFrameAnimation(&self, out: *mut *mut Vector4KeyFrameAnimation) -> HRESULT,
    fn GetCommitBatch(&self, batchType: CompositionBatchTypes, out: *mut *mut CompositionCommitBatch) -> HRESULT
}}
impl ICompositor {
    #[inline] pub fn create_color_key_frame_animation(&self) -> Result<Option<ComPtr<ColorKeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateColorKeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_color_brush(&self) -> Result<Option<ComPtr<CompositionColorBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateColorBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_color_brush_with_color(&self, color: super::Color) -> Result<Option<ComPtr<CompositionColorBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateColorBrushWithColor)(self as *const _ as *mut _, color, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_container_visual(&self) -> Result<Option<ComPtr<ContainerVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateContainerVisual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_cubic_bezier_easing_function(&self, controlPoint1: foundation::numerics::Vector2, controlPoint2: foundation::numerics::Vector2) -> Result<Option<ComPtr<CubicBezierEasingFunction>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCubicBezierEasingFunction)(self as *const _ as *mut _, controlPoint1, controlPoint2, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_effect_factory(&self, graphicsEffect: &super::super::graphics::effects::IGraphicsEffect) -> Result<Option<ComPtr<CompositionEffectFactory>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateEffectFactory)(self as *const _ as *mut _, graphicsEffect as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_effect_factory_with_properties(&self, graphicsEffect: &super::super::graphics::effects::IGraphicsEffect, animatableProperties: &foundation::collections::IIterable<HString>) -> Result<Option<ComPtr<CompositionEffectFactory>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateEffectFactoryWithProperties)(self as *const _ as *mut _, graphicsEffect as *const _ as *mut _, animatableProperties as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_expression_animation(&self) -> Result<Option<ComPtr<ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateExpressionAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_expression_animation_with_expression(&self, expression: &HStringArg) -> Result<Option<ComPtr<ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateExpressionAnimationWithExpression)(self as *const _ as *mut _, expression.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_inset_clip(&self) -> Result<Option<ComPtr<InsetClip>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInsetClip)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_inset_clip_with_insets(&self, leftInset: f32, topInset: f32, rightInset: f32, bottomInset: f32) -> Result<Option<ComPtr<InsetClip>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInsetClipWithInsets)(self as *const _ as *mut _, leftInset, topInset, rightInset, bottomInset, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_linear_easing_function(&self) -> Result<Option<ComPtr<LinearEasingFunction>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLinearEasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_property_set(&self) -> Result<Option<ComPtr<CompositionPropertySet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePropertySet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_quaternion_key_frame_animation(&self) -> Result<Option<ComPtr<QuaternionKeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateQuaternionKeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_scalar_key_frame_animation(&self) -> Result<Option<ComPtr<ScalarKeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateScalarKeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_scoped_batch(&self, batchType: CompositionBatchTypes) -> Result<Option<ComPtr<CompositionScopedBatch>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateScopedBatch)(self as *const _ as *mut _, batchType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_sprite_visual(&self) -> Result<Option<ComPtr<SpriteVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpriteVisual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_surface_brush(&self) -> Result<Option<ComPtr<CompositionSurfaceBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSurfaceBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_surface_brush_with_surface(&self, surface: &ICompositionSurface) -> Result<Option<ComPtr<CompositionSurfaceBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSurfaceBrushWithSurface)(self as *const _ as *mut _, surface as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_target_for_current_view(&self) -> Result<Option<ComPtr<CompositionTarget>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTargetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_vector2_key_frame_animation(&self) -> Result<Option<ComPtr<Vector2KeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateVector2KeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_vector3_key_frame_animation(&self) -> Result<Option<ComPtr<Vector3KeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateVector3KeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_vector4_key_frame_animation(&self) -> Result<Option<ComPtr<Vector4KeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateVector4KeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_commit_batch(&self, batchType: CompositionBatchTypes) -> Result<Option<ComPtr<CompositionCommitBatch>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCommitBatch)(self as *const _ as *mut _, batchType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Compositor: ICompositor}
impl RtActivatable<ICompositorStatics> for Compositor {}
impl RtActivatable<IActivationFactory> for Compositor {}
impl Compositor {
    #[inline] pub fn get_max_global_playback_rate() -> Result<f32> {
        <Self as RtActivatable<ICompositorStatics>>::get_activation_factory().get_max_global_playback_rate()
    }
    #[inline] pub fn get_min_global_playback_rate() -> Result<f32> {
        <Self as RtActivatable<ICompositorStatics>>::get_activation_factory().get_min_global_playback_rate()
    }
}
DEFINE_CLSID!(Compositor(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,67,111,109,112,111,115,105,116,111,114,0]) [CLSID_Compositor]);
DEFINE_IID!(IID_ICompositor2, 1934655964, 24100, 17882, 163, 143, 227, 44, 195, 73, 169, 160);
RT_INTERFACE!{interface ICompositor2(ICompositor2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositor2] {
    fn CreateAmbientLight(&self, out: *mut *mut AmbientLight) -> HRESULT,
    fn CreateAnimationGroup(&self, out: *mut *mut CompositionAnimationGroup) -> HRESULT,
    fn CreateBackdropBrush(&self, out: *mut *mut CompositionBackdropBrush) -> HRESULT,
    fn CreateDistantLight(&self, out: *mut *mut DistantLight) -> HRESULT,
    fn CreateDropShadow(&self, out: *mut *mut DropShadow) -> HRESULT,
    fn CreateImplicitAnimationCollection(&self, out: *mut *mut ImplicitAnimationCollection) -> HRESULT,
    fn CreateLayerVisual(&self, out: *mut *mut LayerVisual) -> HRESULT,
    fn CreateMaskBrush(&self, out: *mut *mut CompositionMaskBrush) -> HRESULT,
    fn CreateNineGridBrush(&self, out: *mut *mut CompositionNineGridBrush) -> HRESULT,
    fn CreatePointLight(&self, out: *mut *mut PointLight) -> HRESULT,
    fn CreateSpotLight(&self, out: *mut *mut SpotLight) -> HRESULT,
    fn CreateStepEasingFunction(&self, out: *mut *mut StepEasingFunction) -> HRESULT,
    fn CreateStepEasingFunctionWithStepCount(&self, stepCount: i32, out: *mut *mut StepEasingFunction) -> HRESULT
}}
impl ICompositor2 {
    #[inline] pub fn create_ambient_light(&self) -> Result<Option<ComPtr<AmbientLight>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAmbientLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_animation_group(&self) -> Result<Option<ComPtr<CompositionAnimationGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAnimationGroup)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_backdrop_brush(&self) -> Result<Option<ComPtr<CompositionBackdropBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBackdropBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_distant_light(&self) -> Result<Option<ComPtr<DistantLight>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDistantLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_drop_shadow(&self) -> Result<Option<ComPtr<DropShadow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDropShadow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_implicit_animation_collection(&self) -> Result<Option<ComPtr<ImplicitAnimationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateImplicitAnimationCollection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_layer_visual(&self) -> Result<Option<ComPtr<LayerVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLayerVisual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_mask_brush(&self) -> Result<Option<ComPtr<CompositionMaskBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateMaskBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_nine_grid_brush(&self) -> Result<Option<ComPtr<CompositionNineGridBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateNineGridBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_point_light(&self) -> Result<Option<ComPtr<PointLight>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePointLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_spot_light(&self) -> Result<Option<ComPtr<SpotLight>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpotLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_step_easing_function(&self) -> Result<Option<ComPtr<StepEasingFunction>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateStepEasingFunction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_step_easing_function_with_step_count(&self, stepCount: i32) -> Result<Option<ComPtr<StepEasingFunction>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateStepEasingFunctionWithStepCount)(self as *const _ as *mut _, stepCount, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositor3, 3386740464, 28337, 20028, 166, 88, 103, 93, 156, 100, 212, 171);
RT_INTERFACE!{interface ICompositor3(ICompositor3Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositor3] {
    fn CreateHostBackdropBrush(&self, out: *mut *mut CompositionBackdropBrush) -> HRESULT
}}
impl ICompositor3 {
    #[inline] pub fn create_host_backdrop_brush(&self) -> Result<Option<ComPtr<CompositionBackdropBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateHostBackdropBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositor4, 2923947914, 30992, 17445, 164, 130, 160, 91, 117, 138, 220, 233);
RT_INTERFACE!{interface ICompositor4(ICompositor4Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositor4] {
    fn CreateColorGradientStop(&self, out: *mut *mut CompositionColorGradientStop) -> HRESULT,
    fn CreateColorGradientStopWithOffsetAndColor(&self, offset: f32, color: super::Color, out: *mut *mut CompositionColorGradientStop) -> HRESULT,
    fn CreateLinearGradientBrush(&self, out: *mut *mut CompositionLinearGradientBrush) -> HRESULT,
    fn CreateSpringScalarAnimation(&self, out: *mut *mut SpringScalarNaturalMotionAnimation) -> HRESULT,
    fn CreateSpringVector2Animation(&self, out: *mut *mut SpringVector2NaturalMotionAnimation) -> HRESULT,
    fn CreateSpringVector3Animation(&self, out: *mut *mut SpringVector3NaturalMotionAnimation) -> HRESULT
}}
impl ICompositor4 {
    #[inline] pub fn create_color_gradient_stop(&self) -> Result<Option<ComPtr<CompositionColorGradientStop>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateColorGradientStop)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_color_gradient_stop_with_offset_and_color(&self, offset: f32, color: super::Color) -> Result<Option<ComPtr<CompositionColorGradientStop>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateColorGradientStopWithOffsetAndColor)(self as *const _ as *mut _, offset, color, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_linear_gradient_brush(&self) -> Result<Option<ComPtr<CompositionLinearGradientBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLinearGradientBrush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_spring_scalar_animation(&self) -> Result<Option<ComPtr<SpringScalarNaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpringScalarAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_spring_vector2_animation(&self) -> Result<Option<ComPtr<SpringVector2NaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpringVector2Animation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_spring_vector3_animation(&self) -> Result<Option<ComPtr<SpringVector3NaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpringVector3Animation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositor5, 1223307693, 32717, 16502, 167, 156, 144, 204, 75, 133, 44, 155);
RT_INTERFACE!{interface ICompositor5(ICompositor5Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositor5] {
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Comment(&self, value: HSTRING) -> HRESULT,
    fn get_GlobalPlaybackRate(&self, out: *mut f32) -> HRESULT,
    fn put_GlobalPlaybackRate(&self, value: f32) -> HRESULT,
    fn CreateBounceScalarAnimation(&self, out: *mut *mut BounceScalarNaturalMotionAnimation) -> HRESULT,
    fn CreateBounceVector2Animation(&self, out: *mut *mut BounceVector2NaturalMotionAnimation) -> HRESULT,
    fn CreateBounceVector3Animation(&self, out: *mut *mut BounceVector3NaturalMotionAnimation) -> HRESULT,
    fn CreateContainerShape(&self, out: *mut *mut CompositionContainerShape) -> HRESULT,
    fn CreateEllipseGeometry(&self, out: *mut *mut CompositionEllipseGeometry) -> HRESULT,
    fn CreateLineGeometry(&self, out: *mut *mut CompositionLineGeometry) -> HRESULT,
    fn CreatePathGeometry(&self, out: *mut *mut CompositionPathGeometry) -> HRESULT,
    fn CreatePathGeometryWithPath(&self, path: *mut CompositionPath, out: *mut *mut CompositionPathGeometry) -> HRESULT,
    fn CreatePathKeyFrameAnimation(&self, out: *mut *mut PathKeyFrameAnimation) -> HRESULT,
    fn CreateRectangleGeometry(&self, out: *mut *mut CompositionRectangleGeometry) -> HRESULT,
    fn CreateRoundedRectangleGeometry(&self, out: *mut *mut CompositionRoundedRectangleGeometry) -> HRESULT,
    fn CreateShapeVisual(&self, out: *mut *mut ShapeVisual) -> HRESULT,
    fn CreateSpriteShape(&self, out: *mut *mut CompositionSpriteShape) -> HRESULT,
    fn CreateSpriteShapeWithGeometry(&self, geometry: *mut CompositionGeometry, out: *mut *mut CompositionSpriteShape) -> HRESULT,
    fn CreateViewBox(&self, out: *mut *mut CompositionViewBox) -> HRESULT,
    fn RequestCommitAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ICompositor5 {
    #[inline] pub fn get_comment(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_comment(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Comment)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_global_playback_rate(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GlobalPlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_global_playback_rate(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_GlobalPlaybackRate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_bounce_scalar_animation(&self) -> Result<Option<ComPtr<BounceScalarNaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBounceScalarAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_bounce_vector2_animation(&self) -> Result<Option<ComPtr<BounceVector2NaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBounceVector2Animation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_bounce_vector3_animation(&self) -> Result<Option<ComPtr<BounceVector3NaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBounceVector3Animation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_container_shape(&self) -> Result<Option<ComPtr<CompositionContainerShape>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateContainerShape)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_ellipse_geometry(&self) -> Result<Option<ComPtr<CompositionEllipseGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateEllipseGeometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_line_geometry(&self) -> Result<Option<ComPtr<CompositionLineGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLineGeometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_path_geometry(&self) -> Result<Option<ComPtr<CompositionPathGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePathGeometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_path_geometry_with_path(&self, path: &CompositionPath) -> Result<Option<ComPtr<CompositionPathGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePathGeometryWithPath)(self as *const _ as *mut _, path as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_path_key_frame_animation(&self) -> Result<Option<ComPtr<PathKeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreatePathKeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_rectangle_geometry(&self) -> Result<Option<ComPtr<CompositionRectangleGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateRectangleGeometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_rounded_rectangle_geometry(&self) -> Result<Option<ComPtr<CompositionRoundedRectangleGeometry>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateRoundedRectangleGeometry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_shape_visual(&self) -> Result<Option<ComPtr<ShapeVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateShapeVisual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_sprite_shape(&self) -> Result<Option<ComPtr<CompositionSpriteShape>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpriteShape)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_sprite_shape_with_geometry(&self, geometry: &CompositionGeometry) -> Result<Option<ComPtr<CompositionSpriteShape>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSpriteShapeWithGeometry)(self as *const _ as *mut _, geometry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_view_box(&self) -> Result<Option<ComPtr<CompositionViewBox>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateViewBox)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_commit_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestCommitAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositor6, 2050536125, 52936, 20203, 131, 15, 216, 208, 122, 237, 235, 195);
RT_INTERFACE!{interface ICompositor6(ICompositor6Vtbl): IInspectable(IInspectableVtbl) [IID_ICompositor6] {
    fn CreateGeometricClip(&self, out: *mut *mut CompositionGeometricClip) -> HRESULT,
    fn CreateGeometricClipWithGeometry(&self, geometry: *mut CompositionGeometry, out: *mut *mut CompositionGeometricClip) -> HRESULT,
    fn CreateRedirectVisual(&self, out: *mut *mut RedirectVisual) -> HRESULT,
    fn CreateRedirectVisualWithSourceVisual(&self, source: *mut Visual, out: *mut *mut RedirectVisual) -> HRESULT,
    fn CreateBooleanKeyFrameAnimation(&self, out: *mut *mut BooleanKeyFrameAnimation) -> HRESULT
}}
impl ICompositor6 {
    #[inline] pub fn create_geometric_clip(&self) -> Result<Option<ComPtr<CompositionGeometricClip>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateGeometricClip)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_geometric_clip_with_geometry(&self, geometry: &CompositionGeometry) -> Result<Option<ComPtr<CompositionGeometricClip>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateGeometricClipWithGeometry)(self as *const _ as *mut _, geometry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_redirect_visual(&self) -> Result<Option<ComPtr<RedirectVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateRedirectVisual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_redirect_visual_with_source_visual(&self, source: &Visual) -> Result<Option<ComPtr<RedirectVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateRedirectVisualWithSourceVisual)(self as *const _ as *mut _, source as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_boolean_key_frame_animation(&self) -> Result<Option<ComPtr<BooleanKeyFrameAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBooleanKeyFrameAnimation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositorStatics, 135117118, 4638, 19863, 139, 116, 29, 252, 249, 25, 135, 234);
RT_INTERFACE!{static interface ICompositorStatics(ICompositorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositorStatics] {
    fn get_MaxGlobalPlaybackRate(&self, out: *mut f32) -> HRESULT,
    fn get_MinGlobalPlaybackRate(&self, out: *mut f32) -> HRESULT
}}
impl ICompositorStatics {
    #[inline] pub fn get_max_global_playback_rate(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxGlobalPlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_global_playback_rate(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinGlobalPlaybackRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IContainerVisual, 49724532, 60704, 18291, 175, 230, 212, 155, 74, 147, 219, 50);
RT_INTERFACE!{interface IContainerVisual(IContainerVisualVtbl): IInspectable(IInspectableVtbl) [IID_IContainerVisual] {
    fn get_Children(&self, out: *mut *mut VisualCollection) -> HRESULT
}}
impl IContainerVisual {
    #[inline] pub fn get_children(&self) -> Result<Option<ComPtr<VisualCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ContainerVisual: IContainerVisual}
DEFINE_IID!(IID_IContainerVisualFactory, 56862299, 51162, 19866, 149, 244, 105, 181, 200, 223, 103, 11);
RT_INTERFACE!{interface IContainerVisualFactory(IContainerVisualFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContainerVisualFactory] {
    
}}
DEFINE_IID!(IID_ICubicBezierEasingFunction, 842335846, 49640, 17657, 150, 184, 201, 138, 207, 10, 230, 152);
RT_INTERFACE!{interface ICubicBezierEasingFunction(ICubicBezierEasingFunctionVtbl): IInspectable(IInspectableVtbl) [IID_ICubicBezierEasingFunction] {
    fn get_ControlPoint1(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn get_ControlPoint2(&self, out: *mut foundation::numerics::Vector2) -> HRESULT
}}
impl ICubicBezierEasingFunction {
    #[inline] pub fn get_control_point1(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ControlPoint1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control_point2(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ControlPoint2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CubicBezierEasingFunction: ICubicBezierEasingFunction}
DEFINE_IID!(IID_IDistantLight, 831322876, 23779, 19285, 171, 93, 7, 160, 3, 83, 172, 153);
RT_INTERFACE!{interface IDistantLight(IDistantLightVtbl): IInspectable(IInspectableVtbl) [IID_IDistantLight] {
    fn get_Color(&self, out: *mut super::Color) -> HRESULT,
    fn put_Color(&self, value: super::Color) -> HRESULT,
    fn get_CoordinateSpace(&self, out: *mut *mut Visual) -> HRESULT,
    fn put_CoordinateSpace(&self, value: *mut Visual) -> HRESULT,
    fn get_Direction(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Direction(&self, value: foundation::numerics::Vector3) -> HRESULT
}}
impl IDistantLight {
    #[inline] pub fn get_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_coordinate_space(&self) -> Result<Option<ComPtr<Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CoordinateSpace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_coordinate_space(&self, value: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CoordinateSpace)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_direction(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_direction(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Direction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DistantLight: IDistantLight}
DEFINE_IID!(IID_IDistantLight2, 3687688732, 10571, 18647, 182, 14, 118, 223, 100, 170, 57, 43);
RT_INTERFACE!{interface IDistantLight2(IDistantLight2Vtbl): IInspectable(IInspectableVtbl) [IID_IDistantLight2] {
    fn get_Intensity(&self, out: *mut f32) -> HRESULT,
    fn put_Intensity(&self, value: f32) -> HRESULT
}}
impl IDistantLight2 {
    #[inline] pub fn get_intensity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Intensity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_intensity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Intensity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDropShadow, 3415702535, 41300, 18513, 133, 231, 168, 146, 76, 132, 250, 216);
RT_INTERFACE!{interface IDropShadow(IDropShadowVtbl): IInspectable(IInspectableVtbl) [IID_IDropShadow] {
    fn get_BlurRadius(&self, out: *mut f32) -> HRESULT,
    fn put_BlurRadius(&self, value: f32) -> HRESULT,
    fn get_Color(&self, out: *mut super::Color) -> HRESULT,
    fn put_Color(&self, value: super::Color) -> HRESULT,
    fn get_Mask(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_Mask(&self, value: *mut CompositionBrush) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Opacity(&self, out: *mut f32) -> HRESULT,
    fn put_Opacity(&self, value: f32) -> HRESULT
}}
impl IDropShadow {
    #[inline] pub fn get_blur_radius(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BlurRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_blur_radius(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BlurRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mask(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Mask)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_mask(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Mask)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_opacity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Opacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_opacity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Opacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DropShadow: IDropShadow}
DEFINE_IID!(IID_IDropShadow2, 1816271036, 5561, 19501, 141, 74, 7, 103, 223, 17, 151, 122);
RT_INTERFACE!{interface IDropShadow2(IDropShadow2Vtbl): IInspectable(IInspectableVtbl) [IID_IDropShadow2] {
    fn get_SourcePolicy(&self, out: *mut CompositionDropShadowSourcePolicy) -> HRESULT,
    fn put_SourcePolicy(&self, value: CompositionDropShadowSourcePolicy) -> HRESULT
}}
impl IDropShadow2 {
    #[inline] pub fn get_source_policy(&self) -> Result<CompositionDropShadowSourcePolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourcePolicy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_source_policy(&self, value: CompositionDropShadowSourcePolicy) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SourcePolicy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IExpressionAnimation, 1791775793, 32061, 19443, 171, 182, 244, 75, 220, 72, 136, 193);
RT_INTERFACE!{interface IExpressionAnimation(IExpressionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IExpressionAnimation] {
    fn get_Expression(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Expression(&self, value: HSTRING) -> HRESULT
}}
impl IExpressionAnimation {
    #[inline] pub fn get_expression(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Expression)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expression(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Expression)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ExpressionAnimation: IExpressionAnimation}
DEFINE_IID!(IID_IImplicitAnimationCollection, 93889535, 2706, 19613, 164, 39, 178, 85, 25, 37, 13, 191);
RT_INTERFACE!{interface IImplicitAnimationCollection(IImplicitAnimationCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IImplicitAnimationCollection] {
    
}}
RT_CLASS!{class ImplicitAnimationCollection: IImplicitAnimationCollection}
RT_CLASS!{class InitialValueExpressionCollection: foundation::collections::IMap<HString, HString>}
DEFINE_IID!(IID_IInsetClip, 510912071, 33991, 18298, 180, 116, 88, 128, 224, 68, 46, 21);
RT_INTERFACE!{interface IInsetClip(IInsetClipVtbl): IInspectable(IInspectableVtbl) [IID_IInsetClip] {
    fn get_BottomInset(&self, out: *mut f32) -> HRESULT,
    fn put_BottomInset(&self, value: f32) -> HRESULT,
    fn get_LeftInset(&self, out: *mut f32) -> HRESULT,
    fn put_LeftInset(&self, value: f32) -> HRESULT,
    fn get_RightInset(&self, out: *mut f32) -> HRESULT,
    fn put_RightInset(&self, value: f32) -> HRESULT,
    fn get_TopInset(&self, out: *mut f32) -> HRESULT,
    fn put_TopInset(&self, value: f32) -> HRESULT
}}
impl IInsetClip {
    #[inline] pub fn get_bottom_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BottomInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bottom_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BottomInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_top_inset(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TopInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_top_inset(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TopInset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InsetClip: IInsetClip}
DEFINE_IID!(IID_IKeyFrameAnimation, 309231394, 15081, 17728, 154, 138, 222, 174, 138, 74, 74, 132);
RT_INTERFACE!{interface IKeyFrameAnimation(IKeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IKeyFrameAnimation] {
    fn get_DelayTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DelayTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_IterationBehavior(&self, out: *mut AnimationIterationBehavior) -> HRESULT,
    fn put_IterationBehavior(&self, value: AnimationIterationBehavior) -> HRESULT,
    fn get_IterationCount(&self, out: *mut i32) -> HRESULT,
    fn put_IterationCount(&self, value: i32) -> HRESULT,
    fn get_KeyFrameCount(&self, out: *mut i32) -> HRESULT,
    fn get_StopBehavior(&self, out: *mut AnimationStopBehavior) -> HRESULT,
    fn put_StopBehavior(&self, value: AnimationStopBehavior) -> HRESULT,
    fn InsertExpressionKeyFrame(&self, normalizedProgressKey: f32, value: HSTRING) -> HRESULT,
    fn InsertExpressionKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: HSTRING, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IKeyFrameAnimation {
    #[inline] pub fn get_delay_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DelayTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delay_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DelayTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Duration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_iteration_behavior(&self) -> Result<AnimationIterationBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IterationBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_iteration_behavior(&self, value: AnimationIterationBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IterationBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_iteration_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IterationCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_iteration_count(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IterationCount)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_key_frame_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyFrameCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stop_behavior(&self) -> Result<AnimationStopBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StopBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stop_behavior(&self, value: AnimationStopBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StopBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_expression_key_frame(&self, normalizedProgressKey: f32, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertExpressionKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_expression_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: &HStringArg, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertExpressionKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value.get(), easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class KeyFrameAnimation: IKeyFrameAnimation}
DEFINE_IID!(IID_IKeyFrameAnimation2, 4105472187, 10560, 20160, 164, 26, 235, 109, 128, 26, 47, 24);
RT_INTERFACE!{interface IKeyFrameAnimation2(IKeyFrameAnimation2Vtbl): IInspectable(IInspectableVtbl) [IID_IKeyFrameAnimation2] {
    fn get_Direction(&self, out: *mut AnimationDirection) -> HRESULT,
    fn put_Direction(&self, value: AnimationDirection) -> HRESULT
}}
impl IKeyFrameAnimation2 {
    #[inline] pub fn get_direction(&self) -> Result<AnimationDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_direction(&self, value: AnimationDirection) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Direction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IKeyFrameAnimation3, 2220617908, 55518, 17967, 135, 83, 200, 13, 67, 198, 255, 90);
RT_INTERFACE!{interface IKeyFrameAnimation3(IKeyFrameAnimation3Vtbl): IInspectable(IInspectableVtbl) [IID_IKeyFrameAnimation3] {
    fn get_DelayBehavior(&self, out: *mut AnimationDelayBehavior) -> HRESULT,
    fn put_DelayBehavior(&self, value: AnimationDelayBehavior) -> HRESULT
}}
impl IKeyFrameAnimation3 {
    #[inline] pub fn get_delay_behavior(&self) -> Result<AnimationDelayBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DelayBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delay_behavior(&self, value: AnimationDelayBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DelayBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IKeyFrameAnimationFactory, 3204973560, 28970, 20417, 140, 135, 151, 8, 89, 237, 141, 46);
RT_INTERFACE!{interface IKeyFrameAnimationFactory(IKeyFrameAnimationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IKeyFrameAnimationFactory] {
    
}}
DEFINE_IID!(IID_ILayerVisual, 2944678277, 1092, 18567, 142, 131, 180, 11, 37, 63, 130, 44);
RT_INTERFACE!{interface ILayerVisual(ILayerVisualVtbl): IInspectable(IInspectableVtbl) [IID_ILayerVisual] {
    fn get_Effect(&self, out: *mut *mut CompositionEffectBrush) -> HRESULT,
    fn put_Effect(&self, value: *mut CompositionEffectBrush) -> HRESULT
}}
impl ILayerVisual {
    #[inline] pub fn get_effect(&self) -> Result<Option<ComPtr<CompositionEffectBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Effect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_effect(&self, value: &CompositionEffectBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Effect)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LayerVisual: ILayerVisual}
DEFINE_IID!(IID_ILayerVisual2, 2566500075, 28451, 18929, 144, 177, 31, 89, 161, 79, 188, 227);
RT_INTERFACE!{interface ILayerVisual2(ILayerVisual2Vtbl): IInspectable(IInspectableVtbl) [IID_ILayerVisual2] {
    fn get_Shadow(&self, out: *mut *mut CompositionShadow) -> HRESULT,
    fn put_Shadow(&self, value: *mut CompositionShadow) -> HRESULT
}}
impl ILayerVisual2 {
    #[inline] pub fn get_shadow(&self) -> Result<Option<ComPtr<CompositionShadow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Shadow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_shadow(&self, value: &CompositionShadow) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Shadow)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILinearEasingFunction, 2483066714, 51110, 18099, 172, 247, 26, 38, 138, 10, 17, 125);
RT_INTERFACE!{interface ILinearEasingFunction(ILinearEasingFunctionVtbl): IInspectable(IInspectableVtbl) [IID_ILinearEasingFunction] {
    
}}
RT_CLASS!{class LinearEasingFunction: ILinearEasingFunction}
DEFINE_IID!(IID_INaturalMotionAnimation, 1133371693, 30363, 18465, 169, 73, 40, 74, 101, 71, 232, 115);
RT_INTERFACE!{interface INaturalMotionAnimation(INaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_INaturalMotionAnimation] {
    fn get_DelayBehavior(&self, out: *mut AnimationDelayBehavior) -> HRESULT,
    fn put_DelayBehavior(&self, value: AnimationDelayBehavior) -> HRESULT,
    fn get_DelayTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DelayTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StopBehavior(&self, out: *mut AnimationStopBehavior) -> HRESULT,
    fn put_StopBehavior(&self, value: AnimationStopBehavior) -> HRESULT
}}
impl INaturalMotionAnimation {
    #[inline] pub fn get_delay_behavior(&self) -> Result<AnimationDelayBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DelayBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delay_behavior(&self, value: AnimationDelayBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DelayBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delay_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DelayTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delay_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DelayTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stop_behavior(&self) -> Result<AnimationStopBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StopBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stop_behavior(&self, value: AnimationStopBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StopBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NaturalMotionAnimation: INaturalMotionAnimation}
DEFINE_IID!(IID_INaturalMotionAnimationFactory, 4114270982, 53098, 17287, 163, 254, 82, 33, 243, 231, 224, 224);
RT_INTERFACE!{interface INaturalMotionAnimationFactory(INaturalMotionAnimationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_INaturalMotionAnimationFactory] {
    
}}
DEFINE_IID!(IID_IPathKeyFrameAnimation, 2634881225, 5494, 19263, 190, 96, 29, 80, 49, 245, 231, 27);
RT_INTERFACE!{interface IPathKeyFrameAnimation(IPathKeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPathKeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, path: *mut CompositionPath) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, path: *mut CompositionPath, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IPathKeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, path: &CompositionPath) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, path as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, path: &CompositionPath, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, path as *const _ as *mut _, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PathKeyFrameAnimation: IPathKeyFrameAnimation}
DEFINE_IID!(IID_IPointLight, 2978301363, 3162, 19120, 190, 220, 79, 53, 70, 148, 130, 114);
RT_INTERFACE!{interface IPointLight(IPointLightVtbl): IInspectable(IInspectableVtbl) [IID_IPointLight] {
    fn get_Color(&self, out: *mut super::Color) -> HRESULT,
    fn put_Color(&self, value: super::Color) -> HRESULT,
    fn get_ConstantAttenuation(&self, out: *mut f32) -> HRESULT,
    fn put_ConstantAttenuation(&self, value: f32) -> HRESULT,
    fn get_CoordinateSpace(&self, out: *mut *mut Visual) -> HRESULT,
    fn put_CoordinateSpace(&self, value: *mut Visual) -> HRESULT,
    fn get_LinearAttenuation(&self, out: *mut f32) -> HRESULT,
    fn put_LinearAttenuation(&self, value: f32) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_QuadraticAttenuation(&self, out: *mut f32) -> HRESULT,
    fn put_QuadraticAttenuation(&self, value: f32) -> HRESULT
}}
impl IPointLight {
    #[inline] pub fn get_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_constant_attenuation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ConstantAttenuation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_constant_attenuation(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ConstantAttenuation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_coordinate_space(&self) -> Result<Option<ComPtr<Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CoordinateSpace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_coordinate_space(&self, value: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CoordinateSpace)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_linear_attenuation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LinearAttenuation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_linear_attenuation(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LinearAttenuation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_quadratic_attenuation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_QuadraticAttenuation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_quadratic_attenuation(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_QuadraticAttenuation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PointLight: IPointLight}
DEFINE_IID!(IID_IPointLight2, 4025061164, 1656, 20329, 177, 100, 168, 16, 217, 149, 188, 183);
RT_INTERFACE!{interface IPointLight2(IPointLight2Vtbl): IInspectable(IInspectableVtbl) [IID_IPointLight2] {
    fn get_Intensity(&self, out: *mut f32) -> HRESULT,
    fn put_Intensity(&self, value: f32) -> HRESULT
}}
impl IPointLight2 {
    #[inline] pub fn get_intensity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Intensity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_intensity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Intensity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPointLight3, 1275757415, 54505, 18058, 135, 174, 123, 164, 58, 178, 148, 133);
RT_INTERFACE!{interface IPointLight3(IPointLight3Vtbl): IInspectable(IInspectableVtbl) [IID_IPointLight3] {
    fn get_MinAttenuationCutoff(&self, out: *mut f32) -> HRESULT,
    fn put_MinAttenuationCutoff(&self, value: f32) -> HRESULT,
    fn get_MaxAttenuationCutoff(&self, out: *mut f32) -> HRESULT,
    fn put_MaxAttenuationCutoff(&self, value: f32) -> HRESULT
}}
impl IPointLight3 {
    #[inline] pub fn get_min_attenuation_cutoff(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinAttenuationCutoff)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_attenuation_cutoff(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MinAttenuationCutoff)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_attenuation_cutoff(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxAttenuationCutoff)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_attenuation_cutoff(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MaxAttenuationCutoff)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IQuaternionKeyFrameAnimation, 1078876213, 60662, 16960, 133, 32, 103, 18, 121, 207, 54, 188);
RT_INTERFACE!{interface IQuaternionKeyFrameAnimation(IQuaternionKeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IQuaternionKeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: foundation::numerics::Quaternion) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: foundation::numerics::Quaternion, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IQuaternionKeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: foundation::numerics::Quaternion, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class QuaternionKeyFrameAnimation: IQuaternionKeyFrameAnimation}
DEFINE_IID!(IID_IRedirectVisual, 2361844544, 35701, 21538, 176, 111, 9, 255, 233, 248, 97, 126);
RT_INTERFACE!{interface IRedirectVisual(IRedirectVisualVtbl): IInspectable(IInspectableVtbl) [IID_IRedirectVisual] {
    fn get_Source(&self, out: *mut *mut Visual) -> HRESULT,
    fn put_Source(&self, value: *mut Visual) -> HRESULT
}}
impl IRedirectVisual {
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, value: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Source)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RedirectVisual: IRedirectVisual}
DEFINE_IID!(IID_IRenderingDeviceReplacedEventArgs, 976333949, 10431, 20090, 133, 36, 113, 103, 157, 72, 15, 56);
RT_INTERFACE!{interface IRenderingDeviceReplacedEventArgs(IRenderingDeviceReplacedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRenderingDeviceReplacedEventArgs] {
    fn get_GraphicsDevice(&self, out: *mut *mut CompositionGraphicsDevice) -> HRESULT
}}
impl IRenderingDeviceReplacedEventArgs {
    #[inline] pub fn get_graphics_device(&self) -> Result<Option<ComPtr<CompositionGraphicsDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GraphicsDevice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RenderingDeviceReplacedEventArgs: IRenderingDeviceReplacedEventArgs}
DEFINE_IID!(IID_IScalarKeyFrameAnimation, 2921893801, 9516, 19349, 167, 37, 191, 133, 227, 128, 0, 161);
RT_INTERFACE!{interface IScalarKeyFrameAnimation(IScalarKeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IScalarKeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: f32) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: f32, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IScalarKeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: f32, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ScalarKeyFrameAnimation: IScalarKeyFrameAnimation}
DEFINE_IID!(IID_IScalarNaturalMotionAnimation, 2494121345, 49042, 18779, 181, 189, 210, 198, 89, 67, 7, 55);
RT_INTERFACE!{interface IScalarNaturalMotionAnimation(IScalarNaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IScalarNaturalMotionAnimation] {
    fn get_FinalValue(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn put_FinalValue(&self, value: *mut foundation::IReference<f32>) -> HRESULT,
    fn get_InitialValue(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn put_InitialValue(&self, value: *mut foundation::IReference<f32>) -> HRESULT,
    fn get_InitialVelocity(&self, out: *mut f32) -> HRESULT,
    fn put_InitialVelocity(&self, value: f32) -> HRESULT
}}
impl IScalarNaturalMotionAnimation {
    #[inline] pub fn get_final_value(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FinalValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_final_value(&self, value: &foundation::IReference<f32>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FinalValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_value(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_value(&self, value: &foundation::IReference<f32>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_velocity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InitialVelocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_velocity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialVelocity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ScalarNaturalMotionAnimation: IScalarNaturalMotionAnimation}
DEFINE_IID!(IID_IScalarNaturalMotionAnimationFactory, 2203755772, 26396, 16861, 175, 72, 174, 141, 239, 139, 21, 41);
RT_INTERFACE!{interface IScalarNaturalMotionAnimationFactory(IScalarNaturalMotionAnimationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IScalarNaturalMotionAnimationFactory] {
    
}}
DEFINE_IID!(IID_IShapeVisual, 4072477635, 47742, 19215, 145, 38, 255, 183, 83, 107, 129, 118);
RT_INTERFACE!{interface IShapeVisual(IShapeVisualVtbl): IInspectable(IInspectableVtbl) [IID_IShapeVisual] {
    fn get_Shapes(&self, out: *mut *mut CompositionShapeCollection) -> HRESULT,
    fn get_ViewBox(&self, out: *mut *mut CompositionViewBox) -> HRESULT,
    fn put_ViewBox(&self, value: *mut CompositionViewBox) -> HRESULT
}}
impl IShapeVisual {
    #[inline] pub fn get_shapes(&self) -> Result<Option<ComPtr<CompositionShapeCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Shapes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_view_box(&self) -> Result<Option<ComPtr<CompositionViewBox>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewBox)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_view_box(&self, value: &CompositionViewBox) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ViewBox)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ShapeVisual: IShapeVisual}
DEFINE_IID!(IID_ISpotLight, 1520427635, 17569, 20373, 164, 34, 143, 165, 17, 107, 219, 68);
RT_INTERFACE!{interface ISpotLight(ISpotLightVtbl): IInspectable(IInspectableVtbl) [IID_ISpotLight] {
    fn get_ConstantAttenuation(&self, out: *mut f32) -> HRESULT,
    fn put_ConstantAttenuation(&self, value: f32) -> HRESULT,
    fn get_CoordinateSpace(&self, out: *mut *mut Visual) -> HRESULT,
    fn put_CoordinateSpace(&self, value: *mut Visual) -> HRESULT,
    fn get_Direction(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Direction(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_InnerConeAngle(&self, out: *mut f32) -> HRESULT,
    fn put_InnerConeAngle(&self, value: f32) -> HRESULT,
    fn get_InnerConeAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_InnerConeAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_InnerConeColor(&self, out: *mut super::Color) -> HRESULT,
    fn put_InnerConeColor(&self, value: super::Color) -> HRESULT,
    fn get_LinearAttenuation(&self, out: *mut f32) -> HRESULT,
    fn put_LinearAttenuation(&self, value: f32) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_OuterConeAngle(&self, out: *mut f32) -> HRESULT,
    fn put_OuterConeAngle(&self, value: f32) -> HRESULT,
    fn get_OuterConeAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_OuterConeAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_OuterConeColor(&self, out: *mut super::Color) -> HRESULT,
    fn put_OuterConeColor(&self, value: super::Color) -> HRESULT,
    fn get_QuadraticAttenuation(&self, out: *mut f32) -> HRESULT,
    fn put_QuadraticAttenuation(&self, value: f32) -> HRESULT
}}
impl ISpotLight {
    #[inline] pub fn get_constant_attenuation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ConstantAttenuation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_constant_attenuation(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ConstantAttenuation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_coordinate_space(&self) -> Result<Option<ComPtr<Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CoordinateSpace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_coordinate_space(&self, value: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CoordinateSpace)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_direction(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_direction(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Direction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inner_cone_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InnerConeAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inner_cone_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InnerConeAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inner_cone_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InnerConeAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inner_cone_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InnerConeAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inner_cone_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InnerConeColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inner_cone_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InnerConeColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_linear_attenuation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LinearAttenuation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_linear_attenuation(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LinearAttenuation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outer_cone_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OuterConeAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outer_cone_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_OuterConeAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outer_cone_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OuterConeAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outer_cone_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_OuterConeAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outer_cone_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OuterConeColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outer_cone_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_OuterConeColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_quadratic_attenuation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_QuadraticAttenuation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_quadratic_attenuation(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_QuadraticAttenuation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpotLight: ISpotLight}
DEFINE_IID!(IID_ISpotLight2, 1693344094, 1670, 19946, 169, 232, 188, 58, 140, 112, 20, 89);
RT_INTERFACE!{interface ISpotLight2(ISpotLight2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpotLight2] {
    fn get_InnerConeIntensity(&self, out: *mut f32) -> HRESULT,
    fn put_InnerConeIntensity(&self, value: f32) -> HRESULT,
    fn get_OuterConeIntensity(&self, out: *mut f32) -> HRESULT,
    fn put_OuterConeIntensity(&self, value: f32) -> HRESULT
}}
impl ISpotLight2 {
    #[inline] pub fn get_inner_cone_intensity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InnerConeIntensity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inner_cone_intensity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InnerConeIntensity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outer_cone_intensity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OuterConeIntensity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outer_cone_intensity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_OuterConeIntensity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpotLight3, 3838852842, 4895, 18446, 133, 158, 184, 39, 5, 183, 67, 96);
RT_INTERFACE!{interface ISpotLight3(ISpotLight3Vtbl): IInspectable(IInspectableVtbl) [IID_ISpotLight3] {
    fn get_MinAttenuationCutoff(&self, out: *mut f32) -> HRESULT,
    fn put_MinAttenuationCutoff(&self, value: f32) -> HRESULT,
    fn get_MaxAttenuationCutoff(&self, out: *mut f32) -> HRESULT,
    fn put_MaxAttenuationCutoff(&self, value: f32) -> HRESULT
}}
impl ISpotLight3 {
    #[inline] pub fn get_min_attenuation_cutoff(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinAttenuationCutoff)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_attenuation_cutoff(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MinAttenuationCutoff)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_attenuation_cutoff(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxAttenuationCutoff)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_attenuation_cutoff(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MaxAttenuationCutoff)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpringScalarNaturalMotionAnimation, 91400543, 14329, 20414, 184, 123, 92, 208, 58, 137, 80, 28);
RT_INTERFACE!{interface ISpringScalarNaturalMotionAnimation(ISpringScalarNaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISpringScalarNaturalMotionAnimation] {
    fn get_DampingRatio(&self, out: *mut f32) -> HRESULT,
    fn put_DampingRatio(&self, value: f32) -> HRESULT,
    fn get_Period(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Period(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl ISpringScalarNaturalMotionAnimation {
    #[inline] pub fn get_damping_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DampingRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_damping_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DampingRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_period(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Period)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_period(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Period)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpringScalarNaturalMotionAnimation: ISpringScalarNaturalMotionAnimation}
DEFINE_IID!(IID_ISpringVector2NaturalMotionAnimation, 603231413, 61043, 20239, 164, 35, 64, 43, 148, 109, 244, 179);
RT_INTERFACE!{interface ISpringVector2NaturalMotionAnimation(ISpringVector2NaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISpringVector2NaturalMotionAnimation] {
    fn get_DampingRatio(&self, out: *mut f32) -> HRESULT,
    fn put_DampingRatio(&self, value: f32) -> HRESULT,
    fn get_Period(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Period(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl ISpringVector2NaturalMotionAnimation {
    #[inline] pub fn get_damping_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DampingRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_damping_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DampingRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_period(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Period)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_period(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Period)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpringVector2NaturalMotionAnimation: ISpringVector2NaturalMotionAnimation}
DEFINE_IID!(IID_ISpringVector3NaturalMotionAnimation, 1820805599, 54651, 18324, 142, 45, 206, 203, 17, 225, 148, 229);
RT_INTERFACE!{interface ISpringVector3NaturalMotionAnimation(ISpringVector3NaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_ISpringVector3NaturalMotionAnimation] {
    fn get_DampingRatio(&self, out: *mut f32) -> HRESULT,
    fn put_DampingRatio(&self, value: f32) -> HRESULT,
    fn get_Period(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Period(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl ISpringVector3NaturalMotionAnimation {
    #[inline] pub fn get_damping_ratio(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DampingRatio)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_damping_ratio(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DampingRatio)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_period(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Period)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_period(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Period)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpringVector3NaturalMotionAnimation: ISpringVector3NaturalMotionAnimation}
DEFINE_IID!(IID_ISpriteVisual, 148919681, 6865, 20375, 151, 87, 64, 45, 118, 228, 35, 59);
RT_INTERFACE!{interface ISpriteVisual(ISpriteVisualVtbl): IInspectable(IInspectableVtbl) [IID_ISpriteVisual] {
    fn get_Brush(&self, out: *mut *mut CompositionBrush) -> HRESULT,
    fn put_Brush(&self, value: *mut CompositionBrush) -> HRESULT
}}
impl ISpriteVisual {
    #[inline] pub fn get_brush(&self) -> Result<Option<ComPtr<CompositionBrush>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Brush)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_brush(&self, value: &CompositionBrush) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Brush)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpriteVisual: ISpriteVisual}
DEFINE_IID!(IID_ISpriteVisual2, 1485608548, 39290, 18512, 145, 254, 83, 203, 88, 248, 28, 233);
RT_INTERFACE!{interface ISpriteVisual2(ISpriteVisual2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpriteVisual2] {
    fn get_Shadow(&self, out: *mut *mut CompositionShadow) -> HRESULT,
    fn put_Shadow(&self, value: *mut CompositionShadow) -> HRESULT
}}
impl ISpriteVisual2 {
    #[inline] pub fn get_shadow(&self) -> Result<Option<ComPtr<CompositionShadow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Shadow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_shadow(&self, value: &CompositionShadow) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Shadow)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStepEasingFunction, 3502942027, 22028, 18955, 165, 246, 32, 108, 168, 195, 236, 214);
RT_INTERFACE!{interface IStepEasingFunction(IStepEasingFunctionVtbl): IInspectable(IInspectableVtbl) [IID_IStepEasingFunction] {
    fn get_FinalStep(&self, out: *mut i32) -> HRESULT,
    fn put_FinalStep(&self, value: i32) -> HRESULT,
    fn get_InitialStep(&self, out: *mut i32) -> HRESULT,
    fn put_InitialStep(&self, value: i32) -> HRESULT,
    fn get_IsFinalStepSingleFrame(&self, out: *mut bool) -> HRESULT,
    fn put_IsFinalStepSingleFrame(&self, value: bool) -> HRESULT,
    fn get_IsInitialStepSingleFrame(&self, out: *mut bool) -> HRESULT,
    fn put_IsInitialStepSingleFrame(&self, value: bool) -> HRESULT,
    fn get_StepCount(&self, out: *mut i32) -> HRESULT,
    fn put_StepCount(&self, value: i32) -> HRESULT
}}
impl IStepEasingFunction {
    #[inline] pub fn get_final_step(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FinalStep)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_final_step(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FinalStep)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_step(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InitialStep)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_step(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialStep)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_final_step_single_frame(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFinalStepSingleFrame)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_final_step_single_frame(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsFinalStepSingleFrame)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_initial_step_single_frame(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInitialStepSingleFrame)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_initial_step_single_frame(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInitialStepSingleFrame)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_step_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StepCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_step_count(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StepCount)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class StepEasingFunction: IStepEasingFunction}
DEFINE_IID!(IID_IVector2KeyFrameAnimation, 3745596693, 20009, 20241, 181, 94, 191, 42, 110, 179, 98, 148);
RT_INTERFACE!{interface IVector2KeyFrameAnimation(IVector2KeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IVector2KeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector2) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector2, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IVector2KeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector2, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Vector2KeyFrameAnimation: IVector2KeyFrameAnimation}
DEFINE_IID!(IID_IVector2NaturalMotionAnimation, 255724413, 58642, 18333, 160, 12, 119, 201, 58, 48, 163, 149);
RT_INTERFACE!{interface IVector2NaturalMotionAnimation(IVector2NaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IVector2NaturalMotionAnimation] {
    fn get_FinalValue(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector2>) -> HRESULT,
    fn put_FinalValue(&self, value: *mut foundation::IReference<foundation::numerics::Vector2>) -> HRESULT,
    fn get_InitialValue(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector2>) -> HRESULT,
    fn put_InitialValue(&self, value: *mut foundation::IReference<foundation::numerics::Vector2>) -> HRESULT,
    fn get_InitialVelocity(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_InitialVelocity(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl IVector2NaturalMotionAnimation {
    #[inline] pub fn get_final_value(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector2>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FinalValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_final_value(&self, value: &foundation::IReference<foundation::numerics::Vector2>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FinalValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_value(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector2>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_value(&self, value: &foundation::IReference<foundation::numerics::Vector2>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_velocity(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InitialVelocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_velocity(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialVelocity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Vector2NaturalMotionAnimation: IVector2NaturalMotionAnimation}
DEFINE_IID!(IID_IVector2NaturalMotionAnimationFactory, 2356477793, 1889, 18594, 189, 219, 106, 252, 197, 43, 137, 216);
RT_INTERFACE!{interface IVector2NaturalMotionAnimationFactory(IVector2NaturalMotionAnimationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVector2NaturalMotionAnimationFactory] {
    
}}
DEFINE_IID!(IID_IVector3KeyFrameAnimation, 3355680170, 41601, 17346, 167, 61, 182, 142, 60, 83, 60, 64);
RT_INTERFACE!{interface IVector3KeyFrameAnimation(IVector3KeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IVector3KeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector3) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector3, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IVector3KeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector3, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Vector3KeyFrameAnimation: IVector3KeyFrameAnimation}
DEFINE_IID!(IID_IVector3NaturalMotionAnimation, 2618754092, 58058, 17837, 150, 158, 78, 120, 183, 185, 173, 65);
RT_INTERFACE!{interface IVector3NaturalMotionAnimation(IVector3NaturalMotionAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IVector3NaturalMotionAnimation] {
    fn get_FinalValue(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn put_FinalValue(&self, value: *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_InitialValue(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn put_InitialValue(&self, value: *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_InitialVelocity(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_InitialVelocity(&self, value: foundation::numerics::Vector3) -> HRESULT
}}
impl IVector3NaturalMotionAnimation {
    #[inline] pub fn get_final_value(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FinalValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_final_value(&self, value: &foundation::IReference<foundation::numerics::Vector3>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FinalValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_value(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_value(&self, value: &foundation::IReference<foundation::numerics::Vector3>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_velocity(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InitialVelocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_initial_velocity(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InitialVelocity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Vector3NaturalMotionAnimation: IVector3NaturalMotionAnimation}
DEFINE_IID!(IID_IVector3NaturalMotionAnimationFactory, 564665647, 2176, 17787, 172, 135, 182, 9, 1, 140, 135, 109);
RT_INTERFACE!{interface IVector3NaturalMotionAnimationFactory(IVector3NaturalMotionAnimationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVector3NaturalMotionAnimationFactory] {
    
}}
DEFINE_IID!(IID_IVector4KeyFrameAnimation, 609719387, 44509, 17285, 150, 6, 182, 163, 213, 228, 225, 185);
RT_INTERFACE!{interface IVector4KeyFrameAnimation(IVector4KeyFrameAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IVector4KeyFrameAnimation] {
    fn InsertKeyFrame(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector4) -> HRESULT,
    fn InsertKeyFrameWithEasingFunction(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector4, easingFunction: *mut CompositionEasingFunction) -> HRESULT
}}
impl IVector4KeyFrameAnimation {
    #[inline] pub fn insert_key_frame(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector4) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrame)(self as *const _ as *mut _, normalizedProgressKey, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_key_frame_with_easing_function(&self, normalizedProgressKey: f32, value: foundation::numerics::Vector4, easingFunction: &CompositionEasingFunction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertKeyFrameWithEasingFunction)(self as *const _ as *mut _, normalizedProgressKey, value, easingFunction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Vector4KeyFrameAnimation: IVector4KeyFrameAnimation}
DEFINE_IID!(IID_IVisual, 293478445, 43097, 19593, 135, 59, 194, 170, 86, 103, 136, 227);
RT_INTERFACE!{interface IVisual(IVisualVtbl): IInspectable(IInspectableVtbl) [IID_IVisual] {
    fn get_AnchorPoint(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_AnchorPoint(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_BackfaceVisibility(&self, out: *mut CompositionBackfaceVisibility) -> HRESULT,
    fn put_BackfaceVisibility(&self, value: CompositionBackfaceVisibility) -> HRESULT,
    fn get_BorderMode(&self, out: *mut CompositionBorderMode) -> HRESULT,
    fn put_BorderMode(&self, value: CompositionBorderMode) -> HRESULT,
    fn get_CenterPoint(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_CenterPoint(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Clip(&self, out: *mut *mut CompositionClip) -> HRESULT,
    fn put_Clip(&self, value: *mut CompositionClip) -> HRESULT,
    fn get_CompositeMode(&self, out: *mut CompositionCompositeMode) -> HRESULT,
    fn put_CompositeMode(&self, value: CompositionCompositeMode) -> HRESULT,
    fn get_IsVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsVisible(&self, value: bool) -> HRESULT,
    fn get_Offset(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Offset(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Opacity(&self, out: *mut f32) -> HRESULT,
    fn put_Opacity(&self, value: f32) -> HRESULT,
    fn get_Orientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT,
    fn put_Orientation(&self, value: foundation::numerics::Quaternion) -> HRESULT,
    fn get_Parent(&self, out: *mut *mut ContainerVisual) -> HRESULT,
    fn get_RotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngle(&self, value: f32) -> HRESULT,
    fn get_RotationAngleInDegrees(&self, out: *mut f32) -> HRESULT,
    fn put_RotationAngleInDegrees(&self, value: f32) -> HRESULT,
    fn get_RotationAxis(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_RotationAxis(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Scale(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_Scale(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_Size(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_Size(&self, value: foundation::numerics::Vector2) -> HRESULT,
    fn get_TransformMatrix(&self, out: *mut foundation::numerics::Matrix4x4) -> HRESULT,
    fn put_TransformMatrix(&self, value: foundation::numerics::Matrix4x4) -> HRESULT
}}
impl IVisual {
    #[inline] pub fn get_anchor_point(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnchorPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_anchor_point(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AnchorPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_backface_visibility(&self) -> Result<CompositionBackfaceVisibility> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackfaceVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_backface_visibility(&self, value: CompositionBackfaceVisibility) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackfaceVisibility)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_border_mode(&self) -> Result<CompositionBorderMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BorderMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_border_mode(&self, value: CompositionBorderMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BorderMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_center_point(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CenterPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_center_point(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CenterPoint)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clip(&self) -> Result<Option<ComPtr<CompositionClip>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Clip)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_clip(&self, value: &CompositionClip) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Clip)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_composite_mode(&self) -> Result<CompositionCompositeMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CompositeMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_composite_mode(&self, value: CompositionCompositeMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CompositeMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Offset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Offset)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_opacity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Opacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_opacity(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Opacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_orientation(&self, value: foundation::numerics::Quaternion) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_parent(&self) -> Result<Option<ComPtr<ContainerVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_angle_in_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAngleInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_angle_in_degrees(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAngleInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_axis(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationAxis)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_axis(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationAxis)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Scale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_size(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transform_matrix(&self) -> Result<foundation::numerics::Matrix4x4> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransformMatrix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transform_matrix(&self, value: foundation::numerics::Matrix4x4) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TransformMatrix)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Visual: IVisual}
DEFINE_IID!(IID_IVisual2, 810726929, 22211, 19518, 139, 243, 246, 225, 173, 71, 63, 6);
RT_INTERFACE!{interface IVisual2(IVisual2Vtbl): IInspectable(IInspectableVtbl) [IID_IVisual2] {
    fn get_ParentForTransform(&self, out: *mut *mut Visual) -> HRESULT,
    fn put_ParentForTransform(&self, value: *mut Visual) -> HRESULT,
    fn get_RelativeOffsetAdjustment(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_RelativeOffsetAdjustment(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_RelativeSizeAdjustment(&self, out: *mut foundation::numerics::Vector2) -> HRESULT,
    fn put_RelativeSizeAdjustment(&self, value: foundation::numerics::Vector2) -> HRESULT
}}
impl IVisual2 {
    #[inline] pub fn get_parent_for_transform(&self) -> Result<Option<ComPtr<Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ParentForTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_parent_for_transform(&self, value: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ParentForTransform)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_relative_offset_adjustment(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RelativeOffsetAdjustment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_relative_offset_adjustment(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RelativeOffsetAdjustment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_relative_size_adjustment(&self) -> Result<foundation::numerics::Vector2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RelativeSizeAdjustment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_relative_size_adjustment(&self, value: foundation::numerics::Vector2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RelativeSizeAdjustment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVisualCollection, 2339656965, 64830, 19096, 132, 168, 233, 73, 70, 140, 107, 203);
RT_INTERFACE!{interface IVisualCollection(IVisualCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IVisualCollection] {
    fn get_Count(&self, out: *mut i32) -> HRESULT,
    fn InsertAbove(&self, newChild: *mut Visual, sibling: *mut Visual) -> HRESULT,
    fn InsertAtBottom(&self, newChild: *mut Visual) -> HRESULT,
    fn InsertAtTop(&self, newChild: *mut Visual) -> HRESULT,
    fn InsertBelow(&self, newChild: *mut Visual, sibling: *mut Visual) -> HRESULT,
    fn Remove(&self, child: *mut Visual) -> HRESULT,
    fn RemoveAll(&self) -> HRESULT
}}
impl IVisualCollection {
    #[inline] pub fn get_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Count)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn insert_above(&self, newChild: &Visual, sibling: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertAbove)(self as *const _ as *mut _, newChild as *const _ as *mut _, sibling as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_at_bottom(&self, newChild: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertAtBottom)(self as *const _ as *mut _, newChild as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_at_top(&self, newChild: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertAtTop)(self as *const _ as *mut _, newChild as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_below(&self, newChild: &Visual, sibling: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertBelow)(self as *const _ as *mut _, newChild as *const _ as *mut _, sibling as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove(&self, child: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Remove)(self as *const _ as *mut _, child as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VisualCollection: IVisualCollection}
DEFINE_IID!(IID_IVisualFactory, 2903505214, 46338, 20149, 135, 180, 154, 56, 167, 29, 1, 55);
RT_INTERFACE!{interface IVisualFactory(IVisualFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVisualFactory] {
    
}}
DEFINE_IID!(IID_IVisualUnorderedCollection, 865053296, 21704, 16551, 128, 41, 201, 206, 235, 10, 162, 80);
RT_INTERFACE!{interface IVisualUnorderedCollection(IVisualUnorderedCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IVisualUnorderedCollection] {
    fn get_Count(&self, out: *mut i32) -> HRESULT,
    fn Add(&self, newVisual: *mut Visual) -> HRESULT,
    fn Remove(&self, visual: *mut Visual) -> HRESULT,
    fn RemoveAll(&self) -> HRESULT
}}
impl IVisualUnorderedCollection {
    #[inline] pub fn get_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Count)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add(&self, newVisual: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Add)(self as *const _ as *mut _, newVisual as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove(&self, visual: &Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Remove)(self as *const _ as *mut _, visual as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VisualUnorderedCollection: IVisualUnorderedCollection}
pub mod core { // Windows.UI.Composition.Core
use crate::prelude::*;
DEFINE_IID!(IID_ICompositorController, 762704730, 28839, 17301, 186, 45, 206, 240, 177, 131, 153, 249);
RT_INTERFACE!{interface ICompositorController(ICompositorControllerVtbl): IInspectable(IInspectableVtbl) [IID_ICompositorController] {
    fn get_Compositor(&self, out: *mut *mut super::Compositor) -> HRESULT,
    fn Commit(&self) -> HRESULT,
    fn EnsurePreviousCommitCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn add_CommitNeeded(&self, handler: *mut foundation::TypedEventHandler<CompositorController, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CommitNeeded(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICompositorController {
    #[inline] pub fn get_compositor(&self) -> Result<Option<ComPtr<super::Compositor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Compositor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn commit(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Commit)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn ensure_previous_commit_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).EnsurePreviousCommitCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_commit_needed(&self, handler: &foundation::TypedEventHandler<CompositorController, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CommitNeeded)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_commit_needed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CommitNeeded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositorController: ICompositorController}
impl RtActivatable<IActivationFactory> for CompositorController {}
DEFINE_CLSID!(CompositorController(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,67,111,114,101,46,67,111,109,112,111,115,105,116,111,114,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_CompositorController]);
} // Windows.UI.Composition.Core
pub mod desktop { // Windows.UI.Composition.Desktop
use crate::prelude::*;
DEFINE_IID!(IID_IDesktopWindowTarget, 1663686346, 13158, 18702, 157, 179, 37, 49, 41, 41, 172, 81);
RT_INTERFACE!{interface IDesktopWindowTarget(IDesktopWindowTargetVtbl): IInspectable(IInspectableVtbl) [IID_IDesktopWindowTarget] {
    fn get_IsTopmost(&self, out: *mut bool) -> HRESULT
}}
impl IDesktopWindowTarget {
    #[inline] pub fn get_is_topmost(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTopmost)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DesktopWindowTarget: IDesktopWindowTarget}
} // Windows.UI.Composition.Desktop
pub mod diagnostics { // Windows.UI.Composition.Diagnostics
use crate::prelude::*;
DEFINE_IID!(IID_ICompositionDebugHeatMaps, 3835465900, 12275, 22533, 113, 140, 183, 37, 238, 7, 101, 15);
RT_INTERFACE!{interface ICompositionDebugHeatMaps(ICompositionDebugHeatMapsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionDebugHeatMaps] {
    fn Hide(&self, subtree: *mut super::Visual) -> HRESULT,
    fn ShowMemoryUsage(&self, subtree: *mut super::Visual) -> HRESULT,
    fn ShowOverdraw(&self, subtree: *mut super::Visual, contentKinds: CompositionDebugOverdrawContentKinds) -> HRESULT,
    fn ShowRedraw(&self, subtree: *mut super::Visual) -> HRESULT
}}
impl ICompositionDebugHeatMaps {
    #[inline] pub fn hide(&self, subtree: &super::Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Hide)(self as *const _ as *mut _, subtree as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_memory_usage(&self, subtree: &super::Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ShowMemoryUsage)(self as *const _ as *mut _, subtree as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_overdraw(&self, subtree: &super::Visual, contentKinds: CompositionDebugOverdrawContentKinds) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ShowOverdraw)(self as *const _ as *mut _, subtree as *const _ as *mut _, contentKinds);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_redraw(&self, subtree: &super::Visual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ShowRedraw)(self as *const _ as *mut _, subtree as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionDebugHeatMaps: ICompositionDebugHeatMaps}
RT_ENUM! { enum CompositionDebugOverdrawContentKinds: u32 {
    None = 0, OffscreenRendered = 1, Colors = 2, Effects = 4, Shadows = 8, Lights = 16, Surfaces = 32, SwapChains = 64, All = 4294967295,
}}
DEFINE_IID!(IID_ICompositionDebugSettings, 674338942, 7554, 19768, 183, 183, 239, 209, 28, 123, 195, 209);
RT_INTERFACE!{interface ICompositionDebugSettings(ICompositionDebugSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionDebugSettings] {
    fn get_HeatMaps(&self, out: *mut *mut CompositionDebugHeatMaps) -> HRESULT
}}
impl ICompositionDebugSettings {
    #[inline] pub fn get_heat_maps(&self) -> Result<Option<ComPtr<CompositionDebugHeatMaps>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeatMaps)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionDebugSettings: ICompositionDebugSettings}
impl RtActivatable<ICompositionDebugSettingsStatics> for CompositionDebugSettings {}
impl CompositionDebugSettings {
    #[inline] pub fn try_get_settings(compositor: &super::Compositor) -> Result<Option<ComPtr<CompositionDebugSettings>>> {
        <Self as RtActivatable<ICompositionDebugSettingsStatics>>::get_activation_factory().try_get_settings(compositor)
    }
}
DEFINE_CLSID!(CompositionDebugSettings(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,68,105,97,103,110,111,115,116,105,99,115,46,67,111,109,112,111,115,105,116,105,111,110,68,101,98,117,103,83,101,116,116,105,110,103,115,0]) [CLSID_CompositionDebugSettings]);
DEFINE_IID!(IID_ICompositionDebugSettingsStatics, 1693196062, 27384, 19192, 184, 20, 200, 112, 253, 90, 149, 5);
RT_INTERFACE!{static interface ICompositionDebugSettingsStatics(ICompositionDebugSettingsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionDebugSettingsStatics] {
    fn TryGetSettings(&self, compositor: *mut super::Compositor, out: *mut *mut CompositionDebugSettings) -> HRESULT
}}
impl ICompositionDebugSettingsStatics {
    #[inline] pub fn try_get_settings(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<CompositionDebugSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetSettings)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Composition.Diagnostics
pub mod effects { // Windows.UI.Composition.Effects
use crate::prelude::*;
DEFINE_IID!(IID_ISceneLightingEffect, 2444975698, 38353, 20363, 154, 90, 100, 8, 178, 75, 140, 106);
RT_INTERFACE!{interface ISceneLightingEffect(ISceneLightingEffectVtbl): IInspectable(IInspectableVtbl) [IID_ISceneLightingEffect] {
    fn get_AmbientAmount(&self, out: *mut f32) -> HRESULT,
    fn put_AmbientAmount(&self, value: f32) -> HRESULT,
    fn get_DiffuseAmount(&self, out: *mut f32) -> HRESULT,
    fn put_DiffuseAmount(&self, value: f32) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_NormalMapSource(&self, out: *mut *mut crate::windows::graphics::effects::IGraphicsEffectSource) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_NormalMapSource(&self, value: *mut crate::windows::graphics::effects::IGraphicsEffectSource) -> HRESULT,
    fn get_SpecularAmount(&self, out: *mut f32) -> HRESULT,
    fn put_SpecularAmount(&self, value: f32) -> HRESULT,
    fn get_SpecularShine(&self, out: *mut f32) -> HRESULT,
    fn put_SpecularShine(&self, value: f32) -> HRESULT
}}
impl ISceneLightingEffect {
    #[inline] pub fn get_ambient_amount(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AmbientAmount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ambient_amount(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AmbientAmount)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_diffuse_amount(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DiffuseAmount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_diffuse_amount(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DiffuseAmount)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_normal_map_source(&self) -> Result<Option<ComPtr<crate::windows::graphics::effects::IGraphicsEffectSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NormalMapSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_normal_map_source(&self, value: &crate::windows::graphics::effects::IGraphicsEffectSource) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_NormalMapSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_specular_amount(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpecularAmount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_specular_amount(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SpecularAmount)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_specular_shine(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpecularShine)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_specular_shine(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SpecularShine)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SceneLightingEffect: ISceneLightingEffect}
impl RtActivatable<IActivationFactory> for SceneLightingEffect {}
DEFINE_CLSID!(SceneLightingEffect(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,69,102,102,101,99,116,115,46,83,99,101,110,101,76,105,103,104,116,105,110,103,69,102,102,101,99,116,0]) [CLSID_SceneLightingEffect]);
DEFINE_IID!(IID_ISceneLightingEffect2, 2653359745, 29424, 19548, 149, 248, 138, 110, 0, 36, 244, 9);
RT_INTERFACE!{interface ISceneLightingEffect2(ISceneLightingEffect2Vtbl): IInspectable(IInspectableVtbl) [IID_ISceneLightingEffect2] {
    fn get_ReflectanceModel(&self, out: *mut SceneLightingEffectReflectanceModel) -> HRESULT,
    fn put_ReflectanceModel(&self, value: SceneLightingEffectReflectanceModel) -> HRESULT
}}
impl ISceneLightingEffect2 {
    #[inline] pub fn get_reflectance_model(&self) -> Result<SceneLightingEffectReflectanceModel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ReflectanceModel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_reflectance_model(&self, value: SceneLightingEffectReflectanceModel) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ReflectanceModel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum SceneLightingEffectReflectanceModel: i32 {
    BlinnPhong = 0, PhysicallyBasedBlinnPhong = 1,
}}
} // Windows.UI.Composition.Effects
pub mod interactions { // Windows.UI.Composition.Interactions
use crate::prelude::*;
DEFINE_IID!(IID_ICompositionConditionalValue, 1126499640, 60275, 17761, 167, 29, 26, 67, 234, 235, 122, 155);
RT_INTERFACE!{interface ICompositionConditionalValue(ICompositionConditionalValueVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionConditionalValue] {
    fn get_Condition(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Condition(&self, value: *mut super::ExpressionAnimation) -> HRESULT,
    fn get_Value(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Value(&self, value: *mut super::ExpressionAnimation) -> HRESULT
}}
impl ICompositionConditionalValue {
    #[inline] pub fn get_condition(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Condition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_condition(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Condition)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionConditionalValue: ICompositionConditionalValue}
impl RtActivatable<ICompositionConditionalValueStatics> for CompositionConditionalValue {}
impl CompositionConditionalValue {
    #[inline] pub fn create(compositor: &super::Compositor) -> Result<Option<ComPtr<CompositionConditionalValue>>> {
        <Self as RtActivatable<ICompositionConditionalValueStatics>>::get_activation_factory().create(compositor)
    }
}
DEFINE_CLSID!(CompositionConditionalValue(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,67,111,109,112,111,115,105,116,105,111,110,67,111,110,100,105,116,105,111,110,97,108,86,97,108,117,101,0]) [CLSID_CompositionConditionalValue]);
DEFINE_IID!(IID_ICompositionConditionalValueStatics, 151800690, 33895, 19722, 144, 101, 172, 70, 184, 10, 85, 34);
RT_INTERFACE!{static interface ICompositionConditionalValueStatics(ICompositionConditionalValueStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionConditionalValueStatics] {
    fn Create(&self, compositor: *mut super::Compositor, out: *mut *mut CompositionConditionalValue) -> HRESULT
}}
impl ICompositionConditionalValueStatics {
    #[inline] pub fn create(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<CompositionConditionalValue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompositionInteractionSource, 70984753, 1763, 18778, 186, 84, 64, 159, 0, 23, 250, 192);
RT_INTERFACE!{interface ICompositionInteractionSource(ICompositionInteractionSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionInteractionSource] {
    
}}
DEFINE_IID!(IID_ICompositionInteractionSourceCollection, 457608779, 42431, 18392, 165, 71, 56, 148, 21, 90, 21, 140);
RT_INTERFACE!{interface ICompositionInteractionSourceCollection(ICompositionInteractionSourceCollectionVtbl): IInspectable(IInspectableVtbl) [IID_ICompositionInteractionSourceCollection] {
    fn get_Count(&self, out: *mut i32) -> HRESULT,
    fn Add(&self, value: *mut ICompositionInteractionSource) -> HRESULT,
    fn Remove(&self, value: *mut ICompositionInteractionSource) -> HRESULT,
    fn RemoveAll(&self) -> HRESULT
}}
impl ICompositionInteractionSourceCollection {
    #[inline] pub fn get_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Count)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add(&self, value: &ICompositionInteractionSource) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Add)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove(&self, value: &ICompositionInteractionSource) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Remove)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_all(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveAll)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CompositionInteractionSourceCollection: ICompositionInteractionSourceCollection}
RT_ENUM! { enum InteractionChainingMode: i32 {
    Auto = 0, Always = 1, Never = 2,
}}
DEFINE_IID!(IID_IInteractionSourceConfiguration, 2810398693, 43473, 19714, 152, 94, 185, 48, 205, 11, 157, 164);
RT_INTERFACE!{interface IInteractionSourceConfiguration(IInteractionSourceConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionSourceConfiguration] {
    fn get_PositionXSourceMode(&self, out: *mut InteractionSourceRedirectionMode) -> HRESULT,
    fn put_PositionXSourceMode(&self, value: InteractionSourceRedirectionMode) -> HRESULT,
    fn get_PositionYSourceMode(&self, out: *mut InteractionSourceRedirectionMode) -> HRESULT,
    fn put_PositionYSourceMode(&self, value: InteractionSourceRedirectionMode) -> HRESULT,
    fn get_ScaleSourceMode(&self, out: *mut InteractionSourceRedirectionMode) -> HRESULT,
    fn put_ScaleSourceMode(&self, value: InteractionSourceRedirectionMode) -> HRESULT
}}
impl IInteractionSourceConfiguration {
    #[inline] pub fn get_position_x_source_mode(&self) -> Result<InteractionSourceRedirectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionXSourceMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_x_source_mode(&self, value: InteractionSourceRedirectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionXSourceMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_y_source_mode(&self) -> Result<InteractionSourceRedirectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionYSourceMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_y_source_mode(&self, value: InteractionSourceRedirectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionYSourceMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_source_mode(&self) -> Result<InteractionSourceRedirectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleSourceMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale_source_mode(&self, value: InteractionSourceRedirectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ScaleSourceMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionSourceConfiguration: IInteractionSourceConfiguration}
RT_ENUM! { enum InteractionSourceMode: i32 {
    Disabled = 0, EnabledWithInertia = 1, EnabledWithoutInertia = 2,
}}
RT_ENUM! { enum InteractionSourceRedirectionMode: i32 {
    Disabled = 0, Enabled = 1,
}}
DEFINE_IID!(IID_IInteractionTracker, 713985201, 4096, 17430, 131, 99, 204, 39, 251, 135, 115, 8);
RT_INTERFACE!{interface IInteractionTracker(IInteractionTrackerVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTracker] {
    fn get_InteractionSources(&self, out: *mut *mut CompositionInteractionSourceCollection) -> HRESULT,
    fn get_IsPositionRoundingSuggested(&self, out: *mut bool) -> HRESULT,
    fn get_MaxPosition(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_MaxPosition(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_MaxScale(&self, out: *mut f32) -> HRESULT,
    fn put_MaxScale(&self, value: f32) -> HRESULT,
    fn get_MinPosition(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn put_MinPosition(&self, value: foundation::numerics::Vector3) -> HRESULT,
    fn get_MinScale(&self, out: *mut f32) -> HRESULT,
    fn put_MinScale(&self, value: f32) -> HRESULT,
    fn get_NaturalRestingPosition(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_NaturalRestingScale(&self, out: *mut f32) -> HRESULT,
    fn get_Owner(&self, out: *mut *mut IInteractionTrackerOwner) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_PositionInertiaDecayRate(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn put_PositionInertiaDecayRate(&self, value: *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_PositionVelocityInPixelsPerSecond(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_Scale(&self, out: *mut f32) -> HRESULT,
    fn get_ScaleInertiaDecayRate(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn put_ScaleInertiaDecayRate(&self, value: *mut foundation::IReference<f32>) -> HRESULT,
    fn get_ScaleVelocityInPercentPerSecond(&self, out: *mut f32) -> HRESULT,
    fn AdjustPositionXIfGreaterThanThreshold(&self, adjustment: f32, positionThreshold: f32) -> HRESULT,
    fn AdjustPositionYIfGreaterThanThreshold(&self, adjustment: f32, positionThreshold: f32) -> HRESULT,
    fn ConfigurePositionXInertiaModifiers(&self, modifiers: *mut foundation::collections::IIterable<InteractionTrackerInertiaModifier>) -> HRESULT,
    fn ConfigurePositionYInertiaModifiers(&self, modifiers: *mut foundation::collections::IIterable<InteractionTrackerInertiaModifier>) -> HRESULT,
    fn ConfigureScaleInertiaModifiers(&self, modifiers: *mut foundation::collections::IIterable<InteractionTrackerInertiaModifier>) -> HRESULT,
    fn TryUpdatePosition(&self, value: foundation::numerics::Vector3, out: *mut i32) -> HRESULT,
    fn TryUpdatePositionBy(&self, amount: foundation::numerics::Vector3, out: *mut i32) -> HRESULT,
    fn TryUpdatePositionWithAnimation(&self, animation: *mut super::CompositionAnimation, out: *mut i32) -> HRESULT,
    fn TryUpdatePositionWithAdditionalVelocity(&self, velocityInPixelsPerSecond: foundation::numerics::Vector3, out: *mut i32) -> HRESULT,
    fn TryUpdateScale(&self, value: f32, centerPoint: foundation::numerics::Vector3, out: *mut i32) -> HRESULT,
    fn TryUpdateScaleWithAnimation(&self, animation: *mut super::CompositionAnimation, centerPoint: foundation::numerics::Vector3, out: *mut i32) -> HRESULT,
    fn TryUpdateScaleWithAdditionalVelocity(&self, velocityInPercentPerSecond: f32, centerPoint: foundation::numerics::Vector3, out: *mut i32) -> HRESULT
}}
impl IInteractionTracker {
    #[inline] pub fn get_interaction_sources(&self) -> Result<Option<ComPtr<CompositionInteractionSourceCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InteractionSources)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_position_rounding_suggested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPositionRoundingSuggested)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_position(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MaxPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MaxScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_min_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_position(&self, value: foundation::numerics::Vector3) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MinPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_min_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MinScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_resting_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalRestingPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_resting_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalRestingScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_owner(&self) -> Result<Option<ComPtr<IInteractionTrackerOwner>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Owner)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position_inertia_decay_rate(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PositionInertiaDecayRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_position_inertia_decay_rate(&self, value: &foundation::IReference<foundation::numerics::Vector3>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionInertiaDecayRate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_velocity_in_pixels_per_second(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionVelocityInPixelsPerSecond)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_inertia_decay_rate(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScaleInertiaDecayRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_scale_inertia_decay_rate(&self, value: &foundation::IReference<f32>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ScaleInertiaDecayRate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_velocity_in_percent_per_second(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleVelocityInPercentPerSecond)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn adjust_position_x_if_greater_than_threshold(&self, adjustment: f32, positionThreshold: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AdjustPositionXIfGreaterThanThreshold)(self as *const _ as *mut _, adjustment, positionThreshold);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn adjust_position_y_if_greater_than_threshold(&self, adjustment: f32, positionThreshold: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AdjustPositionYIfGreaterThanThreshold)(self as *const _ as *mut _, adjustment, positionThreshold);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_position_x_inertia_modifiers(&self, modifiers: &foundation::collections::IIterable<InteractionTrackerInertiaModifier>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigurePositionXInertiaModifiers)(self as *const _ as *mut _, modifiers as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_position_y_inertia_modifiers(&self, modifiers: &foundation::collections::IIterable<InteractionTrackerInertiaModifier>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigurePositionYInertiaModifiers)(self as *const _ as *mut _, modifiers as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_scale_inertia_modifiers(&self, modifiers: &foundation::collections::IIterable<InteractionTrackerInertiaModifier>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureScaleInertiaModifiers)(self as *const _ as *mut _, modifiers as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_update_position(&self, value: foundation::numerics::Vector3) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdatePosition)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_position_by(&self, amount: foundation::numerics::Vector3) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdatePositionBy)(self as *const _ as *mut _, amount, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_position_with_animation(&self, animation: &super::CompositionAnimation) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdatePositionWithAnimation)(self as *const _ as *mut _, animation as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_position_with_additional_velocity(&self, velocityInPixelsPerSecond: foundation::numerics::Vector3) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdatePositionWithAdditionalVelocity)(self as *const _ as *mut _, velocityInPixelsPerSecond, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_scale(&self, value: f32, centerPoint: foundation::numerics::Vector3) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdateScale)(self as *const _ as *mut _, value, centerPoint, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_scale_with_animation(&self, animation: &super::CompositionAnimation, centerPoint: foundation::numerics::Vector3) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdateScaleWithAnimation)(self as *const _ as *mut _, animation as *const _ as *mut _, centerPoint, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_scale_with_additional_velocity(&self, velocityInPercentPerSecond: f32, centerPoint: foundation::numerics::Vector3) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdateScaleWithAdditionalVelocity)(self as *const _ as *mut _, velocityInPercentPerSecond, centerPoint, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTracker: IInteractionTracker}
impl RtActivatable<IInteractionTrackerStatics> for InteractionTracker {}
impl InteractionTracker {
    #[inline] pub fn create(compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTracker>>> {
        <Self as RtActivatable<IInteractionTrackerStatics>>::get_activation_factory().create(compositor)
    }
    #[inline] pub fn create_with_owner(compositor: &super::Compositor, owner: &IInteractionTrackerOwner) -> Result<Option<ComPtr<InteractionTracker>>> {
        <Self as RtActivatable<IInteractionTrackerStatics>>::get_activation_factory().create_with_owner(compositor, owner)
    }
}
DEFINE_CLSID!(InteractionTracker(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,73,110,116,101,114,97,99,116,105,111,110,84,114,97,99,107,101,114,0]) [CLSID_InteractionTracker]);
DEFINE_IID!(IID_IInteractionTracker2, 628529726, 52845, 17548, 131, 134, 146, 98, 13, 36, 7, 86);
RT_INTERFACE!{interface IInteractionTracker2(IInteractionTracker2Vtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTracker2] {
    fn ConfigureCenterPointXInertiaModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT,
    fn ConfigureCenterPointYInertiaModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT
}}
impl IInteractionTracker2 {
    #[inline] pub fn configure_center_point_x_inertia_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureCenterPointXInertiaModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_center_point_y_inertia_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureCenterPointYInertiaModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTracker3, 3871725474, 23627, 17094, 132, 183, 246, 148, 65, 177, 128, 145);
RT_INTERFACE!{interface IInteractionTracker3(IInteractionTracker3Vtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTracker3] {
    fn ConfigureVector2PositionInertiaModifiers(&self, modifiers: *mut foundation::collections::IIterable<InteractionTrackerVector2InertiaModifier>) -> HRESULT
}}
impl IInteractionTracker3 {
    #[inline] pub fn configure_vector2_position_inertia_modifiers(&self, modifiers: &foundation::collections::IIterable<InteractionTrackerVector2InertiaModifier>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureVector2PositionInertiaModifiers)(self as *const _ as *mut _, modifiers as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTracker4, 3956417212, 1199, 19143, 132, 125, 6, 234, 54, 232, 10, 22);
RT_INTERFACE!{interface IInteractionTracker4(IInteractionTracker4Vtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTracker4] {
    fn TryUpdatePositionWithOption(&self, value: foundation::numerics::Vector3, option: InteractionTrackerClampingOption, out: *mut i32) -> HRESULT,
    fn TryUpdatePositionByWithOption(&self, amount: foundation::numerics::Vector3, option: InteractionTrackerClampingOption, out: *mut i32) -> HRESULT,
    fn get_IsInertiaFromImpulse(&self, out: *mut bool) -> HRESULT
}}
impl IInteractionTracker4 {
    #[inline] pub fn try_update_position_with_option(&self, value: foundation::numerics::Vector3, option: InteractionTrackerClampingOption) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdatePositionWithOption)(self as *const _ as *mut _, value, option, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_update_position_by_with_option(&self, amount: foundation::numerics::Vector3, option: InteractionTrackerClampingOption) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUpdatePositionByWithOption)(self as *const _ as *mut _, amount, option, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_inertia_from_impulse(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInertiaFromImpulse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum InteractionTrackerClampingOption: i32 {
    Auto = 0, Disabled = 1,
}}
DEFINE_IID!(IID_IInteractionTrackerCustomAnimationStateEnteredArgs, 2367458545, 55216, 17228, 165, 210, 45, 118, 17, 134, 72, 52);
RT_INTERFACE!{interface IInteractionTrackerCustomAnimationStateEnteredArgs(IInteractionTrackerCustomAnimationStateEnteredArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerCustomAnimationStateEnteredArgs] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT
}}
impl IInteractionTrackerCustomAnimationStateEnteredArgs {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerCustomAnimationStateEnteredArgs: IInteractionTrackerCustomAnimationStateEnteredArgs}
DEFINE_IID!(IID_IInteractionTrackerIdleStateEnteredArgs, 1342255018, 5392, 16706, 161, 165, 1, 155, 9, 248, 133, 123);
RT_INTERFACE!{interface IInteractionTrackerIdleStateEnteredArgs(IInteractionTrackerIdleStateEnteredArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerIdleStateEnteredArgs] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT
}}
impl IInteractionTrackerIdleStateEnteredArgs {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerIdleStateEnteredArgs: IInteractionTrackerIdleStateEnteredArgs}
DEFINE_IID!(IID_IInteractionTrackerInertiaModifier, 2699217184, 9908, 19874, 139, 97, 94, 104, 57, 121, 187, 226);
RT_INTERFACE!{interface IInteractionTrackerInertiaModifier(IInteractionTrackerInertiaModifierVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaModifier] {
    
}}
RT_CLASS!{class InteractionTrackerInertiaModifier: IInteractionTrackerInertiaModifier}
DEFINE_IID!(IID_IInteractionTrackerInertiaModifierFactory, 2570590462, 51534, 19334, 135, 243, 146, 38, 101, 186, 70, 185);
RT_INTERFACE!{interface IInteractionTrackerInertiaModifierFactory(IInteractionTrackerInertiaModifierFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaModifierFactory] {
    
}}
DEFINE_IID!(IID_IInteractionTrackerInertiaMotion, 76689372, 61780, 19640, 191, 51, 204, 27, 166, 17, 230, 219);
RT_INTERFACE!{interface IInteractionTrackerInertiaMotion(IInteractionTrackerInertiaMotionVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaMotion] {
    fn get_Condition(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Condition(&self, value: *mut super::ExpressionAnimation) -> HRESULT,
    fn get_Motion(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Motion(&self, value: *mut super::ExpressionAnimation) -> HRESULT
}}
impl IInteractionTrackerInertiaMotion {
    #[inline] pub fn get_condition(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Condition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_condition(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Condition)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_motion(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Motion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_motion(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Motion)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerInertiaMotion: IInteractionTrackerInertiaMotion}
impl RtActivatable<IInteractionTrackerInertiaMotionStatics> for InteractionTrackerInertiaMotion {}
impl InteractionTrackerInertiaMotion {
    #[inline] pub fn create(compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerInertiaMotion>>> {
        <Self as RtActivatable<IInteractionTrackerInertiaMotionStatics>>::get_activation_factory().create(compositor)
    }
}
DEFINE_CLSID!(InteractionTrackerInertiaMotion(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,73,110,116,101,114,97,99,116,105,111,110,84,114,97,99,107,101,114,73,110,101,114,116,105,97,77,111,116,105,111,110,0]) [CLSID_InteractionTrackerInertiaMotion]);
DEFINE_IID!(IID_IInteractionTrackerInertiaMotionStatics, 2361933270, 47739, 17178, 132, 75, 110, 172, 145, 48, 249, 154);
RT_INTERFACE!{static interface IInteractionTrackerInertiaMotionStatics(IInteractionTrackerInertiaMotionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaMotionStatics] {
    fn Create(&self, compositor: *mut super::Compositor, out: *mut *mut InteractionTrackerInertiaMotion) -> HRESULT
}}
impl IInteractionTrackerInertiaMotionStatics {
    #[inline] pub fn create(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerInertiaMotion>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTrackerInertiaNaturalMotion, 1890376366, 10204, 18669, 163, 195, 109, 97, 201, 160, 41, 210);
RT_INTERFACE!{interface IInteractionTrackerInertiaNaturalMotion(IInteractionTrackerInertiaNaturalMotionVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaNaturalMotion] {
    fn get_Condition(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Condition(&self, value: *mut super::ExpressionAnimation) -> HRESULT,
    fn get_NaturalMotion(&self, out: *mut *mut super::ScalarNaturalMotionAnimation) -> HRESULT,
    fn put_NaturalMotion(&self, value: *mut super::ScalarNaturalMotionAnimation) -> HRESULT
}}
impl IInteractionTrackerInertiaNaturalMotion {
    #[inline] pub fn get_condition(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Condition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_condition(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Condition)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_motion(&self) -> Result<Option<ComPtr<super::ScalarNaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NaturalMotion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_natural_motion(&self, value: &super::ScalarNaturalMotionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_NaturalMotion)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerInertiaNaturalMotion: IInteractionTrackerInertiaNaturalMotion}
impl RtActivatable<IInteractionTrackerInertiaNaturalMotionStatics> for InteractionTrackerInertiaNaturalMotion {}
impl InteractionTrackerInertiaNaturalMotion {
    #[inline] pub fn create(compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerInertiaNaturalMotion>>> {
        <Self as RtActivatable<IInteractionTrackerInertiaNaturalMotionStatics>>::get_activation_factory().create(compositor)
    }
}
DEFINE_CLSID!(InteractionTrackerInertiaNaturalMotion(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,73,110,116,101,114,97,99,116,105,111,110,84,114,97,99,107,101,114,73,110,101,114,116,105,97,78,97,116,117,114,97,108,77,111,116,105,111,110,0]) [CLSID_InteractionTrackerInertiaNaturalMotion]);
DEFINE_IID!(IID_IInteractionTrackerInertiaNaturalMotionStatics, 3487192496, 24126, 17033, 147, 45, 238, 95, 80, 231, 66, 131);
RT_INTERFACE!{static interface IInteractionTrackerInertiaNaturalMotionStatics(IInteractionTrackerInertiaNaturalMotionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaNaturalMotionStatics] {
    fn Create(&self, compositor: *mut super::Compositor, out: *mut *mut InteractionTrackerInertiaNaturalMotion) -> HRESULT
}}
impl IInteractionTrackerInertiaNaturalMotionStatics {
    #[inline] pub fn create(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerInertiaNaturalMotion>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTrackerInertiaRestingValue, 2264394761, 20630, 16752, 156, 200, 223, 47, 225, 1, 187, 147);
RT_INTERFACE!{interface IInteractionTrackerInertiaRestingValue(IInteractionTrackerInertiaRestingValueVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaRestingValue] {
    fn get_Condition(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Condition(&self, value: *mut super::ExpressionAnimation) -> HRESULT,
    fn get_RestingValue(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_RestingValue(&self, value: *mut super::ExpressionAnimation) -> HRESULT
}}
impl IInteractionTrackerInertiaRestingValue {
    #[inline] pub fn get_condition(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Condition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_condition(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Condition)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_resting_value(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RestingValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_resting_value(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RestingValue)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerInertiaRestingValue: IInteractionTrackerInertiaRestingValue}
impl RtActivatable<IInteractionTrackerInertiaRestingValueStatics> for InteractionTrackerInertiaRestingValue {}
impl InteractionTrackerInertiaRestingValue {
    #[inline] pub fn create(compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerInertiaRestingValue>>> {
        <Self as RtActivatable<IInteractionTrackerInertiaRestingValueStatics>>::get_activation_factory().create(compositor)
    }
}
DEFINE_CLSID!(InteractionTrackerInertiaRestingValue(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,73,110,116,101,114,97,99,116,105,111,110,84,114,97,99,107,101,114,73,110,101,114,116,105,97,82,101,115,116,105,110,103,86,97,108,117,101,0]) [CLSID_InteractionTrackerInertiaRestingValue]);
DEFINE_IID!(IID_IInteractionTrackerInertiaRestingValueStatics, 418203289, 1861, 16534, 188, 171, 58, 78, 153, 86, 155, 207);
RT_INTERFACE!{static interface IInteractionTrackerInertiaRestingValueStatics(IInteractionTrackerInertiaRestingValueStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaRestingValueStatics] {
    fn Create(&self, compositor: *mut super::Compositor, out: *mut *mut InteractionTrackerInertiaRestingValue) -> HRESULT
}}
impl IInteractionTrackerInertiaRestingValueStatics {
    #[inline] pub fn create(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerInertiaRestingValue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTrackerInertiaStateEnteredArgs, 2266008818, 59391, 20349, 159, 253, 215, 47, 30, 64, 155, 99);
RT_INTERFACE!{interface IInteractionTrackerInertiaStateEnteredArgs(IInteractionTrackerInertiaStateEnteredArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaStateEnteredArgs] {
    fn get_ModifiedRestingPosition(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_ModifiedRestingScale(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn get_NaturalRestingPosition(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_NaturalRestingScale(&self, out: *mut f32) -> HRESULT,
    fn get_PositionVelocityInPixelsPerSecond(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_RequestId(&self, out: *mut i32) -> HRESULT,
    fn get_ScaleVelocityInPercentPerSecond(&self, out: *mut f32) -> HRESULT
}}
impl IInteractionTrackerInertiaStateEnteredArgs {
    #[inline] pub fn get_modified_resting_position(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ModifiedRestingPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_modified_resting_scale(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ModifiedRestingScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_resting_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalRestingPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_resting_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NaturalRestingScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position_velocity_in_pixels_per_second(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionVelocityInPixelsPerSecond)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_velocity_in_percent_per_second(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleVelocityInPercentPerSecond)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerInertiaStateEnteredArgs: IInteractionTrackerInertiaStateEnteredArgs}
DEFINE_IID!(IID_IInteractionTrackerInertiaStateEnteredArgs2, 2984981238, 49772, 16886, 161, 137, 250, 188, 34, 179, 35, 204);
RT_INTERFACE!{interface IInteractionTrackerInertiaStateEnteredArgs2(IInteractionTrackerInertiaStateEnteredArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInertiaStateEnteredArgs2] {
    fn get_IsInertiaFromImpulse(&self, out: *mut bool) -> HRESULT
}}
impl IInteractionTrackerInertiaStateEnteredArgs2 {
    #[inline] pub fn get_is_inertia_from_impulse(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInertiaFromImpulse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTrackerInteractingStateEnteredArgs, 2804300089, 41339, 16401, 153, 253, 181, 194, 79, 20, 55, 72);
RT_INTERFACE!{interface IInteractionTrackerInteractingStateEnteredArgs(IInteractionTrackerInteractingStateEnteredArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerInteractingStateEnteredArgs] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT
}}
impl IInteractionTrackerInteractingStateEnteredArgs {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerInteractingStateEnteredArgs: IInteractionTrackerInteractingStateEnteredArgs}
DEFINE_IID!(IID_IInteractionTrackerOwner, 3677260531, 19947, 20051, 178, 156, 176, 108, 159, 150, 214, 81);
RT_INTERFACE!{interface IInteractionTrackerOwner(IInteractionTrackerOwnerVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerOwner] {
    fn CustomAnimationStateEntered(&self, sender: *mut InteractionTracker, args: *mut InteractionTrackerCustomAnimationStateEnteredArgs) -> HRESULT,
    fn IdleStateEntered(&self, sender: *mut InteractionTracker, args: *mut InteractionTrackerIdleStateEnteredArgs) -> HRESULT,
    fn InertiaStateEntered(&self, sender: *mut InteractionTracker, args: *mut InteractionTrackerInertiaStateEnteredArgs) -> HRESULT,
    fn InteractingStateEntered(&self, sender: *mut InteractionTracker, args: *mut InteractionTrackerInteractingStateEnteredArgs) -> HRESULT,
    fn RequestIgnored(&self, sender: *mut InteractionTracker, args: *mut InteractionTrackerRequestIgnoredArgs) -> HRESULT,
    fn ValuesChanged(&self, sender: *mut InteractionTracker, args: *mut InteractionTrackerValuesChangedArgs) -> HRESULT
}}
impl IInteractionTrackerOwner {
    #[inline] pub fn custom_animation_state_entered(&self, sender: &InteractionTracker, args: &InteractionTrackerCustomAnimationStateEnteredArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).CustomAnimationStateEntered)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn idle_state_entered(&self, sender: &InteractionTracker, args: &InteractionTrackerIdleStateEnteredArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).IdleStateEntered)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn inertia_state_entered(&self, sender: &InteractionTracker, args: &InteractionTrackerInertiaStateEnteredArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InertiaStateEntered)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn interacting_state_entered(&self, sender: &InteractionTracker, args: &InteractionTrackerInteractingStateEnteredArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InteractingStateEntered)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn request_ignored(&self, sender: &InteractionTracker, args: &InteractionTrackerRequestIgnoredArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RequestIgnored)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn values_changed(&self, sender: &InteractionTracker, args: &InteractionTrackerValuesChangedArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ValuesChanged)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTrackerRequestIgnoredArgs, 2162000625, 52773, 18575, 145, 221, 203, 100, 85, 204, 255, 46);
RT_INTERFACE!{interface IInteractionTrackerRequestIgnoredArgs(IInteractionTrackerRequestIgnoredArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerRequestIgnoredArgs] {
    fn get_RequestId(&self, out: *mut i32) -> HRESULT
}}
impl IInteractionTrackerRequestIgnoredArgs {
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerRequestIgnoredArgs: IInteractionTrackerRequestIgnoredArgs}
DEFINE_IID!(IID_IInteractionTrackerStatics, 3148208055, 26000, 17560, 141, 108, 235, 98, 181, 20, 201, 42);
RT_INTERFACE!{static interface IInteractionTrackerStatics(IInteractionTrackerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerStatics] {
    fn Create(&self, compositor: *mut super::Compositor, out: *mut *mut InteractionTracker) -> HRESULT,
    fn CreateWithOwner(&self, compositor: *mut super::Compositor, owner: *mut IInteractionTrackerOwner, out: *mut *mut InteractionTracker) -> HRESULT
}}
impl IInteractionTrackerStatics {
    #[inline] pub fn create(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTracker>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_owner(&self, compositor: &super::Compositor, owner: &IInteractionTrackerOwner) -> Result<Option<ComPtr<InteractionTracker>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithOwner)(self as *const _ as *mut _, compositor as *const _ as *mut _, owner as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInteractionTrackerValuesChangedArgs, 3474290927, 54239, 17665, 185, 230, 240, 47, 178, 47, 115, 208);
RT_INTERFACE!{interface IInteractionTrackerValuesChangedArgs(IInteractionTrackerValuesChangedArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerValuesChangedArgs] {
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_RequestId(&self, out: *mut i32) -> HRESULT,
    fn get_Scale(&self, out: *mut f32) -> HRESULT
}}
impl IInteractionTrackerValuesChangedArgs {
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_request_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerValuesChangedArgs: IInteractionTrackerValuesChangedArgs}
DEFINE_IID!(IID_IInteractionTrackerVector2InertiaModifier, 2279639728, 12422, 18515, 164, 183, 119, 136, 42, 213, 215, 227);
RT_INTERFACE!{interface IInteractionTrackerVector2InertiaModifier(IInteractionTrackerVector2InertiaModifierVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerVector2InertiaModifier] {
    
}}
RT_CLASS!{class InteractionTrackerVector2InertiaModifier: IInteractionTrackerVector2InertiaModifier}
DEFINE_IID!(IID_IInteractionTrackerVector2InertiaModifierFactory, 1946277572, 27757, 18655, 188, 62, 23, 30, 34, 126, 125, 127);
RT_INTERFACE!{interface IInteractionTrackerVector2InertiaModifierFactory(IInteractionTrackerVector2InertiaModifierFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerVector2InertiaModifierFactory] {
    
}}
DEFINE_IID!(IID_IInteractionTrackerVector2InertiaNaturalMotion, 1595369820, 5677, 19463, 148, 0, 194, 130, 178, 130, 118, 202);
RT_INTERFACE!{interface IInteractionTrackerVector2InertiaNaturalMotion(IInteractionTrackerVector2InertiaNaturalMotionVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerVector2InertiaNaturalMotion] {
    fn get_Condition(&self, out: *mut *mut super::ExpressionAnimation) -> HRESULT,
    fn put_Condition(&self, value: *mut super::ExpressionAnimation) -> HRESULT,
    fn get_NaturalMotion(&self, out: *mut *mut super::Vector2NaturalMotionAnimation) -> HRESULT,
    fn put_NaturalMotion(&self, value: *mut super::Vector2NaturalMotionAnimation) -> HRESULT
}}
impl IInteractionTrackerVector2InertiaNaturalMotion {
    #[inline] pub fn get_condition(&self) -> Result<Option<ComPtr<super::ExpressionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Condition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_condition(&self, value: &super::ExpressionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Condition)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_natural_motion(&self) -> Result<Option<ComPtr<super::Vector2NaturalMotionAnimation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NaturalMotion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_natural_motion(&self, value: &super::Vector2NaturalMotionAnimation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_NaturalMotion)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InteractionTrackerVector2InertiaNaturalMotion: IInteractionTrackerVector2InertiaNaturalMotion}
impl RtActivatable<IInteractionTrackerVector2InertiaNaturalMotionStatics> for InteractionTrackerVector2InertiaNaturalMotion {}
impl InteractionTrackerVector2InertiaNaturalMotion {
    #[inline] pub fn create(compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerVector2InertiaNaturalMotion>>> {
        <Self as RtActivatable<IInteractionTrackerVector2InertiaNaturalMotionStatics>>::get_activation_factory().create(compositor)
    }
}
DEFINE_CLSID!(InteractionTrackerVector2InertiaNaturalMotion(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,73,110,116,101,114,97,99,116,105,111,110,84,114,97,99,107,101,114,86,101,99,116,111,114,50,73,110,101,114,116,105,97,78,97,116,117,114,97,108,77,111,116,105,111,110,0]) [CLSID_InteractionTrackerVector2InertiaNaturalMotion]);
DEFINE_IID!(IID_IInteractionTrackerVector2InertiaNaturalMotionStatics, 2181044808, 2496, 17231, 129, 137, 20, 28, 102, 223, 54, 47);
RT_INTERFACE!{static interface IInteractionTrackerVector2InertiaNaturalMotionStatics(IInteractionTrackerVector2InertiaNaturalMotionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInteractionTrackerVector2InertiaNaturalMotionStatics] {
    fn Create(&self, compositor: *mut super::Compositor, out: *mut *mut InteractionTrackerVector2InertiaNaturalMotion) -> HRESULT
}}
impl IInteractionTrackerVector2InertiaNaturalMotionStatics {
    #[inline] pub fn create(&self, compositor: &super::Compositor) -> Result<Option<ComPtr<InteractionTrackerVector2InertiaNaturalMotion>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, compositor as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVisualInteractionSource, 3389950598, 55510, 16657, 176, 136, 112, 52, 123, 210, 176, 237);
RT_INTERFACE!{interface IVisualInteractionSource(IVisualInteractionSourceVtbl): IInspectable(IInspectableVtbl) [IID_IVisualInteractionSource] {
    fn get_IsPositionXRailsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPositionXRailsEnabled(&self, value: bool) -> HRESULT,
    fn get_IsPositionYRailsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPositionYRailsEnabled(&self, value: bool) -> HRESULT,
    fn get_ManipulationRedirectionMode(&self, out: *mut VisualInteractionSourceRedirectionMode) -> HRESULT,
    fn put_ManipulationRedirectionMode(&self, value: VisualInteractionSourceRedirectionMode) -> HRESULT,
    fn get_PositionXChainingMode(&self, out: *mut InteractionChainingMode) -> HRESULT,
    fn put_PositionXChainingMode(&self, value: InteractionChainingMode) -> HRESULT,
    fn get_PositionXSourceMode(&self, out: *mut InteractionSourceMode) -> HRESULT,
    fn put_PositionXSourceMode(&self, value: InteractionSourceMode) -> HRESULT,
    fn get_PositionYChainingMode(&self, out: *mut InteractionChainingMode) -> HRESULT,
    fn put_PositionYChainingMode(&self, value: InteractionChainingMode) -> HRESULT,
    fn get_PositionYSourceMode(&self, out: *mut InteractionSourceMode) -> HRESULT,
    fn put_PositionYSourceMode(&self, value: InteractionSourceMode) -> HRESULT,
    fn get_ScaleChainingMode(&self, out: *mut InteractionChainingMode) -> HRESULT,
    fn put_ScaleChainingMode(&self, value: InteractionChainingMode) -> HRESULT,
    fn get_ScaleSourceMode(&self, out: *mut InteractionSourceMode) -> HRESULT,
    fn put_ScaleSourceMode(&self, value: InteractionSourceMode) -> HRESULT,
    fn get_Source(&self, out: *mut *mut super::Visual) -> HRESULT,
    fn TryRedirectForManipulation(&self, pointerPoint: *mut super::super::input::PointerPoint) -> HRESULT
}}
impl IVisualInteractionSource {
    #[inline] pub fn get_is_position_x_rails_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPositionXRailsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_position_x_rails_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsPositionXRailsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_position_y_rails_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPositionYRailsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_position_y_rails_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsPositionYRailsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_manipulation_redirection_mode(&self) -> Result<VisualInteractionSourceRedirectionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ManipulationRedirectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_manipulation_redirection_mode(&self, value: VisualInteractionSourceRedirectionMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ManipulationRedirectionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_x_chaining_mode(&self) -> Result<InteractionChainingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionXChainingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_x_chaining_mode(&self, value: InteractionChainingMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionXChainingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_x_source_mode(&self) -> Result<InteractionSourceMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionXSourceMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_x_source_mode(&self, value: InteractionSourceMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionXSourceMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_y_chaining_mode(&self) -> Result<InteractionChainingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionYChainingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_y_chaining_mode(&self, value: InteractionChainingMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionYChainingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position_y_source_mode(&self) -> Result<InteractionSourceMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionYSourceMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position_y_source_mode(&self, value: InteractionSourceMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PositionYSourceMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_chaining_mode(&self) -> Result<InteractionChainingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleChainingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale_chaining_mode(&self, value: InteractionChainingMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ScaleChainingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_source_mode(&self) -> Result<InteractionSourceMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleSourceMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scale_source_mode(&self, value: InteractionSourceMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ScaleSourceMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<super::Visual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_redirect_for_manipulation(&self, pointerPoint: &super::super::input::PointerPoint) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).TryRedirectForManipulation)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VisualInteractionSource: IVisualInteractionSource}
impl RtActivatable<IVisualInteractionSourceStatics> for VisualInteractionSource {}
impl VisualInteractionSource {
    #[inline] pub fn create(source: &super::Visual) -> Result<Option<ComPtr<VisualInteractionSource>>> {
        <Self as RtActivatable<IVisualInteractionSourceStatics>>::get_activation_factory().create(source)
    }
}
DEFINE_CLSID!(VisualInteractionSource(&[87,105,110,100,111,119,115,46,85,73,46,67,111,109,112,111,115,105,116,105,111,110,46,73,110,116,101,114,97,99,116,105,111,110,115,46,86,105,115,117,97,108,73,110,116,101,114,97,99,116,105,111,110,83,111,117,114,99,101,0]) [CLSID_VisualInteractionSource]);
DEFINE_IID!(IID_IVisualInteractionSource2, 2861648019, 42812, 16717, 128, 208, 36, 155, 173, 47, 189, 147);
RT_INTERFACE!{interface IVisualInteractionSource2(IVisualInteractionSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IVisualInteractionSource2] {
    fn get_DeltaPosition(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_DeltaScale(&self, out: *mut f32) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_PositionVelocity(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_Scale(&self, out: *mut f32) -> HRESULT,
    fn get_ScaleVelocity(&self, out: *mut f32) -> HRESULT,
    fn ConfigureCenterPointXModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT,
    fn ConfigureCenterPointYModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT,
    fn ConfigureDeltaPositionXModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT,
    fn ConfigureDeltaPositionYModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT,
    fn ConfigureDeltaScaleModifiers(&self, conditionalValues: *mut foundation::collections::IIterable<CompositionConditionalValue>) -> HRESULT
}}
impl IVisualInteractionSource2 {
    #[inline] pub fn get_delta_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeltaPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_delta_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeltaScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position_velocity(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionVelocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Scale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scale_velocity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScaleVelocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn configure_center_point_x_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureCenterPointXModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_center_point_y_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureCenterPointYModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_delta_position_x_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureDeltaPositionXModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_delta_position_y_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureDeltaPositionYModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn configure_delta_scale_modifiers(&self, conditionalValues: &foundation::collections::IIterable<CompositionConditionalValue>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureDeltaScaleModifiers)(self as *const _ as *mut _, conditionalValues as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVisualInteractionSource3, 3644976938, 3420, 16471, 146, 215, 201, 113, 21, 51, 32, 79);
RT_INTERFACE!{interface IVisualInteractionSource3(IVisualInteractionSource3Vtbl): IInspectable(IInspectableVtbl) [IID_IVisualInteractionSource3] {
    fn get_PointerWheelConfig(&self, out: *mut *mut InteractionSourceConfiguration) -> HRESULT
}}
impl IVisualInteractionSource3 {
    #[inline] pub fn get_pointer_wheel_config(&self) -> Result<Option<ComPtr<InteractionSourceConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerWheelConfig)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IVisualInteractionSourceObjectFactory, 2999619964, 59786, 16882, 179, 201, 137, 28, 146, 102, 200, 246);
RT_INTERFACE!{interface IVisualInteractionSourceObjectFactory(IVisualInteractionSourceObjectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IVisualInteractionSourceObjectFactory] {
    
}}
RT_ENUM! { enum VisualInteractionSourceRedirectionMode: i32 {
    Off = 0, CapableTouchpadOnly = 1, PointerWheelOnly = 2, CapableTouchpadAndPointerWheel = 3,
}}
DEFINE_IID!(IID_IVisualInteractionSourceStatics, 916022753, 34373, 20341, 186, 0, 100, 121, 205, 16, 200, 230);
RT_INTERFACE!{static interface IVisualInteractionSourceStatics(IVisualInteractionSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVisualInteractionSourceStatics] {
    fn Create(&self, source: *mut super::Visual, out: *mut *mut VisualInteractionSource) -> HRESULT
}}
impl IVisualInteractionSourceStatics {
    #[inline] pub fn create(&self, source: &super::Visual) -> Result<Option<ComPtr<VisualInteractionSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, source as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Composition.Interactions
} // Windows.UI.Composition
pub mod core { // Windows.UI.Core
use crate::prelude::*;
DEFINE_IID!(IID_IAcceleratorKeyEventArgs, 4280044618, 37511, 18187, 131, 110, 144, 134, 227, 18, 106, 222);
RT_INTERFACE!{interface IAcceleratorKeyEventArgs(IAcceleratorKeyEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAcceleratorKeyEventArgs] {
    fn get_EventType(&self, out: *mut CoreAcceleratorKeyEventType) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn get_VirtualKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    fn get_KeyStatus(&self, out: *mut CorePhysicalKeyStatus) -> HRESULT
}}
impl IAcceleratorKeyEventArgs {
    #[inline] pub fn get_event_type(&self) -> Result<CoreAcceleratorKeyEventType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EventType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_virtual_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VirtualKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_key_status(&self) -> Result<CorePhysicalKeyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AcceleratorKeyEventArgs: IAcceleratorKeyEventArgs}
DEFINE_IID!(IID_IAcceleratorKeyEventArgs2, 3540036086, 12158, 18547, 165, 85, 22, 110, 89, 110, 225, 197);
RT_INTERFACE!{interface IAcceleratorKeyEventArgs2(IAcceleratorKeyEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IAcceleratorKeyEventArgs2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAcceleratorKeyEventArgs2 {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AppViewBackButtonVisibility: i32 {
    Visible = 0, Collapsed = 1, Disabled = 2,
}}
DEFINE_IID!(IID_IAutomationProviderRequestedEventArgs, 2518676056, 8639, 19266, 162, 152, 250, 71, 157, 76, 82, 226);
RT_INTERFACE!{interface IAutomationProviderRequestedEventArgs(IAutomationProviderRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAutomationProviderRequestedEventArgs] {
    fn get_AutomationProvider(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_AutomationProvider(&self, value: *mut IInspectable) -> HRESULT
}}
impl IAutomationProviderRequestedEventArgs {
    #[inline] pub fn get_automation_provider(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutomationProvider)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_automation_provider(&self, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AutomationProvider)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AutomationProviderRequestedEventArgs: IAutomationProviderRequestedEventArgs}
DEFINE_IID!(IID_IBackRequestedEventArgs, 3590574730, 58385, 19022, 186, 65, 106, 50, 122, 134, 117, 188);
RT_INTERFACE!{interface IBackRequestedEventArgs(IBackRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBackRequestedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IBackRequestedEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BackRequestedEventArgs: IBackRequestedEventArgs}
DEFINE_IID!(IID_ICharacterReceivedEventArgs, 3313788319, 39346, 19404, 189, 51, 4, 230, 63, 66, 144, 46);
RT_INTERFACE!{interface ICharacterReceivedEventArgs(ICharacterReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICharacterReceivedEventArgs] {
    fn get_KeyCode(&self, out: *mut u32) -> HRESULT,
    fn get_KeyStatus(&self, out: *mut CorePhysicalKeyStatus) -> HRESULT
}}
impl ICharacterReceivedEventArgs {
    #[inline] pub fn get_key_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_key_status(&self) -> Result<CorePhysicalKeyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CharacterReceivedEventArgs: ICharacterReceivedEventArgs}
DEFINE_IID!(IID_IClosestInteractiveBoundsRequestedEventArgs, 880546263, 63224, 16611, 178, 159, 174, 80, 211, 232, 100, 134);
RT_INTERFACE!{interface IClosestInteractiveBoundsRequestedEventArgs(IClosestInteractiveBoundsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IClosestInteractiveBoundsRequestedEventArgs] {
    fn get_PointerPosition(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_SearchBounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_ClosestInteractiveBounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_ClosestInteractiveBounds(&self, value: foundation::Rect) -> HRESULT
}}
impl IClosestInteractiveBoundsRequestedEventArgs {
    #[inline] pub fn get_pointer_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_search_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SearchBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_closest_interactive_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ClosestInteractiveBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_closest_interactive_bounds(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ClosestInteractiveBounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClosestInteractiveBoundsRequestedEventArgs: IClosestInteractiveBoundsRequestedEventArgs}
RT_ENUM! { enum CoreAcceleratorKeyEventType: i32 {
    Character = 2, DeadCharacter = 3, KeyDown = 0, KeyUp = 1, SystemCharacter = 6, SystemDeadCharacter = 7, SystemKeyDown = 4, SystemKeyUp = 5, UnicodeCharacter = 8,
}}
DEFINE_IID!(IID_ICoreAcceleratorKeys, 2684221429, 47305, 20208, 183, 210, 29, 230, 38, 86, 31, 200);
RT_INTERFACE!{interface ICoreAcceleratorKeys(ICoreAcceleratorKeysVtbl): IInspectable(IInspectableVtbl) [IID_ICoreAcceleratorKeys] {
    fn add_AcceleratorKeyActivated(&self, handler: *mut foundation::TypedEventHandler<CoreDispatcher, AcceleratorKeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AcceleratorKeyActivated(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreAcceleratorKeys {
    #[inline] pub fn add_accelerator_key_activated(&self, handler: &foundation::TypedEventHandler<CoreDispatcher, AcceleratorKeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AcceleratorKeyActivated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_accelerator_key_activated(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_AcceleratorKeyActivated)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreAcceleratorKeys: ICoreAcceleratorKeys}
DEFINE_IID!(IID_ICoreClosestInteractiveBoundsRequested, 4077061178, 59583, 20110, 174, 105, 201, 218, 221, 87, 161, 20);
RT_INTERFACE!{interface ICoreClosestInteractiveBoundsRequested(ICoreClosestInteractiveBoundsRequestedVtbl): IInspectable(IInspectableVtbl) [IID_ICoreClosestInteractiveBoundsRequested] {
    fn add_ClosestInteractiveBoundsRequested(&self, handler: *mut foundation::TypedEventHandler<CoreComponentInputSource, ClosestInteractiveBoundsRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ClosestInteractiveBoundsRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreClosestInteractiveBoundsRequested {
    #[inline] pub fn add_closest_interactive_bounds_requested(&self, handler: &foundation::TypedEventHandler<CoreComponentInputSource, ClosestInteractiveBoundsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ClosestInteractiveBoundsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closest_interactive_bounds_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ClosestInteractiveBoundsRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreComponentFocusable, 1392078755, 34626, 17425, 174, 105, 121, 168, 95, 41, 172, 139);
RT_INTERFACE!{interface ICoreComponentFocusable(ICoreComponentFocusableVtbl): IInspectable(IInspectableVtbl) [IID_ICoreComponentFocusable] {
    fn get_HasFocus(&self, out: *mut bool) -> HRESULT,
    fn add_GotFocus(&self, handler: *mut foundation::TypedEventHandler<IInspectable, CoreWindowEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GotFocus(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_LostFocus(&self, handler: *mut foundation::TypedEventHandler<IInspectable, CoreWindowEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LostFocus(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreComponentFocusable {
    #[inline] pub fn get_has_focus(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_got_focus(&self, handler: &foundation::TypedEventHandler<IInspectable, CoreWindowEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_GotFocus)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_got_focus(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_GotFocus)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_lost_focus(&self, handler: &foundation::TypedEventHandler<IInspectable, CoreWindowEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LostFocus)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_lost_focus(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_LostFocus)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreComponentInputSource: ICoreInputSourceBase}
DEFINE_IID!(IID_ICoreCursor, 2525575887, 4381, 17452, 138, 119, 184, 121, 146, 248, 226, 214);
RT_INTERFACE!{interface ICoreCursor(ICoreCursorVtbl): IInspectable(IInspectableVtbl) [IID_ICoreCursor] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_Type(&self, out: *mut CoreCursorType) -> HRESULT
}}
impl ICoreCursor {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<CoreCursorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreCursor: ICoreCursor}
impl RtActivatable<ICoreCursorFactory> for CoreCursor {}
impl CoreCursor {
    #[inline] pub fn create_cursor(type_: CoreCursorType, id: u32) -> Result<ComPtr<CoreCursor>> {
        <Self as RtActivatable<ICoreCursorFactory>>::get_activation_factory().create_cursor(type_, id)
    }
}
DEFINE_CLSID!(CoreCursor(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,67,111,114,101,67,117,114,115,111,114,0]) [CLSID_CoreCursor]);
DEFINE_IID!(IID_ICoreCursorFactory, 4130706977, 42909, 20179, 140, 50, 169, 239, 157, 107, 118, 164);
RT_INTERFACE!{static interface ICoreCursorFactory(ICoreCursorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICoreCursorFactory] {
    fn CreateCursor(&self, type_: CoreCursorType, id: u32, out: *mut *mut CoreCursor) -> HRESULT
}}
impl ICoreCursorFactory {
    #[inline] pub fn create_cursor(&self, type_: CoreCursorType, id: u32) -> Result<ComPtr<CoreCursor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCursor)(self as *const _ as *mut _, type_, id, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreCursorType: i32 {
    Arrow = 0, Cross = 1, Custom = 2, Hand = 3, Help = 4, IBeam = 5, SizeAll = 6, SizeNortheastSouthwest = 7, SizeNorthSouth = 8, SizeNorthwestSoutheast = 9, SizeWestEast = 10, UniversalNo = 11, UpArrow = 12, Wait = 13, Pin = 14, Person = 15,
}}
DEFINE_IID!(IID_ICoreDispatcher, 1624977320, 46853, 20446, 167, 214, 235, 187, 24, 145, 211, 158);
RT_INTERFACE!{interface ICoreDispatcher(ICoreDispatcherVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDispatcher] {
    fn get_HasThreadAccess(&self, out: *mut bool) -> HRESULT,
    fn ProcessEvents(&self, options: CoreProcessEventsOption) -> HRESULT,
    fn RunAsync(&self, priority: CoreDispatcherPriority, agileCallback: *mut DispatchedHandler, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn RunIdleAsync(&self, agileCallback: *mut IdleDispatchedHandler, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ICoreDispatcher {
    #[inline] pub fn get_has_thread_access(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasThreadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn process_events(&self, options: CoreProcessEventsOption) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessEvents)(self as *const _ as *mut _, options);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn run_async(&self, priority: CoreDispatcherPriority, agileCallback: &DispatchedHandler) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RunAsync)(self as *const _ as *mut _, priority, agileCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn run_idle_async(&self, agileCallback: &IdleDispatchedHandler) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RunIdleAsync)(self as *const _ as *mut _, agileCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreDispatcher: ICoreDispatcher}
DEFINE_IID!(IID_ICoreDispatcher2, 1868456903, 58282, 20142, 176, 224, 220, 243, 33, 202, 75, 47);
RT_INTERFACE!{interface ICoreDispatcher2(ICoreDispatcher2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreDispatcher2] {
    fn TryRunAsync(&self, priority: CoreDispatcherPriority, agileCallback: *mut DispatchedHandler, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryRunIdleAsync(&self, agileCallback: *mut IdleDispatchedHandler, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ICoreDispatcher2 {
    #[inline] pub fn try_run_async(&self, priority: CoreDispatcherPriority, agileCallback: &DispatchedHandler) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryRunAsync)(self as *const _ as *mut _, priority, agileCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_run_idle_async(&self, agileCallback: &IdleDispatchedHandler) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryRunIdleAsync)(self as *const _ as *mut _, agileCallback as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreDispatcherPriority: i32 {
    Idle = -2, Low = -1, Normal = 0, High = 1,
}}
DEFINE_IID!(IID_ICoreDispatcherWithTaskPriority, 3137006765, 18509, 16830, 186, 128, 29, 88, 198, 82, 99, 234);
RT_INTERFACE!{interface ICoreDispatcherWithTaskPriority(ICoreDispatcherWithTaskPriorityVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDispatcherWithTaskPriority] {
    fn get_CurrentPriority(&self, out: *mut CoreDispatcherPriority) -> HRESULT,
    fn put_CurrentPriority(&self, value: CoreDispatcherPriority) -> HRESULT,
    fn ShouldYield(&self, out: *mut bool) -> HRESULT,
    fn ShouldYieldToPriority(&self, priority: CoreDispatcherPriority, out: *mut bool) -> HRESULT,
    fn StopProcessEvents(&self) -> HRESULT
}}
impl ICoreDispatcherWithTaskPriority {
    #[inline] pub fn get_current_priority(&self) -> Result<CoreDispatcherPriority> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentPriority)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_current_priority(&self, value: CoreDispatcherPriority) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CurrentPriority)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn should_yield(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ShouldYield)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn should_yield_to_priority(&self, priority: CoreDispatcherPriority) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ShouldYieldToPriority)(self as *const _ as *mut _, priority, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn stop_process_events(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StopProcessEvents)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreIndependentInputSource: ICoreInputSourceBase}
RT_ENUM! { enum CoreInputDeviceTypes: u32 {
    None = 0, Touch = 1, Pen = 2, Mouse = 4,
}}
DEFINE_IID!(IID_ICoreInputSourceBase, 2672330759, 17792, 19432, 190, 104, 146, 169, 49, 23, 19, 187);
RT_INTERFACE!{interface ICoreInputSourceBase(ICoreInputSourceBaseVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputSourceBase] {
    fn get_Dispatcher(&self, out: *mut *mut CoreDispatcher) -> HRESULT,
    fn get_IsInputEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsInputEnabled(&self, value: bool) -> HRESULT,
    fn add_InputEnabled(&self, handler: *mut foundation::TypedEventHandler<IInspectable, InputEnabledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InputEnabled(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreInputSourceBase {
    #[inline] pub fn get_dispatcher(&self) -> Result<Option<ComPtr<CoreDispatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_input_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInputEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_input_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInputEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_input_enabled(&self, handler: &foundation::TypedEventHandler<IInspectable, InputEnabledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_InputEnabled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_input_enabled(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_InputEnabled)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreKeyboardInputSource, 589074568, 58473, 19953, 178, 8, 110, 73, 13, 113, 203, 144);
RT_INTERFACE!{interface ICoreKeyboardInputSource(ICoreKeyboardInputSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICoreKeyboardInputSource] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn GetCurrentKeyState(&self, virtualKey: super::super::system::VirtualKey, out: *mut CoreVirtualKeyStates) -> HRESULT,
    fn add_CharacterReceived(&self, handler: *mut foundation::TypedEventHandler<IInspectable, CharacterReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CharacterReceived(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeyDown(&self, handler: *mut foundation::TypedEventHandler<IInspectable, KeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyDown(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeyUp(&self, handler: *mut foundation::TypedEventHandler<IInspectable, KeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyUp(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreKeyboardInputSource {
    #[cfg(feature="windows-system")] #[inline] pub fn get_current_key_state(&self, virtualKey: super::super::system::VirtualKey) -> Result<CoreVirtualKeyStates> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetCurrentKeyState)(self as *const _ as *mut _, virtualKey, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_character_received(&self, handler: &foundation::TypedEventHandler<IInspectable, CharacterReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CharacterReceived)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_character_received(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CharacterReceived)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_key_down(&self, handler: &foundation::TypedEventHandler<IInspectable, KeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyDown)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_key_down(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_KeyDown)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_key_up(&self, handler: &foundation::TypedEventHandler<IInspectable, KeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyUp)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_key_up(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_KeyUp)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreKeyboardInputSource2, 4196715412, 63843, 18341, 135, 120, 32, 124, 72, 43, 10, 253);
RT_INTERFACE!{interface ICoreKeyboardInputSource2(ICoreKeyboardInputSource2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreKeyboardInputSource2] {
    fn GetCurrentKeyEventDeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICoreKeyboardInputSource2 {
    #[inline] pub fn get_current_key_event_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentKeyEventDeviceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_STRUCT! { struct CorePhysicalKeyStatus {
    RepeatCount: u32, ScanCode: u32, IsExtendedKey: bool, IsMenuKeyDown: bool, WasKeyDown: bool, IsKeyReleased: bool,
}}
DEFINE_IID!(IID_ICorePointerInputSource, 3153181464, 58490, 18667, 136, 7, 248, 248, 211, 234, 69, 81);
RT_INTERFACE!{interface ICorePointerInputSource(ICorePointerInputSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICorePointerInputSource] {
    fn ReleasePointerCapture(&self) -> HRESULT,
    fn SetPointerCapture(&self) -> HRESULT,
    fn get_HasCapture(&self, out: *mut bool) -> HRESULT,
    fn get_PointerPosition(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_PointerCursor(&self, out: *mut *mut CoreCursor) -> HRESULT,
    fn put_PointerCursor(&self, value: *mut CoreCursor) -> HRESULT,
    fn add_PointerCaptureLost(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerCaptureLost(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerEntered(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerEntered(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerExited(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerExited(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerMoved(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerMoved(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerPressed(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerReleased(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerReleased(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerWheelChanged(&self, handler: *mut foundation::TypedEventHandler<IInspectable, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerWheelChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICorePointerInputSource {
    #[inline] pub fn release_pointer_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ReleasePointerCapture)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetPointerCapture)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_has_capture(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasCapture)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_cursor(&self) -> Result<Option<ComPtr<CoreCursor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerCursor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_cursor(&self, value: &CoreCursor) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PointerCursor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_capture_lost(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerCaptureLost)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_capture_lost(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerCaptureLost)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_entered(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerEntered)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_entered(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerEntered)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_exited(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerExited)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_exited(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerExited)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_moved(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerMoved)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_moved(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerMoved)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_pressed(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerPressed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerPressed)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_released(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerReleased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_released(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerReleased)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_wheel_changed(&self, handler: &foundation::TypedEventHandler<IInspectable, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerWheelChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_wheel_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerWheelChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICorePointerInputSource2, 3607326858, 17686, 18310, 177, 229, 39, 81, 213, 99, 249, 151);
RT_INTERFACE!{interface ICorePointerInputSource2(ICorePointerInputSource2Vtbl): IInspectable(IInspectableVtbl) [IID_ICorePointerInputSource2] {
    #[cfg(feature="windows-system")] fn get_DispatcherQueue(&self, out: *mut *mut super::super::system::DispatcherQueue) -> HRESULT
}}
impl ICorePointerInputSource2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_dispatcher_queue(&self) -> Result<Option<ComPtr<super::super::system::DispatcherQueue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DispatcherQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICorePointerRedirector, 2409434260, 22152, 19212, 169, 241, 249, 49, 247, 250, 61, 195);
RT_INTERFACE!{interface ICorePointerRedirector(ICorePointerRedirectorVtbl): IInspectable(IInspectableVtbl) [IID_ICorePointerRedirector] {
    fn add_PointerRoutedAway(&self, handler: *mut foundation::TypedEventHandler<ICorePointerRedirector, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerRoutedAway(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerRoutedTo(&self, handler: *mut foundation::TypedEventHandler<ICorePointerRedirector, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerRoutedTo(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerRoutedReleased(&self, handler: *mut foundation::TypedEventHandler<ICorePointerRedirector, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerRoutedReleased(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICorePointerRedirector {
    #[inline] pub fn add_pointer_routed_away(&self, handler: &foundation::TypedEventHandler<ICorePointerRedirector, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerRoutedAway)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_routed_away(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerRoutedAway)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_routed_to(&self, handler: &foundation::TypedEventHandler<ICorePointerRedirector, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerRoutedTo)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_routed_to(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerRoutedTo)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_routed_released(&self, handler: &foundation::TypedEventHandler<ICorePointerRedirector, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerRoutedReleased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_routed_released(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerRoutedReleased)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreProcessEventsOption: i32 {
    ProcessOneAndAllPending = 0, ProcessOneIfPresent = 1, ProcessUntilQuit = 2, ProcessAllIfPresent = 3,
}}
RT_STRUCT! { struct CoreProximityEvaluation {
    Score: i32, AdjustedPoint: foundation::Point,
}}
RT_ENUM! { enum CoreProximityEvaluationScore: i32 {
    Closest = 0, Farthest = 2147483647,
}}
DEFINE_IID!(IID_ICoreTouchHitTesting, 2983764617, 15055, 16676, 159, 163, 234, 138, 186, 53, 60, 33);
RT_INTERFACE!{interface ICoreTouchHitTesting(ICoreTouchHitTestingVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTouchHitTesting] {
    fn add_TouchHitTesting(&self, handler: *mut foundation::TypedEventHandler<IInspectable, TouchHitTestingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TouchHitTesting(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreTouchHitTesting {
    #[inline] pub fn add_touch_hit_testing(&self, handler: &foundation::TypedEventHandler<IInspectable, TouchHitTestingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TouchHitTesting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_touch_hit_testing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_TouchHitTesting)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreVirtualKeyStates: u32 {
    None = 0, Down = 1, Locked = 2,
}}
DEFINE_IID!(IID_ICoreWindow, 2042222066, 34718, 19337, 183, 152, 121, 228, 117, 152, 3, 12);
RT_INTERFACE!{interface ICoreWindow(ICoreWindowVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindow] {
    fn get_AutomationHostProvider(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Bounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_CustomProperties(&self, out: *mut *mut foundation::collections::IPropertySet) -> HRESULT,
    fn get_Dispatcher(&self, out: *mut *mut CoreDispatcher) -> HRESULT,
    fn get_FlowDirection(&self, out: *mut CoreWindowFlowDirection) -> HRESULT,
    fn put_FlowDirection(&self, value: CoreWindowFlowDirection) -> HRESULT,
    fn get_IsInputEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsInputEnabled(&self, value: bool) -> HRESULT,
    fn get_PointerCursor(&self, out: *mut *mut CoreCursor) -> HRESULT,
    fn put_PointerCursor(&self, value: *mut CoreCursor) -> HRESULT,
    fn get_PointerPosition(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn Activate(&self) -> HRESULT,
    fn Close(&self) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-system")] fn GetAsyncKeyState(&self, virtualKey: super::super::system::VirtualKey, out: *mut CoreVirtualKeyStates) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-system")] fn GetKeyState(&self, virtualKey: super::super::system::VirtualKey, out: *mut CoreVirtualKeyStates) -> HRESULT,
    fn ReleasePointerCapture(&self) -> HRESULT,
    fn SetPointerCapture(&self) -> HRESULT,
    fn add_Activated(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, WindowActivatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AutomationProviderRequested(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, AutomationProviderRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AutomationProviderRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CharacterReceived(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, CharacterReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CharacterReceived(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, CoreWindowEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_InputEnabled(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, InputEnabledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InputEnabled(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeyDown(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, KeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyDown(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeyUp(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, KeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyUp(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerCaptureLost(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerCaptureLost(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerEntered(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerEntered(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerExited(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerExited(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerMoved(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerMoved(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerPressed(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerReleased(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerReleased(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TouchHitTesting(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, TouchHitTestingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TouchHitTesting(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerWheelChanged(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerWheelChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SizeChanged(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, WindowSizeChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SizeChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VisibilityChanged(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, VisibilityChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisibilityChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreWindow {
    #[inline] pub fn get_automation_host_provider(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutomationHostProvider)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_properties(&self) -> Result<Option<ComPtr<foundation::collections::IPropertySet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dispatcher(&self) -> Result<Option<ComPtr<CoreDispatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_flow_direction(&self) -> Result<CoreWindowFlowDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FlowDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_flow_direction(&self, value: CoreWindowFlowDirection) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FlowDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_input_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInputEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_input_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInputEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_cursor(&self) -> Result<Option<ComPtr<CoreCursor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerCursor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_cursor(&self, value: &CoreCursor) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PointerCursor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn activate(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Activate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Close)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_async_key_state(&self, virtualKey: super::super::system::VirtualKey) -> Result<CoreVirtualKeyStates> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAsyncKeyState)(self as *const _ as *mut _, virtualKey, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_key_state(&self, virtualKey: super::super::system::VirtualKey) -> Result<CoreVirtualKeyStates> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetKeyState)(self as *const _ as *mut _, virtualKey, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn release_pointer_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ReleasePointerCapture)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_capture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetPointerCapture)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_activated(&self, handler: &foundation::TypedEventHandler<CoreWindow, WindowActivatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Activated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_activated(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Activated)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_automation_provider_requested(&self, handler: &foundation::TypedEventHandler<CoreWindow, AutomationProviderRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AutomationProviderRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_automation_provider_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_AutomationProviderRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_character_received(&self, handler: &foundation::TypedEventHandler<CoreWindow, CharacterReceivedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CharacterReceived)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_character_received(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CharacterReceived)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<CoreWindow, CoreWindowEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_input_enabled(&self, handler: &foundation::TypedEventHandler<CoreWindow, InputEnabledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_InputEnabled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_input_enabled(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_InputEnabled)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_key_down(&self, handler: &foundation::TypedEventHandler<CoreWindow, KeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyDown)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_key_down(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_KeyDown)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_key_up(&self, handler: &foundation::TypedEventHandler<CoreWindow, KeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyUp)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_key_up(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_KeyUp)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_capture_lost(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerCaptureLost)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_capture_lost(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerCaptureLost)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_entered(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerEntered)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_entered(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerEntered)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_exited(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerExited)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_exited(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerExited)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_moved(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerMoved)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_moved(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerMoved)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_pressed(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerPressed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerPressed)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_released(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerReleased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_released(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerReleased)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_touch_hit_testing(&self, handler: &foundation::TypedEventHandler<CoreWindow, TouchHitTestingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TouchHitTesting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_touch_hit_testing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_TouchHitTesting)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_wheel_changed(&self, handler: &foundation::TypedEventHandler<CoreWindow, PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerWheelChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_wheel_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerWheelChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_size_changed(&self, handler: &foundation::TypedEventHandler<CoreWindow, WindowSizeChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SizeChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_size_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SizeChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_visibility_changed(&self, handler: &foundation::TypedEventHandler<CoreWindow, VisibilityChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VisibilityChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_visibility_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_VisibilityChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWindow: ICoreWindow}
impl RtActivatable<ICoreWindowStatic> for CoreWindow {}
impl CoreWindow {
    #[inline] pub fn get_for_current_thread() -> Result<Option<ComPtr<CoreWindow>>> {
        <Self as RtActivatable<ICoreWindowStatic>>::get_activation_factory().get_for_current_thread()
    }
}
DEFINE_CLSID!(CoreWindow(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,67,111,114,101,87,105,110,100,111,119,0]) [CLSID_CoreWindow]);
DEFINE_IID!(IID_ICoreWindow2, 2083199877, 26903, 17249, 156, 2, 13, 158, 58, 66, 11, 149);
RT_INTERFACE!{interface ICoreWindow2(ICoreWindow2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindow2] {
    fn put_PointerPosition(&self, value: foundation::Point) -> HRESULT
}}
impl ICoreWindow2 {
    #[inline] pub fn set_pointer_position(&self, value: foundation::Point) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PointerPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindow3, 851578328, 64239, 17269, 162, 171, 50, 100, 14, 72, 21, 199);
RT_INTERFACE!{interface ICoreWindow3(ICoreWindow3Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindow3] {
    fn add_ClosestInteractiveBoundsRequested(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, ClosestInteractiveBoundsRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ClosestInteractiveBoundsRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn GetCurrentKeyEventDeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ICoreWindow3 {
    #[inline] pub fn add_closest_interactive_bounds_requested(&self, handler: &foundation::TypedEventHandler<CoreWindow, ClosestInteractiveBoundsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ClosestInteractiveBoundsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closest_interactive_bounds_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ClosestInteractiveBoundsRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_key_event_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentKeyEventDeviceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindow4, 902492368, 18416, 17260, 175, 151, 13, 216, 143, 111, 95, 2);
RT_INTERFACE!{interface ICoreWindow4(ICoreWindow4Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindow4] {
    fn add_ResizeStarted(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResizeStarted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResizeCompleted(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResizeCompleted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreWindow4 {
    #[inline] pub fn add_resize_started(&self, handler: &foundation::TypedEventHandler<CoreWindow, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ResizeStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resize_started(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ResizeStarted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_resize_completed(&self, handler: &foundation::TypedEventHandler<CoreWindow, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ResizeCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resize_completed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ResizeCompleted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindow5, 1263198689, 11885, 20138, 189, 161, 28, 92, 193, 190, 225, 65);
RT_INTERFACE!{interface ICoreWindow5(ICoreWindow5Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindow5] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_DispatcherQueue(&self, out: *mut *mut super::super::system::DispatcherQueue) -> HRESULT,
    fn get_ActivationMode(&self, out: *mut CoreWindowActivationMode) -> HRESULT
}}
impl ICoreWindow5 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_dispatcher_queue(&self) -> Result<Option<ComPtr<super::super::system::DispatcherQueue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DispatcherQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_activation_mode(&self) -> Result<CoreWindowActivationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivationMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreWindowActivationMode: i32 {
    None = 0, Deactivated = 1, ActivatedNotForeground = 2, ActivatedInForeground = 3,
}}
RT_ENUM! { enum CoreWindowActivationState: i32 {
    CodeActivated = 0, Deactivated = 1, PointerActivated = 2,
}}
DEFINE_IID!(IID_ICoreWindowDialog, 3879283936, 51085, 17022, 139, 44, 1, 255, 66, 12, 105, 213);
RT_INTERFACE!{interface ICoreWindowDialog(ICoreWindowDialogVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowDialog] {
    fn add_Showing(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, CoreWindowPopupShowingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Showing(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_MaxSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_MinSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_IsInteractionDelayed(&self, out: *mut i32) -> HRESULT,
    fn put_IsInteractionDelayed(&self, value: i32) -> HRESULT,
    fn get_Commands(&self, out: *mut *mut foundation::collections::IVector<super::popups::IUICommand>) -> HRESULT,
    fn get_DefaultCommandIndex(&self, out: *mut u32) -> HRESULT,
    fn put_DefaultCommandIndex(&self, value: u32) -> HRESULT,
    fn get_CancelCommandIndex(&self, out: *mut u32) -> HRESULT,
    fn put_CancelCommandIndex(&self, value: u32) -> HRESULT,
    fn get_BackButtonCommand(&self, out: *mut *mut super::popups::UICommandInvokedHandler) -> HRESULT,
    fn put_BackButtonCommand(&self, value: *mut super::popups::UICommandInvokedHandler) -> HRESULT,
    fn ShowAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::popups::IUICommand>) -> HRESULT
}}
impl ICoreWindowDialog {
    #[inline] pub fn add_showing(&self, handler: &foundation::TypedEventHandler<CoreWindow, CoreWindowPopupShowingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Showing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_showing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Showing)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_interaction_delayed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInteractionDelayed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_interaction_delayed(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInteractionDelayed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<super::popups::IUICommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Commands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_command_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultCommandIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_command_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DefaultCommandIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cancel_command_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CancelCommandIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cancel_command_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CancelCommandIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_back_button_command(&self) -> Result<Option<ComPtr<super::popups::UICommandInvokedHandler>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackButtonCommand)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_back_button_command(&self, value: &super::popups::UICommandInvokedHandler) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackButtonCommand)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::popups::IUICommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWindowDialog: ICoreWindowDialog}
impl RtActivatable<ICoreWindowDialogFactory> for CoreWindowDialog {}
impl RtActivatable<IActivationFactory> for CoreWindowDialog {}
impl CoreWindowDialog {
    #[inline] pub fn create_with_title(title: &HStringArg) -> Result<ComPtr<CoreWindowDialog>> {
        <Self as RtActivatable<ICoreWindowDialogFactory>>::get_activation_factory().create_with_title(title)
    }
}
DEFINE_CLSID!(CoreWindowDialog(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,67,111,114,101,87,105,110,100,111,119,68,105,97,108,111,103,0]) [CLSID_CoreWindowDialog]);
DEFINE_IID!(IID_ICoreWindowDialogFactory, 3484592213, 7257, 19219, 177, 229, 22, 226, 152, 5, 247, 196);
RT_INTERFACE!{static interface ICoreWindowDialogFactory(ICoreWindowDialogFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowDialogFactory] {
    fn CreateWithTitle(&self, title: HSTRING, out: *mut *mut CoreWindowDialog) -> HRESULT
}}
impl ICoreWindowDialogFactory {
    #[inline] pub fn create_with_title(&self, title: &HStringArg) -> Result<ComPtr<CoreWindowDialog>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithTitle)(self as *const _ as *mut _, title.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindowEventArgs, 657137395, 50739, 19877, 162, 108, 198, 208, 245, 107, 41, 218);
RT_INTERFACE!{interface ICoreWindowEventArgs(ICoreWindowEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl ICoreWindowEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWindowEventArgs: ICoreWindowEventArgs}
RT_ENUM! { enum CoreWindowFlowDirection: i32 {
    LeftToRight = 0, RightToLeft = 1,
}}
DEFINE_IID!(IID_ICoreWindowFlyout, 3902637389, 8272, 16571, 179, 68, 246, 243, 85, 238, 179, 20);
RT_INTERFACE!{interface ICoreWindowFlyout(ICoreWindowFlyoutVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowFlyout] {
    fn add_Showing(&self, handler: *mut foundation::TypedEventHandler<CoreWindow, CoreWindowPopupShowingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Showing(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_MaxSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_MinSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_IsInteractionDelayed(&self, out: *mut i32) -> HRESULT,
    fn put_IsInteractionDelayed(&self, value: i32) -> HRESULT,
    fn get_Commands(&self, out: *mut *mut foundation::collections::IVector<super::popups::IUICommand>) -> HRESULT,
    fn get_DefaultCommandIndex(&self, out: *mut u32) -> HRESULT,
    fn put_DefaultCommandIndex(&self, value: u32) -> HRESULT,
    fn get_BackButtonCommand(&self, out: *mut *mut super::popups::UICommandInvokedHandler) -> HRESULT,
    fn put_BackButtonCommand(&self, value: *mut super::popups::UICommandInvokedHandler) -> HRESULT,
    fn ShowAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::popups::IUICommand>) -> HRESULT
}}
impl ICoreWindowFlyout {
    #[inline] pub fn add_showing(&self, handler: &foundation::TypedEventHandler<CoreWindow, CoreWindowPopupShowingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Showing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_showing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Showing)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_interaction_delayed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInteractionDelayed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_interaction_delayed(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInteractionDelayed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<super::popups::IUICommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Commands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_command_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultCommandIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_command_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DefaultCommandIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_back_button_command(&self) -> Result<Option<ComPtr<super::popups::UICommandInvokedHandler>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackButtonCommand)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_back_button_command(&self, value: &super::popups::UICommandInvokedHandler) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackButtonCommand)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::popups::IUICommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWindowFlyout: ICoreWindowFlyout}
impl RtActivatable<ICoreWindowFlyoutFactory> for CoreWindowFlyout {}
impl CoreWindowFlyout {
    #[inline] pub fn create(position: foundation::Point) -> Result<ComPtr<CoreWindowFlyout>> {
        <Self as RtActivatable<ICoreWindowFlyoutFactory>>::get_activation_factory().create(position)
    }
    #[inline] pub fn create_with_title(position: foundation::Point, title: &HStringArg) -> Result<ComPtr<CoreWindowFlyout>> {
        <Self as RtActivatable<ICoreWindowFlyoutFactory>>::get_activation_factory().create_with_title(position, title)
    }
}
DEFINE_CLSID!(CoreWindowFlyout(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,67,111,114,101,87,105,110,100,111,119,70,108,121,111,117,116,0]) [CLSID_CoreWindowFlyout]);
DEFINE_IID!(IID_ICoreWindowFlyoutFactory, 3737437892, 37864, 20348, 190, 39, 206, 250, 161, 175, 104, 167);
RT_INTERFACE!{static interface ICoreWindowFlyoutFactory(ICoreWindowFlyoutFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowFlyoutFactory] {
    fn Create(&self, position: foundation::Point, out: *mut *mut CoreWindowFlyout) -> HRESULT,
    fn CreateWithTitle(&self, position: foundation::Point, title: HSTRING, out: *mut *mut CoreWindowFlyout) -> HRESULT
}}
impl ICoreWindowFlyoutFactory {
    #[inline] pub fn create(&self, position: foundation::Point) -> Result<ComPtr<CoreWindowFlyout>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, position, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_title(&self, position: foundation::Point, title: &HStringArg) -> Result<ComPtr<CoreWindowFlyout>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithTitle)(self as *const _ as *mut _, position, title.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindowPopupShowingEventArgs, 638934946, 23461, 20132, 163, 180, 45, 199, 214, 60, 142, 38);
RT_INTERFACE!{interface ICoreWindowPopupShowingEventArgs(ICoreWindowPopupShowingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowPopupShowingEventArgs] {
    fn SetDesiredSize(&self, value: foundation::Size) -> HRESULT
}}
impl ICoreWindowPopupShowingEventArgs {
    #[inline] pub fn set_desired_size(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDesiredSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWindowPopupShowingEventArgs: ICoreWindowPopupShowingEventArgs}
DEFINE_IID!(IID_ICoreWindowResizeManager, 3102783781, 45904, 18611, 161, 152, 92, 26, 132, 112, 2, 67);
RT_INTERFACE!{interface ICoreWindowResizeManager(ICoreWindowResizeManagerVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowResizeManager] {
    fn NotifyLayoutCompleted(&self) -> HRESULT
}}
impl ICoreWindowResizeManager {
    #[inline] pub fn notify_layout_completed(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).NotifyLayoutCompleted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWindowResizeManager: ICoreWindowResizeManager}
impl RtActivatable<ICoreWindowResizeManagerStatics> for CoreWindowResizeManager {}
impl CoreWindowResizeManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<CoreWindowResizeManager>>> {
        <Self as RtActivatable<ICoreWindowResizeManagerStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(CoreWindowResizeManager(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,67,111,114,101,87,105,110,100,111,119,82,101,115,105,122,101,77,97,110,97,103,101,114,0]) [CLSID_CoreWindowResizeManager]);
DEFINE_IID!(IID_ICoreWindowResizeManagerLayoutCapability, 3145003643, 42308, 17153, 128, 230, 10, 224, 51, 239, 69, 54);
RT_INTERFACE!{interface ICoreWindowResizeManagerLayoutCapability(ICoreWindowResizeManagerLayoutCapabilityVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowResizeManagerLayoutCapability] {
    fn put_ShouldWaitForLayoutCompletion(&self, value: bool) -> HRESULT,
    fn get_ShouldWaitForLayoutCompletion(&self, out: *mut bool) -> HRESULT
}}
impl ICoreWindowResizeManagerLayoutCapability {
    #[inline] pub fn set_should_wait_for_layout_completion(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShouldWaitForLayoutCompletion)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_should_wait_for_layout_completion(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldWaitForLayoutCompletion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindowResizeManagerStatics, 2924122181, 28016, 18907, 142, 104, 70, 255, 189, 23, 211, 141);
RT_INTERFACE!{static interface ICoreWindowResizeManagerStatics(ICoreWindowResizeManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowResizeManagerStatics] {
    fn GetForCurrentView(&self, out: *mut *mut CoreWindowResizeManager) -> HRESULT
}}
impl ICoreWindowResizeManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<CoreWindowResizeManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreWindowStatic, 1294176261, 15402, 16817, 144, 34, 83, 107, 185, 207, 147, 177);
RT_INTERFACE!{static interface ICoreWindowStatic(ICoreWindowStaticVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWindowStatic] {
    fn GetForCurrentThread(&self, out: *mut *mut CoreWindow) -> HRESULT
}}
impl ICoreWindowStatic {
    #[inline] pub fn get_for_current_thread(&self) -> Result<Option<ComPtr<CoreWindow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentThread)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_DispatchedHandler, 3522328260, 39128, 17974, 191, 73, 235, 121, 80, 117, 72, 233);
RT_DELEGATE!{delegate DispatchedHandler(DispatchedHandlerVtbl, DispatchedHandlerImpl) [IID_DispatchedHandler] {
    fn Invoke(&self) -> HRESULT
}}
impl DispatchedHandler {
    #[inline] pub fn invoke(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IdleDispatchedHandler, 2754284580, 32545, 19132, 153, 193, 143, 1, 0, 127, 8, 128);
RT_DELEGATE!{delegate IdleDispatchedHandler(IdleDispatchedHandlerVtbl, IdleDispatchedHandlerImpl) [IID_IdleDispatchedHandler] {
    fn Invoke(&self, e: *mut IdleDispatchedHandlerArgs) -> HRESULT
}}
impl IdleDispatchedHandler {
    #[inline] pub fn invoke(&self, e: &IdleDispatchedHandlerArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IIdleDispatchedHandlerArgs, 2562419236, 56348, 17355, 180, 237, 209, 192, 235, 35, 145, 243);
RT_INTERFACE!{interface IIdleDispatchedHandlerArgs(IIdleDispatchedHandlerArgsVtbl): IInspectable(IInspectableVtbl) [IID_IIdleDispatchedHandlerArgs] {
    fn get_IsDispatcherIdle(&self, out: *mut bool) -> HRESULT
}}
impl IIdleDispatchedHandlerArgs {
    #[inline] pub fn get_is_dispatcher_idle(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDispatcherIdle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class IdleDispatchedHandlerArgs: IIdleDispatchedHandlerArgs}
DEFINE_IID!(IID_IInitializeWithCoreWindow, 412033238, 39027, 17994, 172, 229, 87, 224, 16, 244, 101, 230);
RT_INTERFACE!{interface IInitializeWithCoreWindow(IInitializeWithCoreWindowVtbl): IInspectable(IInspectableVtbl) [IID_IInitializeWithCoreWindow] {
    fn Initialize(&self, window: *mut CoreWindow) -> HRESULT
}}
impl IInitializeWithCoreWindow {
    #[inline] pub fn initialize(&self, window: &CoreWindow) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Initialize)(self as *const _ as *mut _, window as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInputEnabledEventArgs, 2151095631, 12248, 19492, 170, 134, 49, 99, 168, 123, 78, 90);
RT_INTERFACE!{interface IInputEnabledEventArgs(IInputEnabledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInputEnabledEventArgs] {
    fn get_InputEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IInputEnabledEventArgs {
    #[inline] pub fn get_input_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InputEnabledEventArgs: IInputEnabledEventArgs}
DEFINE_IID!(IID_IKeyEventArgs, 1609951536, 9540, 18967, 189, 120, 31, 47, 222, 187, 16, 107);
RT_INTERFACE!{interface IKeyEventArgs(IKeyEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IKeyEventArgs] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_VirtualKey(&self, out: *mut super::super::system::VirtualKey) -> HRESULT,
    fn get_KeyStatus(&self, out: *mut CorePhysicalKeyStatus) -> HRESULT
}}
impl IKeyEventArgs {
    #[cfg(feature="windows-system")] #[inline] pub fn get_virtual_key(&self) -> Result<super::super::system::VirtualKey> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VirtualKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_key_status(&self) -> Result<CorePhysicalKeyStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class KeyEventArgs: IKeyEventArgs}
DEFINE_IID!(IID_IKeyEventArgs2, 1480252824, 1936, 17777, 155, 18, 100, 94, 249, 215, 158, 66);
RT_INTERFACE!{interface IKeyEventArgs2(IKeyEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IKeyEventArgs2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKeyEventArgs2 {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPointerEventArgs, 2450365617, 42492, 18977, 140, 9, 73, 223, 230, 255, 226, 95);
RT_INTERFACE!{interface IPointerEventArgs(IPointerEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerEventArgs] {
    fn get_CurrentPoint(&self, out: *mut *mut super::input::PointerPoint) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn get_KeyModifiers(&self, out: *mut super::super::system::VirtualKeyModifiers) -> HRESULT,
    fn GetIntermediatePoints(&self, out: *mut *mut foundation::collections::IVector<super::input::PointerPoint>) -> HRESULT
}}
impl IPointerEventArgs {
    #[inline] pub fn get_current_point(&self) -> Result<Option<ComPtr<super::input::PointerPoint>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_key_modifiers(&self) -> Result<super::super::system::VirtualKeyModifiers> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyModifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_points(&self) -> Result<Option<ComPtr<foundation::collections::IVector<super::input::PointerPoint>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIntermediatePoints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PointerEventArgs: IPointerEventArgs}
DEFINE_IID!(IID_ISystemNavigationManager, 2466394392, 53072, 17062, 151, 6, 105, 16, 127, 161, 34, 225);
RT_INTERFACE!{interface ISystemNavigationManager(ISystemNavigationManagerVtbl): IInspectable(IInspectableVtbl) [IID_ISystemNavigationManager] {
    fn add_BackRequested(&self, handler: *mut foundation::EventHandler<BackRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISystemNavigationManager {
    #[inline] pub fn add_back_requested(&self, handler: &foundation::EventHandler<BackRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BackRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_back_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_BackRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemNavigationManager: ISystemNavigationManager}
impl RtActivatable<ISystemNavigationManagerStatics> for SystemNavigationManager {}
impl SystemNavigationManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<SystemNavigationManager>>> {
        <Self as RtActivatable<ISystemNavigationManagerStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(SystemNavigationManager(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,83,121,115,116,101,109,78,97,118,105,103,97,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_SystemNavigationManager]);
DEFINE_IID!(IID_ISystemNavigationManager2, 2354119681, 26558, 18862, 149, 9, 103, 28, 30, 84, 163, 137);
RT_INTERFACE!{interface ISystemNavigationManager2(ISystemNavigationManager2Vtbl): IInspectable(IInspectableVtbl) [IID_ISystemNavigationManager2] {
    fn get_AppViewBackButtonVisibility(&self, out: *mut AppViewBackButtonVisibility) -> HRESULT,
    fn put_AppViewBackButtonVisibility(&self, value: AppViewBackButtonVisibility) -> HRESULT
}}
impl ISystemNavigationManager2 {
    #[inline] pub fn get_app_view_back_button_visibility(&self) -> Result<AppViewBackButtonVisibility> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AppViewBackButtonVisibility)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_app_view_back_button_visibility(&self, value: AppViewBackButtonVisibility) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AppViewBackButtonVisibility)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISystemNavigationManagerStatics, 3696408014, 48864, 17157, 140, 84, 104, 34, 142, 214, 131, 181);
RT_INTERFACE!{static interface ISystemNavigationManagerStatics(ISystemNavigationManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISystemNavigationManagerStatics] {
    fn GetForCurrentView(&self, out: *mut *mut SystemNavigationManager) -> HRESULT
}}
impl ISystemNavigationManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<SystemNavigationManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITouchHitTestingEventArgs, 586397731, 2940, 16974, 157, 247, 51, 212, 249, 98, 147, 27);
RT_INTERFACE!{interface ITouchHitTestingEventArgs(ITouchHitTestingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITouchHitTestingEventArgs] {
    fn get_ProximityEvaluation(&self, out: *mut CoreProximityEvaluation) -> HRESULT,
    fn put_ProximityEvaluation(&self, value: CoreProximityEvaluation) -> HRESULT,
    fn get_Point(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_BoundingBox(&self, out: *mut foundation::Rect) -> HRESULT,
    fn EvaluateProximityToRect(&self, controlBoundingBox: foundation::Rect, out: *mut CoreProximityEvaluation) -> HRESULT,
    fn EvaluateProximityToPolygon(&self, controlVerticesSize: u32, controlVertices: *mut foundation::Point, out: *mut CoreProximityEvaluation) -> HRESULT
}}
impl ITouchHitTestingEventArgs {
    #[inline] pub fn get_proximity_evaluation(&self) -> Result<CoreProximityEvaluation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProximityEvaluation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_proximity_evaluation(&self, value: CoreProximityEvaluation) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ProximityEvaluation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_point(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Point)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bounding_box(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BoundingBox)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn evaluate_proximity_to_rect(&self, controlBoundingBox: foundation::Rect) -> Result<CoreProximityEvaluation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).EvaluateProximityToRect)(self as *const _ as *mut _, controlBoundingBox, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn evaluate_proximity_to_polygon(&self, controlVertices: &[foundation::Point]) -> Result<CoreProximityEvaluation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).EvaluateProximityToPolygon)(self as *const _ as *mut _, controlVertices.len() as u32, controlVertices.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TouchHitTestingEventArgs: ITouchHitTestingEventArgs}
DEFINE_IID!(IID_IVisibilityChangedEventArgs, 3214481642, 55297, 17764, 164, 149, 177, 232, 79, 138, 208, 133);
RT_INTERFACE!{interface IVisibilityChangedEventArgs(IVisibilityChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IVisibilityChangedEventArgs] {
    fn get_Visible(&self, out: *mut bool) -> HRESULT
}}
impl IVisibilityChangedEventArgs {
    #[inline] pub fn get_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class VisibilityChangedEventArgs: IVisibilityChangedEventArgs}
DEFINE_IID!(IID_IWindowActivatedEventArgs, 396191207, 18008, 19638, 170, 19, 65, 208, 148, 234, 37, 94);
RT_INTERFACE!{interface IWindowActivatedEventArgs(IWindowActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWindowActivatedEventArgs] {
    fn get_WindowActivationState(&self, out: *mut CoreWindowActivationState) -> HRESULT
}}
impl IWindowActivatedEventArgs {
    #[inline] pub fn get_window_activation_state(&self) -> Result<CoreWindowActivationState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WindowActivationState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WindowActivatedEventArgs: IWindowActivatedEventArgs}
DEFINE_IID!(IID_IWindowSizeChangedEventArgs, 1512050375, 1062, 18396, 184, 108, 111, 71, 89, 21, 228, 81);
RT_INTERFACE!{interface IWindowSizeChangedEventArgs(IWindowSizeChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWindowSizeChangedEventArgs] {
    fn get_Size(&self, out: *mut foundation::Size) -> HRESULT
}}
impl IWindowSizeChangedEventArgs {
    #[inline] pub fn get_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WindowSizeChangedEventArgs: IWindowSizeChangedEventArgs}
pub mod animationmetrics { // Windows.UI.Core.AnimationMetrics
use crate::prelude::*;
DEFINE_IID!(IID_IAnimationDescription, 2098308425, 48701, 16862, 176, 129, 5, 193, 73, 150, 47, 155);
RT_INTERFACE!{interface IAnimationDescription(IAnimationDescriptionVtbl): IInspectable(IInspectableVtbl) [IID_IAnimationDescription] {
    fn get_Animations(&self, out: *mut *mut foundation::collections::IVectorView<IPropertyAnimation>) -> HRESULT,
    fn get_StaggerDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_StaggerDelayFactor(&self, out: *mut f32) -> HRESULT,
    fn get_DelayLimit(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_ZOrder(&self, out: *mut i32) -> HRESULT
}}
impl IAnimationDescription {
    #[inline] pub fn get_animations(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<IPropertyAnimation>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Animations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_stagger_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StaggerDelay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stagger_delay_factor(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StaggerDelayFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_delay_limit(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DelayLimit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_z_order(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ZOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AnimationDescription: IAnimationDescription}
impl RtActivatable<IAnimationDescriptionFactory> for AnimationDescription {}
impl AnimationDescription {
    #[inline] pub fn create_instance(effect: AnimationEffect, target: AnimationEffectTarget) -> Result<ComPtr<AnimationDescription>> {
        <Self as RtActivatable<IAnimationDescriptionFactory>>::get_activation_factory().create_instance(effect, target)
    }
}
DEFINE_CLSID!(AnimationDescription(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,65,110,105,109,97,116,105,111,110,77,101,116,114,105,99,115,46,65,110,105,109,97,116,105,111,110,68,101,115,99,114,105,112,116,105,111,110,0]) [CLSID_AnimationDescription]);
DEFINE_IID!(IID_IAnimationDescriptionFactory, 3336731326, 49659, 18613, 146, 113, 236, 199, 10, 200, 110, 240);
RT_INTERFACE!{static interface IAnimationDescriptionFactory(IAnimationDescriptionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAnimationDescriptionFactory] {
    fn CreateInstance(&self, effect: AnimationEffect, target: AnimationEffectTarget, out: *mut *mut AnimationDescription) -> HRESULT
}}
impl IAnimationDescriptionFactory {
    #[inline] pub fn create_instance(&self, effect: AnimationEffect, target: AnimationEffectTarget) -> Result<ComPtr<AnimationDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, effect, target, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AnimationEffect: i32 {
    Expand = 0, Collapse = 1, Reposition = 2, FadeIn = 3, FadeOut = 4, AddToList = 5, DeleteFromList = 6, AddToGrid = 7, DeleteFromGrid = 8, AddToSearchGrid = 9, DeleteFromSearchGrid = 10, AddToSearchList = 11, DeleteFromSearchList = 12, ShowEdgeUI = 13, ShowPanel = 14, HideEdgeUI = 15, HidePanel = 16, ShowPopup = 17, HidePopup = 18, PointerDown = 19, PointerUp = 20, DragSourceStart = 21, DragSourceEnd = 22, TransitionContent = 23, Reveal = 24, Hide = 25, DragBetweenEnter = 26, DragBetweenLeave = 27, SwipeSelect = 28, SwipeDeselect = 29, SwipeReveal = 30, EnterPage = 31, TransitionPage = 32, CrossFade = 33, Peek = 34, UpdateBadge = 35,
}}
RT_ENUM! { enum AnimationEffectTarget: i32 {
    Primary = 0, Added = 1, Affected = 2, Background = 3, Content = 4, Deleted = 5, Deselected = 6, DragSource = 7, Hidden = 8, Incoming = 9, Outgoing = 10, Outline = 11, Remaining = 12, Revealed = 13, RowIn = 14, RowOut = 15, Selected = 16, Selection = 17, Shown = 18, Tapped = 19,
}}
DEFINE_IID!(IID_IOpacityAnimation, 2151328741, 61054, 17759, 132, 233, 37, 6, 175, 184, 210, 180);
RT_INTERFACE!{interface IOpacityAnimation(IOpacityAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IOpacityAnimation] {
    fn get_InitialOpacity(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn get_FinalOpacity(&self, out: *mut f32) -> HRESULT
}}
impl IOpacityAnimation {
    #[inline] pub fn get_initial_opacity(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialOpacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_final_opacity(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FinalOpacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class OpacityAnimation: IOpacityAnimation}
DEFINE_IID!(IID_IPropertyAnimation, 973190362, 19852, 16670, 182, 21, 26, 222, 104, 58, 153, 3);
RT_INTERFACE!{interface IPropertyAnimation(IPropertyAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IPropertyAnimation] {
    fn get_Type(&self, out: *mut PropertyAnimationType) -> HRESULT,
    fn get_Delay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Control1(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Control2(&self, out: *mut foundation::Point) -> HRESULT
}}
impl IPropertyAnimation {
    #[inline] pub fn get_type(&self) -> Result<PropertyAnimationType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Delay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control1(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Control1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control2(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Control2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PropertyAnimation: IPropertyAnimation}
RT_ENUM! { enum PropertyAnimationType: i32 {
    Scale = 0, Translation = 1, Opacity = 2,
}}
DEFINE_IID!(IID_IScaleAnimation, 37049031, 29099, 17036, 156, 159, 211, 23, 128, 150, 73, 149);
RT_INTERFACE!{interface IScaleAnimation(IScaleAnimationVtbl): IInspectable(IInspectableVtbl) [IID_IScaleAnimation] {
    fn get_InitialScaleX(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn get_InitialScaleY(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT,
    fn get_FinalScaleX(&self, out: *mut f32) -> HRESULT,
    fn get_FinalScaleY(&self, out: *mut f32) -> HRESULT,
    fn get_NormalizedOrigin(&self, out: *mut foundation::Point) -> HRESULT
}}
impl IScaleAnimation {
    #[inline] pub fn get_initial_scale_x(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialScaleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_initial_scale_y(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InitialScaleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_final_scale_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FinalScaleX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_final_scale_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FinalScaleY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_normalized_origin(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NormalizedOrigin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ScaleAnimation: IScaleAnimation}
RT_CLASS!{class TranslationAnimation: IPropertyAnimation}
} // Windows.UI.Core.AnimationMetrics
pub mod preview { // Windows.UI.Core.Preview
use crate::prelude::*;
DEFINE_IID!(IID_ISystemNavigationCloseRequestedPreviewEventArgs, 2211450337, 52197, 20273, 132, 20, 54, 29, 160, 70, 81, 143);
RT_INTERFACE!{interface ISystemNavigationCloseRequestedPreviewEventArgs(ISystemNavigationCloseRequestedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISystemNavigationCloseRequestedPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ISystemNavigationCloseRequestedPreviewEventArgs {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemNavigationCloseRequestedPreviewEventArgs: ISystemNavigationCloseRequestedPreviewEventArgs}
DEFINE_IID!(IID_ISystemNavigationManagerPreview, 3965650056, 25637, 18295, 165, 54, 203, 86, 52, 66, 127, 13);
RT_INTERFACE!{interface ISystemNavigationManagerPreview(ISystemNavigationManagerPreviewVtbl): IInspectable(IInspectableVtbl) [IID_ISystemNavigationManagerPreview] {
    fn add_CloseRequested(&self, handler: *mut foundation::EventHandler<SystemNavigationCloseRequestedPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CloseRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISystemNavigationManagerPreview {
    #[inline] pub fn add_close_requested(&self, handler: &foundation::EventHandler<SystemNavigationCloseRequestedPreviewEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CloseRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_close_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CloseRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SystemNavigationManagerPreview: ISystemNavigationManagerPreview}
impl RtActivatable<ISystemNavigationManagerPreviewStatics> for SystemNavigationManagerPreview {}
impl SystemNavigationManagerPreview {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<SystemNavigationManagerPreview>>> {
        <Self as RtActivatable<ISystemNavigationManagerPreviewStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(SystemNavigationManagerPreview(&[87,105,110,100,111,119,115,46,85,73,46,67,111,114,101,46,80,114,101,118,105,101,119,46,83,121,115,116,101,109,78,97,118,105,103,97,116,105,111,110,77,97,110,97,103,101,114,80,114,101,118,105,101,119,0]) [CLSID_SystemNavigationManagerPreview]);
DEFINE_IID!(IID_ISystemNavigationManagerPreviewStatics, 244781920, 57204, 19406, 132, 203, 189, 17, 129, 172, 10, 113);
RT_INTERFACE!{static interface ISystemNavigationManagerPreviewStatics(ISystemNavigationManagerPreviewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISystemNavigationManagerPreviewStatics] {
    fn GetForCurrentView(&self, out: *mut *mut SystemNavigationManagerPreview) -> HRESULT
}}
impl ISystemNavigationManagerPreviewStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<SystemNavigationManagerPreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Core.Preview
} // Windows.UI.Core
pub mod input { // Windows.UI.Input
use crate::prelude::*;
RT_STRUCT! { struct CrossSlideThresholds {
    SelectionStart: f32, SpeedBumpStart: f32, SpeedBumpEnd: f32, RearrangeStart: f32,
}}
DEFINE_IID!(IID_ICrossSlidingEventArgs, 3912714040, 28552, 16857, 135, 32, 120, 224, 142, 57, 131, 73);
RT_INTERFACE!{interface ICrossSlidingEventArgs(ICrossSlidingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICrossSlidingEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_CrossSlidingState(&self, out: *mut CrossSlidingState) -> HRESULT
}}
impl ICrossSlidingEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cross_sliding_state(&self) -> Result<CrossSlidingState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CrossSlidingState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CrossSlidingEventArgs: ICrossSlidingEventArgs}
RT_ENUM! { enum CrossSlidingState: i32 {
    Started = 0, Dragging = 1, Selecting = 2, SelectSpeedBumping = 3, SpeedBumping = 4, Rearranging = 5, Completed = 6,
}}
DEFINE_IID!(IID_IDraggingEventArgs, 479220612, 2108, 19411, 181, 89, 23, 156, 221, 235, 51, 236);
RT_INTERFACE!{interface IDraggingEventArgs(IDraggingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDraggingEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_DraggingState(&self, out: *mut DraggingState) -> HRESULT
}}
impl IDraggingEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dragging_state(&self) -> Result<DraggingState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DraggingState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DraggingEventArgs: IDraggingEventArgs}
RT_ENUM! { enum DraggingState: i32 {
    Started = 0, Continuing = 1, Completed = 2,
}}
DEFINE_IID!(IID_IEdgeGesture, 1477268114, 10929, 18858, 167, 240, 51, 189, 63, 141, 249, 241);
RT_INTERFACE!{interface IEdgeGesture(IEdgeGestureVtbl): IInspectable(IInspectableVtbl) [IID_IEdgeGesture] {
    fn add_Starting(&self, handler: *mut foundation::TypedEventHandler<EdgeGesture, EdgeGestureEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Starting(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Completed(&self, handler: *mut foundation::TypedEventHandler<EdgeGesture, EdgeGestureEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Canceled(&self, handler: *mut foundation::TypedEventHandler<EdgeGesture, EdgeGestureEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Canceled(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IEdgeGesture {
    #[inline] pub fn add_starting(&self, handler: &foundation::TypedEventHandler<EdgeGesture, EdgeGestureEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Starting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_starting(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Starting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_completed(&self, handler: &foundation::TypedEventHandler<EdgeGesture, EdgeGestureEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_canceled(&self, handler: &foundation::TypedEventHandler<EdgeGesture, EdgeGestureEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Canceled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_canceled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Canceled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class EdgeGesture: IEdgeGesture}
impl RtActivatable<IEdgeGestureStatics> for EdgeGesture {}
impl EdgeGesture {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<EdgeGesture>>> {
        <Self as RtActivatable<IEdgeGestureStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(EdgeGesture(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,69,100,103,101,71,101,115,116,117,114,101,0]) [CLSID_EdgeGesture]);
DEFINE_IID!(IID_IEdgeGestureEventArgs, 1157253668, 11529, 17121, 139, 94, 54, 130, 8, 121, 106, 76);
RT_INTERFACE!{interface IEdgeGestureEventArgs(IEdgeGestureEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEdgeGestureEventArgs] {
    fn get_Kind(&self, out: *mut EdgeGestureKind) -> HRESULT
}}
impl IEdgeGestureEventArgs {
    #[inline] pub fn get_kind(&self) -> Result<EdgeGestureKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EdgeGestureEventArgs: IEdgeGestureEventArgs}
RT_ENUM! { enum EdgeGestureKind: i32 {
    Touch = 0, Keyboard = 1, Mouse = 2,
}}
DEFINE_IID!(IID_IEdgeGestureStatics, 3161097497, 6382, 16451, 152, 57, 79, 197, 132, 214, 10, 20);
RT_INTERFACE!{static interface IEdgeGestureStatics(IEdgeGestureStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEdgeGestureStatics] {
    fn GetForCurrentView(&self, out: *mut *mut EdgeGesture) -> HRESULT
}}
impl IEdgeGestureStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<EdgeGesture>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGestureRecognizer, 3027908543, 15723, 20360, 131, 232, 109, 203, 64, 18, 255, 176);
RT_INTERFACE!{interface IGestureRecognizer(IGestureRecognizerVtbl): IInspectable(IInspectableVtbl) [IID_IGestureRecognizer] {
    fn get_GestureSettings(&self, out: *mut GestureSettings) -> HRESULT,
    fn put_GestureSettings(&self, value: GestureSettings) -> HRESULT,
    fn get_IsInertial(&self, out: *mut bool) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_ShowGestureFeedback(&self, out: *mut bool) -> HRESULT,
    fn put_ShowGestureFeedback(&self, value: bool) -> HRESULT,
    fn get_PivotCenter(&self, out: *mut foundation::Point) -> HRESULT,
    fn put_PivotCenter(&self, value: foundation::Point) -> HRESULT,
    fn get_PivotRadius(&self, out: *mut f32) -> HRESULT,
    fn put_PivotRadius(&self, value: f32) -> HRESULT,
    fn get_InertiaTranslationDeceleration(&self, out: *mut f32) -> HRESULT,
    fn put_InertiaTranslationDeceleration(&self, value: f32) -> HRESULT,
    fn get_InertiaRotationDeceleration(&self, out: *mut f32) -> HRESULT,
    fn put_InertiaRotationDeceleration(&self, value: f32) -> HRESULT,
    fn get_InertiaExpansionDeceleration(&self, out: *mut f32) -> HRESULT,
    fn put_InertiaExpansionDeceleration(&self, value: f32) -> HRESULT,
    fn get_InertiaTranslationDisplacement(&self, out: *mut f32) -> HRESULT,
    fn put_InertiaTranslationDisplacement(&self, value: f32) -> HRESULT,
    fn get_InertiaRotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_InertiaRotationAngle(&self, value: f32) -> HRESULT,
    fn get_InertiaExpansion(&self, out: *mut f32) -> HRESULT,
    fn put_InertiaExpansion(&self, value: f32) -> HRESULT,
    fn get_ManipulationExact(&self, out: *mut bool) -> HRESULT,
    fn put_ManipulationExact(&self, value: bool) -> HRESULT,
    fn get_CrossSlideThresholds(&self, out: *mut CrossSlideThresholds) -> HRESULT,
    fn put_CrossSlideThresholds(&self, value: CrossSlideThresholds) -> HRESULT,
    fn get_CrossSlideHorizontally(&self, out: *mut bool) -> HRESULT,
    fn put_CrossSlideHorizontally(&self, value: bool) -> HRESULT,
    fn get_CrossSlideExact(&self, out: *mut bool) -> HRESULT,
    fn put_CrossSlideExact(&self, value: bool) -> HRESULT,
    fn get_AutoProcessInertia(&self, out: *mut bool) -> HRESULT,
    fn put_AutoProcessInertia(&self, value: bool) -> HRESULT,
    fn get_MouseWheelParameters(&self, out: *mut *mut MouseWheelParameters) -> HRESULT,
    fn CanBeDoubleTap(&self, value: *mut PointerPoint, out: *mut bool) -> HRESULT,
    fn ProcessDownEvent(&self, value: *mut PointerPoint) -> HRESULT,
    fn ProcessMoveEvents(&self, value: *mut foundation::collections::IVector<PointerPoint>) -> HRESULT,
    fn ProcessUpEvent(&self, value: *mut PointerPoint) -> HRESULT,
    fn ProcessMouseWheelEvent(&self, value: *mut PointerPoint, isShiftKeyDown: bool, isControlKeyDown: bool) -> HRESULT,
    fn ProcessInertia(&self) -> HRESULT,
    fn CompleteGesture(&self) -> HRESULT,
    fn add_Tapped(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, TappedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Tapped(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RightTapped(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, RightTappedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RightTapped(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Holding(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, HoldingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Holding(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Dragging(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, DraggingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Dragging(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationStarted(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, ManipulationStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationStarted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationUpdated(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, ManipulationUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationUpdated(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationInertiaStarting(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, ManipulationInertiaStartingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationInertiaStarting(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationCompleted(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, ManipulationCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationCompleted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CrossSliding(&self, handler: *mut foundation::TypedEventHandler<GestureRecognizer, CrossSlidingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CrossSliding(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IGestureRecognizer {
    #[inline] pub fn get_gesture_settings(&self) -> Result<GestureSettings> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GestureSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_gesture_settings(&self, value: GestureSettings) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_GestureSettings)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_inertial(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInertial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_show_gesture_feedback(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowGestureFeedback)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_show_gesture_feedback(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShowGestureFeedback)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pivot_center(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PivotCenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pivot_center(&self, value: foundation::Point) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PivotCenter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pivot_radius(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PivotRadius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pivot_radius(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PivotRadius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inertia_translation_deceleration(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InertiaTranslationDeceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inertia_translation_deceleration(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InertiaTranslationDeceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inertia_rotation_deceleration(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InertiaRotationDeceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inertia_rotation_deceleration(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InertiaRotationDeceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inertia_expansion_deceleration(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InertiaExpansionDeceleration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inertia_expansion_deceleration(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InertiaExpansionDeceleration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inertia_translation_displacement(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InertiaTranslationDisplacement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inertia_translation_displacement(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InertiaTranslationDisplacement)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inertia_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InertiaRotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inertia_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InertiaRotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inertia_expansion(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InertiaExpansion)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inertia_expansion(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InertiaExpansion)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_manipulation_exact(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ManipulationExact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_manipulation_exact(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ManipulationExact)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cross_slide_thresholds(&self) -> Result<CrossSlideThresholds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CrossSlideThresholds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cross_slide_thresholds(&self, value: CrossSlideThresholds) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CrossSlideThresholds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cross_slide_horizontally(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CrossSlideHorizontally)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cross_slide_horizontally(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CrossSlideHorizontally)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cross_slide_exact(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CrossSlideExact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cross_slide_exact(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CrossSlideExact)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_process_inertia(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoProcessInertia)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_process_inertia(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AutoProcessInertia)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mouse_wheel_parameters(&self) -> Result<Option<ComPtr<MouseWheelParameters>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MouseWheelParameters)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_be_double_tap(&self, value: &PointerPoint) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanBeDoubleTap)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn process_down_event(&self, value: &PointerPoint) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessDownEvent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_move_events(&self, value: &foundation::collections::IVector<PointerPoint>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessMoveEvents)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_up_event(&self, value: &PointerPoint) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessUpEvent)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_mouse_wheel_event(&self, value: &PointerPoint, isShiftKeyDown: bool, isControlKeyDown: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessMouseWheelEvent)(self as *const _ as *mut _, value as *const _ as *mut _, isShiftKeyDown, isControlKeyDown);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_inertia(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessInertia)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn complete_gesture(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).CompleteGesture)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_tapped(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, TappedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Tapped)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_tapped(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Tapped)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_right_tapped(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, RightTappedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RightTapped)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_right_tapped(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_RightTapped)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_holding(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, HoldingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Holding)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_holding(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Holding)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_dragging(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, DraggingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Dragging)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_dragging(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Dragging)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_started(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, ManipulationStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_started(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationStarted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_updated(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, ManipulationUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationUpdated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_updated(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationUpdated)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_inertia_starting(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, ManipulationInertiaStartingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationInertiaStarting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_inertia_starting(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationInertiaStarting)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_completed(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, ManipulationCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_completed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationCompleted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_cross_sliding(&self, handler: &foundation::TypedEventHandler<GestureRecognizer, CrossSlidingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CrossSliding)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_cross_sliding(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CrossSliding)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GestureRecognizer: IGestureRecognizer}
impl RtActivatable<IActivationFactory> for GestureRecognizer {}
DEFINE_CLSID!(GestureRecognizer(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,71,101,115,116,117,114,101,82,101,99,111,103,110,105,122,101,114,0]) [CLSID_GestureRecognizer]);
RT_ENUM! { enum GestureSettings: u32 {
    None = 0, Tap = 1, DoubleTap = 2, Hold = 4, HoldWithMouse = 8, RightTap = 16, Drag = 32, ManipulationTranslateX = 64, ManipulationTranslateY = 128, ManipulationTranslateRailsX = 256, ManipulationTranslateRailsY = 512, ManipulationRotate = 1024, ManipulationScale = 2048, ManipulationTranslateInertia = 4096, ManipulationRotateInertia = 8192, ManipulationScaleInertia = 16384, CrossSlide = 32768, ManipulationMultipleFingerPanning = 65536,
}}
DEFINE_IID!(IID_IHoldingEventArgs, 737629637, 59289, 16820, 187, 64, 36, 47, 64, 149, 155, 113);
RT_INTERFACE!{interface IHoldingEventArgs(IHoldingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHoldingEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_HoldingState(&self, out: *mut HoldingState) -> HRESULT
}}
impl IHoldingEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_holding_state(&self) -> Result<HoldingState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HoldingState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class HoldingEventArgs: IHoldingEventArgs}
RT_ENUM! { enum HoldingState: i32 {
    Started = 0, Completed = 1, Canceled = 2,
}}
DEFINE_IID!(IID_IKeyboardDeliveryInterceptor, 3032150120, 36681, 17516, 141, 181, 140, 15, 254, 133, 204, 158);
RT_INTERFACE!{interface IKeyboardDeliveryInterceptor(IKeyboardDeliveryInterceptorVtbl): IInspectable(IInspectableVtbl) [IID_IKeyboardDeliveryInterceptor] {
    fn get_IsInterceptionEnabledWhenInForeground(&self, out: *mut bool) -> HRESULT,
    fn put_IsInterceptionEnabledWhenInForeground(&self, value: bool) -> HRESULT,
    fn add_KeyDown(&self, handler: *mut foundation::TypedEventHandler<KeyboardDeliveryInterceptor, super::core::KeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyDown(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_KeyUp(&self, handler: *mut foundation::TypedEventHandler<KeyboardDeliveryInterceptor, super::core::KeyEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_KeyUp(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IKeyboardDeliveryInterceptor {
    #[inline] pub fn get_is_interception_enabled_when_in_foreground(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInterceptionEnabledWhenInForeground)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_interception_enabled_when_in_foreground(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInterceptionEnabledWhenInForeground)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_key_down(&self, handler: &foundation::TypedEventHandler<KeyboardDeliveryInterceptor, super::core::KeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyDown)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_key_down(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_KeyDown)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_key_up(&self, handler: &foundation::TypedEventHandler<KeyboardDeliveryInterceptor, super::core::KeyEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_KeyUp)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_key_up(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_KeyUp)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class KeyboardDeliveryInterceptor: IKeyboardDeliveryInterceptor}
impl RtActivatable<IKeyboardDeliveryInterceptorStatics> for KeyboardDeliveryInterceptor {}
impl KeyboardDeliveryInterceptor {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<KeyboardDeliveryInterceptor>>> {
        <Self as RtActivatable<IKeyboardDeliveryInterceptorStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(KeyboardDeliveryInterceptor(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,75,101,121,98,111,97,114,100,68,101,108,105,118,101,114,121,73,110,116,101,114,99,101,112,116,111,114,0]) [CLSID_KeyboardDeliveryInterceptor]);
DEFINE_IID!(IID_IKeyboardDeliveryInterceptorStatics, 4193663906, 52922, 18261, 138, 126, 20, 192, 255, 236, 210, 57);
RT_INTERFACE!{static interface IKeyboardDeliveryInterceptorStatics(IKeyboardDeliveryInterceptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKeyboardDeliveryInterceptorStatics] {
    fn GetForCurrentView(&self, out: *mut *mut KeyboardDeliveryInterceptor) -> HRESULT
}}
impl IKeyboardDeliveryInterceptorStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<KeyboardDeliveryInterceptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IManipulationCompletedEventArgs, 3008016939, 53659, 18175, 159, 56, 222, 199, 117, 75, 185, 231);
RT_INTERFACE!{interface IManipulationCompletedEventArgs(IManipulationCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationCompletedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Cumulative(&self, out: *mut ManipulationDelta) -> HRESULT,
    fn get_Velocities(&self, out: *mut ManipulationVelocities) -> HRESULT
}}
impl IManipulationCompletedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative(&self) -> Result<ManipulationDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocities(&self) -> Result<ManipulationVelocities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Velocities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ManipulationCompletedEventArgs: IManipulationCompletedEventArgs}
RT_STRUCT! { struct ManipulationDelta {
    Translation: foundation::Point, Scale: f32, Rotation: f32, Expansion: f32,
}}
DEFINE_IID!(IID_IManipulationInertiaStartingEventArgs, 3711412376, 9919, 18042, 156, 229, 204, 243, 251, 17, 55, 30);
RT_INTERFACE!{interface IManipulationInertiaStartingEventArgs(IManipulationInertiaStartingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationInertiaStartingEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Delta(&self, out: *mut ManipulationDelta) -> HRESULT,
    fn get_Cumulative(&self, out: *mut ManipulationDelta) -> HRESULT,
    fn get_Velocities(&self, out: *mut ManipulationVelocities) -> HRESULT
}}
impl IManipulationInertiaStartingEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_delta(&self) -> Result<ManipulationDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Delta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative(&self) -> Result<ManipulationDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocities(&self) -> Result<ManipulationVelocities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Velocities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ManipulationInertiaStartingEventArgs: IManipulationInertiaStartingEventArgs}
DEFINE_IID!(IID_IManipulationStartedEventArgs, 3723265854, 53198, 18738, 140, 29, 60, 61, 1, 26, 52, 192);
RT_INTERFACE!{interface IManipulationStartedEventArgs(IManipulationStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationStartedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Cumulative(&self, out: *mut ManipulationDelta) -> HRESULT
}}
impl IManipulationStartedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative(&self) -> Result<ManipulationDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ManipulationStartedEventArgs: IManipulationStartedEventArgs}
DEFINE_IID!(IID_IManipulationUpdatedEventArgs, 3409267941, 43960, 20383, 179, 206, 129, 129, 170, 97, 173, 130);
RT_INTERFACE!{interface IManipulationUpdatedEventArgs(IManipulationUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IManipulationUpdatedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Delta(&self, out: *mut ManipulationDelta) -> HRESULT,
    fn get_Cumulative(&self, out: *mut ManipulationDelta) -> HRESULT,
    fn get_Velocities(&self, out: *mut ManipulationVelocities) -> HRESULT
}}
impl IManipulationUpdatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_delta(&self) -> Result<ManipulationDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Delta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative(&self) -> Result<ManipulationDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cumulative)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocities(&self) -> Result<ManipulationVelocities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Velocities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ManipulationUpdatedEventArgs: IManipulationUpdatedEventArgs}
RT_STRUCT! { struct ManipulationVelocities {
    Linear: foundation::Point, Angular: f32, Expansion: f32,
}}
DEFINE_IID!(IID_IMouseWheelParameters, 3939551812, 40429, 16439, 129, 73, 94, 76, 194, 86, 68, 104);
RT_INTERFACE!{interface IMouseWheelParameters(IMouseWheelParametersVtbl): IInspectable(IInspectableVtbl) [IID_IMouseWheelParameters] {
    fn get_CharTranslation(&self, out: *mut foundation::Point) -> HRESULT,
    fn put_CharTranslation(&self, value: foundation::Point) -> HRESULT,
    fn get_DeltaScale(&self, out: *mut f32) -> HRESULT,
    fn put_DeltaScale(&self, value: f32) -> HRESULT,
    fn get_DeltaRotationAngle(&self, out: *mut f32) -> HRESULT,
    fn put_DeltaRotationAngle(&self, value: f32) -> HRESULT,
    fn get_PageTranslation(&self, out: *mut foundation::Point) -> HRESULT,
    fn put_PageTranslation(&self, value: foundation::Point) -> HRESULT
}}
impl IMouseWheelParameters {
    #[inline] pub fn get_char_translation(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CharTranslation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_char_translation(&self, value: foundation::Point) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CharTranslation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delta_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeltaScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delta_scale(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DeltaScale)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delta_rotation_angle(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeltaRotationAngle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delta_rotation_angle(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DeltaRotationAngle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_page_translation(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PageTranslation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_page_translation(&self, value: foundation::Point) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PageTranslation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseWheelParameters: IMouseWheelParameters}
DEFINE_IID!(IID_IPointerPoint, 3918868861, 29334, 17113, 130, 51, 197, 190, 115, 183, 74, 74);
RT_INTERFACE!{interface IPointerPoint(IPointerPointVtbl): IInspectable(IInspectableVtbl) [IID_IPointerPoint] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDevice(&self, out: *mut *mut super::super::devices::input::PointerDevice) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_RawPosition(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_PointerId(&self, out: *mut u32) -> HRESULT,
    fn get_FrameId(&self, out: *mut u32) -> HRESULT,
    fn get_Timestamp(&self, out: *mut u64) -> HRESULT,
    fn get_IsInContact(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut PointerPointProperties) -> HRESULT
}}
impl IPointerPoint {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device(&self) -> Result<Option<ComPtr<super::super::devices::input::PointerDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PointerDevice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RawPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FrameId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_in_contact(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInContact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<PointerPointProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PointerPoint: IPointerPoint}
impl RtActivatable<IPointerPointStatics> for PointerPoint {}
impl PointerPoint {
    #[inline] pub fn get_current_point(pointerId: u32) -> Result<Option<ComPtr<PointerPoint>>> {
        <Self as RtActivatable<IPointerPointStatics>>::get_activation_factory().get_current_point(pointerId)
    }
    #[inline] pub fn get_intermediate_points(pointerId: u32) -> Result<Option<ComPtr<foundation::collections::IVector<PointerPoint>>>> {
        <Self as RtActivatable<IPointerPointStatics>>::get_activation_factory().get_intermediate_points(pointerId)
    }
    #[inline] pub fn get_current_point_transformed(pointerId: u32, transform: &IPointerPointTransform) -> Result<Option<ComPtr<PointerPoint>>> {
        <Self as RtActivatable<IPointerPointStatics>>::get_activation_factory().get_current_point_transformed(pointerId, transform)
    }
    #[inline] pub fn get_intermediate_points_transformed(pointerId: u32, transform: &IPointerPointTransform) -> Result<Option<ComPtr<foundation::collections::IVector<PointerPoint>>>> {
        <Self as RtActivatable<IPointerPointStatics>>::get_activation_factory().get_intermediate_points_transformed(pointerId, transform)
    }
}
DEFINE_CLSID!(PointerPoint(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,111,105,110,116,101,114,80,111,105,110,116,0]) [CLSID_PointerPoint]);
DEFINE_IID!(IID_IPointerPointProperties, 3348990539, 49507, 20199, 128, 63, 103, 206, 121, 249, 151, 45);
RT_INTERFACE!{interface IPointerPointProperties(IPointerPointPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_IPointerPointProperties] {
    fn get_Pressure(&self, out: *mut f32) -> HRESULT,
    fn get_IsInverted(&self, out: *mut bool) -> HRESULT,
    fn get_IsEraser(&self, out: *mut bool) -> HRESULT,
    fn get_Orientation(&self, out: *mut f32) -> HRESULT,
    fn get_XTilt(&self, out: *mut f32) -> HRESULT,
    fn get_YTilt(&self, out: *mut f32) -> HRESULT,
    fn get_Twist(&self, out: *mut f32) -> HRESULT,
    fn get_ContactRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_ContactRectRaw(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_TouchConfidence(&self, out: *mut bool) -> HRESULT,
    fn get_IsLeftButtonPressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsRightButtonPressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsMiddleButtonPressed(&self, out: *mut bool) -> HRESULT,
    fn get_MouseWheelDelta(&self, out: *mut i32) -> HRESULT,
    fn get_IsHorizontalMouseWheel(&self, out: *mut bool) -> HRESULT,
    fn get_IsPrimary(&self, out: *mut bool) -> HRESULT,
    fn get_IsInRange(&self, out: *mut bool) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn get_IsBarrelButtonPressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsXButton1Pressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsXButton2Pressed(&self, out: *mut bool) -> HRESULT,
    fn get_PointerUpdateKind(&self, out: *mut PointerUpdateKind) -> HRESULT,
    fn HasUsage(&self, usagePage: u32, usageId: u32, out: *mut bool) -> HRESULT,
    fn GetUsageValue(&self, usagePage: u32, usageId: u32, out: *mut i32) -> HRESULT
}}
impl IPointerPointProperties {
    #[inline] pub fn get_pressure(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pressure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_inverted(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInverted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_eraser(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEraser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_x_tilt(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_XTilt)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_y_tilt(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_YTilt)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_twist(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Twist)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContactRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contact_rect_raw(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContactRectRaw)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_touch_confidence(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TouchConfidence)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_left_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsLeftButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_right_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRightButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_middle_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMiddleButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mouse_wheel_delta(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MouseWheelDelta)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_horizontal_mouse_wheel(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHorizontalMouseWheel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_primary(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPrimary)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_in_range(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInRange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_barrel_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsBarrelButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_x_button1_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsXButton1Pressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_x_button2_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsXButton2Pressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_update_kind(&self) -> Result<PointerUpdateKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerUpdateKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn has_usage(&self, usagePage: u32, usageId: u32) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HasUsage)(self as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_value(&self, usagePage: u32, usageId: u32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetUsageValue)(self as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PointerPointProperties: IPointerPointProperties}
DEFINE_IID!(IID_IPointerPointProperties2, 583222074, 51259, 16832, 162, 150, 94, 35, 45, 100, 214, 175);
RT_INTERFACE!{interface IPointerPointProperties2(IPointerPointProperties2Vtbl): IInspectable(IInspectableVtbl) [IID_IPointerPointProperties2] {
    fn get_ZDistance(&self, out: *mut *mut foundation::IReference<f32>) -> HRESULT
}}
impl IPointerPointProperties2 {
    #[inline] pub fn get_z_distance(&self) -> Result<Option<ComPtr<foundation::IReference<f32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ZDistance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPointerPointStatics, 2768659341, 10778, 16702, 188, 117, 159, 56, 56, 28, 192, 105);
RT_INTERFACE!{static interface IPointerPointStatics(IPointerPointStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerPointStatics] {
    fn GetCurrentPoint(&self, pointerId: u32, out: *mut *mut PointerPoint) -> HRESULT,
    fn GetIntermediatePoints(&self, pointerId: u32, out: *mut *mut foundation::collections::IVector<PointerPoint>) -> HRESULT,
    fn GetCurrentPointTransformed(&self, pointerId: u32, transform: *mut IPointerPointTransform, out: *mut *mut PointerPoint) -> HRESULT,
    fn GetIntermediatePointsTransformed(&self, pointerId: u32, transform: *mut IPointerPointTransform, out: *mut *mut foundation::collections::IVector<PointerPoint>) -> HRESULT
}}
impl IPointerPointStatics {
    #[inline] pub fn get_current_point(&self, pointerId: u32) -> Result<Option<ComPtr<PointerPoint>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentPoint)(self as *const _ as *mut _, pointerId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_points(&self, pointerId: u32) -> Result<Option<ComPtr<foundation::collections::IVector<PointerPoint>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIntermediatePoints)(self as *const _ as *mut _, pointerId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point_transformed(&self, pointerId: u32, transform: &IPointerPointTransform) -> Result<Option<ComPtr<PointerPoint>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentPointTransformed)(self as *const _ as *mut _, pointerId, transform as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_points_transformed(&self, pointerId: u32, transform: &IPointerPointTransform) -> Result<Option<ComPtr<foundation::collections::IVector<PointerPoint>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIntermediatePointsTransformed)(self as *const _ as *mut _, pointerId, transform as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPointerPointTransform, 1298129231, 47228, 16424, 188, 156, 89, 233, 148, 127, 176, 86);
RT_INTERFACE!{interface IPointerPointTransform(IPointerPointTransformVtbl): IInspectable(IInspectableVtbl) [IID_IPointerPointTransform] {
    fn get_Inverse(&self, out: *mut *mut IPointerPointTransform) -> HRESULT,
    fn TryTransform(&self, inPoint: foundation::Point, outPoint: *mut foundation::Point, out: *mut bool) -> HRESULT,
    fn TransformBounds(&self, rect: foundation::Rect, out: *mut foundation::Rect) -> HRESULT
}}
impl IPointerPointTransform {
    #[inline] pub fn get_inverse(&self) -> Result<Option<ComPtr<IPointerPointTransform>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Inverse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_transform(&self, inPoint: foundation::Point) -> Result<(foundation::Point, bool)> { unsafe { 
        let mut outPoint = zeroed(); let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryTransform)(self as *const _ as *mut _, inPoint, &mut outPoint, &mut out);
        if hr == S_OK { Ok((outPoint, out)) } else { err(hr) }
    }}
    #[inline] pub fn transform_bounds(&self, rect: foundation::Rect) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TransformBounds)(self as *const _ as *mut _, rect, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum PointerUpdateKind: i32 {
    Other = 0, LeftButtonPressed = 1, LeftButtonReleased = 2, RightButtonPressed = 3, RightButtonReleased = 4, MiddleButtonPressed = 5, MiddleButtonReleased = 6, XButton1Pressed = 7, XButton1Released = 8, XButton2Pressed = 9, XButton2Released = 10,
}}
DEFINE_IID!(IID_IPointerVisualizationSettings, 1293837409, 34039, 18845, 189, 145, 42, 54, 226, 183, 170, 162);
RT_INTERFACE!{interface IPointerVisualizationSettings(IPointerVisualizationSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerVisualizationSettings] {
    fn put_IsContactFeedbackEnabled(&self, value: bool) -> HRESULT,
    fn get_IsContactFeedbackEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsBarrelButtonFeedbackEnabled(&self, value: bool) -> HRESULT,
    fn get_IsBarrelButtonFeedbackEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IPointerVisualizationSettings {
    #[inline] pub fn set_is_contact_feedback_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsContactFeedbackEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_contact_feedback_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContactFeedbackEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_barrel_button_feedback_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsBarrelButtonFeedbackEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_barrel_button_feedback_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsBarrelButtonFeedbackEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PointerVisualizationSettings: IPointerVisualizationSettings}
impl RtActivatable<IPointerVisualizationSettingsStatics> for PointerVisualizationSettings {}
impl PointerVisualizationSettings {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<PointerVisualizationSettings>>> {
        <Self as RtActivatable<IPointerVisualizationSettingsStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(PointerVisualizationSettings(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,111,105,110,116,101,114,86,105,115,117,97,108,105,122,97,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_PointerVisualizationSettings]);
DEFINE_IID!(IID_IPointerVisualizationSettingsStatics, 1753681627, 5723, 16916, 180, 243, 88, 78, 202, 140, 138, 105);
RT_INTERFACE!{static interface IPointerVisualizationSettingsStatics(IPointerVisualizationSettingsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerVisualizationSettingsStatics] {
    fn GetForCurrentView(&self, out: *mut *mut PointerVisualizationSettings) -> HRESULT
}}
impl IPointerVisualizationSettingsStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<PointerVisualizationSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialController, 810930632, 57169, 17364, 178, 59, 14, 16, 55, 70, 122, 9);
RT_INTERFACE!{interface IRadialController(IRadialControllerVtbl): IInspectable(IInspectableVtbl) [IID_IRadialController] {
    fn get_Menu(&self, out: *mut *mut RadialControllerMenu) -> HRESULT,
    fn get_RotationResolutionInDegrees(&self, out: *mut f64) -> HRESULT,
    fn put_RotationResolutionInDegrees(&self, value: f64) -> HRESULT,
    fn get_UseAutomaticHapticFeedback(&self, out: *mut bool) -> HRESULT,
    fn put_UseAutomaticHapticFeedback(&self, value: bool) -> HRESULT,
    fn add_ScreenContactStarted(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerScreenContactStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScreenContactStarted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ScreenContactEnded(&self, handler: *mut foundation::TypedEventHandler<RadialController, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScreenContactEnded(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ScreenContactContinued(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerScreenContactContinuedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScreenContactContinued(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ControlLost(&self, handler: *mut foundation::TypedEventHandler<RadialController, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ControlLost(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RotationChanged(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerRotationChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RotationChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ButtonClicked(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerButtonClickedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ButtonClicked(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ControlAcquired(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerControlAcquiredEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ControlAcquired(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRadialController {
    #[inline] pub fn get_menu(&self) -> Result<Option<ComPtr<RadialControllerMenu>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Menu)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_resolution_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationResolutionInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation_resolution_in_degrees(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RotationResolutionInDegrees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_use_automatic_haptic_feedback(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UseAutomaticHapticFeedback)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_use_automatic_haptic_feedback(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_UseAutomaticHapticFeedback)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_screen_contact_started(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerScreenContactStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ScreenContactStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_screen_contact_started(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ScreenContactStarted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_screen_contact_ended(&self, handler: &foundation::TypedEventHandler<RadialController, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ScreenContactEnded)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_screen_contact_ended(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ScreenContactEnded)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_screen_contact_continued(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerScreenContactContinuedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ScreenContactContinued)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_screen_contact_continued(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ScreenContactContinued)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_control_lost(&self, handler: &foundation::TypedEventHandler<RadialController, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ControlLost)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_control_lost(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ControlLost)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_rotation_changed(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerRotationChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RotationChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_rotation_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_RotationChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_button_clicked(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerButtonClickedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ButtonClicked)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_button_clicked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ButtonClicked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_control_acquired(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerControlAcquiredEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ControlAcquired)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_control_acquired(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ControlAcquired)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialController: IRadialController}
impl RtActivatable<IRadialControllerStatics> for RadialController {}
impl RadialController {
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<IRadialControllerStatics>>::get_activation_factory().is_supported()
    }
    #[inline] pub fn create_for_current_view() -> Result<Option<ComPtr<RadialController>>> {
        <Self as RtActivatable<IRadialControllerStatics>>::get_activation_factory().create_for_current_view()
    }
}
DEFINE_CLSID!(RadialController(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,82,97,100,105,97,108,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_RadialController]);
DEFINE_IID!(IID_IRadialController2, 1029144319, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialController2(IRadialController2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialController2] {
    fn add_ButtonPressed(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerButtonPressedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ButtonPressed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ButtonHolding(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerButtonHoldingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ButtonHolding(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ButtonReleased(&self, handler: *mut foundation::TypedEventHandler<RadialController, RadialControllerButtonReleasedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ButtonReleased(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRadialController2 {
    #[inline] pub fn add_button_pressed(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerButtonPressedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ButtonPressed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_button_pressed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ButtonPressed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_button_holding(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerButtonHoldingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ButtonHolding)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_button_holding(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ButtonHolding)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_button_released(&self, handler: &foundation::TypedEventHandler<RadialController, RadialControllerButtonReleasedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ButtonReleased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_button_released(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ButtonReleased)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerButtonClickedEventArgs, 543859768, 58961, 4581, 191, 98, 44, 39, 215, 64, 78, 133);
RT_INTERFACE!{interface IRadialControllerButtonClickedEventArgs(IRadialControllerButtonClickedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerButtonClickedEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT
}}
impl IRadialControllerButtonClickedEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerButtonClickedEventArgs: IRadialControllerButtonClickedEventArgs}
DEFINE_IID!(IID_IRadialControllerButtonClickedEventArgs2, 1029144307, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerButtonClickedEventArgs2(IRadialControllerButtonClickedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerButtonClickedEventArgs2] {
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerButtonClickedEventArgs2 {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerButtonHoldingEventArgs, 1029144302, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerButtonHoldingEventArgs(IRadialControllerButtonHoldingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerButtonHoldingEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerButtonHoldingEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerButtonHoldingEventArgs: IRadialControllerButtonHoldingEventArgs}
DEFINE_IID!(IID_IRadialControllerButtonPressedEventArgs, 1029144301, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerButtonPressedEventArgs(IRadialControllerButtonPressedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerButtonPressedEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerButtonPressedEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerButtonPressedEventArgs: IRadialControllerButtonPressedEventArgs}
DEFINE_IID!(IID_IRadialControllerButtonReleasedEventArgs, 1029144303, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerButtonReleasedEventArgs(IRadialControllerButtonReleasedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerButtonReleasedEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerButtonReleasedEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerButtonReleasedEventArgs: IRadialControllerButtonReleasedEventArgs}
DEFINE_IID!(IID_IRadialControllerConfiguration, 2797051595, 27218, 17456, 145, 12, 86, 55, 10, 157, 107, 66);
RT_INTERFACE!{interface IRadialControllerConfiguration(IRadialControllerConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerConfiguration] {
    fn SetDefaultMenuItems(&self, buttons: *mut foundation::collections::IIterable<RadialControllerSystemMenuItemKind>) -> HRESULT,
    fn ResetToDefaultMenuItems(&self) -> HRESULT,
    fn TrySelectDefaultMenuItem(&self, type_: RadialControllerSystemMenuItemKind, out: *mut bool) -> HRESULT
}}
impl IRadialControllerConfiguration {
    #[inline] pub fn set_default_menu_items(&self, buttons: &foundation::collections::IIterable<RadialControllerSystemMenuItemKind>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDefaultMenuItems)(self as *const _ as *mut _, buttons as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn reset_to_default_menu_items(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ResetToDefaultMenuItems)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_select_default_menu_item(&self, type_: RadialControllerSystemMenuItemKind) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySelectDefaultMenuItem)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerConfiguration: IRadialControllerConfiguration}
impl RtActivatable<IRadialControllerConfigurationStatics> for RadialControllerConfiguration {}
impl RtActivatable<IRadialControllerConfigurationStatics2> for RadialControllerConfiguration {}
impl RadialControllerConfiguration {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<RadialControllerConfiguration>>> {
        <Self as RtActivatable<IRadialControllerConfigurationStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn set_app_controller(value: &RadialController) -> Result<()> {
        <Self as RtActivatable<IRadialControllerConfigurationStatics2>>::get_activation_factory().set_app_controller(value)
    }
    #[inline] pub fn get_app_controller() -> Result<Option<ComPtr<RadialController>>> {
        <Self as RtActivatable<IRadialControllerConfigurationStatics2>>::get_activation_factory().get_app_controller()
    }
    #[inline] pub fn set_is_app_controller_enabled(value: bool) -> Result<()> {
        <Self as RtActivatable<IRadialControllerConfigurationStatics2>>::get_activation_factory().set_is_app_controller_enabled(value)
    }
    #[inline] pub fn get_is_app_controller_enabled() -> Result<bool> {
        <Self as RtActivatable<IRadialControllerConfigurationStatics2>>::get_activation_factory().get_is_app_controller_enabled()
    }
}
DEFINE_CLSID!(RadialControllerConfiguration(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,82,97,100,105,97,108,67,111,110,116,114,111,108,108,101,114,67,111,110,102,105,103,117,114,97,116,105,111,110,0]) [CLSID_RadialControllerConfiguration]);
DEFINE_IID!(IID_IRadialControllerConfiguration2, 1029144311, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerConfiguration2(IRadialControllerConfiguration2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerConfiguration2] {
    fn put_ActiveControllerWhenMenuIsSuppressed(&self, value: *mut RadialController) -> HRESULT,
    fn get_ActiveControllerWhenMenuIsSuppressed(&self, out: *mut *mut RadialController) -> HRESULT,
    fn put_IsMenuSuppressed(&self, value: bool) -> HRESULT,
    fn get_IsMenuSuppressed(&self, out: *mut bool) -> HRESULT
}}
impl IRadialControllerConfiguration2 {
    #[inline] pub fn set_active_controller_when_menu_is_suppressed(&self, value: &RadialController) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ActiveControllerWhenMenuIsSuppressed)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_active_controller_when_menu_is_suppressed(&self) -> Result<Option<ComPtr<RadialController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActiveControllerWhenMenuIsSuppressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_menu_suppressed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsMenuSuppressed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_menu_suppressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMenuSuppressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerConfigurationStatics, 2042015973, 1690, 17542, 169, 157, 141, 183, 114, 185, 100, 47);
RT_INTERFACE!{static interface IRadialControllerConfigurationStatics(IRadialControllerConfigurationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerConfigurationStatics] {
    fn GetForCurrentView(&self, out: *mut *mut RadialControllerConfiguration) -> HRESULT
}}
impl IRadialControllerConfigurationStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<RadialControllerConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerConfigurationStatics2, 1407224599, 57861, 18643, 156, 175, 128, 255, 71, 196, 215, 199);
RT_INTERFACE!{static interface IRadialControllerConfigurationStatics2(IRadialControllerConfigurationStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerConfigurationStatics2] {
    fn put_AppController(&self, value: *mut RadialController) -> HRESULT,
    fn get_AppController(&self, out: *mut *mut RadialController) -> HRESULT,
    fn put_IsAppControllerEnabled(&self, value: bool) -> HRESULT,
    fn get_IsAppControllerEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IRadialControllerConfigurationStatics2 {
    #[inline] pub fn set_app_controller(&self, value: &RadialController) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AppController)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_controller(&self) -> Result<Option<ComPtr<RadialController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_app_controller_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsAppControllerEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_app_controller_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAppControllerEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerControlAcquiredEventArgs, 543859769, 58961, 4581, 191, 98, 44, 39, 215, 64, 78, 133);
RT_INTERFACE!{interface IRadialControllerControlAcquiredEventArgs(IRadialControllerControlAcquiredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerControlAcquiredEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT
}}
impl IRadialControllerControlAcquiredEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerControlAcquiredEventArgs: IRadialControllerControlAcquiredEventArgs}
DEFINE_IID!(IID_IRadialControllerControlAcquiredEventArgs2, 1029144308, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerControlAcquiredEventArgs2(IRadialControllerControlAcquiredEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerControlAcquiredEventArgs2] {
    fn get_IsButtonPressed(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerControlAcquiredEventArgs2 {
    #[inline] pub fn get_is_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerMenu, 2231808861, 63040, 17426, 171, 160, 186, 208, 119, 229, 234, 138);
RT_INTERFACE!{interface IRadialControllerMenu(IRadialControllerMenuVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerMenu] {
    fn get_Items(&self, out: *mut *mut foundation::collections::IVector<RadialControllerMenuItem>) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn GetSelectedMenuItem(&self, out: *mut *mut RadialControllerMenuItem) -> HRESULT,
    fn SelectMenuItem(&self, menuItem: *mut RadialControllerMenuItem) -> HRESULT,
    fn TrySelectPreviouslySelectedMenuItem(&self, out: *mut bool) -> HRESULT
}}
impl IRadialControllerMenu {
    #[inline] pub fn get_items(&self) -> Result<Option<ComPtr<foundation::collections::IVector<RadialControllerMenuItem>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_menu_item(&self) -> Result<Option<ComPtr<RadialControllerMenuItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSelectedMenuItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn select_menu_item(&self, menuItem: &RadialControllerMenuItem) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SelectMenuItem)(self as *const _ as *mut _, menuItem as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_select_previously_selected_menu_item(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySelectPreviouslySelectedMenuItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerMenu: IRadialControllerMenu}
DEFINE_IID!(IID_IRadialControllerMenuItem, 3356477837, 44299, 19612, 143, 47, 19, 106, 35, 115, 166, 186);
RT_INTERFACE!{interface IRadialControllerMenuItem(IRadialControllerMenuItemVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerMenuItem] {
    fn get_DisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Tag(&self, value: *mut IInspectable) -> HRESULT,
    fn add_Invoked(&self, handler: *mut foundation::TypedEventHandler<RadialControllerMenuItem, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Invoked(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IRadialControllerMenuItem {
    #[inline] pub fn get_display_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_tag(&self, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_invoked(&self, handler: &foundation::TypedEventHandler<RadialControllerMenuItem, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Invoked)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_invoked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Invoked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerMenuItem: IRadialControllerMenuItem}
impl RtActivatable<IRadialControllerMenuItemStatics> for RadialControllerMenuItem {}
impl RtActivatable<IRadialControllerMenuItemStatics2> for RadialControllerMenuItem {}
impl RadialControllerMenuItem {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_icon(displayText: &HStringArg, icon: &super::super::storage::streams::RandomAccessStreamReference) -> Result<Option<ComPtr<RadialControllerMenuItem>>> {
        <Self as RtActivatable<IRadialControllerMenuItemStatics>>::get_activation_factory().create_from_icon(displayText, icon)
    }
    #[inline] pub fn create_from_known_icon(displayText: &HStringArg, value: RadialControllerMenuKnownIcon) -> Result<Option<ComPtr<RadialControllerMenuItem>>> {
        <Self as RtActivatable<IRadialControllerMenuItemStatics>>::get_activation_factory().create_from_known_icon(displayText, value)
    }
    #[inline] pub fn create_from_font_glyph(displayText: &HStringArg, glyph: &HStringArg, fontFamily: &HStringArg) -> Result<Option<ComPtr<RadialControllerMenuItem>>> {
        <Self as RtActivatable<IRadialControllerMenuItemStatics2>>::get_activation_factory().create_from_font_glyph(displayText, glyph, fontFamily)
    }
    #[inline] pub fn create_from_font_glyph_with_uri(displayText: &HStringArg, glyph: &HStringArg, fontFamily: &HStringArg, fontUri: &foundation::Uri) -> Result<Option<ComPtr<RadialControllerMenuItem>>> {
        <Self as RtActivatable<IRadialControllerMenuItemStatics2>>::get_activation_factory().create_from_font_glyph_with_uri(displayText, glyph, fontFamily, fontUri)
    }
}
DEFINE_CLSID!(RadialControllerMenuItem(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,82,97,100,105,97,108,67,111,110,116,114,111,108,108,101,114,77,101,110,117,73,116,101,109,0]) [CLSID_RadialControllerMenuItem]);
DEFINE_IID!(IID_IRadialControllerMenuItemStatics, 614336647, 55362, 17700, 157, 248, 224, 214, 71, 237, 200, 135);
RT_INTERFACE!{static interface IRadialControllerMenuItemStatics(IRadialControllerMenuItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerMenuItemStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromIcon(&self, displayText: HSTRING, icon: *mut super::super::storage::streams::RandomAccessStreamReference, out: *mut *mut RadialControllerMenuItem) -> HRESULT,
    fn CreateFromKnownIcon(&self, displayText: HSTRING, value: RadialControllerMenuKnownIcon, out: *mut *mut RadialControllerMenuItem) -> HRESULT
}}
impl IRadialControllerMenuItemStatics {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_icon(&self, displayText: &HStringArg, icon: &super::super::storage::streams::RandomAccessStreamReference) -> Result<Option<ComPtr<RadialControllerMenuItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromIcon)(self as *const _ as *mut _, displayText.get(), icon as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_known_icon(&self, displayText: &HStringArg, value: RadialControllerMenuKnownIcon) -> Result<Option<ComPtr<RadialControllerMenuItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromKnownIcon)(self as *const _ as *mut _, displayText.get(), value, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerMenuItemStatics2, 213610686, 32318, 18621, 190, 4, 44, 127, 202, 169, 193, 255);
RT_INTERFACE!{static interface IRadialControllerMenuItemStatics2(IRadialControllerMenuItemStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerMenuItemStatics2] {
    fn CreateFromFontGlyph(&self, displayText: HSTRING, glyph: HSTRING, fontFamily: HSTRING, out: *mut *mut RadialControllerMenuItem) -> HRESULT,
    fn CreateFromFontGlyphWithUri(&self, displayText: HSTRING, glyph: HSTRING, fontFamily: HSTRING, fontUri: *mut foundation::Uri, out: *mut *mut RadialControllerMenuItem) -> HRESULT
}}
impl IRadialControllerMenuItemStatics2 {
    #[inline] pub fn create_from_font_glyph(&self, displayText: &HStringArg, glyph: &HStringArg, fontFamily: &HStringArg) -> Result<Option<ComPtr<RadialControllerMenuItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromFontGlyph)(self as *const _ as *mut _, displayText.get(), glyph.get(), fontFamily.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_font_glyph_with_uri(&self, displayText: &HStringArg, glyph: &HStringArg, fontFamily: &HStringArg, fontUri: &foundation::Uri) -> Result<Option<ComPtr<RadialControllerMenuItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromFontGlyphWithUri)(self as *const _ as *mut _, displayText.get(), glyph.get(), fontFamily.get(), fontUri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum RadialControllerMenuKnownIcon: i32 {
    Scroll = 0, Zoom = 1, UndoRedo = 2, Volume = 3, NextPreviousTrack = 4, Ruler = 5, InkColor = 6, InkThickness = 7, PenType = 8,
}}
DEFINE_IID!(IID_IRadialControllerRotationChangedEventArgs, 543859765, 58961, 4581, 191, 98, 44, 39, 215, 64, 78, 133);
RT_INTERFACE!{interface IRadialControllerRotationChangedEventArgs(IRadialControllerRotationChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerRotationChangedEventArgs] {
    fn get_RotationDeltaInDegrees(&self, out: *mut f64) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT
}}
impl IRadialControllerRotationChangedEventArgs {
    #[inline] pub fn get_rotation_delta_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RotationDeltaInDegrees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerRotationChangedEventArgs: IRadialControllerRotationChangedEventArgs}
DEFINE_IID!(IID_IRadialControllerRotationChangedEventArgs2, 1029144300, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerRotationChangedEventArgs2(IRadialControllerRotationChangedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerRotationChangedEventArgs2] {
    fn get_IsButtonPressed(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerRotationChangedEventArgs2 {
    #[inline] pub fn get_is_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerScreenContact, 543859764, 58961, 4581, 191, 98, 44, 39, 215, 64, 78, 133);
RT_INTERFACE!{interface IRadialControllerScreenContact(IRadialControllerScreenContactVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerScreenContact] {
    fn get_Bounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT
}}
impl IRadialControllerScreenContact {
    #[inline] pub fn get_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerScreenContact: IRadialControllerScreenContact}
DEFINE_IID!(IID_IRadialControllerScreenContactContinuedEventArgs, 543859767, 58961, 4581, 191, 98, 44, 39, 215, 64, 78, 133);
RT_INTERFACE!{interface IRadialControllerScreenContactContinuedEventArgs(IRadialControllerScreenContactContinuedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerScreenContactContinuedEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT
}}
impl IRadialControllerScreenContactContinuedEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerScreenContactContinuedEventArgs: IRadialControllerScreenContactContinuedEventArgs}
DEFINE_IID!(IID_IRadialControllerScreenContactContinuedEventArgs2, 1029144305, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerScreenContactContinuedEventArgs2(IRadialControllerScreenContactContinuedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerScreenContactContinuedEventArgs2] {
    fn get_IsButtonPressed(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerScreenContactContinuedEventArgs2 {
    #[inline] pub fn get_is_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerScreenContactEndedEventArgs, 1029144306, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerScreenContactEndedEventArgs(IRadialControllerScreenContactEndedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerScreenContactEndedEventArgs] {
    fn get_IsButtonPressed(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerScreenContactEndedEventArgs {
    #[inline] pub fn get_is_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerScreenContactEndedEventArgs: IRadialControllerScreenContactEndedEventArgs}
DEFINE_IID!(IID_IRadialControllerScreenContactStartedEventArgs, 543859766, 58961, 4581, 191, 98, 44, 39, 215, 64, 78, 133);
RT_INTERFACE!{interface IRadialControllerScreenContactStartedEventArgs(IRadialControllerScreenContactStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerScreenContactStartedEventArgs] {
    fn get_Contact(&self, out: *mut *mut RadialControllerScreenContact) -> HRESULT
}}
impl IRadialControllerScreenContactStartedEventArgs {
    #[inline] pub fn get_contact(&self) -> Result<Option<ComPtr<RadialControllerScreenContact>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerScreenContactStartedEventArgs: IRadialControllerScreenContactStartedEventArgs}
DEFINE_IID!(IID_IRadialControllerScreenContactStartedEventArgs2, 1029144304, 15598, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerScreenContactStartedEventArgs2(IRadialControllerScreenContactStartedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerScreenContactStartedEventArgs2] {
    fn get_IsButtonPressed(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut super::super::devices::haptics::SimpleHapticsController) -> HRESULT
}}
impl IRadialControllerScreenContactStartedEventArgs2 {
    #[inline] pub fn get_is_button_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsButtonPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<super::super::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerStatics, 4208906423, 47180, 18580, 135, 170, 143, 37, 170, 95, 40, 139);
RT_INTERFACE!{static interface IRadialControllerStatics(IRadialControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerStatics] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT,
    fn CreateForCurrentView(&self, out: *mut *mut RadialController) -> HRESULT
}}
impl IRadialControllerStatics {
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_for_current_view(&self) -> Result<Option<ComPtr<RadialController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum RadialControllerSystemMenuItemKind: i32 {
    Scroll = 0, Zoom = 1, UndoRedo = 2, Volume = 3, NextPreviousTrack = 4,
}}
DEFINE_IID!(IID_IRightTappedEventArgs, 1287602365, 44922, 18998, 148, 118, 177, 220, 225, 65, 112, 154);
RT_INTERFACE!{interface IRightTappedEventArgs(IRightTappedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRightTappedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT
}}
impl IRightTappedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class RightTappedEventArgs: IRightTappedEventArgs}
DEFINE_IID!(IID_ITappedEventArgs, 3483444964, 9530, 19516, 149, 59, 57, 92, 55, 174, 211, 9);
RT_INTERFACE!{interface ITappedEventArgs(ITappedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITappedEventArgs] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_PointerDeviceType(&self, out: *mut super::super::devices::input::PointerDeviceType) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_TapCount(&self, out: *mut u32) -> HRESULT
}}
impl ITappedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub fn get_pointer_device_type(&self) -> Result<super::super::devices::input::PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerDeviceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tap_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TapCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TappedEventArgs: ITappedEventArgs}
pub mod core { // Windows.UI.Input.Core
use crate::prelude::*;
DEFINE_IID!(IID_IRadialControllerIndependentInputSource, 1029144310, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface IRadialControllerIndependentInputSource(IRadialControllerIndependentInputSourceVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerIndependentInputSource] {
    fn get_Controller(&self, out: *mut *mut super::RadialController) -> HRESULT,
    fn get_Dispatcher(&self, out: *mut *mut super::super::core::CoreDispatcher) -> HRESULT
}}
impl IRadialControllerIndependentInputSource {
    #[inline] pub fn get_controller(&self) -> Result<Option<ComPtr<super::RadialController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Controller)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_dispatcher(&self) -> Result<Option<ComPtr<super::super::core::CoreDispatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RadialControllerIndependentInputSource: IRadialControllerIndependentInputSource}
impl RtActivatable<IRadialControllerIndependentInputSourceStatics> for RadialControllerIndependentInputSource {}
impl RadialControllerIndependentInputSource {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn create_for_view(view: &crate::windows::applicationmodel::core::CoreApplicationView) -> Result<Option<ComPtr<RadialControllerIndependentInputSource>>> {
        <Self as RtActivatable<IRadialControllerIndependentInputSourceStatics>>::get_activation_factory().create_for_view(view)
    }
}
DEFINE_CLSID!(RadialControllerIndependentInputSource(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,67,111,114,101,46,82,97,100,105,97,108,67,111,110,116,114,111,108,108,101,114,73,110,100,101,112,101,110,100,101,110,116,73,110,112,117,116,83,111,117,114,99,101,0]) [CLSID_RadialControllerIndependentInputSource]);
DEFINE_IID!(IID_IRadialControllerIndependentInputSource2, 1886628568, 13811, 20203, 135, 81, 190, 77, 10, 102, 250, 244);
RT_INTERFACE!{interface IRadialControllerIndependentInputSource2(IRadialControllerIndependentInputSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerIndependentInputSource2] {
    #[cfg(feature="windows-system")] fn get_DispatcherQueue(&self, out: *mut *mut crate::windows::system::DispatcherQueue) -> HRESULT
}}
impl IRadialControllerIndependentInputSource2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_dispatcher_queue(&self) -> Result<Option<ComPtr<crate::windows::system::DispatcherQueue>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DispatcherQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRadialControllerIndependentInputSourceStatics, 1029144309, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{static interface IRadialControllerIndependentInputSourceStatics(IRadialControllerIndependentInputSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadialControllerIndependentInputSourceStatics] {
    #[cfg(feature="windows-applicationmodel")] fn CreateForView(&self, view: *mut crate::windows::applicationmodel::core::CoreApplicationView, out: *mut *mut RadialControllerIndependentInputSource) -> HRESULT
}}
impl IRadialControllerIndependentInputSourceStatics {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn create_for_view(&self, view: &crate::windows::applicationmodel::core::CoreApplicationView) -> Result<Option<ComPtr<RadialControllerIndependentInputSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateForView)(self as *const _ as *mut _, view as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Input.Core
pub mod inking { // Windows.UI.Input.Inking
use crate::prelude::*;
RT_ENUM! { enum HandwritingLineHeight: i32 {
    Small = 0, Medium = 1, Large = 2,
}}
DEFINE_IID!(IID_IInkDrawingAttributes, 2543982444, 26484, 18605, 132, 240, 72, 245, 169, 190, 116, 249);
RT_INTERFACE!{interface IInkDrawingAttributes(IInkDrawingAttributesVtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributes] {
    fn get_Color(&self, out: *mut super::super::Color) -> HRESULT,
    fn put_Color(&self, value: super::super::Color) -> HRESULT,
    fn get_PenTip(&self, out: *mut PenTipShape) -> HRESULT,
    fn put_PenTip(&self, value: PenTipShape) -> HRESULT,
    fn get_Size(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_Size(&self, value: foundation::Size) -> HRESULT,
    fn get_IgnorePressure(&self, out: *mut bool) -> HRESULT,
    fn put_IgnorePressure(&self, value: bool) -> HRESULT,
    fn get_FitToCurve(&self, out: *mut bool) -> HRESULT,
    fn put_FitToCurve(&self, value: bool) -> HRESULT
}}
impl IInkDrawingAttributes {
    #[inline] pub fn get_color(&self) -> Result<super::super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Color)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color(&self, value: super::super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Color)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pen_tip(&self) -> Result<PenTipShape> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PenTip)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pen_tip(&self, value: PenTipShape) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PenTip)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_size(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ignore_pressure(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IgnorePressure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ignore_pressure(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IgnorePressure)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_fit_to_curve(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FitToCurve)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_fit_to_curve(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FitToCurve)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkDrawingAttributes: IInkDrawingAttributes}
impl RtActivatable<IInkDrawingAttributesStatics> for InkDrawingAttributes {}
impl RtActivatable<IActivationFactory> for InkDrawingAttributes {}
impl InkDrawingAttributes {
    #[inline] pub fn create_for_pencil() -> Result<Option<ComPtr<InkDrawingAttributes>>> {
        <Self as RtActivatable<IInkDrawingAttributesStatics>>::get_activation_factory().create_for_pencil()
    }
}
DEFINE_CLSID!(InkDrawingAttributes(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,68,114,97,119,105,110,103,65,116,116,114,105,98,117,116,101,115,0]) [CLSID_InkDrawingAttributes]);
DEFINE_IID!(IID_IInkDrawingAttributes2, 2091607304, 36548, 17149, 165, 165, 228, 183, 209, 213, 49, 109);
RT_INTERFACE!{interface IInkDrawingAttributes2(IInkDrawingAttributes2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributes2] {
    fn get_PenTipTransform(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_PenTipTransform(&self, value: foundation::numerics::Matrix3x2) -> HRESULT,
    fn get_DrawAsHighlighter(&self, out: *mut bool) -> HRESULT,
    fn put_DrawAsHighlighter(&self, value: bool) -> HRESULT
}}
impl IInkDrawingAttributes2 {
    #[inline] pub fn get_pen_tip_transform(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PenTipTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pen_tip_transform(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PenTipTransform)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_draw_as_highlighter(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DrawAsHighlighter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_draw_as_highlighter(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DrawAsHighlighter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkDrawingAttributes3, 1912733698, 32091, 18064, 138, 244, 230, 100, 203, 226, 183, 79);
RT_INTERFACE!{interface IInkDrawingAttributes3(IInkDrawingAttributes3Vtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributes3] {
    fn get_Kind(&self, out: *mut InkDrawingAttributesKind) -> HRESULT,
    fn get_PencilProperties(&self, out: *mut *mut InkDrawingAttributesPencilProperties) -> HRESULT
}}
impl IInkDrawingAttributes3 {
    #[inline] pub fn get_kind(&self) -> Result<InkDrawingAttributesKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pencil_properties(&self) -> Result<Option<ComPtr<InkDrawingAttributesPencilProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PencilProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkDrawingAttributes4, 4016430117, 40729, 17773, 145, 163, 188, 58, 61, 145, 197, 251);
RT_INTERFACE!{interface IInkDrawingAttributes4(IInkDrawingAttributes4Vtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributes4] {
    fn get_IgnoreTilt(&self, out: *mut bool) -> HRESULT,
    fn put_IgnoreTilt(&self, value: bool) -> HRESULT
}}
impl IInkDrawingAttributes4 {
    #[inline] pub fn get_ignore_tilt(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IgnoreTilt)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ignore_tilt(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IgnoreTilt)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkDrawingAttributes5, 3508183227, 1909, 18514, 174, 100, 65, 20, 58, 122, 230, 201);
RT_INTERFACE!{interface IInkDrawingAttributes5(IInkDrawingAttributes5Vtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributes5] {
    fn get_ModelerAttributes(&self, out: *mut *mut InkModelerAttributes) -> HRESULT
}}
impl IInkDrawingAttributes5 {
    #[inline] pub fn get_modeler_attributes(&self) -> Result<Option<ComPtr<InkModelerAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ModelerAttributes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum InkDrawingAttributesKind: i32 {
    Default = 0, Pencil = 1,
}}
DEFINE_IID!(IID_IInkDrawingAttributesPencilProperties, 1327838411, 11654, 16827, 176, 232, 228, 194, 160, 37, 60, 82);
RT_INTERFACE!{interface IInkDrawingAttributesPencilProperties(IInkDrawingAttributesPencilPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributesPencilProperties] {
    fn get_Opacity(&self, out: *mut f64) -> HRESULT,
    fn put_Opacity(&self, value: f64) -> HRESULT
}}
impl IInkDrawingAttributesPencilProperties {
    #[inline] pub fn get_opacity(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Opacity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_opacity(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Opacity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkDrawingAttributesPencilProperties: IInkDrawingAttributesPencilProperties}
DEFINE_IID!(IID_IInkDrawingAttributesStatics, 4147241023, 6757, 18530, 150, 203, 110, 22, 101, 225, 127, 109);
RT_INTERFACE!{static interface IInkDrawingAttributesStatics(IInkDrawingAttributesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkDrawingAttributesStatics] {
    fn CreateForPencil(&self, out: *mut *mut InkDrawingAttributes) -> HRESULT
}}
impl IInkDrawingAttributesStatics {
    #[inline] pub fn create_for_pencil(&self) -> Result<Option<ComPtr<InkDrawingAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateForPencil)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum InkHighContrastAdjustment: i32 {
    UseSystemColorsWhenNecessary = 0, UseSystemColors = 1, UseOriginalColors = 2,
}}
DEFINE_IID!(IID_IInkInputConfiguration, 2477166020, 2939, 18903, 179, 79, 153, 1, 229, 36, 220, 242);
RT_INTERFACE!{interface IInkInputConfiguration(IInkInputConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IInkInputConfiguration] {
    fn get_IsPrimaryBarrelButtonInputEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPrimaryBarrelButtonInputEnabled(&self, value: bool) -> HRESULT,
    fn get_IsEraserInputEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEraserInputEnabled(&self, value: bool) -> HRESULT
}}
impl IInkInputConfiguration {
    #[inline] pub fn get_is_primary_barrel_button_input_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPrimaryBarrelButtonInputEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_primary_barrel_button_input_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsPrimaryBarrelButtonInputEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_eraser_input_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEraserInputEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_eraser_input_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsEraserInputEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkInputConfiguration: IInkInputConfiguration}
DEFINE_IID!(IID_IInkInputProcessingConfiguration, 662231134, 13258, 19206, 166, 211, 172, 57, 69, 17, 109, 55);
RT_INTERFACE!{interface IInkInputProcessingConfiguration(IInkInputProcessingConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IInkInputProcessingConfiguration] {
    fn get_Mode(&self, out: *mut InkInputProcessingMode) -> HRESULT,
    fn put_Mode(&self, value: InkInputProcessingMode) -> HRESULT,
    fn get_RightDragAction(&self, out: *mut InkInputRightDragAction) -> HRESULT,
    fn put_RightDragAction(&self, value: InkInputRightDragAction) -> HRESULT
}}
impl IInkInputProcessingConfiguration {
    #[inline] pub fn get_mode(&self) -> Result<InkInputProcessingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Mode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: InkInputProcessingMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Mode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_drag_action(&self) -> Result<InkInputRightDragAction> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightDragAction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_drag_action(&self, value: InkInputRightDragAction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightDragAction)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkInputProcessingConfiguration: IInkInputProcessingConfiguration}
RT_ENUM! { enum InkInputProcessingMode: i32 {
    None = 0, Inking = 1, Erasing = 2,
}}
RT_ENUM! { enum InkInputRightDragAction: i32 {
    LeaveUnprocessed = 0, AllowProcessing = 1,
}}
DEFINE_IID!(IID_IInkManager, 1195668349, 26395, 16739, 156, 149, 78, 141, 122, 3, 95, 225);
RT_INTERFACE!{interface IInkManager(IInkManagerVtbl): IInspectable(IInspectableVtbl) [IID_IInkManager] {
    fn get_Mode(&self, out: *mut InkManipulationMode) -> HRESULT,
    fn put_Mode(&self, value: InkManipulationMode) -> HRESULT,
    fn ProcessPointerDown(&self, pointerPoint: *mut super::PointerPoint) -> HRESULT,
    fn ProcessPointerUpdate(&self, pointerPoint: *mut super::PointerPoint, out: *mut *mut IInspectable) -> HRESULT,
    fn ProcessPointerUp(&self, pointerPoint: *mut super::PointerPoint, out: *mut foundation::Rect) -> HRESULT,
    fn SetDefaultDrawingAttributes(&self, drawingAttributes: *mut InkDrawingAttributes) -> HRESULT,
    fn RecognizeAsync2(&self, recognitionTarget: InkRecognitionTarget, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<InkRecognitionResult>>) -> HRESULT
}}
impl IInkManager {
    #[inline] pub fn get_mode(&self) -> Result<InkManipulationMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Mode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: InkManipulationMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Mode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_pointer_down(&self, pointerPoint: &super::PointerPoint) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ProcessPointerDown)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn process_pointer_update(&self, pointerPoint: &super::PointerPoint) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ProcessPointerUpdate)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn process_pointer_up(&self, pointerPoint: &super::PointerPoint) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ProcessPointerUp)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_drawing_attributes(&self, drawingAttributes: &InkDrawingAttributes) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDefaultDrawingAttributes)(self as *const _ as *mut _, drawingAttributes as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn recognize_async2(&self, recognitionTarget: InkRecognitionTarget) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<InkRecognitionResult>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RecognizeAsync2)(self as *const _ as *mut _, recognitionTarget, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkManager: IInkManager}
impl RtActivatable<IActivationFactory> for InkManager {}
DEFINE_CLSID!(InkManager(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,77,97,110,97,103,101,114,0]) [CLSID_InkManager]);
RT_ENUM! { enum InkManipulationMode: i32 {
    Inking = 0, Erasing = 1, Selecting = 2,
}}
DEFINE_IID!(IID_IInkModelerAttributes, 3134398247, 3289, 19453, 182, 243, 158, 3, 186, 141, 116, 84);
RT_INTERFACE!{interface IInkModelerAttributes(IInkModelerAttributesVtbl): IInspectable(IInspectableVtbl) [IID_IInkModelerAttributes] {
    fn get_PredictionTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_PredictionTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_ScalingFactor(&self, out: *mut f32) -> HRESULT,
    fn put_ScalingFactor(&self, value: f32) -> HRESULT
}}
impl IInkModelerAttributes {
    #[inline] pub fn get_prediction_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PredictionTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_prediction_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PredictionTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scaling_factor(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScalingFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scaling_factor(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ScalingFactor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkModelerAttributes: IInkModelerAttributes}
RT_ENUM! { enum InkPersistenceFormat: i32 {
    GifWithEmbeddedIsf = 0, Isf = 1,
}}
DEFINE_IID!(IID_IInkPoint, 2676434731, 34188, 18085, 155, 65, 209, 149, 151, 4, 89, 253);
RT_INTERFACE!{interface IInkPoint(IInkPointVtbl): IInspectable(IInspectableVtbl) [IID_IInkPoint] {
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Pressure(&self, out: *mut f32) -> HRESULT
}}
impl IInkPoint {
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pressure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InkPoint: IInkPoint}
impl RtActivatable<IInkPointFactory> for InkPoint {}
impl RtActivatable<IInkPointFactory2> for InkPoint {}
impl InkPoint {
    #[inline] pub fn create_ink_point(position: foundation::Point, pressure: f32) -> Result<ComPtr<InkPoint>> {
        <Self as RtActivatable<IInkPointFactory>>::get_activation_factory().create_ink_point(position, pressure)
    }
    #[inline] pub fn create_ink_point_with_tilt_and_timestamp(position: foundation::Point, pressure: f32, tiltX: f32, tiltY: f32, timestamp: u64) -> Result<ComPtr<InkPoint>> {
        <Self as RtActivatable<IInkPointFactory2>>::get_activation_factory().create_ink_point_with_tilt_and_timestamp(position, pressure, tiltX, tiltY, timestamp)
    }
}
DEFINE_CLSID!(InkPoint(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,80,111,105,110,116,0]) [CLSID_InkPoint]);
DEFINE_IID!(IID_IInkPoint2, 4222206967, 44630, 19804, 189, 47, 10, 196, 95, 94, 74, 249);
RT_INTERFACE!{interface IInkPoint2(IInkPoint2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkPoint2] {
    fn get_TiltX(&self, out: *mut f32) -> HRESULT,
    fn get_TiltY(&self, out: *mut f32) -> HRESULT,
    fn get_Timestamp(&self, out: *mut u64) -> HRESULT
}}
impl IInkPoint2 {
    #[inline] pub fn get_tilt_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tilt_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPointFactory, 702928156, 51599, 16477, 159, 59, 229, 62, 49, 6, 141, 77);
RT_INTERFACE!{static interface IInkPointFactory(IInkPointFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkPointFactory] {
    fn CreateInkPoint(&self, position: foundation::Point, pressure: f32, out: *mut *mut InkPoint) -> HRESULT
}}
impl IInkPointFactory {
    #[inline] pub fn create_ink_point(&self, position: foundation::Point, pressure: f32) -> Result<ComPtr<InkPoint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInkPoint)(self as *const _ as *mut _, position, pressure, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPointFactory2, 3759431301, 56063, 17906, 173, 105, 5, 13, 130, 86, 162, 9);
RT_INTERFACE!{static interface IInkPointFactory2(IInkPointFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkPointFactory2] {
    fn CreateInkPointWithTiltAndTimestamp(&self, position: foundation::Point, pressure: f32, tiltX: f32, tiltY: f32, timestamp: u64, out: *mut *mut InkPoint) -> HRESULT
}}
impl IInkPointFactory2 {
    #[inline] pub fn create_ink_point_with_tilt_and_timestamp(&self, position: foundation::Point, pressure: f32, tiltX: f32, tiltY: f32, timestamp: u64) -> Result<ComPtr<InkPoint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInkPointWithTiltAndTimestamp)(self as *const _ as *mut _, position, pressure, tiltX, tiltY, timestamp, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPresenter, 2795204834, 34939, 17807, 177, 115, 79, 228, 67, 137, 48, 163);
RT_INTERFACE!{interface IInkPresenter(IInkPresenterVtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenter] {
    fn get_IsInputEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsInputEnabled(&self, value: bool) -> HRESULT,
    fn get_InputDeviceTypes(&self, out: *mut super::super::core::CoreInputDeviceTypes) -> HRESULT,
    fn put_InputDeviceTypes(&self, value: super::super::core::CoreInputDeviceTypes) -> HRESULT,
    fn get_UnprocessedInput(&self, out: *mut *mut InkUnprocessedInput) -> HRESULT,
    fn get_StrokeInput(&self, out: *mut *mut InkStrokeInput) -> HRESULT,
    fn get_InputProcessingConfiguration(&self, out: *mut *mut InkInputProcessingConfiguration) -> HRESULT,
    fn get_StrokeContainer(&self, out: *mut *mut InkStrokeContainer) -> HRESULT,
    fn put_StrokeContainer(&self, value: *mut InkStrokeContainer) -> HRESULT,
    fn CopyDefaultDrawingAttributes(&self, out: *mut *mut InkDrawingAttributes) -> HRESULT,
    fn UpdateDefaultDrawingAttributes(&self, value: *mut InkDrawingAttributes) -> HRESULT,
    fn ActivateCustomDrying(&self, out: *mut *mut InkSynchronizer) -> HRESULT,
    fn SetPredefinedConfiguration(&self, value: InkPresenterPredefinedConfiguration) -> HRESULT,
    fn add_StrokesCollected(&self, handler: *mut foundation::TypedEventHandler<InkPresenter, InkStrokesCollectedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StrokesCollected(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StrokesErased(&self, handler: *mut foundation::TypedEventHandler<InkPresenter, InkStrokesErasedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StrokesErased(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IInkPresenter {
    #[inline] pub fn get_is_input_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInputEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_input_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsInputEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_input_device_types(&self) -> Result<super::super::core::CoreInputDeviceTypes> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputDeviceTypes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_input_device_types(&self, value: super::super::core::CoreInputDeviceTypes) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InputDeviceTypes)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_unprocessed_input(&self) -> Result<Option<ComPtr<InkUnprocessedInput>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnprocessedInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_input(&self) -> Result<Option<ComPtr<InkStrokeInput>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_input_processing_configuration(&self) -> Result<Option<ComPtr<InkInputProcessingConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputProcessingConfiguration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_container(&self) -> Result<Option<ComPtr<InkStrokeContainer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeContainer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_container(&self, value: &InkStrokeContainer) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeContainer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn copy_default_drawing_attributes(&self) -> Result<Option<ComPtr<InkDrawingAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CopyDefaultDrawingAttributes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_default_drawing_attributes(&self, value: &InkDrawingAttributes) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).UpdateDefaultDrawingAttributes)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn activate_custom_drying(&self) -> Result<Option<ComPtr<InkSynchronizer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ActivateCustomDrying)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_predefined_configuration(&self, value: InkPresenterPredefinedConfiguration) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetPredefinedConfiguration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_strokes_collected(&self, handler: &foundation::TypedEventHandler<InkPresenter, InkStrokesCollectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StrokesCollected)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_strokes_collected(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_StrokesCollected)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_strokes_erased(&self, handler: &foundation::TypedEventHandler<InkPresenter, InkStrokesErasedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StrokesErased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_strokes_erased(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_StrokesErased)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkPresenter: IInkPresenter}
DEFINE_IID!(IID_IInkPresenter2, 3478382098, 39476, 4582, 159, 51, 162, 79, 192, 217, 100, 156);
RT_INTERFACE!{interface IInkPresenter2(IInkPresenter2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenter2] {
    fn get_HighContrastAdjustment(&self, out: *mut InkHighContrastAdjustment) -> HRESULT,
    fn put_HighContrastAdjustment(&self, value: InkHighContrastAdjustment) -> HRESULT
}}
impl IInkPresenter2 {
    #[inline] pub fn get_high_contrast_adjustment(&self) -> Result<InkHighContrastAdjustment> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HighContrastAdjustment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_high_contrast_adjustment(&self, value: InkHighContrastAdjustment) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_HighContrastAdjustment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPresenter3, 1373752969, 54141, 19088, 131, 252, 127, 94, 157, 251, 242, 23);
RT_INTERFACE!{interface IInkPresenter3(IInkPresenter3Vtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenter3] {
    fn get_InputConfiguration(&self, out: *mut *mut InkInputConfiguration) -> HRESULT
}}
impl IInkPresenter3 {
    #[inline] pub fn get_input_configuration(&self) -> Result<Option<ComPtr<InkInputConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputConfiguration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum InkPresenterPredefinedConfiguration: i32 {
    SimpleSinglePointer = 0, SimpleMultiplePointer = 1,
}}
DEFINE_IID!(IID_IInkPresenterProtractor, 2112090794, 61292, 20113, 167, 59, 91, 112, 213, 111, 189, 23);
RT_INTERFACE!{interface IInkPresenterProtractor(IInkPresenterProtractorVtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenterProtractor] {
    fn get_AreTickMarksVisible(&self, out: *mut bool) -> HRESULT,
    fn put_AreTickMarksVisible(&self, value: bool) -> HRESULT,
    fn get_AreRaysVisible(&self, out: *mut bool) -> HRESULT,
    fn put_AreRaysVisible(&self, value: bool) -> HRESULT,
    fn get_IsCenterMarkerVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsCenterMarkerVisible(&self, value: bool) -> HRESULT,
    fn get_IsAngleReadoutVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsAngleReadoutVisible(&self, value: bool) -> HRESULT,
    fn get_IsResizable(&self, out: *mut bool) -> HRESULT,
    fn put_IsResizable(&self, value: bool) -> HRESULT,
    fn get_Radius(&self, out: *mut f64) -> HRESULT,
    fn put_Radius(&self, value: f64) -> HRESULT,
    fn get_AccentColor(&self, out: *mut super::super::Color) -> HRESULT,
    fn put_AccentColor(&self, value: super::super::Color) -> HRESULT
}}
impl IInkPresenterProtractor {
    #[inline] pub fn get_are_tick_marks_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreTickMarksVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_are_tick_marks_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AreTickMarksVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_are_rays_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreRaysVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_are_rays_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AreRaysVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_center_marker_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCenterMarkerVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_center_marker_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsCenterMarkerVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_angle_readout_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAngleReadoutVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_angle_readout_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsAngleReadoutVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_resizable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsResizable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_resizable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsResizable)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_radius(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Radius)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_radius(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Radius)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_accent_color(&self) -> Result<super::super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AccentColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_accent_color(&self, value: super::super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AccentColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkPresenterProtractor: IInkPresenterProtractor}
impl RtActivatable<IInkPresenterProtractorFactory> for InkPresenterProtractor {}
impl InkPresenterProtractor {
    #[inline] pub fn create(inkPresenter: &InkPresenter) -> Result<ComPtr<InkPresenterProtractor>> {
        <Self as RtActivatable<IInkPresenterProtractorFactory>>::get_activation_factory().create(inkPresenter)
    }
}
DEFINE_CLSID!(InkPresenterProtractor(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,80,114,101,115,101,110,116,101,114,80,114,111,116,114,97,99,116,111,114,0]) [CLSID_InkPresenterProtractor]);
DEFINE_IID!(IID_IInkPresenterProtractorFactory, 838927305, 26874, 18409, 129, 39, 131, 112, 113, 31, 196, 108);
RT_INTERFACE!{static interface IInkPresenterProtractorFactory(IInkPresenterProtractorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenterProtractorFactory] {
    fn Create(&self, inkPresenter: *mut InkPresenter, out: *mut *mut InkPresenterProtractor) -> HRESULT
}}
impl IInkPresenterProtractorFactory {
    #[inline] pub fn create(&self, inkPresenter: &InkPresenter) -> Result<ComPtr<InkPresenterProtractor>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, inkPresenter as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPresenterRuler, 1826258266, 57031, 19927, 135, 122, 33, 51, 241, 131, 212, 138);
RT_INTERFACE!{interface IInkPresenterRuler(IInkPresenterRulerVtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenterRuler] {
    fn get_Length(&self, out: *mut f64) -> HRESULT,
    fn put_Length(&self, value: f64) -> HRESULT,
    fn get_Width(&self, out: *mut f64) -> HRESULT,
    fn put_Width(&self, value: f64) -> HRESULT
}}
impl IInkPresenterRuler {
    #[inline] pub fn get_length(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Length)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_length(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Length)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Width)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_width(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Width)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkPresenterRuler: IInkPresenterRuler}
impl RtActivatable<IInkPresenterRulerFactory> for InkPresenterRuler {}
impl InkPresenterRuler {
    #[inline] pub fn create(inkPresenter: &InkPresenter) -> Result<ComPtr<InkPresenterRuler>> {
        <Self as RtActivatable<IInkPresenterRulerFactory>>::get_activation_factory().create(inkPresenter)
    }
}
DEFINE_CLSID!(InkPresenterRuler(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,80,114,101,115,101,110,116,101,114,82,117,108,101,114,0]) [CLSID_InkPresenterRuler]);
DEFINE_IID!(IID_IInkPresenterRuler2, 1158876609, 48225, 17620, 164, 35, 84, 113, 42, 230, 113, 196);
RT_INTERFACE!{interface IInkPresenterRuler2(IInkPresenterRuler2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenterRuler2] {
    fn get_AreTickMarksVisible(&self, out: *mut bool) -> HRESULT,
    fn put_AreTickMarksVisible(&self, value: bool) -> HRESULT,
    fn get_IsCompassVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsCompassVisible(&self, value: bool) -> HRESULT
}}
impl IInkPresenterRuler2 {
    #[inline] pub fn get_are_tick_marks_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreTickMarksVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_are_tick_marks_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AreTickMarksVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_compass_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCompassVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_compass_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsCompassVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPresenterRulerFactory, 875961323, 36865, 19019, 166, 144, 105, 219, 175, 99, 229, 1);
RT_INTERFACE!{static interface IInkPresenterRulerFactory(IInkPresenterRulerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenterRulerFactory] {
    fn Create(&self, inkPresenter: *mut InkPresenter, out: *mut *mut InkPresenterRuler) -> HRESULT
}}
impl IInkPresenterRulerFactory {
    #[inline] pub fn create(&self, inkPresenter: &InkPresenter) -> Result<ComPtr<InkPresenterRuler>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, inkPresenter as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkPresenterStencil, 819015021, 15878, 19714, 177, 22, 39, 127, 181, 216, 173, 220);
RT_INTERFACE!{interface IInkPresenterStencil(IInkPresenterStencilVtbl): IInspectable(IInspectableVtbl) [IID_IInkPresenterStencil] {
    fn get_Kind(&self, out: *mut InkPresenterStencilKind) -> HRESULT,
    fn get_IsVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsVisible(&self, value: bool) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut super::super::Color) -> HRESULT,
    fn put_BackgroundColor(&self, value: super::super::Color) -> HRESULT,
    fn get_ForegroundColor(&self, out: *mut super::super::Color) -> HRESULT,
    fn put_ForegroundColor(&self, value: super::super::Color) -> HRESULT,
    fn get_Transform(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_Transform(&self, value: foundation::numerics::Matrix3x2) -> HRESULT
}}
impl IInkPresenterStencil {
    #[inline] pub fn get_kind(&self) -> Result<InkPresenterStencilKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<super::super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_background_color(&self, value: super::super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_foreground_color(&self) -> Result<super::super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_foreground_color(&self, value: super::super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ForegroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transform(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Transform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transform(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Transform)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum InkPresenterStencilKind: i32 {
    Other = 0, Ruler = 1, Protractor = 2,
}}
DEFINE_IID!(IID_IInkRecognitionResult, 910563988, 20584, 16623, 138, 5, 44, 47, 182, 9, 8, 162);
RT_INTERFACE!{interface IInkRecognitionResult(IInkRecognitionResultVtbl): IInspectable(IInspectableVtbl) [IID_IInkRecognitionResult] {
    fn get_BoundingRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn GetTextCandidates(&self, out: *mut *mut foundation::collections::IVectorView<HString>) -> HRESULT,
    fn GetStrokes(&self, out: *mut *mut foundation::collections::IVectorView<InkStroke>) -> HRESULT
}}
impl IInkRecognitionResult {
    #[inline] pub fn get_bounding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BoundingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text_candidates(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTextCandidates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_strokes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkStroke>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStrokes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkRecognitionResult: IInkRecognitionResult}
RT_ENUM! { enum InkRecognitionTarget: i32 {
    All = 0, Selected = 1, Recent = 2,
}}
DEFINE_IID!(IID_IInkRecognizer, 125619875, 36941, 17450, 177, 81, 170, 202, 54, 49, 196, 59);
RT_INTERFACE!{interface IInkRecognizer(IInkRecognizerVtbl): IInspectable(IInspectableVtbl) [IID_IInkRecognizer] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT
}}
impl IInkRecognizer {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkRecognizer: IInkRecognizer}
DEFINE_IID!(IID_IInkRecognizerContainer, 2806880817, 32839, 18072, 169, 18, 248, 42, 80, 133, 1, 47);
RT_INTERFACE!{interface IInkRecognizerContainer(IInkRecognizerContainerVtbl): IInspectable(IInspectableVtbl) [IID_IInkRecognizerContainer] {
    fn SetDefaultRecognizer(&self, recognizer: *mut InkRecognizer) -> HRESULT,
    fn RecognizeAsync(&self, strokeCollection: *mut InkStrokeContainer, recognitionTarget: InkRecognitionTarget, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<InkRecognitionResult>>) -> HRESULT,
    fn GetRecognizers(&self, out: *mut *mut foundation::collections::IVectorView<InkRecognizer>) -> HRESULT
}}
impl IInkRecognizerContainer {
    #[inline] pub fn set_default_recognizer(&self, recognizer: &InkRecognizer) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDefaultRecognizer)(self as *const _ as *mut _, recognizer as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn recognize_async(&self, strokeCollection: &InkStrokeContainer, recognitionTarget: InkRecognitionTarget) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<InkRecognitionResult>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RecognizeAsync)(self as *const _ as *mut _, strokeCollection as *const _ as *mut _, recognitionTarget, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recognizers(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkRecognizer>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRecognizers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkRecognizerContainer: IInkRecognizerContainer}
impl RtActivatable<IActivationFactory> for InkRecognizerContainer {}
DEFINE_CLSID!(InkRecognizerContainer(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,82,101,99,111,103,110,105,122,101,114,67,111,110,116,97,105,110,101,114,0]) [CLSID_InkRecognizerContainer]);
DEFINE_IID!(IID_IInkStroke, 353652064, 52451, 20431, 157, 82, 17, 81, 138, 182, 175, 212);
RT_INTERFACE!{interface IInkStroke(IInkStrokeVtbl): IInspectable(IInspectableVtbl) [IID_IInkStroke] {
    fn get_DrawingAttributes(&self, out: *mut *mut InkDrawingAttributes) -> HRESULT,
    fn put_DrawingAttributes(&self, value: *mut InkDrawingAttributes) -> HRESULT,
    fn get_BoundingRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_Selected(&self, out: *mut bool) -> HRESULT,
    fn put_Selected(&self, value: bool) -> HRESULT,
    fn get_Recognized(&self, out: *mut bool) -> HRESULT,
    fn GetRenderingSegments(&self, out: *mut *mut foundation::collections::IVectorView<InkStrokeRenderingSegment>) -> HRESULT,
    fn Clone(&self, out: *mut *mut InkStroke) -> HRESULT
}}
impl IInkStroke {
    #[inline] pub fn get_drawing_attributes(&self) -> Result<Option<ComPtr<InkDrawingAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DrawingAttributes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_drawing_attributes(&self, value: &InkDrawingAttributes) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DrawingAttributes)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bounding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BoundingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Selected)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selected(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Selected)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recognized(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Recognized)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rendering_segments(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkStrokeRenderingSegment>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRenderingSegments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<ComPtr<InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Clone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStroke: IInkStroke}
DEFINE_IID!(IID_IInkStroke2, 1572463860, 47866, 19937, 137, 211, 32, 27, 30, 215, 216, 155);
RT_INTERFACE!{interface IInkStroke2(IInkStroke2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkStroke2] {
    fn get_PointTransform(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn put_PointTransform(&self, value: foundation::numerics::Matrix3x2) -> HRESULT,
    fn GetInkPoints(&self, out: *mut *mut foundation::collections::IVectorView<InkPoint>) -> HRESULT
}}
impl IInkStroke2 {
    #[inline] pub fn get_point_transform(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_point_transform(&self, value: foundation::numerics::Matrix3x2) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PointTransform)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ink_points(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkPoint>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetInkPoints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkStroke3, 1249932148, 38041, 16669, 161, 196, 104, 133, 93, 3, 214, 95);
RT_INTERFACE!{interface IInkStroke3(IInkStroke3Vtbl): IInspectable(IInspectableVtbl) [IID_IInkStroke3] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_StrokeStartedTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn put_StrokeStartedTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_StrokeDuration(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn put_StrokeDuration(&self, value: *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT
}}
impl IInkStroke3 {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_started_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeStartedTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_started_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeStartedTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_duration(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StrokeDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_duration(&self, value: &foundation::IReference<foundation::TimeSpan>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StrokeDuration)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkStrokeBuilder, 2193347036, 7267, 16860, 158, 7, 75, 74, 112, 206, 216, 1);
RT_INTERFACE!{interface IInkStrokeBuilder(IInkStrokeBuilderVtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeBuilder] {
    fn BeginStroke(&self, pointerPoint: *mut super::PointerPoint) -> HRESULT,
    fn AppendToStroke(&self, pointerPoint: *mut super::PointerPoint, out: *mut *mut super::PointerPoint) -> HRESULT,
    fn EndStroke(&self, pointerPoint: *mut super::PointerPoint, out: *mut *mut InkStroke) -> HRESULT,
    fn CreateStroke(&self, points: *mut foundation::collections::IIterable<foundation::Point>, out: *mut *mut InkStroke) -> HRESULT,
    fn SetDefaultDrawingAttributes(&self, drawingAttributes: *mut InkDrawingAttributes) -> HRESULT
}}
impl IInkStrokeBuilder {
    #[inline] pub fn begin_stroke(&self, pointerPoint: &super::PointerPoint) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).BeginStroke)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn append_to_stroke(&self, pointerPoint: &super::PointerPoint) -> Result<Option<ComPtr<super::PointerPoint>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AppendToStroke)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn end_stroke(&self, pointerPoint: &super::PointerPoint) -> Result<Option<ComPtr<InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).EndStroke)(self as *const _ as *mut _, pointerPoint as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_stroke(&self, points: &foundation::collections::IIterable<foundation::Point>) -> Result<Option<ComPtr<InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateStroke)(self as *const _ as *mut _, points as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_drawing_attributes(&self, drawingAttributes: &InkDrawingAttributes) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDefaultDrawingAttributes)(self as *const _ as *mut _, drawingAttributes as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStrokeBuilder: IInkStrokeBuilder}
impl RtActivatable<IActivationFactory> for InkStrokeBuilder {}
DEFINE_CLSID!(InkStrokeBuilder(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,83,116,114,111,107,101,66,117,105,108,100,101,114,0]) [CLSID_InkStrokeBuilder]);
DEFINE_IID!(IID_IInkStrokeBuilder2, 3179461671, 29471, 19644, 187, 191, 109, 70, 128, 68, 241, 229);
RT_INTERFACE!{interface IInkStrokeBuilder2(IInkStrokeBuilder2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeBuilder2] {
    fn CreateStrokeFromInkPoints(&self, inkPoints: *mut foundation::collections::IIterable<InkPoint>, transform: foundation::numerics::Matrix3x2, out: *mut *mut InkStroke) -> HRESULT
}}
impl IInkStrokeBuilder2 {
    #[inline] pub fn create_stroke_from_ink_points(&self, inkPoints: &foundation::collections::IIterable<InkPoint>, transform: foundation::numerics::Matrix3x2) -> Result<Option<ComPtr<InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateStrokeFromInkPoints)(self as *const _ as *mut _, inkPoints as *const _ as *mut _, transform, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkStrokeBuilder3, 2999394253, 21618, 18097, 168, 29, 195, 122, 61, 22, 148, 65);
RT_INTERFACE!{interface IInkStrokeBuilder3(IInkStrokeBuilder3Vtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeBuilder3] {
    fn CreateStrokeFromInkPoints(&self, inkPoints: *mut foundation::collections::IIterable<InkPoint>, transform: foundation::numerics::Matrix3x2, strokeStartedTime: *mut foundation::IReference<foundation::DateTime>, strokeDuration: *mut foundation::IReference<foundation::TimeSpan>, out: *mut *mut InkStroke) -> HRESULT
}}
impl IInkStrokeBuilder3 {
    #[inline] pub fn create_stroke_from_ink_points(&self, inkPoints: &foundation::collections::IIterable<InkPoint>, transform: foundation::numerics::Matrix3x2, strokeStartedTime: &foundation::IReference<foundation::DateTime>, strokeDuration: &foundation::IReference<foundation::TimeSpan>) -> Result<Option<ComPtr<InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateStrokeFromInkPoints)(self as *const _ as *mut _, inkPoints as *const _ as *mut _, transform, strokeStartedTime as *const _ as *mut _, strokeDuration as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkStrokeContainer, 581749702, 64169, 20244, 182, 140, 246, 206, 230, 112, 174, 22);
RT_INTERFACE!{interface IInkStrokeContainer(IInkStrokeContainerVtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeContainer] {
    fn get_BoundingRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn AddStroke(&self, stroke: *mut InkStroke) -> HRESULT,
    fn DeleteSelected(&self, out: *mut foundation::Rect) -> HRESULT,
    fn MoveSelected(&self, translation: foundation::Point, out: *mut foundation::Rect) -> HRESULT,
    fn SelectWithPolyLine(&self, polyline: *mut foundation::collections::IIterable<foundation::Point>, out: *mut foundation::Rect) -> HRESULT,
    fn SelectWithLine(&self, from: foundation::Point, to: foundation::Point, out: *mut foundation::Rect) -> HRESULT,
    fn CopySelectedToClipboard(&self) -> HRESULT,
    fn PasteFromClipboard(&self, position: foundation::Point, out: *mut foundation::Rect) -> HRESULT,
    fn CanPasteFromClipboard(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn LoadAsync(&self, inputStream: *mut crate::windows::storage::streams::IInputStream, out: *mut *mut foundation::IAsyncActionWithProgress<u64>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn SaveAsync(&self, outputStream: *mut crate::windows::storage::streams::IOutputStream, out: *mut *mut foundation::IAsyncOperationWithProgress<u32, u32>) -> HRESULT,
    fn UpdateRecognitionResults(&self, recognitionResults: *mut foundation::collections::IVectorView<InkRecognitionResult>) -> HRESULT,
    fn GetStrokes(&self, out: *mut *mut foundation::collections::IVectorView<InkStroke>) -> HRESULT,
    fn GetRecognitionResults(&self, out: *mut *mut foundation::collections::IVectorView<InkRecognitionResult>) -> HRESULT
}}
impl IInkStrokeContainer {
    #[inline] pub fn get_bounding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BoundingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_stroke(&self, stroke: &InkStroke) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddStroke)(self as *const _ as *mut _, stroke as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn delete_selected(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).DeleteSelected)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_selected(&self, translation: foundation::Point) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveSelected)(self as *const _ as *mut _, translation, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn select_with_poly_line(&self, polyline: &foundation::collections::IIterable<foundation::Point>) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).SelectWithPolyLine)(self as *const _ as *mut _, polyline as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn select_with_line(&self, from: foundation::Point, to: foundation::Point) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).SelectWithLine)(self as *const _ as *mut _, from, to, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn copy_selected_to_clipboard(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).CopySelectedToClipboard)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn paste_from_clipboard(&self, position: foundation::Point) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).PasteFromClipboard)(self as *const _ as *mut _, position, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn can_paste_from_clipboard(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanPasteFromClipboard)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn load_async(&self, inputStream: &crate::windows::storage::streams::IInputStream) -> Result<ComPtr<foundation::IAsyncActionWithProgress<u64>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadAsync)(self as *const _ as *mut _, inputStream as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn save_async(&self, outputStream: &crate::windows::storage::streams::IOutputStream) -> Result<ComPtr<foundation::IAsyncOperationWithProgress<u32, u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, outputStream as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_recognition_results(&self, recognitionResults: &foundation::collections::IVectorView<InkRecognitionResult>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).UpdateRecognitionResults)(self as *const _ as *mut _, recognitionResults as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_strokes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkStroke>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStrokes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_recognition_results(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkRecognitionResult>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRecognitionResults)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStrokeContainer: IInkStrokeContainer}
impl RtActivatable<IActivationFactory> for InkStrokeContainer {}
DEFINE_CLSID!(InkStrokeContainer(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,73,110,107,83,116,114,111,107,101,67,111,110,116,97,105,110,101,114,0]) [CLSID_InkStrokeContainer]);
DEFINE_IID!(IID_IInkStrokeContainer2, 2298598244, 55862, 19407, 158, 92, 209, 149, 130, 89, 149, 180);
RT_INTERFACE!{interface IInkStrokeContainer2(IInkStrokeContainer2Vtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeContainer2] {
    fn AddStrokes(&self, strokes: *mut foundation::collections::IIterable<InkStroke>) -> HRESULT,
    fn Clear(&self) -> HRESULT
}}
impl IInkStrokeContainer2 {
    #[inline] pub fn add_strokes(&self, strokes: &foundation::collections::IIterable<InkStroke>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddStrokes)(self as *const _ as *mut _, strokes as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkStrokeContainer3, 1023917733, 47850, 19586, 167, 25, 123, 131, 218, 16, 103, 210);
RT_INTERFACE!{interface IInkStrokeContainer3(IInkStrokeContainer3Vtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeContainer3] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn SaveWithFormatAsync(&self, outputStream: *mut crate::windows::storage::streams::IOutputStream, inkPersistenceFormat: InkPersistenceFormat, out: *mut *mut foundation::IAsyncOperationWithProgress<u32, u32>) -> HRESULT,
    fn GetStrokeById(&self, id: u32, out: *mut *mut InkStroke) -> HRESULT
}}
impl IInkStrokeContainer3 {
    #[cfg(feature="windows-storage")] #[inline] pub fn save_with_format_async(&self, outputStream: &crate::windows::storage::streams::IOutputStream, inkPersistenceFormat: InkPersistenceFormat) -> Result<ComPtr<foundation::IAsyncOperationWithProgress<u32, u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveWithFormatAsync)(self as *const _ as *mut _, outputStream as *const _ as *mut _, inkPersistenceFormat, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_by_id(&self, id: u32) -> Result<Option<ComPtr<InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStrokeById)(self as *const _ as *mut _, id, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInkStrokeInput, 3476029051, 24080, 17350, 160, 128, 136, 242, 110, 29, 198, 125);
RT_INTERFACE!{interface IInkStrokeInput(IInkStrokeInputVtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeInput] {
    fn add_StrokeStarted(&self, handler: *mut foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StrokeStarted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StrokeContinued(&self, handler: *mut foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StrokeContinued(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StrokeEnded(&self, handler: *mut foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StrokeEnded(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StrokeCanceled(&self, handler: *mut foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StrokeCanceled(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_InkPresenter(&self, out: *mut *mut InkPresenter) -> HRESULT
}}
impl IInkStrokeInput {
    #[inline] pub fn add_stroke_started(&self, handler: &foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StrokeStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stroke_started(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_StrokeStarted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stroke_continued(&self, handler: &foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StrokeContinued)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stroke_continued(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_StrokeContinued)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stroke_ended(&self, handler: &foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StrokeEnded)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stroke_ended(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_StrokeEnded)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stroke_canceled(&self, handler: &foundation::TypedEventHandler<InkStrokeInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StrokeCanceled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stroke_canceled(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_StrokeCanceled)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ink_presenter(&self) -> Result<Option<ComPtr<InkPresenter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkPresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStrokeInput: IInkStrokeInput}
DEFINE_IID!(IID_IInkStrokeRenderingSegment, 1750142751, 35043, 18298, 162, 250, 86, 159, 95, 31, 155, 213);
RT_INTERFACE!{interface IInkStrokeRenderingSegment(IInkStrokeRenderingSegmentVtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokeRenderingSegment] {
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_BezierControlPoint1(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_BezierControlPoint2(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Pressure(&self, out: *mut f32) -> HRESULT,
    fn get_TiltX(&self, out: *mut f32) -> HRESULT,
    fn get_TiltY(&self, out: *mut f32) -> HRESULT,
    fn get_Twist(&self, out: *mut f32) -> HRESULT
}}
impl IInkStrokeRenderingSegment {
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bezier_control_point1(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BezierControlPoint1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bezier_control_point2(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BezierControlPoint2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pressure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tilt_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tilt_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_twist(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Twist)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStrokeRenderingSegment: IInkStrokeRenderingSegment}
DEFINE_IID!(IID_IInkStrokesCollectedEventArgs, 3304321577, 6456, 18780, 180, 217, 109, 228, 176, 141, 72, 17);
RT_INTERFACE!{interface IInkStrokesCollectedEventArgs(IInkStrokesCollectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokesCollectedEventArgs] {
    fn get_Strokes(&self, out: *mut *mut foundation::collections::IVectorView<InkStroke>) -> HRESULT
}}
impl IInkStrokesCollectedEventArgs {
    #[inline] pub fn get_strokes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkStroke>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Strokes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStrokesCollectedEventArgs: IInkStrokesCollectedEventArgs}
DEFINE_IID!(IID_IInkStrokesErasedEventArgs, 2753653282, 5379, 20159, 143, 245, 45, 232, 69, 132, 168, 170);
RT_INTERFACE!{interface IInkStrokesErasedEventArgs(IInkStrokesErasedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInkStrokesErasedEventArgs] {
    fn get_Strokes(&self, out: *mut *mut foundation::collections::IVectorView<InkStroke>) -> HRESULT
}}
impl IInkStrokesErasedEventArgs {
    #[inline] pub fn get_strokes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkStroke>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Strokes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkStrokesErasedEventArgs: IInkStrokesErasedEventArgs}
DEFINE_IID!(IID_IInkSynchronizer, 2610864480, 44699, 17913, 132, 7, 75, 73, 59, 22, 54, 97);
RT_INTERFACE!{interface IInkSynchronizer(IInkSynchronizerVtbl): IInspectable(IInspectableVtbl) [IID_IInkSynchronizer] {
    fn BeginDry(&self, out: *mut *mut foundation::collections::IVectorView<InkStroke>) -> HRESULT,
    fn EndDry(&self) -> HRESULT
}}
impl IInkSynchronizer {
    #[inline] pub fn begin_dry(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<InkStroke>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).BeginDry)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn end_dry(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EndDry)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InkSynchronizer: IInkSynchronizer}
DEFINE_IID!(IID_IInkUnprocessedInput, 3678684640, 33688, 18721, 172, 59, 171, 151, 140, 91, 162, 86);
RT_INTERFACE!{interface IInkUnprocessedInput(IInkUnprocessedInputVtbl): IInspectable(IInspectableVtbl) [IID_IInkUnprocessedInput] {
    fn add_PointerEntered(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerEntered(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerHovered(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerHovered(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerExited(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerExited(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerPressed(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerPressed(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerMoved(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerMoved(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerReleased(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerReleased(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerLost(&self, handler: *mut foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerLost(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_InkPresenter(&self, out: *mut *mut InkPresenter) -> HRESULT
}}
impl IInkUnprocessedInput {
    #[inline] pub fn add_pointer_entered(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerEntered)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_entered(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerEntered)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_hovered(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerHovered)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_hovered(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerHovered)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_exited(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerExited)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_exited(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerExited)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_pressed(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerPressed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_pressed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerPressed)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_moved(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerMoved)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_moved(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerMoved)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_released(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerReleased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_released(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerReleased)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_lost(&self, handler: &foundation::TypedEventHandler<InkUnprocessedInput, super::super::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerLost)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_lost(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerLost)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ink_presenter(&self) -> Result<Option<ComPtr<InkPresenter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkPresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkUnprocessedInput: IInkUnprocessedInput}
DEFINE_IID!(IID_IPenAndInkSettings, 3157060495, 102, 17576, 187, 122, 184, 57, 179, 222, 184, 245);
RT_INTERFACE!{interface IPenAndInkSettings(IPenAndInkSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IPenAndInkSettings] {
    fn get_IsHandwritingDirectlyIntoTextFieldEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_PenHandedness(&self, out: *mut PenHandedness) -> HRESULT,
    fn get_HandwritingLineHeight(&self, out: *mut HandwritingLineHeight) -> HRESULT,
    fn get_FontFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserConsentsToHandwritingTelemetryCollection(&self, out: *mut bool) -> HRESULT,
    fn get_IsTouchHandwritingEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IPenAndInkSettings {
    #[inline] pub fn get_is_handwriting_directly_into_text_field_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHandwritingDirectlyIntoTextFieldEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pen_handedness(&self) -> Result<PenHandedness> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PenHandedness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_handwriting_line_height(&self) -> Result<HandwritingLineHeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HandwritingLineHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_font_family_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FontFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_consents_to_handwriting_telemetry_collection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UserConsentsToHandwritingTelemetryCollection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_touch_handwriting_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTouchHandwritingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PenAndInkSettings: IPenAndInkSettings}
impl RtActivatable<IPenAndInkSettingsStatics> for PenAndInkSettings {}
impl PenAndInkSettings {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<PenAndInkSettings>>> {
        <Self as RtActivatable<IPenAndInkSettingsStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(PenAndInkSettings(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,80,101,110,65,110,100,73,110,107,83,101,116,116,105,110,103,115,0]) [CLSID_PenAndInkSettings]);
DEFINE_IID!(IID_IPenAndInkSettingsStatics, 3983396918, 22280, 23612, 150, 219, 242, 245, 82, 234, 182, 65);
RT_INTERFACE!{static interface IPenAndInkSettingsStatics(IPenAndInkSettingsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPenAndInkSettingsStatics] {
    fn GetDefault(&self, out: *mut *mut PenAndInkSettings) -> HRESULT
}}
impl IPenAndInkSettingsStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<PenAndInkSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PenHandedness: i32 {
    Right = 0, Left = 1,
}}
RT_ENUM! { enum PenTipShape: i32 {
    Circle = 0, Rectangle = 1,
}}
pub mod analysis { // Windows.UI.Input.Inking.Analysis
use crate::prelude::*;
RT_ENUM! { enum InkAnalysisDrawingKind: i32 {
    Drawing = 0, Circle = 1, Ellipse = 2, Triangle = 3, IsoscelesTriangle = 4, EquilateralTriangle = 5, RightTriangle = 6, Quadrilateral = 7, Rectangle = 8, Square = 9, Diamond = 10, Trapezoid = 11, Parallelogram = 12, Pentagon = 13, Hexagon = 14,
}}
DEFINE_IID!(IID_IInkAnalysisInkBullet, 3993277288, 24848, 16694, 149, 249, 238, 128, 159, 194, 0, 48);
RT_INTERFACE!{interface IInkAnalysisInkBullet(IInkAnalysisInkBulletVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisInkBullet] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT
}}
impl IInkAnalysisInkBullet {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisInkBullet: IInkAnalysisInkBullet}
DEFINE_IID!(IID_IInkAnalysisInkDrawing, 1787161887, 8164, 19989, 137, 140, 142, 17, 35, 119, 224, 33);
RT_INTERFACE!{interface IInkAnalysisInkDrawing(IInkAnalysisInkDrawingVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisInkDrawing] {
    fn get_DrawingKind(&self, out: *mut InkAnalysisDrawingKind) -> HRESULT,
    fn get_Center(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_Points(&self, out: *mut *mut foundation::collections::IVectorView<foundation::Point>) -> HRESULT
}}
impl IInkAnalysisInkDrawing {
    #[inline] pub fn get_drawing_kind(&self) -> Result<InkAnalysisDrawingKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DrawingKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_center(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Center)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_points(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<foundation::Point>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Points)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisInkDrawing: IInkAnalysisInkDrawing}
DEFINE_IID!(IID_IInkAnalysisInkWord, 1272064173, 33711, 16436, 143, 59, 248, 104, 125, 255, 244, 54);
RT_INTERFACE!{interface IInkAnalysisInkWord(IInkAnalysisInkWordVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisInkWord] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TextAlternates(&self, out: *mut *mut foundation::collections::IVectorView<HString>) -> HRESULT
}}
impl IInkAnalysisInkWord {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_alternates(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextAlternates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisInkWord: IInkAnalysisInkWord}
DEFINE_IID!(IID_IInkAnalysisLine, 2691499149, 11149, 18260, 173, 90, 208, 135, 17, 147, 169, 86);
RT_INTERFACE!{interface IInkAnalysisLine(IInkAnalysisLineVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisLine] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IndentLevel(&self, out: *mut i32) -> HRESULT
}}
impl IInkAnalysisLine {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_indent_level(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IndentLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisLine: IInkAnalysisLine}
DEFINE_IID!(IID_IInkAnalysisListItem, 3034825279, 50371, 19514, 161, 166, 157, 133, 84, 126, 229, 134);
RT_INTERFACE!{interface IInkAnalysisListItem(IInkAnalysisListItemVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisListItem] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT
}}
impl IInkAnalysisListItem {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisListItem: IInkAnalysisListItem}
DEFINE_IID!(IID_IInkAnalysisNode, 813899525, 24420, 18988, 186, 55, 79, 72, 135, 135, 149, 116);
RT_INTERFACE!{interface IInkAnalysisNode(IInkAnalysisNodeVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisNode] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_Kind(&self, out: *mut InkAnalysisNodeKind) -> HRESULT,
    fn get_BoundingRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_RotatedBoundingRect(&self, out: *mut *mut foundation::collections::IVectorView<foundation::Point>) -> HRESULT,
    fn get_Children(&self, out: *mut *mut foundation::collections::IVectorView<IInkAnalysisNode>) -> HRESULT,
    fn get_Parent(&self, out: *mut *mut IInkAnalysisNode) -> HRESULT,
    fn GetStrokeIds(&self, out: *mut *mut foundation::collections::IVectorView<u32>) -> HRESULT
}}
impl IInkAnalysisNode {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<InkAnalysisNodeKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bounding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BoundingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rotated_bounding_rect(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<foundation::Point>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RotatedBoundingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_children(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<IInkAnalysisNode>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent(&self) -> Result<Option<ComPtr<IInkAnalysisNode>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Parent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_stroke_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStrokeIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisNode: IInkAnalysisNode}
RT_ENUM! { enum InkAnalysisNodeKind: i32 {
    UnclassifiedInk = 0, Root = 1, WritingRegion = 2, Paragraph = 3, Line = 4, InkWord = 5, InkBullet = 6, InkDrawing = 7, ListItem = 8,
}}
DEFINE_IID!(IID_IInkAnalysisParagraph, 3651994716, 3281, 19924, 166, 139, 235, 31, 18, 179, 215, 39);
RT_INTERFACE!{interface IInkAnalysisParagraph(IInkAnalysisParagraphVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisParagraph] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT
}}
impl IInkAnalysisParagraph {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisParagraph: IInkAnalysisParagraph}
DEFINE_IID!(IID_IInkAnalysisResult, 2303244921, 41539, 19107, 162, 148, 31, 152, 189, 15, 245, 128);
RT_INTERFACE!{interface IInkAnalysisResult(IInkAnalysisResultVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisResult] {
    fn get_Status(&self, out: *mut InkAnalysisStatus) -> HRESULT
}}
impl IInkAnalysisResult {
    #[inline] pub fn get_status(&self) -> Result<InkAnalysisStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisResult: IInkAnalysisResult}
DEFINE_IID!(IID_IInkAnalysisRoot, 1068934084, 12254, 16481, 133, 2, 169, 15, 50, 84, 91, 132);
RT_INTERFACE!{interface IInkAnalysisRoot(IInkAnalysisRootVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisRoot] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT,
    fn FindNodes(&self, nodeKind: InkAnalysisNodeKind, out: *mut *mut foundation::collections::IVectorView<IInkAnalysisNode>) -> HRESULT
}}
impl IInkAnalysisRoot {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_nodes(&self, nodeKind: InkAnalysisNodeKind) -> Result<Option<ComPtr<foundation::collections::IVectorView<IInkAnalysisNode>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindNodes)(self as *const _ as *mut _, nodeKind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisRoot: IInkAnalysisRoot}
RT_ENUM! { enum InkAnalysisStatus: i32 {
    Updated = 0, Unchanged = 1,
}}
RT_ENUM! { enum InkAnalysisStrokeKind: i32 {
    Auto = 0, Writing = 1, Drawing = 2,
}}
DEFINE_IID!(IID_IInkAnalysisWritingRegion, 3714933297, 48406, 18019, 181, 174, 148, 29, 48, 67, 239, 91);
RT_INTERFACE!{interface IInkAnalysisWritingRegion(IInkAnalysisWritingRegionVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalysisWritingRegion] {
    fn get_RecognizedText(&self, out: *mut HSTRING) -> HRESULT
}}
impl IInkAnalysisWritingRegion {
    #[inline] pub fn get_recognized_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecognizedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalysisWritingRegion: IInkAnalysisWritingRegion}
DEFINE_IID!(IID_IInkAnalyzer, 4046163861, 2150, 19909, 140, 119, 248, 134, 20, 223, 227, 140);
RT_INTERFACE!{interface IInkAnalyzer(IInkAnalyzerVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalyzer] {
    fn get_AnalysisRoot(&self, out: *mut *mut InkAnalysisRoot) -> HRESULT,
    fn get_IsAnalyzing(&self, out: *mut bool) -> HRESULT,
    fn AddDataForStroke(&self, stroke: *mut super::InkStroke) -> HRESULT,
    fn AddDataForStrokes(&self, strokes: *mut foundation::collections::IIterable<super::InkStroke>) -> HRESULT,
    fn ClearDataForAllStrokes(&self) -> HRESULT,
    fn RemoveDataForStroke(&self, strokeId: u32) -> HRESULT,
    fn RemoveDataForStrokes(&self, strokeIds: *mut foundation::collections::IIterable<u32>) -> HRESULT,
    fn ReplaceDataForStroke(&self, stroke: *mut super::InkStroke) -> HRESULT,
    fn SetStrokeDataKind(&self, strokeId: u32, strokeKind: InkAnalysisStrokeKind) -> HRESULT,
    fn AnalyzeAsync(&self, out: *mut *mut foundation::IAsyncOperation<InkAnalysisResult>) -> HRESULT
}}
impl IInkAnalyzer {
    #[inline] pub fn get_analysis_root(&self) -> Result<Option<ComPtr<InkAnalysisRoot>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnalysisRoot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_analyzing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAnalyzing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_data_for_stroke(&self, stroke: &super::InkStroke) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddDataForStroke)(self as *const _ as *mut _, stroke as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_data_for_strokes(&self, strokes: &foundation::collections::IIterable<super::InkStroke>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddDataForStrokes)(self as *const _ as *mut _, strokes as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_data_for_all_strokes(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearDataForAllStrokes)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_for_stroke(&self, strokeId: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveDataForStroke)(self as *const _ as *mut _, strokeId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_for_strokes(&self, strokeIds: &foundation::collections::IIterable<u32>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveDataForStrokes)(self as *const _ as *mut _, strokeIds as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn replace_data_for_stroke(&self, stroke: &super::InkStroke) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ReplaceDataForStroke)(self as *const _ as *mut _, stroke as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_stroke_data_kind(&self, strokeId: u32, strokeKind: InkAnalysisStrokeKind) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetStrokeDataKind)(self as *const _ as *mut _, strokeId, strokeKind);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn analyze_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<InkAnalysisResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AnalyzeAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InkAnalyzer: IInkAnalyzer}
impl RtActivatable<IActivationFactory> for InkAnalyzer {}
DEFINE_CLSID!(InkAnalyzer(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,65,110,97,108,121,115,105,115,46,73,110,107,65,110,97,108,121,122,101,114,0]) [CLSID_InkAnalyzer]);
DEFINE_IID!(IID_IInkAnalyzerFactory, 689145478, 6499, 18904, 149, 137, 225, 67, 132, 199, 105, 227);
RT_INTERFACE!{interface IInkAnalyzerFactory(IInkAnalyzerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInkAnalyzerFactory] {
    fn CreateAnalyzer(&self, out: *mut *mut InkAnalyzer) -> HRESULT
}}
impl IInkAnalyzerFactory {
    #[inline] pub fn create_analyzer(&self) -> Result<Option<ComPtr<InkAnalyzer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAnalyzer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Input.Inking.Analysis
pub mod core { // Windows.UI.Input.Inking.Core
use crate::prelude::*;
DEFINE_IID!(IID_ICoreIncrementalInkStroke, 4255126995, 40294, 20349, 165, 127, 204, 112, 185, 207, 170, 118);
RT_INTERFACE!{interface ICoreIncrementalInkStroke(ICoreIncrementalInkStrokeVtbl): IInspectable(IInspectableVtbl) [IID_ICoreIncrementalInkStroke] {
    fn AppendInkPoints(&self, inkPoints: *mut foundation::collections::IIterable<super::InkPoint>, out: *mut foundation::Rect) -> HRESULT,
    fn CreateInkStroke(&self, out: *mut *mut super::InkStroke) -> HRESULT,
    fn get_DrawingAttributes(&self, out: *mut *mut super::InkDrawingAttributes) -> HRESULT,
    fn get_PointTransform(&self, out: *mut foundation::numerics::Matrix3x2) -> HRESULT,
    fn get_BoundingRect(&self, out: *mut foundation::Rect) -> HRESULT
}}
impl ICoreIncrementalInkStroke {
    #[inline] pub fn append_ink_points(&self, inkPoints: &foundation::collections::IIterable<super::InkPoint>) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).AppendInkPoints)(self as *const _ as *mut _, inkPoints as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_ink_stroke(&self) -> Result<Option<ComPtr<super::InkStroke>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInkStroke)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_drawing_attributes(&self) -> Result<Option<ComPtr<super::InkDrawingAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DrawingAttributes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_point_transform(&self) -> Result<foundation::numerics::Matrix3x2> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointTransform)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bounding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BoundingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreIncrementalInkStroke: ICoreIncrementalInkStroke}
impl RtActivatable<ICoreIncrementalInkStrokeFactory> for CoreIncrementalInkStroke {}
impl CoreIncrementalInkStroke {
    #[inline] pub fn create(drawingAttributes: &super::InkDrawingAttributes, pointTransform: foundation::numerics::Matrix3x2) -> Result<ComPtr<CoreIncrementalInkStroke>> {
        <Self as RtActivatable<ICoreIncrementalInkStrokeFactory>>::get_activation_factory().create(drawingAttributes, pointTransform)
    }
}
DEFINE_CLSID!(CoreIncrementalInkStroke(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,67,111,114,101,46,67,111,114,101,73,110,99,114,101,109,101,110,116,97,108,73,110,107,83,116,114,111,107,101,0]) [CLSID_CoreIncrementalInkStroke]);
DEFINE_IID!(IID_ICoreIncrementalInkStrokeFactory, 3620052806, 36264, 20336, 151, 81, 229, 59, 182, 223, 69, 150);
RT_INTERFACE!{static interface ICoreIncrementalInkStrokeFactory(ICoreIncrementalInkStrokeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ICoreIncrementalInkStrokeFactory] {
    fn Create(&self, drawingAttributes: *mut super::InkDrawingAttributes, pointTransform: foundation::numerics::Matrix3x2, out: *mut *mut CoreIncrementalInkStroke) -> HRESULT
}}
impl ICoreIncrementalInkStrokeFactory {
    #[inline] pub fn create(&self, drawingAttributes: &super::InkDrawingAttributes, pointTransform: foundation::numerics::Matrix3x2) -> Result<ComPtr<CoreIncrementalInkStroke>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, drawingAttributes as *const _ as *mut _, pointTransform, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreInkIndependentInputSource, 968068521, 30265, 17561, 165, 181, 25, 29, 0, 227, 91, 22);
RT_INTERFACE!{interface ICoreInkIndependentInputSource(ICoreInkIndependentInputSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInkIndependentInputSource] {
    fn add_PointerEntering(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerEntering(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerHovering(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerHovering(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerExiting(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerExiting(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerPressing(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerPressing(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerMoving(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerMoving(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerReleasing(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerReleasing(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PointerLost(&self, handler: *mut foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PointerLost(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_InkPresenter(&self, out: *mut *mut super::InkPresenter) -> HRESULT
}}
impl ICoreInkIndependentInputSource {
    #[inline] pub fn add_pointer_entering(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerEntering)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_entering(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerEntering)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_hovering(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerHovering)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_hovering(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerHovering)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_exiting(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerExiting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_exiting(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerExiting)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_pressing(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerPressing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_pressing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerPressing)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_moving(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerMoving)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_moving(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerMoving)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_releasing(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerReleasing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_releasing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerReleasing)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pointer_lost(&self, handler: &foundation::TypedEventHandler<CoreInkIndependentInputSource, crate::windows::ui::core::PointerEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PointerLost)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pointer_lost(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_PointerLost)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ink_presenter(&self) -> Result<Option<ComPtr<super::InkPresenter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkPresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreInkIndependentInputSource: ICoreInkIndependentInputSource}
impl RtActivatable<ICoreInkIndependentInputSourceStatics> for CoreInkIndependentInputSource {}
impl CoreInkIndependentInputSource {
    #[inline] pub fn create(inkPresenter: &super::InkPresenter) -> Result<Option<ComPtr<CoreInkIndependentInputSource>>> {
        <Self as RtActivatable<ICoreInkIndependentInputSourceStatics>>::get_activation_factory().create(inkPresenter)
    }
}
DEFINE_CLSID!(CoreInkIndependentInputSource(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,67,111,114,101,46,67,111,114,101,73,110,107,73,110,100,101,112,101,110,100,101,110,116,73,110,112,117,116,83,111,117,114,99,101,0]) [CLSID_CoreInkIndependentInputSource]);
DEFINE_IID!(IID_ICoreInkIndependentInputSourceStatics, 1944453403, 32960, 19963, 155, 102, 16, 186, 127, 63, 156, 132);
RT_INTERFACE!{static interface ICoreInkIndependentInputSourceStatics(ICoreInkIndependentInputSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInkIndependentInputSourceStatics] {
    fn Create(&self, inkPresenter: *mut super::InkPresenter, out: *mut *mut CoreInkIndependentInputSource) -> HRESULT
}}
impl ICoreInkIndependentInputSourceStatics {
    #[inline] pub fn create(&self, inkPresenter: &super::InkPresenter) -> Result<Option<ComPtr<CoreInkIndependentInputSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, inkPresenter as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreInkPresenterHost, 963545574, 32085, 17943, 158, 88, 104, 199, 12, 145, 105, 185);
RT_INTERFACE!{interface ICoreInkPresenterHost(ICoreInkPresenterHostVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInkPresenterHost] {
    fn get_InkPresenter(&self, out: *mut *mut super::InkPresenter) -> HRESULT,
    fn get_RootVisual(&self, out: *mut *mut crate::windows::ui::composition::ContainerVisual) -> HRESULT,
    fn put_RootVisual(&self, value: *mut crate::windows::ui::composition::ContainerVisual) -> HRESULT
}}
impl ICoreInkPresenterHost {
    #[inline] pub fn get_ink_presenter(&self) -> Result<Option<ComPtr<super::InkPresenter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkPresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_root_visual(&self) -> Result<Option<ComPtr<crate::windows::ui::composition::ContainerVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RootVisual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_root_visual(&self, value: &crate::windows::ui::composition::ContainerVisual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RootVisual)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreInkPresenterHost: ICoreInkPresenterHost}
impl RtActivatable<IActivationFactory> for CoreInkPresenterHost {}
DEFINE_CLSID!(CoreInkPresenterHost(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,67,111,114,101,46,67,111,114,101,73,110,107,80,114,101,115,101,110,116,101,114,72,111,115,116,0]) [CLSID_CoreInkPresenterHost]);
RT_ENUM! { enum CoreWetStrokeDisposition: i32 {
    Inking = 0, Completed = 1, Canceled = 2,
}}
DEFINE_IID!(IID_ICoreWetStrokeUpdateEventArgs, 4211593548, 13184, 17786, 169, 135, 153, 19, 87, 137, 108, 27);
RT_INTERFACE!{interface ICoreWetStrokeUpdateEventArgs(ICoreWetStrokeUpdateEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWetStrokeUpdateEventArgs] {
    fn get_NewInkPoints(&self, out: *mut *mut foundation::collections::IVector<super::InkPoint>) -> HRESULT,
    fn get_PointerId(&self, out: *mut u32) -> HRESULT,
    fn get_Disposition(&self, out: *mut CoreWetStrokeDisposition) -> HRESULT,
    fn put_Disposition(&self, value: CoreWetStrokeDisposition) -> HRESULT
}}
impl ICoreWetStrokeUpdateEventArgs {
    #[inline] pub fn get_new_ink_points(&self) -> Result<Option<ComPtr<foundation::collections::IVector<super::InkPoint>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewInkPoints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_disposition(&self) -> Result<CoreWetStrokeDisposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Disposition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_disposition(&self, value: CoreWetStrokeDisposition) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Disposition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWetStrokeUpdateEventArgs: ICoreWetStrokeUpdateEventArgs}
DEFINE_IID!(IID_ICoreWetStrokeUpdateSource, 527535650, 61010, 19968, 130, 9, 76, 62, 91, 33, 163, 204);
RT_INTERFACE!{interface ICoreWetStrokeUpdateSource(ICoreWetStrokeUpdateSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWetStrokeUpdateSource] {
    fn add_WetStrokeStarting(&self, handler: *mut foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WetStrokeStarting(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WetStrokeContinuing(&self, handler: *mut foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WetStrokeContinuing(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WetStrokeStopping(&self, handler: *mut foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WetStrokeStopping(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WetStrokeCompleted(&self, handler: *mut foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WetStrokeCompleted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WetStrokeCanceled(&self, handler: *mut foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WetStrokeCanceled(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_InkPresenter(&self, out: *mut *mut super::InkPresenter) -> HRESULT
}}
impl ICoreWetStrokeUpdateSource {
    #[inline] pub fn add_wet_stroke_starting(&self, handler: &foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_WetStrokeStarting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_wet_stroke_starting(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_WetStrokeStarting)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_wet_stroke_continuing(&self, handler: &foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_WetStrokeContinuing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_wet_stroke_continuing(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_WetStrokeContinuing)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_wet_stroke_stopping(&self, handler: &foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_WetStrokeStopping)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_wet_stroke_stopping(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_WetStrokeStopping)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_wet_stroke_completed(&self, handler: &foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_WetStrokeCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_wet_stroke_completed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_WetStrokeCompleted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_wet_stroke_canceled(&self, handler: &foundation::TypedEventHandler<CoreWetStrokeUpdateSource, CoreWetStrokeUpdateEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_WetStrokeCanceled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_wet_stroke_canceled(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_WetStrokeCanceled)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ink_presenter(&self) -> Result<Option<ComPtr<super::InkPresenter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InkPresenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreWetStrokeUpdateSource: ICoreWetStrokeUpdateSource}
impl RtActivatable<ICoreWetStrokeUpdateSourceStatics> for CoreWetStrokeUpdateSource {}
impl CoreWetStrokeUpdateSource {
    #[inline] pub fn create(inkPresenter: &super::InkPresenter) -> Result<Option<ComPtr<CoreWetStrokeUpdateSource>>> {
        <Self as RtActivatable<ICoreWetStrokeUpdateSourceStatics>>::get_activation_factory().create(inkPresenter)
    }
}
DEFINE_CLSID!(CoreWetStrokeUpdateSource(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,67,111,114,101,46,67,111,114,101,87,101,116,83,116,114,111,107,101,85,112,100,97,116,101,83,111,117,114,99,101,0]) [CLSID_CoreWetStrokeUpdateSource]);
DEFINE_IID!(IID_ICoreWetStrokeUpdateSourceStatics, 1034788026, 7485, 18094, 171, 157, 134, 71, 72, 108, 111, 144);
RT_INTERFACE!{static interface ICoreWetStrokeUpdateSourceStatics(ICoreWetStrokeUpdateSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreWetStrokeUpdateSourceStatics] {
    fn Create(&self, inkPresenter: *mut super::InkPresenter, out: *mut *mut CoreWetStrokeUpdateSource) -> HRESULT
}}
impl ICoreWetStrokeUpdateSourceStatics {
    #[inline] pub fn create(&self, inkPresenter: &super::InkPresenter) -> Result<Option<ComPtr<CoreWetStrokeUpdateSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, inkPresenter as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Input.Inking.Core
pub mod preview { // Windows.UI.Input.Inking.Preview
use crate::prelude::*;
DEFINE_IID!(IID_IPalmRejectionDelayZonePreview, 1656002251, 21405, 21315, 166, 95, 65, 245, 48, 14, 199, 12);
RT_INTERFACE!{interface IPalmRejectionDelayZonePreview(IPalmRejectionDelayZonePreviewVtbl): IInspectable(IInspectableVtbl) [IID_IPalmRejectionDelayZonePreview] {
    
}}
RT_CLASS!{class PalmRejectionDelayZonePreview: IPalmRejectionDelayZonePreview}
impl RtActivatable<IPalmRejectionDelayZonePreviewStatics> for PalmRejectionDelayZonePreview {}
impl PalmRejectionDelayZonePreview {
    #[inline] pub fn create_for_visual(inputPanelVisual: &crate::windows::ui::composition::Visual, inputPanelRect: foundation::Rect) -> Result<Option<ComPtr<PalmRejectionDelayZonePreview>>> {
        <Self as RtActivatable<IPalmRejectionDelayZonePreviewStatics>>::get_activation_factory().create_for_visual(inputPanelVisual, inputPanelRect)
    }
    #[inline] pub fn create_for_visual_with_viewport_clip(inputPanelVisual: &crate::windows::ui::composition::Visual, inputPanelRect: foundation::Rect, viewportVisual: &crate::windows::ui::composition::Visual, viewportRect: foundation::Rect) -> Result<Option<ComPtr<PalmRejectionDelayZonePreview>>> {
        <Self as RtActivatable<IPalmRejectionDelayZonePreviewStatics>>::get_activation_factory().create_for_visual_with_viewport_clip(inputPanelVisual, inputPanelRect, viewportVisual, viewportRect)
    }
}
DEFINE_CLSID!(PalmRejectionDelayZonePreview(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,73,110,107,105,110,103,46,80,114,101,118,105,101,119,46,80,97,108,109,82,101,106,101,99,116,105,111,110,68,101,108,97,121,90,111,110,101,80,114,101,118,105,101,119,0]) [CLSID_PalmRejectionDelayZonePreview]);
DEFINE_IID!(IID_IPalmRejectionDelayZonePreviewStatics, 3455016672, 37840, 21417, 143, 14, 154, 55, 159, 143, 117, 48);
RT_INTERFACE!{static interface IPalmRejectionDelayZonePreviewStatics(IPalmRejectionDelayZonePreviewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPalmRejectionDelayZonePreviewStatics] {
    fn CreateForVisual(&self, inputPanelVisual: *mut crate::windows::ui::composition::Visual, inputPanelRect: foundation::Rect, out: *mut *mut PalmRejectionDelayZonePreview) -> HRESULT,
    fn CreateForVisualWithViewportClip(&self, inputPanelVisual: *mut crate::windows::ui::composition::Visual, inputPanelRect: foundation::Rect, viewportVisual: *mut crate::windows::ui::composition::Visual, viewportRect: foundation::Rect, out: *mut *mut PalmRejectionDelayZonePreview) -> HRESULT
}}
impl IPalmRejectionDelayZonePreviewStatics {
    #[inline] pub fn create_for_visual(&self, inputPanelVisual: &crate::windows::ui::composition::Visual, inputPanelRect: foundation::Rect) -> Result<Option<ComPtr<PalmRejectionDelayZonePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateForVisual)(self as *const _ as *mut _, inputPanelVisual as *const _ as *mut _, inputPanelRect, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_for_visual_with_viewport_clip(&self, inputPanelVisual: &crate::windows::ui::composition::Visual, inputPanelRect: foundation::Rect, viewportVisual: &crate::windows::ui::composition::Visual, viewportRect: foundation::Rect) -> Result<Option<ComPtr<PalmRejectionDelayZonePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateForVisualWithViewportClip)(self as *const _ as *mut _, inputPanelVisual as *const _ as *mut _, inputPanelRect, viewportVisual as *const _ as *mut _, viewportRect, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Input.Inking.Preview
} // Windows.UI.Input.Inking
pub mod preview { // Windows.UI.Input.Preview
pub mod injection { // Windows.UI.Input.Preview.Injection
use crate::prelude::*;
RT_ENUM! { enum InjectedInputButtonChangeKind: i32 {
    None = 0, FirstButtonDown = 1, FirstButtonUp = 2, SecondButtonDown = 3, SecondButtonUp = 4, ThirdButtonDown = 5, ThirdButtonUp = 6, FourthButtonDown = 7, FourthButtonUp = 8, FifthButtonDown = 9, FifthButtonUp = 10,
}}
DEFINE_IID!(IID_IInjectedInputGamepadInfo, 548313663, 57105, 17778, 169, 171, 215, 91, 138, 94, 72, 173);
RT_INTERFACE!{interface IInjectedInputGamepadInfo(IInjectedInputGamepadInfoVtbl): IInspectable(IInspectableVtbl) [IID_IInjectedInputGamepadInfo] {
    #[cfg(not(feature="windows-gaming"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-gaming")] fn get_Buttons(&self, out: *mut crate::windows::gaming::input::GamepadButtons) -> HRESULT,
    #[cfg(not(feature="windows-gaming"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-gaming")] fn put_Buttons(&self, value: crate::windows::gaming::input::GamepadButtons) -> HRESULT,
    fn get_LeftThumbstickX(&self, out: *mut f64) -> HRESULT,
    fn put_LeftThumbstickX(&self, value: f64) -> HRESULT,
    fn get_LeftThumbstickY(&self, out: *mut f64) -> HRESULT,
    fn put_LeftThumbstickY(&self, value: f64) -> HRESULT,
    fn get_LeftTrigger(&self, out: *mut f64) -> HRESULT,
    fn put_LeftTrigger(&self, value: f64) -> HRESULT,
    fn get_RightThumbstickX(&self, out: *mut f64) -> HRESULT,
    fn put_RightThumbstickX(&self, value: f64) -> HRESULT,
    fn get_RightThumbstickY(&self, out: *mut f64) -> HRESULT,
    fn put_RightThumbstickY(&self, value: f64) -> HRESULT,
    fn get_RightTrigger(&self, out: *mut f64) -> HRESULT,
    fn put_RightTrigger(&self, value: f64) -> HRESULT
}}
impl IInjectedInputGamepadInfo {
    #[cfg(feature="windows-gaming")] #[inline] pub fn get_buttons(&self) -> Result<crate::windows::gaming::input::GamepadButtons> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Buttons)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-gaming")] #[inline] pub fn set_buttons(&self, value: crate::windows::gaming::input::GamepadButtons) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Buttons)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_thumbstick_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftThumbstickX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_thumbstick_x(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftThumbstickX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_thumbstick_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftThumbstickY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_thumbstick_y(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftThumbstickY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_trigger(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftTrigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_trigger(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftTrigger)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_thumbstick_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightThumbstickX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_thumbstick_x(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightThumbstickX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_thumbstick_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightThumbstickY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_thumbstick_y(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightThumbstickY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_trigger(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightTrigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_trigger(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightTrigger)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InjectedInputGamepadInfo: IInjectedInputGamepadInfo}
impl RtActivatable<IInjectedInputGamepadInfoFactory> for InjectedInputGamepadInfo {}
impl RtActivatable<IActivationFactory> for InjectedInputGamepadInfo {}
impl InjectedInputGamepadInfo {
    #[cfg(feature="windows-gaming")] #[inline] pub fn create_instance_from_gamepad_reading(reading: crate::windows::gaming::input::GamepadReading) -> Result<ComPtr<InjectedInputGamepadInfo>> {
        <Self as RtActivatable<IInjectedInputGamepadInfoFactory>>::get_activation_factory().create_instance_from_gamepad_reading(reading)
    }
}
DEFINE_CLSID!(InjectedInputGamepadInfo(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,73,110,106,101,99,116,105,111,110,46,73,110,106,101,99,116,101,100,73,110,112,117,116,71,97,109,101,112,97,100,73,110,102,111,0]) [CLSID_InjectedInputGamepadInfo]);
DEFINE_IID!(IID_IInjectedInputGamepadInfoFactory, 1499031670, 27705, 20164, 139, 42, 41, 239, 125, 225, 138, 202);
RT_INTERFACE!{static interface IInjectedInputGamepadInfoFactory(IInjectedInputGamepadInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IInjectedInputGamepadInfoFactory] {
    #[cfg(feature="windows-gaming")] fn CreateInstanceFromGamepadReading(&self, reading: crate::windows::gaming::input::GamepadReading, out: *mut *mut InjectedInputGamepadInfo) -> HRESULT
}}
impl IInjectedInputGamepadInfoFactory {
    #[cfg(feature="windows-gaming")] #[inline] pub fn create_instance_from_gamepad_reading(&self, reading: crate::windows::gaming::input::GamepadReading) -> Result<ComPtr<InjectedInputGamepadInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstanceFromGamepadReading)(self as *const _ as *mut _, reading, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInjectedInputKeyboardInfo, 1262932288, 11114, 24570, 126, 174, 189, 7, 123, 5, 42, 205);
RT_INTERFACE!{interface IInjectedInputKeyboardInfo(IInjectedInputKeyboardInfoVtbl): IInspectable(IInspectableVtbl) [IID_IInjectedInputKeyboardInfo] {
    fn get_KeyOptions(&self, out: *mut InjectedInputKeyOptions) -> HRESULT,
    fn put_KeyOptions(&self, value: InjectedInputKeyOptions) -> HRESULT,
    fn get_ScanCode(&self, out: *mut u16) -> HRESULT,
    fn put_ScanCode(&self, value: u16) -> HRESULT,
    fn get_VirtualKey(&self, out: *mut u16) -> HRESULT,
    fn put_VirtualKey(&self, value: u16) -> HRESULT
}}
impl IInjectedInputKeyboardInfo {
    #[inline] pub fn get_key_options(&self) -> Result<InjectedInputKeyOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeyOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_key_options(&self, value: InjectedInputKeyOptions) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_KeyOptions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_code(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScanCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scan_code(&self, value: u16) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ScanCode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_virtual_key(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VirtualKey)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_virtual_key(&self, value: u16) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_VirtualKey)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InjectedInputKeyboardInfo: IInjectedInputKeyboardInfo}
impl RtActivatable<IActivationFactory> for InjectedInputKeyboardInfo {}
DEFINE_CLSID!(InjectedInputKeyboardInfo(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,73,110,106,101,99,116,105,111,110,46,73,110,106,101,99,116,101,100,73,110,112,117,116,75,101,121,98,111,97,114,100,73,110,102,111,0]) [CLSID_InjectedInputKeyboardInfo]);
RT_ENUM! { enum InjectedInputKeyOptions: u32 {
    None = 0, ExtendedKey = 1, KeyUp = 2, ScanCode = 8, Unicode = 4,
}}
DEFINE_IID!(IID_IInjectedInputMouseInfo, 2532666987, 58490, 23796, 65, 141, 138, 95, 185, 103, 12, 125);
RT_INTERFACE!{interface IInjectedInputMouseInfo(IInjectedInputMouseInfoVtbl): IInspectable(IInspectableVtbl) [IID_IInjectedInputMouseInfo] {
    fn get_MouseOptions(&self, out: *mut InjectedInputMouseOptions) -> HRESULT,
    fn put_MouseOptions(&self, value: InjectedInputMouseOptions) -> HRESULT,
    fn get_MouseData(&self, out: *mut u32) -> HRESULT,
    fn put_MouseData(&self, value: u32) -> HRESULT,
    fn get_DeltaY(&self, out: *mut i32) -> HRESULT,
    fn put_DeltaY(&self, value: i32) -> HRESULT,
    fn get_DeltaX(&self, out: *mut i32) -> HRESULT,
    fn put_DeltaX(&self, value: i32) -> HRESULT,
    fn get_TimeOffsetInMilliseconds(&self, out: *mut u32) -> HRESULT,
    fn put_TimeOffsetInMilliseconds(&self, value: u32) -> HRESULT
}}
impl IInjectedInputMouseInfo {
    #[inline] pub fn get_mouse_options(&self) -> Result<InjectedInputMouseOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MouseOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mouse_options(&self, value: InjectedInputMouseOptions) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MouseOptions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mouse_data(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MouseData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mouse_data(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_MouseData)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delta_y(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeltaY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delta_y(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DeltaY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_delta_x(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeltaX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_delta_x(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DeltaX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_time_offset_in_milliseconds(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TimeOffsetInMilliseconds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_time_offset_in_milliseconds(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TimeOffsetInMilliseconds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InjectedInputMouseInfo: IInjectedInputMouseInfo}
impl RtActivatable<IActivationFactory> for InjectedInputMouseInfo {}
DEFINE_CLSID!(InjectedInputMouseInfo(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,73,110,106,101,99,116,105,111,110,46,73,110,106,101,99,116,101,100,73,110,112,117,116,77,111,117,115,101,73,110,102,111,0]) [CLSID_InjectedInputMouseInfo]);
RT_ENUM! { enum InjectedInputMouseOptions: u32 {
    None = 0, Move = 1, LeftDown = 2, LeftUp = 4, RightDown = 8, RightUp = 16, MiddleDown = 32, MiddleUp = 64, XDown = 128, XUp = 256, Wheel = 2048, HWheel = 4096, MoveNoCoalesce = 8192, VirtualDesk = 16384, Absolute = 32768,
}}
RT_ENUM! { enum InjectedInputPenButtons: u32 {
    None = 0, Barrel = 1, Inverted = 2, Eraser = 4,
}}
DEFINE_IID!(IID_IInjectedInputPenInfo, 1799400707, 51742, 21799, 126, 2, 40, 40, 84, 11, 177, 212);
RT_INTERFACE!{interface IInjectedInputPenInfo(IInjectedInputPenInfoVtbl): IInspectable(IInspectableVtbl) [IID_IInjectedInputPenInfo] {
    fn get_PointerInfo(&self, out: *mut InjectedInputPointerInfo) -> HRESULT,
    fn put_PointerInfo(&self, value: InjectedInputPointerInfo) -> HRESULT,
    fn get_PenButtons(&self, out: *mut InjectedInputPenButtons) -> HRESULT,
    fn put_PenButtons(&self, value: InjectedInputPenButtons) -> HRESULT,
    fn get_PenParameters(&self, out: *mut InjectedInputPenParameters) -> HRESULT,
    fn put_PenParameters(&self, value: InjectedInputPenParameters) -> HRESULT,
    fn get_Pressure(&self, out: *mut f64) -> HRESULT,
    fn put_Pressure(&self, value: f64) -> HRESULT,
    fn get_Rotation(&self, out: *mut f64) -> HRESULT,
    fn put_Rotation(&self, value: f64) -> HRESULT,
    fn get_TiltX(&self, out: *mut i32) -> HRESULT,
    fn put_TiltX(&self, value: i32) -> HRESULT,
    fn get_TiltY(&self, out: *mut i32) -> HRESULT,
    fn put_TiltY(&self, value: i32) -> HRESULT
}}
impl IInjectedInputPenInfo {
    #[inline] pub fn get_pointer_info(&self) -> Result<InjectedInputPointerInfo> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_info(&self, value: InjectedInputPointerInfo) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PointerInfo)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pen_buttons(&self) -> Result<InjectedInputPenButtons> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PenButtons)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pen_buttons(&self, value: InjectedInputPenButtons) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PenButtons)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pen_parameters(&self) -> Result<InjectedInputPenParameters> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PenParameters)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pen_parameters(&self, value: InjectedInputPenParameters) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PenParameters)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pressure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pressure(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Pressure)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Rotation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Rotation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tilt_x(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_tilt_x(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TiltX)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tilt_y(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TiltY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_tilt_y(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TiltY)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InjectedInputPenInfo: IInjectedInputPenInfo}
impl RtActivatable<IActivationFactory> for InjectedInputPenInfo {}
DEFINE_CLSID!(InjectedInputPenInfo(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,73,110,106,101,99,116,105,111,110,46,73,110,106,101,99,116,101,100,73,110,112,117,116,80,101,110,73,110,102,111,0]) [CLSID_InjectedInputPenInfo]);
RT_ENUM! { enum InjectedInputPenParameters: u32 {
    None = 0, Pressure = 1, Rotation = 2, TiltX = 4, TiltY = 8,
}}
RT_STRUCT! { struct InjectedInputPoint {
    PositionX: i32, PositionY: i32,
}}
RT_STRUCT! { struct InjectedInputPointerInfo {
    PointerId: u32, PointerOptions: InjectedInputPointerOptions, PixelLocation: InjectedInputPoint, TimeOffsetInMilliseconds: u32, PerformanceCount: u64,
}}
RT_ENUM! { enum InjectedInputPointerOptions: u32 {
    None = 0, New = 1, InRange = 2, InContact = 4, FirstButton = 16, SecondButton = 32, Primary = 8192, Confidence = 16384, Canceled = 32768, PointerDown = 65536, Update = 131072, PointerUp = 262144, CaptureChanged = 2097152,
}}
RT_STRUCT! { struct InjectedInputRectangle {
    Left: i32, Top: i32, Bottom: i32, Right: i32,
}}
RT_ENUM! { enum InjectedInputShortcut: i32 {
    Back = 0, Start = 1, Search = 2,
}}
DEFINE_IID!(IID_IInjectedInputTouchInfo, 575656415, 17384, 24309, 81, 10, 105, 202, 140, 155, 76, 40);
RT_INTERFACE!{interface IInjectedInputTouchInfo(IInjectedInputTouchInfoVtbl): IInspectable(IInspectableVtbl) [IID_IInjectedInputTouchInfo] {
    fn get_Contact(&self, out: *mut InjectedInputRectangle) -> HRESULT,
    fn put_Contact(&self, value: InjectedInputRectangle) -> HRESULT,
    fn get_Orientation(&self, out: *mut i32) -> HRESULT,
    fn put_Orientation(&self, value: i32) -> HRESULT,
    fn get_PointerInfo(&self, out: *mut InjectedInputPointerInfo) -> HRESULT,
    fn put_PointerInfo(&self, value: InjectedInputPointerInfo) -> HRESULT,
    fn get_Pressure(&self, out: *mut f64) -> HRESULT,
    fn put_Pressure(&self, value: f64) -> HRESULT,
    fn get_TouchParameters(&self, out: *mut InjectedInputTouchParameters) -> HRESULT,
    fn put_TouchParameters(&self, value: InjectedInputTouchParameters) -> HRESULT
}}
impl IInjectedInputTouchInfo {
    #[inline] pub fn get_contact(&self) -> Result<InjectedInputRectangle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_contact(&self, value: InjectedInputRectangle) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Contact)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_orientation(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Orientation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_info(&self) -> Result<InjectedInputPointerInfo> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PointerInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pointer_info(&self, value: InjectedInputPointerInfo) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PointerInfo)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pressure)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_pressure(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Pressure)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_touch_parameters(&self) -> Result<InjectedInputTouchParameters> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TouchParameters)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_touch_parameters(&self, value: InjectedInputTouchParameters) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TouchParameters)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InjectedInputTouchInfo: IInjectedInputTouchInfo}
impl RtActivatable<IActivationFactory> for InjectedInputTouchInfo {}
DEFINE_CLSID!(InjectedInputTouchInfo(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,73,110,106,101,99,116,105,111,110,46,73,110,106,101,99,116,101,100,73,110,112,117,116,84,111,117,99,104,73,110,102,111,0]) [CLSID_InjectedInputTouchInfo]);
RT_ENUM! { enum InjectedInputTouchParameters: u32 {
    None = 0, Contact = 1, Orientation = 2, Pressure = 4,
}}
RT_ENUM! { enum InjectedInputVisualizationMode: i32 {
    None = 0, Default = 1, Indirect = 2,
}}
DEFINE_IID!(IID_IInputInjector, 2395107204, 2818, 19410, 173, 122, 61, 70, 88, 190, 62, 24);
RT_INTERFACE!{interface IInputInjector(IInputInjectorVtbl): IInspectable(IInspectableVtbl) [IID_IInputInjector] {
    fn InjectKeyboardInput(&self, input: *mut foundation::collections::IIterable<InjectedInputKeyboardInfo>) -> HRESULT,
    fn InjectMouseInput(&self, input: *mut foundation::collections::IIterable<InjectedInputMouseInfo>) -> HRESULT,
    fn InitializeTouchInjection(&self, visualMode: InjectedInputVisualizationMode) -> HRESULT,
    fn InjectTouchInput(&self, input: *mut foundation::collections::IIterable<InjectedInputTouchInfo>) -> HRESULT,
    fn UninitializeTouchInjection(&self) -> HRESULT,
    fn InitializePenInjection(&self, visualMode: InjectedInputVisualizationMode) -> HRESULT,
    fn InjectPenInput(&self, input: *mut InjectedInputPenInfo) -> HRESULT,
    fn UninitializePenInjection(&self) -> HRESULT,
    fn InjectShortcut(&self, shortcut: InjectedInputShortcut) -> HRESULT
}}
impl IInputInjector {
    #[inline] pub fn inject_keyboard_input(&self, input: &foundation::collections::IIterable<InjectedInputKeyboardInfo>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InjectKeyboardInput)(self as *const _ as *mut _, input as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn inject_mouse_input(&self, input: &foundation::collections::IIterable<InjectedInputMouseInfo>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InjectMouseInput)(self as *const _ as *mut _, input as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn initialize_touch_injection(&self, visualMode: InjectedInputVisualizationMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InitializeTouchInjection)(self as *const _ as *mut _, visualMode);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn inject_touch_input(&self, input: &foundation::collections::IIterable<InjectedInputTouchInfo>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InjectTouchInput)(self as *const _ as *mut _, input as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn uninitialize_touch_injection(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).UninitializeTouchInjection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn initialize_pen_injection(&self, visualMode: InjectedInputVisualizationMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InitializePenInjection)(self as *const _ as *mut _, visualMode);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn inject_pen_input(&self, input: &InjectedInputPenInfo) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InjectPenInput)(self as *const _ as *mut _, input as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn uninitialize_pen_injection(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).UninitializePenInjection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn inject_shortcut(&self, shortcut: InjectedInputShortcut) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InjectShortcut)(self as *const _ as *mut _, shortcut);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class InputInjector: IInputInjector}
impl RtActivatable<IInputInjectorStatics> for InputInjector {}
impl RtActivatable<IInputInjectorStatics2> for InputInjector {}
impl InputInjector {
    #[inline] pub fn try_create() -> Result<Option<ComPtr<InputInjector>>> {
        <Self as RtActivatable<IInputInjectorStatics>>::get_activation_factory().try_create()
    }
    #[inline] pub fn try_create_for_app_broadcast_only() -> Result<Option<ComPtr<InputInjector>>> {
        <Self as RtActivatable<IInputInjectorStatics2>>::get_activation_factory().try_create_for_app_broadcast_only()
    }
}
DEFINE_CLSID!(InputInjector(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,73,110,106,101,99,116,105,111,110,46,73,110,112,117,116,73,110,106,101,99,116,111,114,0]) [CLSID_InputInjector]);
DEFINE_IID!(IID_IInputInjector2, 2390397021, 5203, 17319, 155, 203, 6, 214, 215, 179, 5, 247);
RT_INTERFACE!{interface IInputInjector2(IInputInjector2Vtbl): IInspectable(IInspectableVtbl) [IID_IInputInjector2] {
    fn InitializeGamepadInjection(&self) -> HRESULT,
    fn InjectGamepadInput(&self, input: *mut InjectedInputGamepadInfo) -> HRESULT,
    fn UninitializeGamepadInjection(&self) -> HRESULT
}}
impl IInputInjector2 {
    #[inline] pub fn initialize_gamepad_injection(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InitializeGamepadInjection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn inject_gamepad_input(&self, input: &InjectedInputGamepadInfo) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InjectGamepadInput)(self as *const _ as *mut _, input as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn uninitialize_gamepad_injection(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).UninitializeGamepadInjection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInputInjectorStatics, 3735972163, 29698, 16705, 165, 198, 12, 1, 170, 87, 177, 106);
RT_INTERFACE!{static interface IInputInjectorStatics(IInputInjectorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInputInjectorStatics] {
    fn TryCreate(&self, out: *mut *mut InputInjector) -> HRESULT
}}
impl IInputInjectorStatics {
    #[inline] pub fn try_create(&self) -> Result<Option<ComPtr<InputInjector>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCreate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInputInjectorStatics2, 2765830395, 56716, 16719, 149, 234, 248, 126, 244, 192, 174, 108);
RT_INTERFACE!{static interface IInputInjectorStatics2(IInputInjectorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IInputInjectorStatics2] {
    fn TryCreateForAppBroadcastOnly(&self, out: *mut *mut InputInjector) -> HRESULT
}}
impl IInputInjectorStatics2 {
    #[inline] pub fn try_create_for_app_broadcast_only(&self) -> Result<Option<ComPtr<InputInjector>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCreateForAppBroadcastOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Input.Preview.Injection
} // Windows.UI.Input.Preview
pub mod spatial { // Windows.UI.Input.Spatial
use crate::prelude::*;
DEFINE_IID!(IID_ISpatialGestureRecognizer, 1902140364, 3125, 18035, 173, 189, 204, 4, 202, 166, 239, 69);
RT_INTERFACE!{interface ISpatialGestureRecognizer(ISpatialGestureRecognizerVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialGestureRecognizer] {
    fn add_RecognitionStarted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialRecognitionStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RecognitionStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_RecognitionEnded(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialRecognitionEndedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RecognitionEnded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Tapped(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialTappedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Tapped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HoldStarted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialHoldStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HoldStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HoldCompleted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialHoldCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HoldCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HoldCanceled(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialHoldCanceledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HoldCanceled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationStarted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationUpdated(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationCompleted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ManipulationCanceled(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationCanceledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ManipulationCanceled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationStarted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationStarted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationUpdated(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationCompleted(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_NavigationCanceled(&self, handler: *mut foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationCanceledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NavigationCanceled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn CaptureInteraction(&self, interaction: *mut SpatialInteraction) -> HRESULT,
    fn CancelPendingGestures(&self) -> HRESULT,
    fn TrySetGestureSettings(&self, settings: SpatialGestureSettings, out: *mut bool) -> HRESULT,
    fn get_GestureSettings(&self, out: *mut SpatialGestureSettings) -> HRESULT
}}
impl ISpatialGestureRecognizer {
    #[inline] pub fn add_recognition_started(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialRecognitionStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RecognitionStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_recognition_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_RecognitionStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_recognition_ended(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialRecognitionEndedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RecognitionEnded)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_recognition_ended(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_RecognitionEnded)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_tapped(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialTappedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Tapped)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_tapped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Tapped)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hold_started(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialHoldStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HoldStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hold_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_HoldStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hold_completed(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialHoldCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HoldCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hold_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_HoldCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hold_canceled(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialHoldCanceledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HoldCanceled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hold_canceled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_HoldCanceled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_started(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_updated(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationUpdated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationUpdated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_completed(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_manipulation_canceled(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialManipulationCanceledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ManipulationCanceled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_manipulation_canceled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ManipulationCanceled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_navigation_started(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_navigation_started(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NavigationStarted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_navigation_updated(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationUpdatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationUpdated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_navigation_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NavigationUpdated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_navigation_completed(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_navigation_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NavigationCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_navigation_canceled(&self, handler: &foundation::TypedEventHandler<SpatialGestureRecognizer, SpatialNavigationCanceledEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NavigationCanceled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_navigation_canceled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NavigationCanceled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn capture_interaction(&self, interaction: &SpatialInteraction) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).CaptureInteraction)(self as *const _ as *mut _, interaction as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cancel_pending_gestures(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).CancelPendingGestures)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_set_gesture_settings(&self, settings: SpatialGestureSettings) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySetGestureSettings)(self as *const _ as *mut _, settings, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gesture_settings(&self) -> Result<SpatialGestureSettings> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GestureSettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialGestureRecognizer: ISpatialGestureRecognizer}
impl RtActivatable<ISpatialGestureRecognizerFactory> for SpatialGestureRecognizer {}
impl SpatialGestureRecognizer {
    #[inline] pub fn create(settings: SpatialGestureSettings) -> Result<ComPtr<SpatialGestureRecognizer>> {
        <Self as RtActivatable<ISpatialGestureRecognizerFactory>>::get_activation_factory().create(settings)
    }
}
DEFINE_CLSID!(SpatialGestureRecognizer(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,83,112,97,116,105,97,108,46,83,112,97,116,105,97,108,71,101,115,116,117,114,101,82,101,99,111,103,110,105,122,101,114,0]) [CLSID_SpatialGestureRecognizer]);
DEFINE_IID!(IID_ISpatialGestureRecognizerFactory, 1998668166, 22457, 12624, 131, 130, 105, 139, 36, 226, 100, 208);
RT_INTERFACE!{static interface ISpatialGestureRecognizerFactory(ISpatialGestureRecognizerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialGestureRecognizerFactory] {
    fn Create(&self, settings: SpatialGestureSettings, out: *mut *mut SpatialGestureRecognizer) -> HRESULT
}}
impl ISpatialGestureRecognizerFactory {
    #[inline] pub fn create(&self, settings: SpatialGestureSettings) -> Result<ComPtr<SpatialGestureRecognizer>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, settings, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpatialGestureSettings: u32 {
    None = 0, Tap = 1, DoubleTap = 2, Hold = 4, ManipulationTranslate = 8, NavigationX = 16, NavigationY = 32, NavigationZ = 64, NavigationRailsX = 128, NavigationRailsY = 256, NavigationRailsZ = 512,
}}
DEFINE_IID!(IID_ISpatialHoldCanceledEventArgs, 1576842855, 19626, 16531, 140, 53, 182, 1, 168, 57, 243, 27);
RT_INTERFACE!{interface ISpatialHoldCanceledEventArgs(ISpatialHoldCanceledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialHoldCanceledEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT
}}
impl ISpatialHoldCanceledEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialHoldCanceledEventArgs: ISpatialHoldCanceledEventArgs}
DEFINE_IID!(IID_ISpatialHoldCompletedEventArgs, 1063536395, 19709, 17370, 141, 196, 230, 69, 82, 23, 57, 113);
RT_INTERFACE!{interface ISpatialHoldCompletedEventArgs(ISpatialHoldCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialHoldCompletedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT
}}
impl ISpatialHoldCompletedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialHoldCompletedEventArgs: ISpatialHoldCompletedEventArgs}
DEFINE_IID!(IID_ISpatialHoldStartedEventArgs, 2385788281, 44214, 16708, 134, 21, 44, 251, 168, 163, 203, 63);
RT_INTERFACE!{interface ISpatialHoldStartedEventArgs(ISpatialHoldStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialHoldStartedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT
}}
impl ISpatialHoldStartedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialHoldStartedEventArgs: ISpatialHoldStartedEventArgs}
DEFINE_IID!(IID_ISpatialInteraction, 4237719097, 35046, 17990, 145, 18, 67, 68, 170, 236, 157, 250);
RT_INTERFACE!{interface ISpatialInteraction(ISpatialInteractionVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteraction] {
    fn get_SourceState(&self, out: *mut *mut SpatialInteractionSourceState) -> HRESULT
}}
impl ISpatialInteraction {
    #[inline] pub fn get_source_state(&self) -> Result<Option<ComPtr<SpatialInteractionSourceState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteraction: ISpatialInteraction}
DEFINE_IID!(IID_ISpatialInteractionController, 1594776483, 2388, 20119, 134, 197, 231, 243, 11, 17, 77, 253);
RT_INTERFACE!{interface ISpatialInteractionController(ISpatialInteractionControllerVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionController] {
    fn get_HasTouchpad(&self, out: *mut bool) -> HRESULT,
    fn get_HasThumbstick(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_SimpleHapticsController(&self, out: *mut *mut crate::windows::devices::haptics::SimpleHapticsController) -> HRESULT,
    fn get_VendorId(&self, out: *mut u16) -> HRESULT,
    fn get_ProductId(&self, out: *mut u16) -> HRESULT,
    fn get_Version(&self, out: *mut u16) -> HRESULT
}}
impl ISpatialInteractionController {
    #[inline] pub fn get_has_touchpad(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasTouchpad)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_thumbstick(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasThumbstick)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<crate::windows::devices::haptics::SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SimpleHapticsController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VendorId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_version(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Version)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionController: ISpatialInteractionController}
DEFINE_IID!(IID_ISpatialInteractionController2, 901175588, 51106, 18871, 183, 46, 84, 54, 178, 251, 143, 156);
RT_INTERFACE!{interface ISpatialInteractionController2(ISpatialInteractionController2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionController2] {
    #[cfg(feature="windows-storage")] fn TryGetRenderableModelAsync(&self, out: *mut *mut foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStreamWithContentType>) -> HRESULT
}}
impl ISpatialInteractionController2 {
    #[cfg(feature="windows-storage")] #[inline] pub fn try_get_renderable_model_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<crate::windows::storage::streams::IRandomAccessStreamWithContentType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetRenderableModelAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialInteractionController3, 1652844192, 40337, 18955, 136, 141, 22, 94, 103, 10, 140, 213);
RT_INTERFACE!{interface ISpatialInteractionController3(ISpatialInteractionController3Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionController3] {
    #[cfg(feature="windows-devices")] fn TryGetBatteryReport(&self, out: *mut *mut crate::windows::devices::power::BatteryReport) -> HRESULT
}}
impl ISpatialInteractionController3 {
    #[cfg(feature="windows-devices")] #[inline] pub fn try_get_battery_report(&self) -> Result<Option<ComPtr<crate::windows::devices::power::BatteryReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetBatteryReport)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialInteractionControllerProperties, 1627746225, 31657, 20021, 185, 63, 146, 114, 203, 169, 178, 139);
RT_INTERFACE!{interface ISpatialInteractionControllerProperties(ISpatialInteractionControllerPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionControllerProperties] {
    fn get_IsTouchpadTouched(&self, out: *mut bool) -> HRESULT,
    fn get_IsTouchpadPressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsThumbstickPressed(&self, out: *mut bool) -> HRESULT,
    fn get_ThumbstickX(&self, out: *mut f64) -> HRESULT,
    fn get_ThumbstickY(&self, out: *mut f64) -> HRESULT,
    fn get_TouchpadX(&self, out: *mut f64) -> HRESULT,
    fn get_TouchpadY(&self, out: *mut f64) -> HRESULT
}}
impl ISpatialInteractionControllerProperties {
    #[inline] pub fn get_is_touchpad_touched(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTouchpadTouched)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_touchpad_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTouchpadPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_thumbstick_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsThumbstickPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbstick_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ThumbstickX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbstick_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ThumbstickY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_touchpad_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TouchpadX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_touchpad_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TouchpadY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionControllerProperties: ISpatialInteractionControllerProperties}
DEFINE_IID!(IID_ISpatialInteractionDetectedEventArgs, 123238628, 22881, 15169, 157, 251, 206, 165, 216, 156, 195, 138);
RT_INTERFACE!{interface ISpatialInteractionDetectedEventArgs(ISpatialInteractionDetectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionDetectedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(not(feature="windows-perception"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT,
    fn get_Interaction(&self, out: *mut *mut SpatialInteraction) -> HRESULT
}}
impl ISpatialInteractionDetectedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interaction(&self) -> Result<Option<ComPtr<SpatialInteraction>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Interaction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionDetectedEventArgs: ISpatialInteractionDetectedEventArgs}
DEFINE_IID!(IID_ISpatialInteractionDetectedEventArgs2, 2066103955, 24339, 16796, 151, 213, 131, 70, 120, 38, 106, 166);
RT_INTERFACE!{interface ISpatialInteractionDetectedEventArgs2(ISpatialInteractionDetectedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionDetectedEventArgs2] {
    fn get_InteractionSource(&self, out: *mut *mut SpatialInteractionSource) -> HRESULT
}}
impl ISpatialInteractionDetectedEventArgs2 {
    #[inline] pub fn get_interaction_source(&self) -> Result<Option<ComPtr<SpatialInteractionSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InteractionSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialInteractionManager, 849759912, 41306, 14741, 184, 189, 128, 81, 60, 181, 173, 239);
RT_INTERFACE!{interface ISpatialInteractionManager(ISpatialInteractionManagerVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionManager] {
    fn add_SourceDetected(&self, handler: *mut foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceDetected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceLost(&self, handler: *mut foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceLost(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceUpdated(&self, handler: *mut foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourcePressed(&self, handler: *mut foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourcePressed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceReleased(&self, handler: *mut foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceReleased(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_InteractionDetected(&self, handler: *mut foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionDetectedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InteractionDetected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-perception")] fn GetDetectedSourcesAtTimestamp(&self, timeStamp: *mut crate::windows::perception::PerceptionTimestamp, out: *mut *mut foundation::collections::IVectorView<SpatialInteractionSourceState>) -> HRESULT
}}
impl ISpatialInteractionManager {
    #[inline] pub fn add_source_detected(&self, handler: &foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SourceDetected)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_detected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SourceDetected)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_lost(&self, handler: &foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SourceLost)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_lost(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SourceLost)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_updated(&self, handler: &foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SourceUpdated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SourceUpdated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_pressed(&self, handler: &foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SourcePressed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_pressed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SourcePressed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_released(&self, handler: &foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionSourceEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SourceReleased)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_released(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SourceReleased)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_interaction_detected(&self, handler: &foundation::TypedEventHandler<SpatialInteractionManager, SpatialInteractionDetectedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_InteractionDetected)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_interaction_detected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_InteractionDetected)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn get_detected_sources_at_timestamp(&self, timeStamp: &crate::windows::perception::PerceptionTimestamp) -> Result<Option<ComPtr<foundation::collections::IVectorView<SpatialInteractionSourceState>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDetectedSourcesAtTimestamp)(self as *const _ as *mut _, timeStamp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionManager: ISpatialInteractionManager}
impl RtActivatable<ISpatialInteractionManagerStatics> for SpatialInteractionManager {}
impl SpatialInteractionManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<SpatialInteractionManager>>> {
        <Self as RtActivatable<ISpatialInteractionManagerStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(SpatialInteractionManager(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,83,112,97,116,105,97,108,46,83,112,97,116,105,97,108,73,110,116,101,114,97,99,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_SpatialInteractionManager]);
DEFINE_IID!(IID_ISpatialInteractionManagerStatics, 14884774, 36002, 12479, 145, 254, 217, 203, 74, 0, 137, 144);
RT_INTERFACE!{static interface ISpatialInteractionManagerStatics(ISpatialInteractionManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionManagerStatics] {
    fn GetForCurrentView(&self, out: *mut *mut SpatialInteractionManager) -> HRESULT
}}
impl ISpatialInteractionManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<SpatialInteractionManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpatialInteractionPressKind: i32 {
    None = 0, Select = 1, Menu = 2, Grasp = 3, Touchpad = 4, Thumbstick = 5,
}}
DEFINE_IID!(IID_ISpatialInteractionSource, 4216599482, 45235, 12616, 159, 59, 233, 245, 222, 86, 143, 93);
RT_INTERFACE!{interface ISpatialInteractionSource(ISpatialInteractionSourceVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSource] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_Kind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT
}}
impl ISpatialInteractionSource {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionSource: ISpatialInteractionSource}
DEFINE_IID!(IID_ISpatialInteractionSource2, 3838162700, 1136, 16424, 136, 192, 160, 235, 68, 211, 78, 254);
RT_INTERFACE!{interface ISpatialInteractionSource2(ISpatialInteractionSource2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSource2] {
    fn get_IsPointingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsMenuSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsGraspSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Controller(&self, out: *mut *mut SpatialInteractionController) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetStateAtTimestamp(&self, timestamp: *mut crate::windows::perception::PerceptionTimestamp, out: *mut *mut SpatialInteractionSourceState) -> HRESULT
}}
impl ISpatialInteractionSource2 {
    #[inline] pub fn get_is_pointing_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPointingSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_menu_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMenuSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_grasp_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGraspSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_controller(&self) -> Result<Option<ComPtr<SpatialInteractionController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Controller)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_state_at_timestamp(&self, timestamp: &crate::windows::perception::PerceptionTimestamp) -> Result<Option<ComPtr<SpatialInteractionSourceState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetStateAtTimestamp)(self as *const _ as *mut _, timestamp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialInteractionSource3, 67557881, 39677, 17657, 133, 220, 112, 0, 35, 169, 98, 227);
RT_INTERFACE!{interface ISpatialInteractionSource3(ISpatialInteractionSource3Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSource3] {
    fn get_Handedness(&self, out: *mut SpatialInteractionSourceHandedness) -> HRESULT
}}
impl ISpatialInteractionSource3 {
    #[inline] pub fn get_handedness(&self) -> Result<SpatialInteractionSourceHandedness> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handedness)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialInteractionSourceEventArgs, 599230159, 60451, 14713, 178, 124, 235, 14, 18, 254, 183, 199);
RT_INTERFACE!{interface ISpatialInteractionSourceEventArgs(ISpatialInteractionSourceEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceEventArgs] {
    fn get_State(&self, out: *mut *mut SpatialInteractionSourceState) -> HRESULT
}}
impl ISpatialInteractionSourceEventArgs {
    #[inline] pub fn get_state(&self) -> Result<Option<ComPtr<SpatialInteractionSourceState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionSourceEventArgs: ISpatialInteractionSourceEventArgs}
DEFINE_IID!(IID_ISpatialInteractionSourceEventArgs2, 3635721319, 58952, 19794, 171, 73, 224, 210, 39, 25, 159, 99);
RT_INTERFACE!{interface ISpatialInteractionSourceEventArgs2(ISpatialInteractionSourceEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceEventArgs2] {
    fn get_PressKind(&self, out: *mut SpatialInteractionPressKind) -> HRESULT
}}
impl ISpatialInteractionSourceEventArgs2 {
    #[inline] pub fn get_press_kind(&self) -> Result<SpatialInteractionPressKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PressKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpatialInteractionSourceHandedness: i32 {
    Unspecified = 0, Left = 1, Right = 2,
}}
RT_ENUM! { enum SpatialInteractionSourceKind: i32 {
    Other = 0, Hand = 1, Voice = 2, Controller = 3,
}}
DEFINE_IID!(IID_ISpatialInteractionSourceLocation, 3930494660, 32395, 12490, 188, 197, 199, 113, 137, 206, 163, 10);
RT_INTERFACE!{interface ISpatialInteractionSourceLocation(ISpatialInteractionSourceLocationVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceLocation] {
    fn get_Position(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_Velocity(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT
}}
impl ISpatialInteractionSourceLocation {
    #[inline] pub fn get_position(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_velocity(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Velocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionSourceLocation: ISpatialInteractionSourceLocation}
DEFINE_IID!(IID_ISpatialInteractionSourceLocation2, 1281822789, 14615, 16636, 169, 172, 49, 201, 207, 95, 249, 27);
RT_INTERFACE!{interface ISpatialInteractionSourceLocation2(ISpatialInteractionSourceLocation2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceLocation2] {
    fn get_Orientation(&self, out: *mut *mut foundation::IReference<foundation::numerics::Quaternion>) -> HRESULT
}}
impl ISpatialInteractionSourceLocation2 {
    #[inline] pub fn get_orientation(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Quaternion>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialInteractionSourceLocation3, 1728243294, 59669, 19707, 156, 27, 5, 56, 239, 200, 102, 135);
RT_INTERFACE!{interface ISpatialInteractionSourceLocation3(ISpatialInteractionSourceLocation3Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceLocation3] {
    fn get_PositionAccuracy(&self, out: *mut SpatialInteractionSourcePositionAccuracy) -> HRESULT,
    fn get_AngularVelocity(&self, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_SourcePointerPose(&self, out: *mut *mut SpatialPointerInteractionSourcePose) -> HRESULT
}}
impl ISpatialInteractionSourceLocation3 {
    #[inline] pub fn get_position_accuracy(&self) -> Result<SpatialInteractionSourcePositionAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionAccuracy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AngularVelocity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_pointer_pose(&self) -> Result<Option<ComPtr<SpatialPointerInteractionSourcePose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePointerPose)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpatialInteractionSourcePositionAccuracy: i32 {
    High = 0, Approximate = 1,
}}
DEFINE_IID!(IID_ISpatialInteractionSourceProperties, 90195266, 16119, 12834, 159, 83, 99, 201, 203, 126, 59, 199);
RT_INTERFACE!{interface ISpatialInteractionSourceProperties(ISpatialInteractionSourcePropertiesVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceProperties] {
    #[cfg(feature="windows-perception")] fn TryGetSourceLossMitigationDirection(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut foundation::IReference<foundation::numerics::Vector3>) -> HRESULT,
    fn get_SourceLossRisk(&self, out: *mut f64) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetLocation(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialInteractionSourceLocation) -> HRESULT
}}
impl ISpatialInteractionSourceProperties {
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_source_loss_mitigation_direction(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<foundation::IReference<foundation::numerics::Vector3>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetSourceLossMitigationDirection)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_loss_risk(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourceLossRisk)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_location(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialInteractionSourceLocation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetLocation)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionSourceProperties: ISpatialInteractionSourceProperties}
DEFINE_IID!(IID_ISpatialInteractionSourceState, 3586422255, 19299, 14316, 152, 185, 159, 198, 82, 185, 210, 242);
RT_INTERFACE!{interface ISpatialInteractionSourceState(ISpatialInteractionSourceStateVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceState] {
    fn get_Source(&self, out: *mut *mut SpatialInteractionSource) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut SpatialInteractionSourceProperties) -> HRESULT,
    fn get_IsPressed(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-perception")] fn get_Timestamp(&self, out: *mut *mut crate::windows::perception::PerceptionTimestamp) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT
}}
impl ISpatialInteractionSourceState {
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<SpatialInteractionSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Source)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<SpatialInteractionSourceProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn get_timestamp(&self) -> Result<Option<ComPtr<crate::windows::perception::PerceptionTimestamp>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialInteractionSourceState: ISpatialInteractionSourceState}
DEFINE_IID!(IID_ISpatialInteractionSourceState2, 1173803197, 6003, 18734, 155, 163, 138, 193, 203, 231, 124, 8);
RT_INTERFACE!{interface ISpatialInteractionSourceState2(ISpatialInteractionSourceState2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialInteractionSourceState2] {
    fn get_IsSelectPressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsMenuPressed(&self, out: *mut bool) -> HRESULT,
    fn get_IsGrasped(&self, out: *mut bool) -> HRESULT,
    fn get_SelectPressedValue(&self, out: *mut f64) -> HRESULT,
    fn get_ControllerProperties(&self, out: *mut *mut SpatialInteractionControllerProperties) -> HRESULT
}}
impl ISpatialInteractionSourceState2 {
    #[inline] pub fn get_is_select_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSelectPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_menu_pressed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMenuPressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_grasped(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGrasped)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_select_pressed_value(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectPressedValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_controller_properties(&self) -> Result<Option<ComPtr<SpatialInteractionControllerProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ControllerProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialManipulationCanceledEventArgs, 759222731, 59354, 16928, 176, 191, 129, 147, 1, 103, 71, 128);
RT_INTERFACE!{interface ISpatialManipulationCanceledEventArgs(ISpatialManipulationCanceledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialManipulationCanceledEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT
}}
impl ISpatialManipulationCanceledEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialManipulationCanceledEventArgs: ISpatialManipulationCanceledEventArgs}
DEFINE_IID!(IID_ISpatialManipulationCompletedEventArgs, 84436994, 62209, 17219, 146, 80, 47, 186, 165, 248, 122, 55);
RT_INTERFACE!{interface ISpatialManipulationCompletedEventArgs(ISpatialManipulationCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialManipulationCompletedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetCumulativeDelta(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialManipulationDelta) -> HRESULT
}}
impl ISpatialManipulationCompletedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_cumulative_delta(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialManipulationDelta>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetCumulativeDelta)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialManipulationCompletedEventArgs: ISpatialManipulationCompletedEventArgs}
DEFINE_IID!(IID_ISpatialManipulationDelta, 2817300090, 53539, 14977, 161, 91, 153, 41, 35, 220, 190, 145);
RT_INTERFACE!{interface ISpatialManipulationDelta(ISpatialManipulationDeltaVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialManipulationDelta] {
    fn get_Translation(&self, out: *mut foundation::numerics::Vector3) -> HRESULT
}}
impl ISpatialManipulationDelta {
    #[inline] pub fn get_translation(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Translation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialManipulationDelta: ISpatialManipulationDelta}
DEFINE_IID!(IID_ISpatialManipulationStartedEventArgs, 2715204558, 17061, 14203, 173, 166, 210, 142, 61, 56, 71, 55);
RT_INTERFACE!{interface ISpatialManipulationStartedEventArgs(ISpatialManipulationStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialManipulationStartedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT
}}
impl ISpatialManipulationStartedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialManipulationStartedEventArgs: ISpatialManipulationStartedEventArgs}
DEFINE_IID!(IID_ISpatialManipulationUpdatedEventArgs, 1596132251, 24774, 19910, 189, 201, 159, 74, 111, 21, 254, 73);
RT_INTERFACE!{interface ISpatialManipulationUpdatedEventArgs(ISpatialManipulationUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialManipulationUpdatedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(feature="windows-perception")] fn TryGetCumulativeDelta(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialManipulationDelta) -> HRESULT
}}
impl ISpatialManipulationUpdatedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_cumulative_delta(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialManipulationDelta>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetCumulativeDelta)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialManipulationUpdatedEventArgs: ISpatialManipulationUpdatedEventArgs}
DEFINE_IID!(IID_ISpatialNavigationCanceledEventArgs, 3461365468, 59557, 18160, 146, 212, 60, 18, 43, 53, 17, 42);
RT_INTERFACE!{interface ISpatialNavigationCanceledEventArgs(ISpatialNavigationCanceledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialNavigationCanceledEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT
}}
impl ISpatialNavigationCanceledEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialNavigationCanceledEventArgs: ISpatialNavigationCanceledEventArgs}
DEFINE_IID!(IID_ISpatialNavigationCompletedEventArgs, 19824823, 44859, 17090, 158, 65, 186, 170, 14, 114, 31, 58);
RT_INTERFACE!{interface ISpatialNavigationCompletedEventArgs(ISpatialNavigationCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialNavigationCompletedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    fn get_NormalizedOffset(&self, out: *mut foundation::numerics::Vector3) -> HRESULT
}}
impl ISpatialNavigationCompletedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_normalized_offset(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NormalizedOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialNavigationCompletedEventArgs: ISpatialNavigationCompletedEventArgs}
DEFINE_IID!(IID_ISpatialNavigationStartedEventArgs, 1967797386, 64356, 18006, 142, 189, 157, 238, 202, 175, 228, 117);
RT_INTERFACE!{interface ISpatialNavigationStartedEventArgs(ISpatialNavigationStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialNavigationStartedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(not(feature="windows-perception"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT,
    fn get_IsNavigatingX(&self, out: *mut bool) -> HRESULT,
    fn get_IsNavigatingY(&self, out: *mut bool) -> HRESULT,
    fn get_IsNavigatingZ(&self, out: *mut bool) -> HRESULT
}}
impl ISpatialNavigationStartedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_navigating_x(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsNavigatingX)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_navigating_y(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsNavigatingY)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_navigating_z(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsNavigatingZ)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialNavigationStartedEventArgs: ISpatialNavigationStartedEventArgs}
DEFINE_IID!(IID_ISpatialNavigationUpdatedEventArgs, 2607890391, 33693, 19060, 135, 50, 69, 70, 111, 192, 68, 181);
RT_INTERFACE!{interface ISpatialNavigationUpdatedEventArgs(ISpatialNavigationUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialNavigationUpdatedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    fn get_NormalizedOffset(&self, out: *mut foundation::numerics::Vector3) -> HRESULT
}}
impl ISpatialNavigationUpdatedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_normalized_offset(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NormalizedOffset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialNavigationUpdatedEventArgs: ISpatialNavigationUpdatedEventArgs}
DEFINE_IID!(IID_ISpatialPointerInteractionSourcePose, 2802860807, 11307, 19770, 146, 167, 128, 206, 215, 196, 160, 208);
RT_INTERFACE!{interface ISpatialPointerInteractionSourcePose(ISpatialPointerInteractionSourcePoseVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialPointerInteractionSourcePose] {
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_ForwardDirection(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_UpDirection(&self, out: *mut foundation::numerics::Vector3) -> HRESULT
}}
impl ISpatialPointerInteractionSourcePose {
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_forward_direction(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForwardDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_up_direction(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UpDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialPointerInteractionSourcePose: ISpatialPointerInteractionSourcePose}
DEFINE_IID!(IID_ISpatialPointerInteractionSourcePose2, 3972892344, 21211, 18079, 158, 63, 128, 196, 127, 116, 188, 233);
RT_INTERFACE!{interface ISpatialPointerInteractionSourcePose2(ISpatialPointerInteractionSourcePose2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialPointerInteractionSourcePose2] {
    fn get_Orientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT,
    fn get_PositionAccuracy(&self, out: *mut SpatialInteractionSourcePositionAccuracy) -> HRESULT
}}
impl ISpatialPointerInteractionSourcePose2 {
    #[inline] pub fn get_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position_accuracy(&self) -> Result<SpatialInteractionSourcePositionAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PositionAccuracy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialPointerPose, 1767089198, 49534, 13693, 151, 161, 114, 105, 208, 237, 45, 16);
RT_INTERFACE!{interface ISpatialPointerPose(ISpatialPointerPoseVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialPointerPose] {
    #[cfg(feature="windows-perception")] fn get_Timestamp(&self, out: *mut *mut crate::windows::perception::PerceptionTimestamp) -> HRESULT,
    #[cfg(feature="windows-perception")] fn get_Head(&self, out: *mut *mut crate::windows::perception::people::HeadPose) -> HRESULT
}}
impl ISpatialPointerPose {
    #[cfg(feature="windows-perception")] #[inline] pub fn get_timestamp(&self) -> Result<Option<ComPtr<crate::windows::perception::PerceptionTimestamp>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn get_head(&self) -> Result<Option<ComPtr<crate::windows::perception::people::HeadPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Head)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialPointerPose: ISpatialPointerPose}
impl RtActivatable<ISpatialPointerPoseStatics> for SpatialPointerPose {}
impl SpatialPointerPose {
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_at_timestamp(coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem, timestamp: &crate::windows::perception::PerceptionTimestamp) -> Result<Option<ComPtr<SpatialPointerPose>>> {
        <Self as RtActivatable<ISpatialPointerPoseStatics>>::get_activation_factory().try_get_at_timestamp(coordinateSystem, timestamp)
    }
}
DEFINE_CLSID!(SpatialPointerPose(&[87,105,110,100,111,119,115,46,85,73,46,73,110,112,117,116,46,83,112,97,116,105,97,108,46,83,112,97,116,105,97,108,80,111,105,110,116,101,114,80,111,115,101,0]) [CLSID_SpatialPointerPose]);
DEFINE_IID!(IID_ISpatialPointerPose2, 2636131095, 38222, 19980, 150, 209, 182, 121, 11, 111, 194, 253);
RT_INTERFACE!{interface ISpatialPointerPose2(ISpatialPointerPose2Vtbl): IInspectable(IInspectableVtbl) [IID_ISpatialPointerPose2] {
    fn TryGetInteractionSourcePose(&self, source: *mut SpatialInteractionSource, out: *mut *mut SpatialPointerInteractionSourcePose) -> HRESULT
}}
impl ISpatialPointerPose2 {
    #[inline] pub fn try_get_interaction_source_pose(&self, source: &SpatialInteractionSource) -> Result<Option<ComPtr<SpatialPointerInteractionSourcePose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetInteractionSourcePose)(self as *const _ as *mut _, source as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialPointerPoseStatics, 2723516841, 44193, 16096, 152, 22, 120, 92, 251, 46, 63, 184);
RT_INTERFACE!{static interface ISpatialPointerPoseStatics(ISpatialPointerPoseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialPointerPoseStatics] {
    #[cfg(feature="windows-perception")] fn TryGetAtTimestamp(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, timestamp: *mut crate::windows::perception::PerceptionTimestamp, out: *mut *mut SpatialPointerPose) -> HRESULT
}}
impl ISpatialPointerPoseStatics {
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_at_timestamp(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem, timestamp: &crate::windows::perception::PerceptionTimestamp) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetAtTimestamp)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, timestamp as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpatialRecognitionEndedEventArgs, 238417355, 16245, 17395, 172, 129, 209, 220, 45, 249, 177, 251);
RT_INTERFACE!{interface ISpatialRecognitionEndedEventArgs(ISpatialRecognitionEndedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialRecognitionEndedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT
}}
impl ISpatialRecognitionEndedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialRecognitionEndedEventArgs: ISpatialRecognitionEndedEventArgs}
DEFINE_IID!(IID_ISpatialRecognitionStartedEventArgs, 618271375, 8, 19053, 170, 80, 42, 118, 249, 207, 178, 100);
RT_INTERFACE!{interface ISpatialRecognitionStartedEventArgs(ISpatialRecognitionStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialRecognitionStartedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(not(feature="windows-perception"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT,
    fn IsGesturePossible(&self, gesture: SpatialGestureSettings, out: *mut bool) -> HRESULT
}}
impl ISpatialRecognitionStartedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_gesture_possible(&self, gesture: SpatialGestureSettings) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsGesturePossible)(self as *const _ as *mut _, gesture, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialRecognitionStartedEventArgs: ISpatialRecognitionStartedEventArgs}
DEFINE_IID!(IID_ISpatialTappedEventArgs, 695043038, 62532, 19105, 178, 191, 157, 200, 141, 86, 125, 166);
RT_INTERFACE!{interface ISpatialTappedEventArgs(ISpatialTappedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISpatialTappedEventArgs] {
    fn get_InteractionSourceKind(&self, out: *mut SpatialInteractionSourceKind) -> HRESULT,
    #[cfg(not(feature="windows-perception"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-perception")] fn TryGetPointerPose(&self, coordinateSystem: *mut crate::windows::perception::spatial::SpatialCoordinateSystem, out: *mut *mut SpatialPointerPose) -> HRESULT,
    fn get_TapCount(&self, out: *mut u32) -> HRESULT
}}
impl ISpatialTappedEventArgs {
    #[inline] pub fn get_interaction_source_kind(&self) -> Result<SpatialInteractionSourceKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InteractionSourceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn try_get_pointer_pose(&self, coordinateSystem: &crate::windows::perception::spatial::SpatialCoordinateSystem) -> Result<Option<ComPtr<SpatialPointerPose>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetPointerPose)(self as *const _ as *mut _, coordinateSystem as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tap_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TapCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SpatialTappedEventArgs: ISpatialTappedEventArgs}
} // Windows.UI.Input.Spatial
} // Windows.UI.Input
pub mod notifications { // Windows.UI.Notifications
use crate::prelude::*;
DEFINE_IID!(IID_IAdaptiveNotificationContent, 3943546470, 29768, 17549, 157, 184, 215, 138, 205, 42, 187, 169);
RT_INTERFACE!{interface IAdaptiveNotificationContent(IAdaptiveNotificationContentVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveNotificationContent] {
    fn get_Kind(&self, out: *mut AdaptiveNotificationContentKind) -> HRESULT,
    fn get_Hints(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT
}}
impl IAdaptiveNotificationContent {
    #[inline] pub fn get_kind(&self) -> Result<AdaptiveNotificationContentKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hints(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Hints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AdaptiveNotificationContentKind: i32 {
    Text = 0,
}}
DEFINE_IID!(IID_IAdaptiveNotificationText, 1188340670, 24730, 17190, 164, 11, 191, 222, 135, 32, 52, 163);
RT_INTERFACE!{interface IAdaptiveNotificationText(IAdaptiveNotificationTextVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveNotificationText] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Language(&self, value: HSTRING) -> HRESULT
}}
impl IAdaptiveNotificationText {
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_language(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Language)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AdaptiveNotificationText: IAdaptiveNotificationText}
impl RtActivatable<IActivationFactory> for AdaptiveNotificationText {}
DEFINE_CLSID!(AdaptiveNotificationText(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,65,100,97,112,116,105,118,101,78,111,116,105,102,105,99,97,116,105,111,110,84,101,120,116,0]) [CLSID_AdaptiveNotificationText]);
DEFINE_IID!(IID_IBadgeNotification, 123516106, 53386, 20015, 146, 51, 126, 40, 156, 31, 119, 34);
RT_INTERFACE!{interface IBadgeNotification(IBadgeNotificationVtbl): IInspectable(IInspectableVtbl) [IID_IBadgeNotification] {
    #[cfg(not(feature="windows-data"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Content(&self, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT
}}
impl IBadgeNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn get_content(&self) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BadgeNotification: IBadgeNotification}
impl RtActivatable<IBadgeNotificationFactory> for BadgeNotification {}
impl BadgeNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn create_badge_notification(content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<BadgeNotification>> {
        <Self as RtActivatable<IBadgeNotificationFactory>>::get_activation_factory().create_badge_notification(content)
    }
}
DEFINE_CLSID!(BadgeNotification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,66,97,100,103,101,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_BadgeNotification]);
DEFINE_IID!(IID_IBadgeNotificationFactory, 3992081870, 1560, 19801, 148, 138, 90, 97, 4, 12, 82, 249);
RT_INTERFACE!{static interface IBadgeNotificationFactory(IBadgeNotificationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBadgeNotificationFactory] {
    #[cfg(feature="windows-data")] fn CreateBadgeNotification(&self, content: *mut super::super::data::xml::dom::XmlDocument, out: *mut *mut BadgeNotification) -> HRESULT
}}
impl IBadgeNotificationFactory {
    #[cfg(feature="windows-data")] #[inline] pub fn create_badge_notification(&self, content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<BadgeNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeNotification)(self as *const _ as *mut _, content as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BadgeTemplateType: i32 {
    BadgeGlyph = 0, BadgeNumber = 1,
}}
RT_CLASS!{static class BadgeUpdateManager}
impl RtActivatable<IBadgeUpdateManagerStatics> for BadgeUpdateManager {}
impl RtActivatable<IBadgeUpdateManagerStatics2> for BadgeUpdateManager {}
impl BadgeUpdateManager {
    #[inline] pub fn create_badge_updater_for_application() -> Result<Option<ComPtr<BadgeUpdater>>> {
        <Self as RtActivatable<IBadgeUpdateManagerStatics>>::get_activation_factory().create_badge_updater_for_application()
    }
    #[inline] pub fn create_badge_updater_for_application_with_id(applicationId: &HStringArg) -> Result<Option<ComPtr<BadgeUpdater>>> {
        <Self as RtActivatable<IBadgeUpdateManagerStatics>>::get_activation_factory().create_badge_updater_for_application_with_id(applicationId)
    }
    #[inline] pub fn create_badge_updater_for_secondary_tile(tileId: &HStringArg) -> Result<Option<ComPtr<BadgeUpdater>>> {
        <Self as RtActivatable<IBadgeUpdateManagerStatics>>::get_activation_factory().create_badge_updater_for_secondary_tile(tileId)
    }
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(type_: BadgeTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> {
        <Self as RtActivatable<IBadgeUpdateManagerStatics>>::get_activation_factory().get_template_content(type_)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<ComPtr<BadgeUpdateManagerForUser>>> {
        <Self as RtActivatable<IBadgeUpdateManagerStatics2>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(BadgeUpdateManager(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,66,97,100,103,101,85,112,100,97,116,101,77,97,110,97,103,101,114,0]) [CLSID_BadgeUpdateManager]);
DEFINE_IID!(IID_IBadgeUpdateManagerForUser, 2573935036, 902, 17637, 186, 141, 12, 16, 119, 166, 46, 146);
RT_INTERFACE!{interface IBadgeUpdateManagerForUser(IBadgeUpdateManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IBadgeUpdateManagerForUser] {
    fn CreateBadgeUpdaterForApplication(&self, out: *mut *mut BadgeUpdater) -> HRESULT,
    fn CreateBadgeUpdaterForApplicationWithId(&self, applicationId: HSTRING, out: *mut *mut BadgeUpdater) -> HRESULT,
    fn CreateBadgeUpdaterForSecondaryTile(&self, tileId: HSTRING, out: *mut *mut BadgeUpdater) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IBadgeUpdateManagerForUser {
    #[inline] pub fn create_badge_updater_for_application(&self) -> Result<Option<ComPtr<BadgeUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeUpdaterForApplication)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_badge_updater_for_application_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<BadgeUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeUpdaterForApplicationWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_badge_updater_for_secondary_tile(&self, tileId: &HStringArg) -> Result<Option<ComPtr<BadgeUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeUpdaterForSecondaryTile)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<ComPtr<super::super::system::User>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BadgeUpdateManagerForUser: IBadgeUpdateManagerForUser}
DEFINE_IID!(IID_IBadgeUpdateManagerStatics, 859836330, 28117, 16645, 174, 188, 155, 80, 252, 164, 146, 218);
RT_INTERFACE!{static interface IBadgeUpdateManagerStatics(IBadgeUpdateManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBadgeUpdateManagerStatics] {
    fn CreateBadgeUpdaterForApplication(&self, out: *mut *mut BadgeUpdater) -> HRESULT,
    fn CreateBadgeUpdaterForApplicationWithId(&self, applicationId: HSTRING, out: *mut *mut BadgeUpdater) -> HRESULT,
    fn CreateBadgeUpdaterForSecondaryTile(&self, tileId: HSTRING, out: *mut *mut BadgeUpdater) -> HRESULT,
    #[cfg(feature="windows-data")] fn GetTemplateContent(&self, type_: BadgeTemplateType, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT
}}
impl IBadgeUpdateManagerStatics {
    #[inline] pub fn create_badge_updater_for_application(&self) -> Result<Option<ComPtr<BadgeUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeUpdaterForApplication)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_badge_updater_for_application_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<BadgeUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeUpdaterForApplicationWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_badge_updater_for_secondary_tile(&self, tileId: &HStringArg) -> Result<Option<ComPtr<BadgeUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateBadgeUpdaterForSecondaryTile)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(&self, type_: BadgeTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTemplateContent)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBadgeUpdateManagerStatics2, 2543465934, 63808, 18623, 148, 232, 202, 36, 77, 64, 11, 65);
RT_INTERFACE!{static interface IBadgeUpdateManagerStatics2(IBadgeUpdateManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBadgeUpdateManagerStatics2] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut BadgeUpdateManagerForUser) -> HRESULT
}}
impl IBadgeUpdateManagerStatics2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<ComPtr<BadgeUpdateManagerForUser>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBadgeUpdater, 3053068244, 30050, 20332, 191, 163, 27, 110, 210, 229, 127, 47);
RT_INTERFACE!{interface IBadgeUpdater(IBadgeUpdaterVtbl): IInspectable(IInspectableVtbl) [IID_IBadgeUpdater] {
    fn Update(&self, notification: *mut BadgeNotification) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn StartPeriodicUpdate(&self, badgeContent: *mut foundation::Uri, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StartPeriodicUpdateAtTime(&self, badgeContent: *mut foundation::Uri, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StopPeriodicUpdate(&self) -> HRESULT
}}
impl IBadgeUpdater {
    #[inline] pub fn update(&self, notification: &BadgeNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Update)(self as *const _ as *mut _, notification as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update(&self, badgeContent: &foundation::Uri, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdate)(self as *const _ as *mut _, badgeContent as *const _ as *mut _, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update_at_time(&self, badgeContent: &foundation::Uri, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdateAtTime)(self as *const _ as *mut _, badgeContent as *const _ as *mut _, startTime, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_periodic_update(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StopPeriodicUpdate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BadgeUpdater: IBadgeUpdater}
RT_CLASS!{static class KnownAdaptiveNotificationHints}
impl RtActivatable<IKnownAdaptiveNotificationHintsStatics> for KnownAdaptiveNotificationHints {}
impl KnownAdaptiveNotificationHints {
    #[inline] pub fn get_style() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationHintsStatics>>::get_activation_factory().get_style()
    }
    #[inline] pub fn get_wrap() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationHintsStatics>>::get_activation_factory().get_wrap()
    }
    #[inline] pub fn get_max_lines() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationHintsStatics>>::get_activation_factory().get_max_lines()
    }
    #[inline] pub fn get_min_lines() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationHintsStatics>>::get_activation_factory().get_min_lines()
    }
    #[inline] pub fn get_text_stacking() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationHintsStatics>>::get_activation_factory().get_text_stacking()
    }
    #[inline] pub fn get_align() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationHintsStatics>>::get_activation_factory().get_align()
    }
}
DEFINE_CLSID!(KnownAdaptiveNotificationHints(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,75,110,111,119,110,65,100,97,112,116,105,118,101,78,111,116,105,102,105,99,97,116,105,111,110,72,105,110,116,115,0]) [CLSID_KnownAdaptiveNotificationHints]);
DEFINE_IID!(IID_IKnownAdaptiveNotificationHintsStatics, 102786456, 54422, 18813, 134, 146, 79, 125, 124, 39, 112, 223);
RT_INTERFACE!{static interface IKnownAdaptiveNotificationHintsStatics(IKnownAdaptiveNotificationHintsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownAdaptiveNotificationHintsStatics] {
    fn get_Style(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Wrap(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MaxLines(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinLines(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TextStacking(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Align(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownAdaptiveNotificationHintsStatics {
    #[inline] pub fn get_style(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Style)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wrap(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Wrap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_lines(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min_lines(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MinLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_stacking(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextStacking)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_align(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Align)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownAdaptiveNotificationTextStyles}
impl RtActivatable<IKnownAdaptiveNotificationTextStylesStatics> for KnownAdaptiveNotificationTextStyles {}
impl KnownAdaptiveNotificationTextStyles {
    #[inline] pub fn get_caption() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_caption()
    }
    #[inline] pub fn get_body() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_body()
    }
    #[inline] pub fn get_base() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_base()
    }
    #[inline] pub fn get_subtitle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_subtitle()
    }
    #[inline] pub fn get_title() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_title()
    }
    #[inline] pub fn get_subheader() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_subheader()
    }
    #[inline] pub fn get_header() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_header()
    }
    #[inline] pub fn get_title_numeral() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_title_numeral()
    }
    #[inline] pub fn get_subheader_numeral() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_subheader_numeral()
    }
    #[inline] pub fn get_header_numeral() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_header_numeral()
    }
    #[inline] pub fn get_caption_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_caption_subtle()
    }
    #[inline] pub fn get_body_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_body_subtle()
    }
    #[inline] pub fn get_base_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_base_subtle()
    }
    #[inline] pub fn get_subtitle_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_subtitle_subtle()
    }
    #[inline] pub fn get_title_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_title_subtle()
    }
    #[inline] pub fn get_subheader_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_subheader_subtle()
    }
    #[inline] pub fn get_subheader_numeral_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_subheader_numeral_subtle()
    }
    #[inline] pub fn get_header_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_header_subtle()
    }
    #[inline] pub fn get_header_numeral_subtle() -> Result<HString> {
        <Self as RtActivatable<IKnownAdaptiveNotificationTextStylesStatics>>::get_activation_factory().get_header_numeral_subtle()
    }
}
DEFINE_CLSID!(KnownAdaptiveNotificationTextStyles(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,75,110,111,119,110,65,100,97,112,116,105,118,101,78,111,116,105,102,105,99,97,116,105,111,110,84,101,120,116,83,116,121,108,101,115,0]) [CLSID_KnownAdaptiveNotificationTextStyles]);
DEFINE_IID!(IID_IKnownAdaptiveNotificationTextStylesStatics, 539071191, 35222, 17834, 139, 161, 212, 97, 215, 44, 42, 27);
RT_INTERFACE!{static interface IKnownAdaptiveNotificationTextStylesStatics(IKnownAdaptiveNotificationTextStylesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownAdaptiveNotificationTextStylesStatics] {
    fn get_Caption(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Base(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Subtitle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Subheader(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Header(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TitleNumeral(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SubheaderNumeral(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HeaderNumeral(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CaptionSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BodySubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BaseSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SubtitleSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TitleSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SubheaderSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SubheaderNumeralSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HeaderSubtle(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HeaderNumeralSubtle(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownAdaptiveNotificationTextStylesStatics {
    #[inline] pub fn get_caption(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Caption)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Body)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_base(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Base)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subtitle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subtitle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subheader(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subheader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_header(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Header)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title_numeral(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleNumeral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subheader_numeral(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SubheaderNumeral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_header_numeral(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderNumeral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_caption_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CaptionSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BodySubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_base_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BaseSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subtitle_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SubtitleSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subheader_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SubheaderSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subheader_numeral_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SubheaderNumeralSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_header_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_header_numeral_subtle(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderNumeralSubtle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownNotificationBindings}
impl RtActivatable<IKnownNotificationBindingsStatics> for KnownNotificationBindings {}
impl KnownNotificationBindings {
    #[inline] pub fn get_toast_generic() -> Result<HString> {
        <Self as RtActivatable<IKnownNotificationBindingsStatics>>::get_activation_factory().get_toast_generic()
    }
}
DEFINE_CLSID!(KnownNotificationBindings(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,75,110,111,119,110,78,111,116,105,102,105,99,97,116,105,111,110,66,105,110,100,105,110,103,115,0]) [CLSID_KnownNotificationBindings]);
DEFINE_IID!(IID_IKnownNotificationBindingsStatics, 2034400174, 43191, 19800, 137, 234, 118, 167, 183, 188, 205, 237);
RT_INTERFACE!{static interface IKnownNotificationBindingsStatics(IKnownNotificationBindingsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownNotificationBindingsStatics] {
    fn get_ToastGeneric(&self, out: *mut HSTRING) -> HRESULT
}}
impl IKnownNotificationBindingsStatics {
    #[inline] pub fn get_toast_generic(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ToastGeneric)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INotification, 276838398, 60278, 20354, 151, 188, 218, 7, 83, 10, 46, 32);
RT_INTERFACE!{interface INotification(INotificationVtbl): IInspectable(IInspectableVtbl) [IID_INotification] {
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_Visual(&self, out: *mut *mut NotificationVisual) -> HRESULT,
    fn put_Visual(&self, value: *mut NotificationVisual) -> HRESULT
}}
impl INotification {
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_visual(&self) -> Result<Option<ComPtr<NotificationVisual>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Visual)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_visual(&self, value: &NotificationVisual) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Visual)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Notification: INotification}
impl RtActivatable<IActivationFactory> for Notification {}
DEFINE_CLSID!(Notification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_Notification]);
DEFINE_IID!(IID_INotificationBinding, 4070460293, 880, 19155, 180, 234, 218, 158, 53, 231, 234, 191);
RT_INTERFACE!{interface INotificationBinding(INotificationBindingVtbl): IInspectable(IInspectableVtbl) [IID_INotificationBinding] {
    fn get_Template(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Template(&self, value: HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Language(&self, value: HSTRING) -> HRESULT,
    fn get_Hints(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT,
    fn GetTextElements(&self, out: *mut *mut foundation::collections::IVectorView<AdaptiveNotificationText>) -> HRESULT
}}
impl INotificationBinding {
    #[inline] pub fn get_template(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Template)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_template(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Template)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_language(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Language)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hints(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Hints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_elements(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<AdaptiveNotificationText>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTextElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NotificationBinding: INotificationBinding}
DEFINE_IID!(IID_INotificationData, 2684166930, 40298, 19119, 182, 172, 255, 23, 240, 193, 242, 128);
RT_INTERFACE!{interface INotificationData(INotificationDataVtbl): IInspectable(IInspectableVtbl) [IID_INotificationData] {
    fn get_Values(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT,
    fn get_SequenceNumber(&self, out: *mut u32) -> HRESULT,
    fn put_SequenceNumber(&self, value: u32) -> HRESULT
}}
impl INotificationData {
    #[inline] pub fn get_values(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Values)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sequence_number(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SequenceNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sequence_number(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SequenceNumber)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class NotificationData: INotificationData}
impl RtActivatable<INotificationDataFactory> for NotificationData {}
impl RtActivatable<IActivationFactory> for NotificationData {}
impl NotificationData {
    #[inline] pub fn create_notification_data_with_values_and_sequence_number(initialValues: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, sequenceNumber: u32) -> Result<ComPtr<NotificationData>> {
        <Self as RtActivatable<INotificationDataFactory>>::get_activation_factory().create_notification_data_with_values_and_sequence_number(initialValues, sequenceNumber)
    }
    #[inline] pub fn create_notification_data_with_values(initialValues: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<ComPtr<NotificationData>> {
        <Self as RtActivatable<INotificationDataFactory>>::get_activation_factory().create_notification_data_with_values(initialValues)
    }
}
DEFINE_CLSID!(NotificationData(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,78,111,116,105,102,105,99,97,116,105,111,110,68,97,116,97,0]) [CLSID_NotificationData]);
DEFINE_IID!(IID_INotificationDataFactory, 599909178, 7184, 18171, 128, 64, 222, 195, 132, 98, 28, 248);
RT_INTERFACE!{static interface INotificationDataFactory(INotificationDataFactoryVtbl): IInspectable(IInspectableVtbl) [IID_INotificationDataFactory] {
    fn CreateNotificationDataWithValuesAndSequenceNumber(&self, initialValues: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, sequenceNumber: u32, out: *mut *mut NotificationData) -> HRESULT,
    fn CreateNotificationDataWithValues(&self, initialValues: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut NotificationData) -> HRESULT
}}
impl INotificationDataFactory {
    #[inline] pub fn create_notification_data_with_values_and_sequence_number(&self, initialValues: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, sequenceNumber: u32) -> Result<ComPtr<NotificationData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateNotificationDataWithValuesAndSequenceNumber)(self as *const _ as *mut _, initialValues as *const _ as *mut _, sequenceNumber, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_notification_data_with_values(&self, initialValues: &foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>) -> Result<ComPtr<NotificationData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateNotificationDataWithValues)(self as *const _ as *mut _, initialValues as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum NotificationKinds: u32 {
    Unknown = 0, Toast = 1,
}}
RT_ENUM! { enum NotificationMirroring: i32 {
    Allowed = 0, Disabled = 1,
}}
RT_ENUM! { enum NotificationSetting: i32 {
    Enabled = 0, DisabledForApplication = 1, DisabledForUser = 2, DisabledByGroupPolicy = 3, DisabledByManifest = 4,
}}
RT_ENUM! { enum NotificationUpdateResult: i32 {
    Succeeded = 0, Failed = 1, NotificationNotFound = 2,
}}
DEFINE_IID!(IID_INotificationVisual, 1753439118, 43606, 19985, 134, 211, 95, 154, 105, 87, 188, 91);
RT_INTERFACE!{interface INotificationVisual(INotificationVisualVtbl): IInspectable(IInspectableVtbl) [IID_INotificationVisual] {
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Language(&self, value: HSTRING) -> HRESULT,
    fn get_Bindings(&self, out: *mut *mut foundation::collections::IVector<NotificationBinding>) -> HRESULT,
    fn GetBinding(&self, templateName: HSTRING, out: *mut *mut NotificationBinding) -> HRESULT
}}
impl INotificationVisual {
    #[inline] pub fn get_language(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_language(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Language)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bindings(&self) -> Result<Option<ComPtr<foundation::collections::IVector<NotificationBinding>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Bindings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_binding(&self, templateName: &HStringArg) -> Result<Option<ComPtr<NotificationBinding>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetBinding)(self as *const _ as *mut _, templateName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NotificationVisual: INotificationVisual}
RT_ENUM! { enum PeriodicUpdateRecurrence: i32 {
    HalfHour = 0, Hour = 1, SixHours = 2, TwelveHours = 3, Daily = 4,
}}
DEFINE_IID!(IID_IScheduledTileNotification, 180135637, 39388, 19576, 161, 28, 201, 231, 248, 109, 126, 247);
RT_INTERFACE!{interface IScheduledTileNotification(IScheduledTileNotificationVtbl): IInspectable(IInspectableVtbl) [IID_IScheduledTileNotification] {
    #[cfg(not(feature="windows-data"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Content(&self, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT,
    fn get_DeliveryTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IScheduledTileNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn get_content(&self) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_delivery_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeliveryTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ScheduledTileNotification: IScheduledTileNotification}
impl RtActivatable<IScheduledTileNotificationFactory> for ScheduledTileNotification {}
impl ScheduledTileNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn create_scheduled_tile_notification(content: &super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime) -> Result<ComPtr<ScheduledTileNotification>> {
        <Self as RtActivatable<IScheduledTileNotificationFactory>>::get_activation_factory().create_scheduled_tile_notification(content, deliveryTime)
    }
}
DEFINE_CLSID!(ScheduledTileNotification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,83,99,104,101,100,117,108,101,100,84,105,108,101,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_ScheduledTileNotification]);
DEFINE_IID!(IID_IScheduledTileNotificationFactory, 864228234, 39104, 19515, 187, 214, 74, 99, 60, 124, 252, 41);
RT_INTERFACE!{static interface IScheduledTileNotificationFactory(IScheduledTileNotificationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IScheduledTileNotificationFactory] {
    #[cfg(feature="windows-data")] fn CreateScheduledTileNotification(&self, content: *mut super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime, out: *mut *mut ScheduledTileNotification) -> HRESULT
}}
impl IScheduledTileNotificationFactory {
    #[cfg(feature="windows-data")] #[inline] pub fn create_scheduled_tile_notification(&self, content: &super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime) -> Result<ComPtr<ScheduledTileNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateScheduledTileNotification)(self as *const _ as *mut _, content as *const _ as *mut _, deliveryTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IScheduledToastNotification, 2046130168, 3559, 18637, 151, 64, 155, 55, 4, 144, 200, 56);
RT_INTERFACE!{interface IScheduledToastNotification(IScheduledToastNotificationVtbl): IInspectable(IInspectableVtbl) [IID_IScheduledToastNotification] {
    #[cfg(not(feature="windows-data"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Content(&self, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT,
    fn get_DeliveryTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_SnoozeInterval(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_MaximumSnoozeCount(&self, out: *mut u32) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IScheduledToastNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn get_content(&self) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_delivery_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeliveryTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_snooze_interval(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SnoozeInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_maximum_snooze_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaximumSnoozeCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ScheduledToastNotification: IScheduledToastNotification}
impl RtActivatable<IScheduledToastNotificationFactory> for ScheduledToastNotification {}
impl ScheduledToastNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn create_scheduled_toast_notification(content: &super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime) -> Result<ComPtr<ScheduledToastNotification>> {
        <Self as RtActivatable<IScheduledToastNotificationFactory>>::get_activation_factory().create_scheduled_toast_notification(content, deliveryTime)
    }
    #[cfg(feature="windows-data")] #[inline] pub fn create_scheduled_toast_notification_recurring(content: &super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime, snoozeInterval: foundation::TimeSpan, maximumSnoozeCount: u32) -> Result<ComPtr<ScheduledToastNotification>> {
        <Self as RtActivatable<IScheduledToastNotificationFactory>>::get_activation_factory().create_scheduled_toast_notification_recurring(content, deliveryTime, snoozeInterval, maximumSnoozeCount)
    }
}
DEFINE_CLSID!(ScheduledToastNotification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,83,99,104,101,100,117,108,101,100,84,111,97,115,116,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_ScheduledToastNotification]);
DEFINE_IID!(IID_IScheduledToastNotification2, 2792267932, 12724, 17328, 181, 221, 122, 64, 232, 83, 99, 177);
RT_INTERFACE!{interface IScheduledToastNotification2(IScheduledToastNotification2Vtbl): IInspectable(IInspectableVtbl) [IID_IScheduledToastNotification2] {
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Group(&self, value: HSTRING) -> HRESULT,
    fn get_Group(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SuppressPopup(&self, value: bool) -> HRESULT,
    fn get_SuppressPopup(&self, out: *mut bool) -> HRESULT
}}
impl IScheduledToastNotification2 {
    #[inline] pub fn set_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_group(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Group)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_group(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Group)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_suppress_popup(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SuppressPopup)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_suppress_popup(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SuppressPopup)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IScheduledToastNotification3, 2554502795, 48434, 19003, 157, 21, 34, 174, 164, 148, 98, 161);
RT_INTERFACE!{interface IScheduledToastNotification3(IScheduledToastNotification3Vtbl): IInspectable(IInspectableVtbl) [IID_IScheduledToastNotification3] {
    fn get_NotificationMirroring(&self, out: *mut NotificationMirroring) -> HRESULT,
    fn put_NotificationMirroring(&self, value: NotificationMirroring) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT
}}
impl IScheduledToastNotification3 {
    #[inline] pub fn get_notification_mirroring(&self) -> Result<NotificationMirroring> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NotificationMirroring)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_notification_mirroring(&self, value: NotificationMirroring) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_NotificationMirroring)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IScheduledToastNotification4, 491217405, 48623, 20042, 150, 190, 1, 1, 54, 155, 88, 210);
RT_INTERFACE!{interface IScheduledToastNotification4(IScheduledToastNotification4Vtbl): IInspectable(IInspectableVtbl) [IID_IScheduledToastNotification4] {
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT
}}
impl IScheduledToastNotification4 {
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IScheduledToastNotificationFactory, 3888042385, 3001, 16777, 131, 148, 49, 118, 27, 71, 111, 215);
RT_INTERFACE!{static interface IScheduledToastNotificationFactory(IScheduledToastNotificationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IScheduledToastNotificationFactory] {
    #[cfg(feature="windows-data")] fn CreateScheduledToastNotification(&self, content: *mut super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime, out: *mut *mut ScheduledToastNotification) -> HRESULT,
    #[cfg(feature="windows-data")] fn CreateScheduledToastNotificationRecurring(&self, content: *mut super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime, snoozeInterval: foundation::TimeSpan, maximumSnoozeCount: u32, out: *mut *mut ScheduledToastNotification) -> HRESULT
}}
impl IScheduledToastNotificationFactory {
    #[cfg(feature="windows-data")] #[inline] pub fn create_scheduled_toast_notification(&self, content: &super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime) -> Result<ComPtr<ScheduledToastNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateScheduledToastNotification)(self as *const _ as *mut _, content as *const _ as *mut _, deliveryTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-data")] #[inline] pub fn create_scheduled_toast_notification_recurring(&self, content: &super::super::data::xml::dom::XmlDocument, deliveryTime: foundation::DateTime, snoozeInterval: foundation::TimeSpan, maximumSnoozeCount: u32) -> Result<ComPtr<ScheduledToastNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateScheduledToastNotificationRecurring)(self as *const _ as *mut _, content as *const _ as *mut _, deliveryTime, snoozeInterval, maximumSnoozeCount, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IScheduledToastNotificationShowingEventArgs, 1634989748, 16682, 24108, 166, 237, 160, 32, 154, 239, 154, 9);
RT_INTERFACE!{interface IScheduledToastNotificationShowingEventArgs(IScheduledToastNotificationShowingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IScheduledToastNotificationShowingEventArgs] {
    fn get_Cancel(&self, out: *mut bool) -> HRESULT,
    fn put_Cancel(&self, value: bool) -> HRESULT,
    fn get_ScheduledToastNotification(&self, out: *mut *mut ScheduledToastNotification) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl IScheduledToastNotificationShowingEventArgs {
    #[inline] pub fn get_cancel(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Cancel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cancel(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Cancel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scheduled_toast_notification(&self) -> Result<Option<ComPtr<ScheduledToastNotification>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ScheduledToastNotification)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ScheduledToastNotificationShowingEventArgs: IScheduledToastNotificationShowingEventArgs}
DEFINE_IID!(IID_IShownTileNotification, 875399560, 23282, 18458, 166, 163, 242, 253, 199, 141, 232, 142);
RT_INTERFACE!{interface IShownTileNotification(IShownTileNotificationVtbl): IInspectable(IInspectableVtbl) [IID_IShownTileNotification] {
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT
}}
impl IShownTileNotification {
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ShownTileNotification: IShownTileNotification}
DEFINE_IID!(IID_ITileFlyoutNotification, 2589176417, 50956, 17086, 178, 243, 244, 42, 169, 125, 52, 229);
RT_INTERFACE!{interface ITileFlyoutNotification(ITileFlyoutNotificationVtbl): IInspectable(IInspectableVtbl) [IID_ITileFlyoutNotification] {
    #[cfg(not(feature="windows-data"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Content(&self, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT
}}
impl ITileFlyoutNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn get_content(&self) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TileFlyoutNotification: ITileFlyoutNotification}
impl RtActivatable<ITileFlyoutNotificationFactory> for TileFlyoutNotification {}
impl TileFlyoutNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn create_tile_flyout_notification(content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<TileFlyoutNotification>> {
        <Self as RtActivatable<ITileFlyoutNotificationFactory>>::get_activation_factory().create_tile_flyout_notification(content)
    }
}
DEFINE_CLSID!(TileFlyoutNotification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,105,108,101,70,108,121,111,117,116,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_TileFlyoutNotification]);
DEFINE_IID!(IID_ITileFlyoutNotificationFactory, 4015353845, 21030, 20267, 178, 120, 136, 163, 93, 254, 86, 159);
RT_INTERFACE!{static interface ITileFlyoutNotificationFactory(ITileFlyoutNotificationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITileFlyoutNotificationFactory] {
    #[cfg(feature="windows-data")] fn CreateTileFlyoutNotification(&self, content: *mut super::super::data::xml::dom::XmlDocument, out: *mut *mut TileFlyoutNotification) -> HRESULT
}}
impl ITileFlyoutNotificationFactory {
    #[cfg(feature="windows-data")] #[inline] pub fn create_tile_flyout_notification(&self, content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<TileFlyoutNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileFlyoutNotification)(self as *const _ as *mut _, content as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum TileFlyoutTemplateType: i32 {
    TileFlyoutTemplate01 = 0,
}}
RT_CLASS!{static class TileFlyoutUpdateManager}
impl RtActivatable<ITileFlyoutUpdateManagerStatics> for TileFlyoutUpdateManager {}
impl TileFlyoutUpdateManager {
    #[inline] pub fn create_tile_flyout_updater_for_application() -> Result<Option<ComPtr<TileFlyoutUpdater>>> {
        <Self as RtActivatable<ITileFlyoutUpdateManagerStatics>>::get_activation_factory().create_tile_flyout_updater_for_application()
    }
    #[inline] pub fn create_tile_flyout_updater_for_application_with_id(applicationId: &HStringArg) -> Result<Option<ComPtr<TileFlyoutUpdater>>> {
        <Self as RtActivatable<ITileFlyoutUpdateManagerStatics>>::get_activation_factory().create_tile_flyout_updater_for_application_with_id(applicationId)
    }
    #[inline] pub fn create_tile_flyout_updater_for_secondary_tile(tileId: &HStringArg) -> Result<Option<ComPtr<TileFlyoutUpdater>>> {
        <Self as RtActivatable<ITileFlyoutUpdateManagerStatics>>::get_activation_factory().create_tile_flyout_updater_for_secondary_tile(tileId)
    }
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(type_: TileFlyoutTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> {
        <Self as RtActivatable<ITileFlyoutUpdateManagerStatics>>::get_activation_factory().get_template_content(type_)
    }
}
DEFINE_CLSID!(TileFlyoutUpdateManager(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,105,108,101,70,108,121,111,117,116,85,112,100,97,116,101,77,97,110,97,103,101,114,0]) [CLSID_TileFlyoutUpdateManager]);
DEFINE_IID!(IID_ITileFlyoutUpdateManagerStatics, 70662923, 6848, 19353, 136, 231, 173, 168, 62, 149, 61, 72);
RT_INTERFACE!{static interface ITileFlyoutUpdateManagerStatics(ITileFlyoutUpdateManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITileFlyoutUpdateManagerStatics] {
    fn CreateTileFlyoutUpdaterForApplication(&self, out: *mut *mut TileFlyoutUpdater) -> HRESULT,
    fn CreateTileFlyoutUpdaterForApplicationWithId(&self, applicationId: HSTRING, out: *mut *mut TileFlyoutUpdater) -> HRESULT,
    fn CreateTileFlyoutUpdaterForSecondaryTile(&self, tileId: HSTRING, out: *mut *mut TileFlyoutUpdater) -> HRESULT,
    #[cfg(feature="windows-data")] fn GetTemplateContent(&self, type_: TileFlyoutTemplateType, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT
}}
impl ITileFlyoutUpdateManagerStatics {
    #[inline] pub fn create_tile_flyout_updater_for_application(&self) -> Result<Option<ComPtr<TileFlyoutUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileFlyoutUpdaterForApplication)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_tile_flyout_updater_for_application_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<TileFlyoutUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileFlyoutUpdaterForApplicationWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_tile_flyout_updater_for_secondary_tile(&self, tileId: &HStringArg) -> Result<Option<ComPtr<TileFlyoutUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileFlyoutUpdaterForSecondaryTile)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(&self, type_: TileFlyoutTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTemplateContent)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITileFlyoutUpdater, 2369832810, 50277, 16466, 167, 64, 92, 38, 84, 193, 160, 137);
RT_INTERFACE!{interface ITileFlyoutUpdater(ITileFlyoutUpdaterVtbl): IInspectable(IInspectableVtbl) [IID_ITileFlyoutUpdater] {
    fn Update(&self, notification: *mut TileFlyoutNotification) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn StartPeriodicUpdate(&self, tileFlyoutContent: *mut foundation::Uri, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StartPeriodicUpdateAtTime(&self, tileFlyoutContent: *mut foundation::Uri, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StopPeriodicUpdate(&self) -> HRESULT,
    fn get_Setting(&self, out: *mut NotificationSetting) -> HRESULT
}}
impl ITileFlyoutUpdater {
    #[inline] pub fn update(&self, notification: &TileFlyoutNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Update)(self as *const _ as *mut _, notification as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update(&self, tileFlyoutContent: &foundation::Uri, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdate)(self as *const _ as *mut _, tileFlyoutContent as *const _ as *mut _, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update_at_time(&self, tileFlyoutContent: &foundation::Uri, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdateAtTime)(self as *const _ as *mut _, tileFlyoutContent as *const _ as *mut _, startTime, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_periodic_update(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StopPeriodicUpdate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_setting(&self) -> Result<NotificationSetting> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Setting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TileFlyoutUpdater: ITileFlyoutUpdater}
DEFINE_IID!(IID_ITileNotification, 3954100474, 20716, 19480, 180, 208, 58, 240, 46, 85, 64, 171);
RT_INTERFACE!{interface ITileNotification(ITileNotificationVtbl): IInspectable(IInspectableVtbl) [IID_ITileNotification] {
    #[cfg(not(feature="windows-data"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Content(&self, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT
}}
impl ITileNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn get_content(&self) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TileNotification: ITileNotification}
impl RtActivatable<ITileNotificationFactory> for TileNotification {}
impl TileNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn create_tile_notification(content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<TileNotification>> {
        <Self as RtActivatable<ITileNotificationFactory>>::get_activation_factory().create_tile_notification(content)
    }
}
DEFINE_CLSID!(TileNotification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,105,108,101,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_TileNotification]);
DEFINE_IID!(IID_ITileNotificationFactory, 3333152110, 18728, 18120, 189, 191, 129, 160, 71, 222, 160, 212);
RT_INTERFACE!{static interface ITileNotificationFactory(ITileNotificationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITileNotificationFactory] {
    #[cfg(feature="windows-data")] fn CreateTileNotification(&self, content: *mut super::super::data::xml::dom::XmlDocument, out: *mut *mut TileNotification) -> HRESULT
}}
impl ITileNotificationFactory {
    #[cfg(feature="windows-data")] #[inline] pub fn create_tile_notification(&self, content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<TileNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileNotification)(self as *const _ as *mut _, content as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum TileTemplateType: i32 {
    TileSquareImage = 0, TileSquareBlock = 1, TileSquareText01 = 2, TileSquareText02 = 3, TileSquareText03 = 4, TileSquareText04 = 5, TileSquarePeekImageAndText01 = 6, TileSquarePeekImageAndText02 = 7, TileSquarePeekImageAndText03 = 8, TileSquarePeekImageAndText04 = 9, TileWideImage = 10, TileWideImageCollection = 11, TileWideImageAndText01 = 12, TileWideImageAndText02 = 13, TileWideBlockAndText01 = 14, TileWideBlockAndText02 = 15, TileWidePeekImageCollection01 = 16, TileWidePeekImageCollection02 = 17, TileWidePeekImageCollection03 = 18, TileWidePeekImageCollection04 = 19, TileWidePeekImageCollection05 = 20, TileWidePeekImageCollection06 = 21, TileWidePeekImageAndText01 = 22, TileWidePeekImageAndText02 = 23, TileWidePeekImage01 = 24, TileWidePeekImage02 = 25, TileWidePeekImage03 = 26, TileWidePeekImage04 = 27, TileWidePeekImage05 = 28, TileWidePeekImage06 = 29, TileWideSmallImageAndText01 = 30, TileWideSmallImageAndText02 = 31, TileWideSmallImageAndText03 = 32, TileWideSmallImageAndText04 = 33, TileWideSmallImageAndText05 = 34, TileWideText01 = 35, TileWideText02 = 36, TileWideText03 = 37, TileWideText04 = 38, TileWideText05 = 39, TileWideText06 = 40, TileWideText07 = 41, TileWideText08 = 42, TileWideText09 = 43, TileWideText10 = 44, TileWideText11 = 45, TileSquare150x150Image = 0, TileSquare150x150Block = 1, TileSquare150x150Text01 = 2, TileSquare150x150Text02 = 3, TileSquare150x150Text03 = 4, TileSquare150x150Text04 = 5, TileSquare150x150PeekImageAndText01 = 6, TileSquare150x150PeekImageAndText02 = 7, TileSquare150x150PeekImageAndText03 = 8, TileSquare150x150PeekImageAndText04 = 9, TileWide310x150Image = 10, TileWide310x150ImageCollection = 11, TileWide310x150ImageAndText01 = 12, TileWide310x150ImageAndText02 = 13, TileWide310x150BlockAndText01 = 14, TileWide310x150BlockAndText02 = 15, TileWide310x150PeekImageCollection01 = 16, TileWide310x150PeekImageCollection02 = 17, TileWide310x150PeekImageCollection03 = 18, TileWide310x150PeekImageCollection04 = 19, TileWide310x150PeekImageCollection05 = 20, TileWide310x150PeekImageCollection06 = 21, TileWide310x150PeekImageAndText01 = 22, TileWide310x150PeekImageAndText02 = 23, TileWide310x150PeekImage01 = 24, TileWide310x150PeekImage02 = 25, TileWide310x150PeekImage03 = 26, TileWide310x150PeekImage04 = 27, TileWide310x150PeekImage05 = 28, TileWide310x150PeekImage06 = 29, TileWide310x150SmallImageAndText01 = 30, TileWide310x150SmallImageAndText02 = 31, TileWide310x150SmallImageAndText03 = 32, TileWide310x150SmallImageAndText04 = 33, TileWide310x150SmallImageAndText05 = 34, TileWide310x150Text01 = 35, TileWide310x150Text02 = 36, TileWide310x150Text03 = 37, TileWide310x150Text04 = 38, TileWide310x150Text05 = 39, TileWide310x150Text06 = 40, TileWide310x150Text07 = 41, TileWide310x150Text08 = 42, TileWide310x150Text09 = 43, TileWide310x150Text10 = 44, TileWide310x150Text11 = 45, TileSquare310x310BlockAndText01 = 46, TileSquare310x310BlockAndText02 = 47, TileSquare310x310Image = 48, TileSquare310x310ImageAndText01 = 49, TileSquare310x310ImageAndText02 = 50, TileSquare310x310ImageAndTextOverlay01 = 51, TileSquare310x310ImageAndTextOverlay02 = 52, TileSquare310x310ImageAndTextOverlay03 = 53, TileSquare310x310ImageCollectionAndText01 = 54, TileSquare310x310ImageCollectionAndText02 = 55, TileSquare310x310ImageCollection = 56, TileSquare310x310SmallImagesAndTextList01 = 57, TileSquare310x310SmallImagesAndTextList02 = 58, TileSquare310x310SmallImagesAndTextList03 = 59, TileSquare310x310SmallImagesAndTextList04 = 60, TileSquare310x310Text01 = 61, TileSquare310x310Text02 = 62, TileSquare310x310Text03 = 63, TileSquare310x310Text04 = 64, TileSquare310x310Text05 = 65, TileSquare310x310Text06 = 66, TileSquare310x310Text07 = 67, TileSquare310x310Text08 = 68, TileSquare310x310TextList01 = 69, TileSquare310x310TextList02 = 70, TileSquare310x310TextList03 = 71, TileSquare310x310SmallImageAndText01 = 72, TileSquare310x310SmallImagesAndTextList05 = 73, TileSquare310x310Text09 = 74, TileSquare71x71IconWithBadge = 75, TileSquare150x150IconWithBadge = 76, TileWide310x150IconWithBadgeAndText = 77, TileSquare71x71Image = 78, TileTall150x310Image = 79,
}}
RT_CLASS!{static class TileUpdateManager}
impl RtActivatable<ITileUpdateManagerStatics> for TileUpdateManager {}
impl RtActivatable<ITileUpdateManagerStatics2> for TileUpdateManager {}
impl TileUpdateManager {
    #[inline] pub fn create_tile_updater_for_application() -> Result<Option<ComPtr<TileUpdater>>> {
        <Self as RtActivatable<ITileUpdateManagerStatics>>::get_activation_factory().create_tile_updater_for_application()
    }
    #[inline] pub fn create_tile_updater_for_application_with_id(applicationId: &HStringArg) -> Result<Option<ComPtr<TileUpdater>>> {
        <Self as RtActivatable<ITileUpdateManagerStatics>>::get_activation_factory().create_tile_updater_for_application_with_id(applicationId)
    }
    #[inline] pub fn create_tile_updater_for_secondary_tile(tileId: &HStringArg) -> Result<Option<ComPtr<TileUpdater>>> {
        <Self as RtActivatable<ITileUpdateManagerStatics>>::get_activation_factory().create_tile_updater_for_secondary_tile(tileId)
    }
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(type_: TileTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> {
        <Self as RtActivatable<ITileUpdateManagerStatics>>::get_activation_factory().get_template_content(type_)
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<ComPtr<TileUpdateManagerForUser>>> {
        <Self as RtActivatable<ITileUpdateManagerStatics2>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(TileUpdateManager(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,105,108,101,85,112,100,97,116,101,77,97,110,97,103,101,114,0]) [CLSID_TileUpdateManager]);
DEFINE_IID!(IID_ITileUpdateManagerForUser, 1427379016, 12002, 20013, 156, 193, 33, 106, 32, 222, 204, 159);
RT_INTERFACE!{interface ITileUpdateManagerForUser(ITileUpdateManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_ITileUpdateManagerForUser] {
    fn CreateTileUpdaterForApplication(&self, out: *mut *mut TileUpdater) -> HRESULT,
    fn CreateTileUpdaterForApplicationWithId(&self, applicationId: HSTRING, out: *mut *mut TileUpdater) -> HRESULT,
    fn CreateTileUpdaterForSecondaryTile(&self, tileId: HSTRING, out: *mut *mut TileUpdater) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl ITileUpdateManagerForUser {
    #[inline] pub fn create_tile_updater_for_application(&self) -> Result<Option<ComPtr<TileUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileUpdaterForApplication)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_tile_updater_for_application_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<TileUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileUpdaterForApplicationWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_tile_updater_for_secondary_tile(&self, tileId: &HStringArg) -> Result<Option<ComPtr<TileUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileUpdaterForSecondaryTile)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<ComPtr<super::super::system::User>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TileUpdateManagerForUser: ITileUpdateManagerForUser}
DEFINE_IID!(IID_ITileUpdateManagerStatics, 3658849885, 16041, 18822, 141, 132, 176, 157, 94, 18, 39, 109);
RT_INTERFACE!{static interface ITileUpdateManagerStatics(ITileUpdateManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITileUpdateManagerStatics] {
    fn CreateTileUpdaterForApplication(&self, out: *mut *mut TileUpdater) -> HRESULT,
    fn CreateTileUpdaterForApplicationWithId(&self, applicationId: HSTRING, out: *mut *mut TileUpdater) -> HRESULT,
    fn CreateTileUpdaterForSecondaryTile(&self, tileId: HSTRING, out: *mut *mut TileUpdater) -> HRESULT,
    #[cfg(feature="windows-data")] fn GetTemplateContent(&self, type_: TileTemplateType, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT
}}
impl ITileUpdateManagerStatics {
    #[inline] pub fn create_tile_updater_for_application(&self) -> Result<Option<ComPtr<TileUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileUpdaterForApplication)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_tile_updater_for_application_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<TileUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileUpdaterForApplicationWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_tile_updater_for_secondary_tile(&self, tileId: &HStringArg) -> Result<Option<ComPtr<TileUpdater>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTileUpdaterForSecondaryTile)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(&self, type_: TileTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTemplateContent)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITileUpdateManagerStatics2, 1931222492, 36372, 19324, 163, 75, 157, 34, 222, 118, 200, 77);
RT_INTERFACE!{static interface ITileUpdateManagerStatics2(ITileUpdateManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ITileUpdateManagerStatics2] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut TileUpdateManagerForUser) -> HRESULT
}}
impl ITileUpdateManagerStatics2 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<ComPtr<TileUpdateManagerForUser>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITileUpdater, 155362443, 7569, 17644, 146, 67, 193, 232, 33, 194, 154, 32);
RT_INTERFACE!{interface ITileUpdater(ITileUpdaterVtbl): IInspectable(IInspectableVtbl) [IID_ITileUpdater] {
    fn Update(&self, notification: *mut TileNotification) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn EnableNotificationQueue(&self, enable: bool) -> HRESULT,
    fn get_Setting(&self, out: *mut NotificationSetting) -> HRESULT,
    fn AddToSchedule(&self, scheduledTile: *mut ScheduledTileNotification) -> HRESULT,
    fn RemoveFromSchedule(&self, scheduledTile: *mut ScheduledTileNotification) -> HRESULT,
    fn GetScheduledTileNotifications(&self, out: *mut *mut foundation::collections::IVectorView<ScheduledTileNotification>) -> HRESULT,
    fn StartPeriodicUpdate(&self, tileContent: *mut foundation::Uri, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StartPeriodicUpdateAtTime(&self, tileContent: *mut foundation::Uri, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StopPeriodicUpdate(&self) -> HRESULT,
    fn StartPeriodicUpdateBatch(&self, tileContents: *mut foundation::collections::IIterable<foundation::Uri>, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT,
    fn StartPeriodicUpdateBatchAtTime(&self, tileContents: *mut foundation::collections::IIterable<foundation::Uri>, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> HRESULT
}}
impl ITileUpdater {
    #[inline] pub fn update(&self, notification: &TileNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Update)(self as *const _ as *mut _, notification as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_notification_queue(&self, enable: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EnableNotificationQueue)(self as *const _ as *mut _, enable);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_setting(&self) -> Result<NotificationSetting> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Setting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_to_schedule(&self, scheduledTile: &ScheduledTileNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddToSchedule)(self as *const _ as *mut _, scheduledTile as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_from_schedule(&self, scheduledTile: &ScheduledTileNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveFromSchedule)(self as *const _ as *mut _, scheduledTile as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scheduled_tile_notifications(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<ScheduledTileNotification>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetScheduledTileNotifications)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update(&self, tileContent: &foundation::Uri, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdate)(self as *const _ as *mut _, tileContent as *const _ as *mut _, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update_at_time(&self, tileContent: &foundation::Uri, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdateAtTime)(self as *const _ as *mut _, tileContent as *const _ as *mut _, startTime, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_periodic_update(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StopPeriodicUpdate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update_batch(&self, tileContents: &foundation::collections::IIterable<foundation::Uri>, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdateBatch)(self as *const _ as *mut _, tileContents as *const _ as *mut _, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_periodic_update_batch_at_time(&self, tileContents: &foundation::collections::IIterable<foundation::Uri>, startTime: foundation::DateTime, requestedInterval: PeriodicUpdateRecurrence) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).StartPeriodicUpdateBatchAtTime)(self as *const _ as *mut _, tileContents as *const _ as *mut _, startTime, requestedInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class TileUpdater: ITileUpdater}
DEFINE_IID!(IID_ITileUpdater2, 2720427538, 5614, 17389, 131, 245, 101, 179, 82, 187, 26, 132);
RT_INTERFACE!{interface ITileUpdater2(ITileUpdater2Vtbl): IInspectable(IInspectableVtbl) [IID_ITileUpdater2] {
    fn EnableNotificationQueueForSquare150x150(&self, enable: bool) -> HRESULT,
    fn EnableNotificationQueueForWide310x150(&self, enable: bool) -> HRESULT,
    fn EnableNotificationQueueForSquare310x310(&self, enable: bool) -> HRESULT
}}
impl ITileUpdater2 {
    #[inline] pub fn enable_notification_queue_for_square_150x150(&self, enable: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EnableNotificationQueueForSquare150x150)(self as *const _ as *mut _, enable);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_notification_queue_for_wide_310x150(&self, enable: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EnableNotificationQueueForWide310x150)(self as *const _ as *mut _, enable);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_notification_queue_for_square_310x310(&self, enable: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EnableNotificationQueueForSquare310x310)(self as *const _ as *mut _, enable);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastActivatedEventArgs, 3820983027, 49559, 17263, 130, 101, 6, 37, 130, 79, 141, 172);
RT_INTERFACE!{interface IToastActivatedEventArgs(IToastActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IToastActivatedEventArgs] {
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT
}}
impl IToastActivatedEventArgs {
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastActivatedEventArgs: IToastActivatedEventArgs}
DEFINE_IID!(IID_IToastCollection, 176931760, 57534, 18520, 188, 42, 137, 223, 224, 179, 40, 99);
RT_INTERFACE!{interface IToastCollection(IToastCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IToastCollection] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_LaunchArgs(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LaunchArgs(&self, value: HSTRING) -> HRESULT,
    fn get_Icon(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Icon(&self, value: *mut foundation::Uri) -> HRESULT
}}
impl IToastCollection {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_launch_args(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LaunchArgs)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_launch_args(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LaunchArgs)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_icon(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Icon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_icon(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Icon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastCollection: IToastCollection}
impl RtActivatable<IToastCollectionFactory> for ToastCollection {}
impl ToastCollection {
    #[inline] pub fn create_instance(collectionId: &HStringArg, displayName: &HStringArg, launchArgs: &HStringArg, iconUri: &foundation::Uri) -> Result<ComPtr<ToastCollection>> {
        <Self as RtActivatable<IToastCollectionFactory>>::get_activation_factory().create_instance(collectionId, displayName, launchArgs, iconUri)
    }
}
DEFINE_CLSID!(ToastCollection(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,111,97,115,116,67,111,108,108,101,99,116,105,111,110,0]) [CLSID_ToastCollection]);
DEFINE_IID!(IID_IToastCollectionFactory, 374199255, 29636, 17655, 180, 255, 251, 109, 75, 241, 244, 198);
RT_INTERFACE!{static interface IToastCollectionFactory(IToastCollectionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToastCollectionFactory] {
    fn CreateInstance(&self, collectionId: HSTRING, displayName: HSTRING, launchArgs: HSTRING, iconUri: *mut foundation::Uri, out: *mut *mut ToastCollection) -> HRESULT
}}
impl IToastCollectionFactory {
    #[inline] pub fn create_instance(&self, collectionId: &HStringArg, displayName: &HStringArg, launchArgs: &HStringArg, iconUri: &foundation::Uri) -> Result<ComPtr<ToastCollection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, collectionId.get(), displayName.get(), launchArgs.get(), iconUri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastCollectionManager, 706224638, 6045, 18876, 183, 157, 165, 39, 146, 13, 54, 101);
RT_INTERFACE!{interface IToastCollectionManager(IToastCollectionManagerVtbl): IInspectable(IInspectableVtbl) [IID_IToastCollectionManager] {
    fn SaveToastCollectionAsync(&self, collection: *mut ToastCollection, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn FindAllToastCollectionsAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<ToastCollection>>) -> HRESULT,
    fn GetToastCollectionAsync(&self, collectionId: HSTRING, out: *mut *mut foundation::IAsyncOperation<ToastCollection>) -> HRESULT,
    fn RemoveToastCollectionAsync(&self, collectionId: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn RemoveAllToastCollectionsAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT,
    fn get_AppId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IToastCollectionManager {
    #[inline] pub fn save_toast_collection_async(&self, collection: &ToastCollection) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveToastCollectionAsync)(self as *const _ as *mut _, collection as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_toast_collections_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<ToastCollection>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllToastCollectionsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_toast_collection_async(&self, collectionId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ToastCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToastCollectionAsync)(self as *const _ as *mut _, collectionId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_toast_collection_async(&self, collectionId: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RemoveToastCollectionAsync)(self as *const _ as *mut _, collectionId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_all_toast_collections_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RemoveAllToastCollectionsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<ComPtr<super::super::system::User>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastCollectionManager: IToastCollectionManager}
RT_ENUM! { enum ToastDismissalReason: i32 {
    UserCanceled = 0, ApplicationHidden = 1, TimedOut = 2,
}}
DEFINE_IID!(IID_IToastDismissedEventArgs, 1065998645, 55755, 17720, 160, 240, 255, 231, 101, 153, 56, 248);
RT_INTERFACE!{interface IToastDismissedEventArgs(IToastDismissedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IToastDismissedEventArgs] {
    fn get_Reason(&self, out: *mut ToastDismissalReason) -> HRESULT
}}
impl IToastDismissedEventArgs {
    #[inline] pub fn get_reason(&self) -> Result<ToastDismissalReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastDismissedEventArgs: IToastDismissedEventArgs}
DEFINE_IID!(IID_IToastFailedEventArgs, 890726498, 53204, 17656, 173, 100, 245, 0, 253, 137, 108, 59);
RT_INTERFACE!{interface IToastFailedEventArgs(IToastFailedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IToastFailedEventArgs] {
    fn get_ErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl IToastFailedEventArgs {
    #[inline] pub fn get_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastFailedEventArgs: IToastFailedEventArgs}
RT_ENUM! { enum ToastHistoryChangedType: i32 {
    Cleared = 0, Removed = 1, Expired = 2, Added = 3,
}}
DEFINE_IID!(IID_IToastNotification, 2575181429, 1438, 20064, 139, 6, 23, 96, 145, 124, 139, 128);
RT_INTERFACE!{interface IToastNotification(IToastNotificationVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotification] {
    #[cfg(not(feature="windows-data"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Content(&self, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT,
    fn put_ExpirationTime(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_ExpirationTime(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn add_Dismissed(&self, handler: *mut foundation::TypedEventHandler<ToastNotification, ToastDismissedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Dismissed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Activated(&self, handler: *mut foundation::TypedEventHandler<ToastNotification, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Failed(&self, handler: *mut foundation::TypedEventHandler<ToastNotification, ToastFailedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Failed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IToastNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn get_content(&self) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_expiration_time(&self, value: &foundation::IReference<foundation::DateTime>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ExpirationTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_time(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_dismissed(&self, handler: &foundation::TypedEventHandler<ToastNotification, ToastDismissedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Dismissed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_dismissed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Dismissed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_activated(&self, handler: &foundation::TypedEventHandler<ToastNotification, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Activated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Activated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_failed(&self, handler: &foundation::TypedEventHandler<ToastNotification, ToastFailedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Failed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_failed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Failed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotification: IToastNotification}
impl RtActivatable<IToastNotificationFactory> for ToastNotification {}
impl ToastNotification {
    #[cfg(feature="windows-data")] #[inline] pub fn create_toast_notification(content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<ToastNotification>> {
        <Self as RtActivatable<IToastNotificationFactory>>::get_activation_factory().create_toast_notification(content)
    }
}
DEFINE_CLSID!(ToastNotification(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,111,97,115,116,78,111,116,105,102,105,99,97,116,105,111,110,0]) [CLSID_ToastNotification]);
DEFINE_IID!(IID_IToastNotification2, 2650513361, 5178, 18702, 144, 191, 185, 251, 167, 19, 45, 231);
RT_INTERFACE!{interface IToastNotification2(IToastNotification2Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotification2] {
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Group(&self, value: HSTRING) -> HRESULT,
    fn get_Group(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SuppressPopup(&self, value: bool) -> HRESULT,
    fn get_SuppressPopup(&self, out: *mut bool) -> HRESULT
}}
impl IToastNotification2 {
    #[inline] pub fn set_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_group(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Group)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_group(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Group)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_suppress_popup(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SuppressPopup)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_suppress_popup(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SuppressPopup)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotification3, 837332696, 33089, 20377, 188, 10, 196, 237, 33, 41, 125, 119);
RT_INTERFACE!{interface IToastNotification3(IToastNotification3Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotification3] {
    fn get_NotificationMirroring(&self, out: *mut NotificationMirroring) -> HRESULT,
    fn put_NotificationMirroring(&self, value: NotificationMirroring) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT
}}
impl IToastNotification3 {
    #[inline] pub fn get_notification_mirroring(&self) -> Result<NotificationMirroring> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NotificationMirroring)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_notification_mirroring(&self, value: NotificationMirroring) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_NotificationMirroring)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotification4, 353716533, 10474, 18215, 136, 233, 197, 134, 128, 226, 209, 24);
RT_INTERFACE!{interface IToastNotification4(IToastNotification4Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotification4] {
    fn get_Data(&self, out: *mut *mut NotificationData) -> HRESULT,
    fn put_Data(&self, value: *mut NotificationData) -> HRESULT,
    fn get_Priority(&self, out: *mut ToastNotificationPriority) -> HRESULT,
    fn put_Priority(&self, value: ToastNotificationPriority) -> HRESULT
}}
impl IToastNotification4 {
    #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<NotificationData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_data(&self, value: &NotificationData) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Data)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_priority(&self) -> Result<ToastNotificationPriority> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Priority)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_priority(&self, value: ToastNotificationPriority) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Priority)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationActionTriggerDetail, 2487554906, 14579, 17142, 150, 170, 121, 85, 176, 240, 61, 162);
RT_INTERFACE!{interface IToastNotificationActionTriggerDetail(IToastNotificationActionTriggerDetailVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationActionTriggerDetail] {
    fn get_Argument(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserInput(&self, out: *mut *mut foundation::collections::ValueSet) -> HRESULT
}}
impl IToastNotificationActionTriggerDetail {
    #[inline] pub fn get_argument(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Argument)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_input(&self) -> Result<Option<ComPtr<foundation::collections::ValueSet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationActionTriggerDetail: IToastNotificationActionTriggerDetail}
DEFINE_IID!(IID_IToastNotificationFactory, 68307744, 33478, 16937, 177, 9, 253, 158, 212, 102, 43, 83);
RT_INTERFACE!{static interface IToastNotificationFactory(IToastNotificationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationFactory] {
    #[cfg(feature="windows-data")] fn CreateToastNotification(&self, content: *mut super::super::data::xml::dom::XmlDocument, out: *mut *mut ToastNotification) -> HRESULT
}}
impl IToastNotificationFactory {
    #[cfg(feature="windows-data")] #[inline] pub fn create_toast_notification(&self, content: &super::super::data::xml::dom::XmlDocument) -> Result<ComPtr<ToastNotification>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateToastNotification)(self as *const _ as *mut _, content as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationHistory, 1554898019, 467, 19607, 152, 111, 5, 51, 72, 63, 238, 20);
RT_INTERFACE!{interface IToastNotificationHistory(IToastNotificationHistoryVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationHistory] {
    fn RemoveGroup(&self, group: HSTRING) -> HRESULT,
    fn RemoveGroupWithId(&self, group: HSTRING, applicationId: HSTRING) -> HRESULT,
    fn RemoveGroupedTagWithId(&self, tag: HSTRING, group: HSTRING, applicationId: HSTRING) -> HRESULT,
    fn RemoveGroupedTag(&self, tag: HSTRING, group: HSTRING) -> HRESULT,
    fn Remove(&self, tag: HSTRING) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn ClearWithId(&self, applicationId: HSTRING) -> HRESULT
}}
impl IToastNotificationHistory {
    #[inline] pub fn remove_group(&self, group: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveGroup)(self as *const _ as *mut _, group.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_group_with_id(&self, group: &HStringArg, applicationId: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveGroupWithId)(self as *const _ as *mut _, group.get(), applicationId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_grouped_tag_with_id(&self, tag: &HStringArg, group: &HStringArg, applicationId: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveGroupedTagWithId)(self as *const _ as *mut _, tag.get(), group.get(), applicationId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_grouped_tag(&self, tag: &HStringArg, group: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveGroupedTag)(self as *const _ as *mut _, tag.get(), group.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove(&self, tag: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Remove)(self as *const _ as *mut _, tag.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_with_id(&self, applicationId: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearWithId)(self as *const _ as *mut _, applicationId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationHistory: IToastNotificationHistory}
DEFINE_IID!(IID_IToastNotificationHistory2, 1002689107, 12081, 16530, 145, 41, 138, 213, 171, 240, 103, 218);
RT_INTERFACE!{interface IToastNotificationHistory2(IToastNotificationHistory2Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationHistory2] {
    fn GetHistory(&self, out: *mut *mut foundation::collections::IVectorView<ToastNotification>) -> HRESULT,
    fn GetHistoryWithId(&self, applicationId: HSTRING, out: *mut *mut foundation::collections::IVectorView<ToastNotification>) -> HRESULT
}}
impl IToastNotificationHistory2 {
    #[inline] pub fn get_history(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<ToastNotification>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHistory)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_history_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<foundation::collections::IVectorView<ToastNotification>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHistoryWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationHistoryChangedTriggerDetail, 3674439674, 104, 16684, 156, 131, 38, 124, 55, 246, 86, 112);
RT_INTERFACE!{interface IToastNotificationHistoryChangedTriggerDetail(IToastNotificationHistoryChangedTriggerDetailVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationHistoryChangedTriggerDetail] {
    fn get_ChangeType(&self, out: *mut ToastHistoryChangedType) -> HRESULT
}}
impl IToastNotificationHistoryChangedTriggerDetail {
    #[inline] pub fn get_change_type(&self) -> Result<ToastHistoryChangedType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationHistoryChangedTriggerDetail: IToastNotificationHistoryChangedTriggerDetail}
DEFINE_IID!(IID_IToastNotificationHistoryChangedTriggerDetail2, 188148098, 51313, 18939, 186, 187, 37, 189, 188, 76, 196, 91);
RT_INTERFACE!{interface IToastNotificationHistoryChangedTriggerDetail2(IToastNotificationHistoryChangedTriggerDetail2Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationHistoryChangedTriggerDetail2] {
    fn get_CollectionId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IToastNotificationHistoryChangedTriggerDetail2 {
    #[inline] pub fn get_collection_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CollectionId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class ToastNotificationManager}
impl RtActivatable<IToastNotificationManagerStatics> for ToastNotificationManager {}
impl RtActivatable<IToastNotificationManagerStatics2> for ToastNotificationManager {}
impl RtActivatable<IToastNotificationManagerStatics4> for ToastNotificationManager {}
impl RtActivatable<IToastNotificationManagerStatics5> for ToastNotificationManager {}
impl ToastNotificationManager {
    #[inline] pub fn create_toast_notifier() -> Result<Option<ComPtr<ToastNotifier>>> {
        <Self as RtActivatable<IToastNotificationManagerStatics>>::get_activation_factory().create_toast_notifier()
    }
    #[inline] pub fn create_toast_notifier_with_id(applicationId: &HStringArg) -> Result<Option<ComPtr<ToastNotifier>>> {
        <Self as RtActivatable<IToastNotificationManagerStatics>>::get_activation_factory().create_toast_notifier_with_id(applicationId)
    }
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(type_: ToastTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> {
        <Self as RtActivatable<IToastNotificationManagerStatics>>::get_activation_factory().get_template_content(type_)
    }
    #[inline] pub fn get_history() -> Result<Option<ComPtr<ToastNotificationHistory>>> {
        <Self as RtActivatable<IToastNotificationManagerStatics2>>::get_activation_factory().get_history()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<ComPtr<ToastNotificationManagerForUser>>> {
        <Self as RtActivatable<IToastNotificationManagerStatics4>>::get_activation_factory().get_for_user(user)
    }
    #[inline] pub fn configure_notification_mirroring(value: NotificationMirroring) -> Result<()> {
        <Self as RtActivatable<IToastNotificationManagerStatics4>>::get_activation_factory().configure_notification_mirroring(value)
    }
    #[inline] pub fn get_default() -> Result<Option<ComPtr<ToastNotificationManagerForUser>>> {
        <Self as RtActivatable<IToastNotificationManagerStatics5>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(ToastNotificationManager(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,84,111,97,115,116,78,111,116,105,102,105,99,97,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_ToastNotificationManager]);
DEFINE_IID!(IID_IToastNotificationManagerForUser, 2041272310, 17406, 18555, 138, 127, 153, 86, 114, 0, 174, 148);
RT_INTERFACE!{interface IToastNotificationManagerForUser(IToastNotificationManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationManagerForUser] {
    fn CreateToastNotifier(&self, out: *mut *mut ToastNotifier) -> HRESULT,
    fn CreateToastNotifierWithId(&self, applicationId: HSTRING, out: *mut *mut ToastNotifier) -> HRESULT,
    fn get_History(&self, out: *mut *mut ToastNotificationHistory) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IToastNotificationManagerForUser {
    #[inline] pub fn create_toast_notifier(&self) -> Result<Option<ComPtr<ToastNotifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateToastNotifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_toast_notifier_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<ToastNotifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateToastNotifierWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_history(&self) -> Result<Option<ComPtr<ToastNotificationHistory>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_History)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<ComPtr<super::super::system::User>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotificationManagerForUser: IToastNotificationManagerForUser}
DEFINE_IID!(IID_IToastNotificationManagerForUser2, 1738302647, 33195, 17090, 136, 25, 201, 88, 118, 119, 83, 244);
RT_INTERFACE!{interface IToastNotificationManagerForUser2(IToastNotificationManagerForUser2Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationManagerForUser2] {
    fn GetToastNotifierForToastCollectionIdAsync(&self, collectionId: HSTRING, out: *mut *mut foundation::IAsyncOperation<ToastNotifier>) -> HRESULT,
    fn GetHistoryForToastCollectionIdAsync(&self, collectionId: HSTRING, out: *mut *mut foundation::IAsyncOperation<ToastNotificationHistory>) -> HRESULT,
    fn GetToastCollectionManager(&self, out: *mut *mut ToastCollectionManager) -> HRESULT,
    fn GetToastCollectionManagerWithAppId(&self, appId: HSTRING, out: *mut *mut ToastCollectionManager) -> HRESULT
}}
impl IToastNotificationManagerForUser2 {
    #[inline] pub fn get_toast_notifier_for_toast_collection_id_async(&self, collectionId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ToastNotifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToastNotifierForToastCollectionIdAsync)(self as *const _ as *mut _, collectionId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_history_for_toast_collection_id_async(&self, collectionId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ToastNotificationHistory>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHistoryForToastCollectionIdAsync)(self as *const _ as *mut _, collectionId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_toast_collection_manager(&self) -> Result<Option<ComPtr<ToastCollectionManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToastCollectionManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_toast_collection_manager_with_app_id(&self, appId: &HStringArg) -> Result<Option<ComPtr<ToastCollectionManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetToastCollectionManagerWithAppId)(self as *const _ as *mut _, appId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationManagerStatics, 1353453631, 53813, 17816, 187, 239, 152, 254, 77, 26, 58, 212);
RT_INTERFACE!{static interface IToastNotificationManagerStatics(IToastNotificationManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationManagerStatics] {
    fn CreateToastNotifier(&self, out: *mut *mut ToastNotifier) -> HRESULT,
    fn CreateToastNotifierWithId(&self, applicationId: HSTRING, out: *mut *mut ToastNotifier) -> HRESULT,
    #[cfg(feature="windows-data")] fn GetTemplateContent(&self, type_: ToastTemplateType, out: *mut *mut super::super::data::xml::dom::XmlDocument) -> HRESULT
}}
impl IToastNotificationManagerStatics {
    #[inline] pub fn create_toast_notifier(&self) -> Result<Option<ComPtr<ToastNotifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateToastNotifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_toast_notifier_with_id(&self, applicationId: &HStringArg) -> Result<Option<ComPtr<ToastNotifier>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateToastNotifierWithId)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-data")] #[inline] pub fn get_template_content(&self, type_: ToastTemplateType) -> Result<Option<ComPtr<super::super::data::xml::dom::XmlDocument>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTemplateContent)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationManagerStatics2, 2058959954, 3656, 18256, 186, 157, 26, 65, 19, 152, 24, 71);
RT_INTERFACE!{static interface IToastNotificationManagerStatics2(IToastNotificationManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationManagerStatics2] {
    fn get_History(&self, out: *mut *mut ToastNotificationHistory) -> HRESULT
}}
impl IToastNotificationManagerStatics2 {
    #[inline] pub fn get_history(&self) -> Result<Option<ComPtr<ToastNotificationHistory>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_History)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationManagerStatics4, 2409185235, 58646, 17915, 129, 48, 57, 142, 147, 250, 82, 195);
RT_INTERFACE!{static interface IToastNotificationManagerStatics4(IToastNotificationManagerStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationManagerStatics4] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut ToastNotificationManagerForUser) -> HRESULT,
    fn ConfigureNotificationMirroring(&self, value: NotificationMirroring) -> HRESULT
}}
impl IToastNotificationManagerStatics4 {
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<ComPtr<ToastNotificationManagerForUser>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn configure_notification_mirroring(&self, value: NotificationMirroring) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ConfigureNotificationMirroring)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotificationManagerStatics5, 3606443369, 54285, 16508, 137, 137, 136, 202, 180, 44, 253, 20);
RT_INTERFACE!{static interface IToastNotificationManagerStatics5(IToastNotificationManagerStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationManagerStatics5] {
    fn GetDefault(&self, out: *mut *mut ToastNotificationManagerForUser) -> HRESULT
}}
impl IToastNotificationManagerStatics5 {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<ToastNotificationManagerForUser>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ToastNotificationPriority: i32 {
    Default = 0, High = 1,
}}
DEFINE_IID!(IID_IToastNotifier, 1972534163, 1011, 16876, 145, 211, 110, 91, 172, 27, 56, 231);
RT_INTERFACE!{interface IToastNotifier(IToastNotifierVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotifier] {
    fn Show(&self, notification: *mut ToastNotification) -> HRESULT,
    fn Hide(&self, notification: *mut ToastNotification) -> HRESULT,
    fn get_Setting(&self, out: *mut NotificationSetting) -> HRESULT,
    fn AddToSchedule(&self, scheduledToast: *mut ScheduledToastNotification) -> HRESULT,
    fn RemoveFromSchedule(&self, scheduledToast: *mut ScheduledToastNotification) -> HRESULT,
    fn GetScheduledToastNotifications(&self, out: *mut *mut foundation::collections::IVectorView<ScheduledToastNotification>) -> HRESULT
}}
impl IToastNotifier {
    #[inline] pub fn show(&self, notification: &ToastNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Show)(self as *const _ as *mut _, notification as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn hide(&self, notification: &ToastNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Hide)(self as *const _ as *mut _, notification as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_setting(&self) -> Result<NotificationSetting> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Setting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_to_schedule(&self, scheduledToast: &ScheduledToastNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddToSchedule)(self as *const _ as *mut _, scheduledToast as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_from_schedule(&self, scheduledToast: &ScheduledToastNotification) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveFromSchedule)(self as *const _ as *mut _, scheduledToast as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scheduled_toast_notifications(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<ScheduledToastNotification>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetScheduledToastNotifications)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ToastNotifier: IToastNotifier}
DEFINE_IID!(IID_IToastNotifier2, 893618630, 31745, 19413, 156, 32, 96, 67, 64, 205, 43, 116);
RT_INTERFACE!{interface IToastNotifier2(IToastNotifier2Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotifier2] {
    fn UpdateWithTagAndGroup(&self, data: *mut NotificationData, tag: HSTRING, group: HSTRING, out: *mut NotificationUpdateResult) -> HRESULT,
    fn UpdateWithTag(&self, data: *mut NotificationData, tag: HSTRING, out: *mut NotificationUpdateResult) -> HRESULT
}}
impl IToastNotifier2 {
    #[inline] pub fn update_with_tag_and_group(&self, data: &NotificationData, tag: &HStringArg, group: &HStringArg) -> Result<NotificationUpdateResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).UpdateWithTagAndGroup)(self as *const _ as *mut _, data as *const _ as *mut _, tag.get(), group.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn update_with_tag(&self, data: &NotificationData, tag: &HStringArg) -> Result<NotificationUpdateResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).UpdateWithTag)(self as *const _ as *mut _, data as *const _ as *mut _, tag.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IToastNotifier3, 2926944330, 15116, 20909, 183, 232, 176, 138, 182, 5, 37, 73);
RT_INTERFACE!{interface IToastNotifier3(IToastNotifier3Vtbl): IInspectable(IInspectableVtbl) [IID_IToastNotifier3] {
    fn add_ScheduledToastNotificationShowing(&self, handler: *mut foundation::TypedEventHandler<ToastNotifier, ScheduledToastNotificationShowingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ScheduledToastNotificationShowing(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IToastNotifier3 {
    #[inline] pub fn add_scheduled_toast_notification_showing(&self, handler: &foundation::TypedEventHandler<ToastNotifier, ScheduledToastNotificationShowingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ScheduledToastNotificationShowing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_scheduled_toast_notification_showing(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ScheduledToastNotificationShowing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum ToastTemplateType: i32 {
    ToastImageAndText01 = 0, ToastImageAndText02 = 1, ToastImageAndText03 = 2, ToastImageAndText04 = 3, ToastText01 = 4, ToastText02 = 5, ToastText03 = 6, ToastText04 = 7,
}}
DEFINE_IID!(IID_IUserNotification, 2918704431, 20051, 17109, 156, 51, 235, 94, 165, 21, 178, 62);
RT_INTERFACE!{interface IUserNotification(IUserNotificationVtbl): IInspectable(IInspectableVtbl) [IID_IUserNotification] {
    fn get_Notification(&self, out: *mut *mut Notification) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_AppInfo(&self, out: *mut *mut super::super::applicationmodel::AppInfo) -> HRESULT,
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_CreationTime(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl IUserNotification {
    #[inline] pub fn get_notification(&self) -> Result<Option<ComPtr<Notification>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Notification)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn get_app_info(&self) -> Result<Option<ComPtr<super::super::applicationmodel::AppInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_creation_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CreationTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UserNotification: IUserNotification}
DEFINE_IID!(IID_IUserNotificationChangedEventArgs, 3065866297, 31183, 19237, 130, 192, 12, 225, 238, 248, 31, 140);
RT_INTERFACE!{interface IUserNotificationChangedEventArgs(IUserNotificationChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserNotificationChangedEventArgs] {
    fn get_ChangeKind(&self, out: *mut UserNotificationChangedKind) -> HRESULT,
    fn get_UserNotificationId(&self, out: *mut u32) -> HRESULT
}}
impl IUserNotificationChangedEventArgs {
    #[inline] pub fn get_change_kind(&self) -> Result<UserNotificationChangedKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_user_notification_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UserNotificationId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UserNotificationChangedEventArgs: IUserNotificationChangedEventArgs}
RT_ENUM! { enum UserNotificationChangedKind: i32 {
    Added = 0, Removed = 1,
}}
pub mod management { // Windows.UI.Notifications.Management
use crate::prelude::*;
DEFINE_IID!(IID_IUserNotificationListener, 1649753665, 35334, 19695, 130, 21, 96, 51, 165, 190, 75, 3);
RT_INTERFACE!{interface IUserNotificationListener(IUserNotificationListenerVtbl): IInspectable(IInspectableVtbl) [IID_IUserNotificationListener] {
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<UserNotificationListenerAccessStatus>) -> HRESULT,
    fn GetAccessStatus(&self, out: *mut UserNotificationListenerAccessStatus) -> HRESULT,
    fn add_NotificationChanged(&self, handler: *mut foundation::TypedEventHandler<UserNotificationListener, super::UserNotificationChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NotificationChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetNotificationsAsync(&self, kinds: super::NotificationKinds, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<super::UserNotification>>) -> HRESULT,
    fn GetNotification(&self, notificationId: u32, out: *mut *mut super::UserNotification) -> HRESULT,
    fn ClearNotifications(&self) -> HRESULT,
    fn RemoveNotification(&self, notificationId: u32) -> HRESULT
}}
impl IUserNotificationListener {
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<UserNotificationListenerAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAccessAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_access_status(&self) -> Result<UserNotificationListenerAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAccessStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_notification_changed(&self, handler: &foundation::TypedEventHandler<UserNotificationListener, super::UserNotificationChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NotificationChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_notification_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NotificationChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_notifications_async(&self, kinds: super::NotificationKinds) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<super::UserNotification>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetNotificationsAsync)(self as *const _ as *mut _, kinds, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_notification(&self, notificationId: u32) -> Result<Option<ComPtr<super::UserNotification>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetNotification)(self as *const _ as *mut _, notificationId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_notifications(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearNotifications)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn remove_notification(&self, notificationId: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).RemoveNotification)(self as *const _ as *mut _, notificationId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UserNotificationListener: IUserNotificationListener}
impl RtActivatable<IUserNotificationListenerStatics> for UserNotificationListener {}
impl UserNotificationListener {
    #[inline] pub fn get_current() -> Result<Option<ComPtr<UserNotificationListener>>> {
        <Self as RtActivatable<IUserNotificationListenerStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(UserNotificationListener(&[87,105,110,100,111,119,115,46,85,73,46,78,111,116,105,102,105,99,97,116,105,111,110,115,46,77,97,110,97,103,101,109,101,110,116,46,85,115,101,114,78,111,116,105,102,105,99,97,116,105,111,110,76,105,115,116,101,110,101,114,0]) [CLSID_UserNotificationListener]);
RT_ENUM! { enum UserNotificationListenerAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, Denied = 2,
}}
DEFINE_IID!(IID_IUserNotificationListenerStatics, 4284556239, 17286, 19107, 183, 61, 184, 4, 229, 182, 59, 35);
RT_INTERFACE!{static interface IUserNotificationListenerStatics(IUserNotificationListenerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserNotificationListenerStatics] {
    fn get_Current(&self, out: *mut *mut UserNotificationListener) -> HRESULT
}}
impl IUserNotificationListenerStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<ComPtr<UserNotificationListener>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Notifications.Management
} // Windows.UI.Notifications
pub mod popups { // Windows.UI.Popups
use crate::prelude::*;
DEFINE_IID!(IID_IMessageDialog, 871734017, 21285, 17323, 154, 179, 189, 174, 68, 14, 65, 33);
RT_INTERFACE!{interface IMessageDialog(IMessageDialogVtbl): IInspectable(IInspectableVtbl) [IID_IMessageDialog] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Commands(&self, out: *mut *mut foundation::collections::IVector<IUICommand>) -> HRESULT,
    fn get_DefaultCommandIndex(&self, out: *mut u32) -> HRESULT,
    fn put_DefaultCommandIndex(&self, value: u32) -> HRESULT,
    fn get_CancelCommandIndex(&self, out: *mut u32) -> HRESULT,
    fn put_CancelCommandIndex(&self, value: u32) -> HRESULT,
    fn get_Content(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Content(&self, value: HSTRING) -> HRESULT,
    fn ShowAsync(&self, out: *mut *mut foundation::IAsyncOperation<IUICommand>) -> HRESULT,
    fn get_Options(&self, out: *mut MessageDialogOptions) -> HRESULT,
    fn put_Options(&self, value: MessageDialogOptions) -> HRESULT
}}
impl IMessageDialog {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<IUICommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Commands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_command_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultCommandIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_command_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DefaultCommandIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cancel_command_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CancelCommandIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cancel_command_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CancelCommandIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_content(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<IUICommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_options(&self) -> Result<MessageDialogOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Options)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_options(&self, value: MessageDialogOptions) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Options)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MessageDialog: IMessageDialog}
impl RtActivatable<IMessageDialogFactory> for MessageDialog {}
impl MessageDialog {
    #[inline] pub fn create(content: &HStringArg) -> Result<ComPtr<MessageDialog>> {
        <Self as RtActivatable<IMessageDialogFactory>>::get_activation_factory().create(content)
    }
    #[inline] pub fn create_with_title(content: &HStringArg, title: &HStringArg) -> Result<ComPtr<MessageDialog>> {
        <Self as RtActivatable<IMessageDialogFactory>>::get_activation_factory().create_with_title(content, title)
    }
}
DEFINE_CLSID!(MessageDialog(&[87,105,110,100,111,119,115,46,85,73,46,80,111,112,117,112,115,46,77,101,115,115,97,103,101,68,105,97,108,111,103,0]) [CLSID_MessageDialog]);
DEFINE_IID!(IID_IMessageDialogFactory, 756422519, 42607, 20133, 187, 135, 121, 63, 250, 73, 65, 242);
RT_INTERFACE!{static interface IMessageDialogFactory(IMessageDialogFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMessageDialogFactory] {
    fn Create(&self, content: HSTRING, out: *mut *mut MessageDialog) -> HRESULT,
    fn CreateWithTitle(&self, content: HSTRING, title: HSTRING, out: *mut *mut MessageDialog) -> HRESULT
}}
impl IMessageDialogFactory {
    #[inline] pub fn create(&self, content: &HStringArg) -> Result<ComPtr<MessageDialog>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, content.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_title(&self, content: &HStringArg, title: &HStringArg) -> Result<ComPtr<MessageDialog>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithTitle)(self as *const _ as *mut _, content.get(), title.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MessageDialogOptions: u32 {
    None = 0, AcceptUserInputAfterDelay = 1,
}}
RT_ENUM! { enum Placement: i32 {
    Default = 0, Above = 1, Below = 2, Left = 3, Right = 4,
}}
DEFINE_IID!(IID_IPopupMenu, 1318831836, 34829, 18428, 160, 161, 114, 182, 57, 230, 37, 89);
RT_INTERFACE!{interface IPopupMenu(IPopupMenuVtbl): IInspectable(IInspectableVtbl) [IID_IPopupMenu] {
    fn get_Commands(&self, out: *mut *mut foundation::collections::IVector<IUICommand>) -> HRESULT,
    fn ShowAsync(&self, invocationPoint: foundation::Point, out: *mut *mut foundation::IAsyncOperation<IUICommand>) -> HRESULT,
    fn ShowAsyncWithRect(&self, selection: foundation::Rect, out: *mut *mut foundation::IAsyncOperation<IUICommand>) -> HRESULT,
    fn ShowAsyncWithRectAndPlacement(&self, selection: foundation::Rect, preferredPlacement: Placement, out: *mut *mut foundation::IAsyncOperation<IUICommand>) -> HRESULT
}}
impl IPopupMenu {
    #[inline] pub fn get_commands(&self) -> Result<Option<ComPtr<foundation::collections::IVector<IUICommand>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Commands)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_async(&self, invocationPoint: foundation::Point) -> Result<ComPtr<foundation::IAsyncOperation<IUICommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsync)(self as *const _ as *mut _, invocationPoint, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_async_with_rect(&self, selection: foundation::Rect) -> Result<ComPtr<foundation::IAsyncOperation<IUICommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsyncWithRect)(self as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_async_with_rect_and_placement(&self, selection: foundation::Rect, preferredPlacement: Placement) -> Result<ComPtr<foundation::IAsyncOperation<IUICommand>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsyncWithRectAndPlacement)(self as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PopupMenu: IPopupMenu}
impl RtActivatable<IActivationFactory> for PopupMenu {}
DEFINE_CLSID!(PopupMenu(&[87,105,110,100,111,119,115,46,85,73,46,80,111,112,117,112,115,46,80,111,112,117,112,77,101,110,117,0]) [CLSID_PopupMenu]);
DEFINE_IID!(IID_IUICommand, 1341733493, 16709, 18431, 172, 127, 223, 241, 193, 250, 91, 15);
RT_INTERFACE!{interface IUICommand(IUICommandVtbl): IInspectable(IInspectableVtbl) [IID_IUICommand] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Invoked(&self, out: *mut *mut UICommandInvokedHandler) -> HRESULT,
    fn put_Invoked(&self, value: *mut UICommandInvokedHandler) -> HRESULT,
    fn get_Id(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Id(&self, value: *mut IInspectable) -> HRESULT
}}
impl IUICommand {
    #[inline] pub fn get_label(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Label)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_label(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Label)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_invoked(&self) -> Result<Option<ComPtr<UICommandInvokedHandler>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Invoked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_invoked(&self, value: &UICommandInvokedHandler) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Invoked)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UICommand: IUICommand}
impl RtActivatable<IUICommandFactory> for UICommand {}
impl RtActivatable<IActivationFactory> for UICommand {}
impl UICommand {
    #[inline] pub fn create(label: &HStringArg) -> Result<ComPtr<UICommand>> {
        <Self as RtActivatable<IUICommandFactory>>::get_activation_factory().create(label)
    }
    #[inline] pub fn create_with_handler(label: &HStringArg, action: &UICommandInvokedHandler) -> Result<ComPtr<UICommand>> {
        <Self as RtActivatable<IUICommandFactory>>::get_activation_factory().create_with_handler(label, action)
    }
    #[inline] pub fn create_with_handler_and_id(label: &HStringArg, action: &UICommandInvokedHandler, commandId: &IInspectable) -> Result<ComPtr<UICommand>> {
        <Self as RtActivatable<IUICommandFactory>>::get_activation_factory().create_with_handler_and_id(label, action, commandId)
    }
}
DEFINE_CLSID!(UICommand(&[87,105,110,100,111,119,115,46,85,73,46,80,111,112,117,112,115,46,85,73,67,111,109,109,97,110,100,0]) [CLSID_UICommand]);
DEFINE_IID!(IID_IUICommandFactory, 2719646089, 9904, 18038, 174, 148, 84, 4, 27, 193, 37, 232);
RT_INTERFACE!{static interface IUICommandFactory(IUICommandFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUICommandFactory] {
    fn Create(&self, label: HSTRING, out: *mut *mut UICommand) -> HRESULT,
    fn CreateWithHandler(&self, label: HSTRING, action: *mut UICommandInvokedHandler, out: *mut *mut UICommand) -> HRESULT,
    fn CreateWithHandlerAndId(&self, label: HSTRING, action: *mut UICommandInvokedHandler, commandId: *mut IInspectable, out: *mut *mut UICommand) -> HRESULT
}}
impl IUICommandFactory {
    #[inline] pub fn create(&self, label: &HStringArg) -> Result<ComPtr<UICommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, label.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_handler(&self, label: &HStringArg, action: &UICommandInvokedHandler) -> Result<ComPtr<UICommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithHandler)(self as *const _ as *mut _, label.get(), action as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_handler_and_id(&self, label: &HStringArg, action: &UICommandInvokedHandler, commandId: &IInspectable) -> Result<ComPtr<UICommand>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithHandlerAndId)(self as *const _ as *mut _, label.get(), action as *const _ as *mut _, commandId as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_UICommandInvokedHandler, 3673651791, 49786, 17048, 154, 198, 41, 34, 196, 94, 125, 166);
RT_DELEGATE!{delegate UICommandInvokedHandler(UICommandInvokedHandlerVtbl, UICommandInvokedHandlerImpl) [IID_UICommandInvokedHandler] {
    fn Invoke(&self, command: *mut IUICommand) -> HRESULT
}}
impl UICommandInvokedHandler {
    #[inline] pub fn invoke(&self, command: &IUICommand) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, command as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UICommandSeparator: IUICommand}
impl RtActivatable<IActivationFactory> for UICommandSeparator {}
DEFINE_CLSID!(UICommandSeparator(&[87,105,110,100,111,119,115,46,85,73,46,80,111,112,117,112,115,46,85,73,67,111,109,109,97,110,100,83,101,112,97,114,97,116,111,114,0]) [CLSID_UICommandSeparator]);
} // Windows.UI.Popups
pub mod shell { // Windows.UI.Shell
use crate::prelude::*;
DEFINE_IID!(IID_IAdaptiveCard, 1926256268, 41588, 16845, 130, 168, 152, 157, 64, 185, 176, 94);
RT_INTERFACE!{interface IAdaptiveCard(IAdaptiveCardVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveCard] {
    fn ToJson(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAdaptiveCard {
    #[inline] pub fn to_json(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ToJson)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class AdaptiveCardBuilder}
impl RtActivatable<IAdaptiveCardBuilderStatics> for AdaptiveCardBuilder {}
impl AdaptiveCardBuilder {
    #[inline] pub fn create_adaptive_card_from_json(value: &HStringArg) -> Result<Option<ComPtr<IAdaptiveCard>>> {
        <Self as RtActivatable<IAdaptiveCardBuilderStatics>>::get_activation_factory().create_adaptive_card_from_json(value)
    }
}
DEFINE_CLSID!(AdaptiveCardBuilder(&[87,105,110,100,111,119,115,46,85,73,46,83,104,101,108,108,46,65,100,97,112,116,105,118,101,67,97,114,100,66,117,105,108,100,101,114,0]) [CLSID_AdaptiveCardBuilder]);
DEFINE_IID!(IID_IAdaptiveCardBuilderStatics, 1986891528, 54270, 17223, 160, 188, 185, 234, 154, 109, 194, 142);
RT_INTERFACE!{static interface IAdaptiveCardBuilderStatics(IAdaptiveCardBuilderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAdaptiveCardBuilderStatics] {
    fn CreateAdaptiveCardFromJson(&self, value: HSTRING, out: *mut *mut IAdaptiveCard) -> HRESULT
}}
impl IAdaptiveCardBuilderStatics {
    #[inline] pub fn create_adaptive_card_from_json(&self, value: &HStringArg) -> Result<Option<ComPtr<IAdaptiveCard>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAdaptiveCardFromJson)(self as *const _ as *mut _, value.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SecurityAppKind: i32 {
    WebProtection = 0,
}}
DEFINE_IID!(IID_ISecurityAppManager, 2527875084, 44756, 22045, 189, 232, 149, 53, 32, 52, 58, 45);
RT_INTERFACE!{interface ISecurityAppManager(ISecurityAppManagerVtbl): IInspectable(IInspectableVtbl) [IID_ISecurityAppManager] {
    fn Register(&self, kind: SecurityAppKind, displayName: HSTRING, detailsUri: *mut foundation::Uri, registerPerUser: bool, out: *mut Guid) -> HRESULT,
    fn Unregister(&self, kind: SecurityAppKind, guidRegistration: Guid) -> HRESULT,
    fn UpdateState(&self, kind: SecurityAppKind, guidRegistration: Guid, state: SecurityAppState, substatus: SecurityAppSubstatus, detailsUri: *mut foundation::Uri) -> HRESULT
}}
impl ISecurityAppManager {
    #[inline] pub fn register(&self, kind: SecurityAppKind, displayName: &HStringArg, detailsUri: &foundation::Uri, registerPerUser: bool) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Register)(self as *const _ as *mut _, kind, displayName.get(), detailsUri as *const _ as *mut _, registerPerUser, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn unregister(&self, kind: SecurityAppKind, guidRegistration: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Unregister)(self as *const _ as *mut _, kind, guidRegistration);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn update_state(&self, kind: SecurityAppKind, guidRegistration: Guid, state: SecurityAppState, substatus: SecurityAppSubstatus, detailsUri: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).UpdateState)(self as *const _ as *mut _, kind, guidRegistration, state, substatus, detailsUri as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SecurityAppManager: ISecurityAppManager}
impl RtActivatable<IActivationFactory> for SecurityAppManager {}
DEFINE_CLSID!(SecurityAppManager(&[87,105,110,100,111,119,115,46,85,73,46,83,104,101,108,108,46,83,101,99,117,114,105,116,121,65,112,112,77,97,110,97,103,101,114,0]) [CLSID_SecurityAppManager]);
RT_ENUM! { enum SecurityAppState: i32 {
    Disabled = 0, Enabled = 1,
}}
RT_ENUM! { enum SecurityAppSubstatus: i32 {
    Undetermined = 0, NoActionNeeded = 1, ActionRecommended = 2, ActionNeeded = 3,
}}
DEFINE_IID!(IID_ITaskbarManager, 2269710873, 6873, 18932, 178, 232, 134, 115, 141, 197, 172, 64);
RT_INTERFACE!{interface ITaskbarManager(ITaskbarManagerVtbl): IInspectable(IInspectableVtbl) [IID_ITaskbarManager] {
    fn get_IsSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPinningAllowed(&self, out: *mut bool) -> HRESULT,
    fn IsCurrentAppPinnedAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn IsAppListEntryPinnedAsync(&self, appListEntry: *mut super::super::applicationmodel::core::AppListEntry, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestPinCurrentAppAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn RequestPinAppListEntryAsync(&self, appListEntry: *mut super::super::applicationmodel::core::AppListEntry, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ITaskbarManager {
    #[inline] pub fn get_is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_pinning_allowed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPinningAllowed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_current_app_pinned_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IsCurrentAppPinnedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn is_app_list_entry_pinned_async(&self, appListEntry: &super::super::applicationmodel::core::AppListEntry) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IsAppListEntryPinnedAsync)(self as *const _ as *mut _, appListEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_current_app_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestPinCurrentAppAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn request_pin_app_list_entry_async(&self, appListEntry: &super::super::applicationmodel::core::AppListEntry) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestPinAppListEntryAsync)(self as *const _ as *mut _, appListEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TaskbarManager: ITaskbarManager}
impl RtActivatable<ITaskbarManagerStatics> for TaskbarManager {}
impl TaskbarManager {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<TaskbarManager>>> {
        <Self as RtActivatable<ITaskbarManagerStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(TaskbarManager(&[87,105,110,100,111,119,115,46,85,73,46,83,104,101,108,108,46,84,97,115,107,98,97,114,77,97,110,97,103,101,114,0]) [CLSID_TaskbarManager]);
DEFINE_IID!(IID_ITaskbarManager2, 2045812846, 31490, 18705, 145, 140, 222, 224, 187, 210, 11, 164);
RT_INTERFACE!{interface ITaskbarManager2(ITaskbarManager2Vtbl): IInspectable(IInspectableVtbl) [IID_ITaskbarManager2] {
    fn IsSecondaryTilePinnedAsync(&self, tileId: HSTRING, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestPinSecondaryTileAsync(&self, secondaryTile: *mut super::startscreen::SecondaryTile, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryUnpinSecondaryTileAsync(&self, tileId: HSTRING, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ITaskbarManager2 {
    #[inline] pub fn is_secondary_tile_pinned_async(&self, tileId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IsSecondaryTilePinnedAsync)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_secondary_tile_async(&self, secondaryTile: &super::startscreen::SecondaryTile) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestPinSecondaryTileAsync)(self as *const _ as *mut _, secondaryTile as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_unpin_secondary_tile_async(&self, tileId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryUnpinSecondaryTileAsync)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITaskbarManagerStatics, 3677530996, 56914, 20454, 183, 182, 149, 255, 159, 131, 149, 223);
RT_INTERFACE!{static interface ITaskbarManagerStatics(ITaskbarManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITaskbarManagerStatics] {
    fn GetDefault(&self, out: *mut *mut TaskbarManager) -> HRESULT
}}
impl ITaskbarManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<TaskbarManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.UI.Shell
pub mod startscreen { // Windows.UI.StartScreen
use crate::prelude::*;
RT_ENUM! { enum ForegroundText: i32 {
    Dark = 0, Light = 1,
}}
DEFINE_IID!(IID_IJumpList, 2955103294, 52591, 19638, 166, 17, 97, 253, 80, 95, 62, 209);
RT_INTERFACE!{interface IJumpList(IJumpListVtbl): IInspectable(IInspectableVtbl) [IID_IJumpList] {
    fn get_Items(&self, out: *mut *mut foundation::collections::IVector<JumpListItem>) -> HRESULT,
    fn get_SystemGroupKind(&self, out: *mut JumpListSystemGroupKind) -> HRESULT,
    fn put_SystemGroupKind(&self, value: JumpListSystemGroupKind) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl IJumpList {
    #[inline] pub fn get_items(&self) -> Result<Option<ComPtr<foundation::collections::IVector<JumpListItem>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_group_kind(&self) -> Result<JumpListSystemGroupKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemGroupKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_system_group_kind(&self, value: JumpListSystemGroupKind) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SystemGroupKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn save_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class JumpList: IJumpList}
impl RtActivatable<IJumpListStatics> for JumpList {}
impl JumpList {
    #[inline] pub fn load_current_async() -> Result<ComPtr<foundation::IAsyncOperation<JumpList>>> {
        <Self as RtActivatable<IJumpListStatics>>::get_activation_factory().load_current_async()
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<IJumpListStatics>>::get_activation_factory().is_supported()
    }
}
DEFINE_CLSID!(JumpList(&[87,105,110,100,111,119,115,46,85,73,46,83,116,97,114,116,83,99,114,101,101,110,46,74,117,109,112,76,105,115,116,0]) [CLSID_JumpList]);
DEFINE_IID!(IID_IJumpListItem, 2061199127, 35677, 18464, 153, 91, 155, 65, 141, 190, 72, 176);
RT_INTERFACE!{interface IJumpListItem(IJumpListItemVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListItem] {
    fn get_Kind(&self, out: *mut JumpListItemKind) -> HRESULT,
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemovedByUser(&self, out: *mut bool) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_GroupName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_GroupName(&self, value: HSTRING) -> HRESULT,
    fn get_Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Logo(&self, value: *mut foundation::Uri) -> HRESULT
}}
impl IJumpListItem {
    #[inline] pub fn get_kind(&self) -> Result<JumpListItemKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_removed_by_user(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RemovedByUser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_group_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_GroupName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_group_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_GroupName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class JumpListItem: IJumpListItem}
impl RtActivatable<IJumpListItemStatics> for JumpListItem {}
impl JumpListItem {
    #[inline] pub fn create_with_arguments(arguments: &HStringArg, displayName: &HStringArg) -> Result<Option<ComPtr<JumpListItem>>> {
        <Self as RtActivatable<IJumpListItemStatics>>::get_activation_factory().create_with_arguments(arguments, displayName)
    }
    #[inline] pub fn create_separator() -> Result<Option<ComPtr<JumpListItem>>> {
        <Self as RtActivatable<IJumpListItemStatics>>::get_activation_factory().create_separator()
    }
}
DEFINE_CLSID!(JumpListItem(&[87,105,110,100,111,119,115,46,85,73,46,83,116,97,114,116,83,99,114,101,101,110,46,74,117,109,112,76,105,115,116,73,116,101,109,0]) [CLSID_JumpListItem]);
RT_ENUM! { enum JumpListItemKind: i32 {
    Arguments = 0, Separator = 1,
}}
DEFINE_IID!(IID_IJumpListItemStatics, 4055876840, 51114, 18891, 141, 222, 236, 252, 205, 122, 215, 228);
RT_INTERFACE!{static interface IJumpListItemStatics(IJumpListItemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListItemStatics] {
    fn CreateWithArguments(&self, arguments: HSTRING, displayName: HSTRING, out: *mut *mut JumpListItem) -> HRESULT,
    fn CreateSeparator(&self, out: *mut *mut JumpListItem) -> HRESULT
}}
impl IJumpListItemStatics {
    #[inline] pub fn create_with_arguments(&self, arguments: &HStringArg, displayName: &HStringArg) -> Result<Option<ComPtr<JumpListItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithArguments)(self as *const _ as *mut _, arguments.get(), displayName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_separator(&self) -> Result<Option<ComPtr<JumpListItem>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSeparator)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IJumpListStatics, 2816525953, 59006, 19316, 130, 80, 63, 50, 44, 77, 146, 195);
RT_INTERFACE!{static interface IJumpListStatics(IJumpListStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IJumpListStatics] {
    fn LoadCurrentAsync(&self, out: *mut *mut foundation::IAsyncOperation<JumpList>) -> HRESULT,
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IJumpListStatics {
    #[inline] pub fn load_current_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<JumpList>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadCurrentAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum JumpListSystemGroupKind: i32 {
    None = 0, Frequent = 1, Recent = 2,
}}
DEFINE_IID!(IID_ISecondaryTile, 2661175776, 11189, 19392, 187, 141, 66, 178, 58, 188, 200, 141);
RT_INTERFACE!{interface ISecondaryTile(ISecondaryTileVtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTile] {
    fn put_TileId(&self, value: HSTRING) -> HRESULT,
    fn get_TileId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Arguments(&self, value: HSTRING) -> HRESULT,
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ShortName(&self, value: HSTRING) -> HRESULT,
    fn get_ShortName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_SmallLogo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_SmallLogo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_WideLogo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_WideLogo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_LockScreenBadgeLogo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_LockScreenBadgeLogo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_LockScreenDisplayBadgeAndTileText(&self, value: bool) -> HRESULT,
    fn get_LockScreenDisplayBadgeAndTileText(&self, out: *mut bool) -> HRESULT,
    fn put_TileOptions(&self, value: TileOptions) -> HRESULT,
    fn get_TileOptions(&self, out: *mut TileOptions) -> HRESULT,
    fn put_ForegroundText(&self, value: ForegroundText) -> HRESULT,
    fn get_ForegroundText(&self, out: *mut ForegroundText) -> HRESULT,
    fn put_BackgroundColor(&self, value: super::Color) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut super::Color) -> HRESULT,
    fn RequestCreateAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestCreateAsyncWithPoint(&self, invocationPoint: foundation::Point, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestCreateAsyncWithRect(&self, selection: foundation::Rect, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestCreateAsyncWithRectAndPlacement(&self, selection: foundation::Rect, preferredPlacement: super::popups::Placement, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestDeleteAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestDeleteAsyncWithPoint(&self, invocationPoint: foundation::Point, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestDeleteAsyncWithRect(&self, selection: foundation::Rect, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestDeleteAsyncWithRectAndPlacement(&self, selection: foundation::Rect, preferredPlacement: super::popups::Placement, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn UpdateAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ISecondaryTile {
    #[inline] pub fn set_tile_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TileId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tile_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TileId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_arguments(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Arguments)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_short_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShortName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_short_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShortName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_small_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SmallLogo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_small_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SmallLogo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_wide_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_WideLogo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wide_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WideLogo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_lock_screen_badge_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LockScreenBadgeLogo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_lock_screen_badge_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LockScreenBadgeLogo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_lock_screen_display_badge_and_tile_text(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LockScreenDisplayBadgeAndTileText)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_lock_screen_display_badge_and_tile_text(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LockScreenDisplayBadgeAndTileText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_tile_options(&self, value: TileOptions) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TileOptions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tile_options(&self) -> Result<TileOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TileOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_foreground_text(&self, value: ForegroundText) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ForegroundText)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_foreground_text(&self) -> Result<ForegroundText> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForegroundText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_background_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_create_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestCreateAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_create_async_with_point(&self, invocationPoint: foundation::Point) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestCreateAsyncWithPoint)(self as *const _ as *mut _, invocationPoint, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_create_async_with_rect(&self, selection: foundation::Rect) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestCreateAsyncWithRect)(self as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_create_async_with_rect_and_placement(&self, selection: foundation::Rect, preferredPlacement: super::popups::Placement) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestCreateAsyncWithRectAndPlacement)(self as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_delete_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestDeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_delete_async_with_point(&self, invocationPoint: foundation::Point) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestDeleteAsyncWithPoint)(self as *const _ as *mut _, invocationPoint, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_delete_async_with_rect(&self, selection: foundation::Rect) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestDeleteAsyncWithRect)(self as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_delete_async_with_rect_and_placement(&self, selection: foundation::Rect, preferredPlacement: super::popups::Placement) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestDeleteAsyncWithRectAndPlacement)(self as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SecondaryTile: ISecondaryTile}
impl RtActivatable<ISecondaryTileFactory> for SecondaryTile {}
impl RtActivatable<ISecondaryTileFactory2> for SecondaryTile {}
impl RtActivatable<ISecondaryTileStatics> for SecondaryTile {}
impl RtActivatable<IActivationFactory> for SecondaryTile {}
impl SecondaryTile {
    #[inline] pub fn create_tile(tileId: &HStringArg, shortName: &HStringArg, displayName: &HStringArg, arguments: &HStringArg, tileOptions: TileOptions, logoReference: &foundation::Uri) -> Result<ComPtr<SecondaryTile>> {
        <Self as RtActivatable<ISecondaryTileFactory>>::get_activation_factory().create_tile(tileId, shortName, displayName, arguments, tileOptions, logoReference)
    }
    #[inline] pub fn create_wide_tile(tileId: &HStringArg, shortName: &HStringArg, displayName: &HStringArg, arguments: &HStringArg, tileOptions: TileOptions, logoReference: &foundation::Uri, wideLogoReference: &foundation::Uri) -> Result<ComPtr<SecondaryTile>> {
        <Self as RtActivatable<ISecondaryTileFactory>>::get_activation_factory().create_wide_tile(tileId, shortName, displayName, arguments, tileOptions, logoReference, wideLogoReference)
    }
    #[inline] pub fn create_with_id(tileId: &HStringArg) -> Result<ComPtr<SecondaryTile>> {
        <Self as RtActivatable<ISecondaryTileFactory>>::get_activation_factory().create_with_id(tileId)
    }
    #[inline] pub fn create_minimal_tile(tileId: &HStringArg, displayName: &HStringArg, arguments: &HStringArg, square150x150Logo: &foundation::Uri, desiredSize: TileSize) -> Result<ComPtr<SecondaryTile>> {
        <Self as RtActivatable<ISecondaryTileFactory2>>::get_activation_factory().create_minimal_tile(tileId, displayName, arguments, square150x150Logo, desiredSize)
    }
    #[inline] pub fn exists(tileId: &HStringArg) -> Result<bool> {
        <Self as RtActivatable<ISecondaryTileStatics>>::get_activation_factory().exists(tileId)
    }
    #[inline] pub fn find_all_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>>> {
        <Self as RtActivatable<ISecondaryTileStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn find_all_for_application_async(applicationId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>>> {
        <Self as RtActivatable<ISecondaryTileStatics>>::get_activation_factory().find_all_for_application_async(applicationId)
    }
    #[inline] pub fn find_all_for_package_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>>> {
        <Self as RtActivatable<ISecondaryTileStatics>>::get_activation_factory().find_all_for_package_async()
    }
}
DEFINE_CLSID!(SecondaryTile(&[87,105,110,100,111,119,115,46,85,73,46,83,116,97,114,116,83,99,114,101,101,110,46,83,101,99,111,110,100,97,114,121,84,105,108,101,0]) [CLSID_SecondaryTile]);
DEFINE_IID!(IID_ISecondaryTile2, 3002518581, 12880, 18832, 146, 60, 41, 74, 180, 182, 148, 221);
RT_INTERFACE!{interface ISecondaryTile2(ISecondaryTile2Vtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTile2] {
    fn put_PhoneticName(&self, value: HSTRING) -> HRESULT,
    fn get_PhoneticName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VisualElements(&self, out: *mut *mut SecondaryTileVisualElements) -> HRESULT,
    fn put_RoamingEnabled(&self, value: bool) -> HRESULT,
    fn get_RoamingEnabled(&self, out: *mut bool) -> HRESULT,
    fn add_VisualElementsRequested(&self, handler: *mut foundation::TypedEventHandler<SecondaryTile, VisualElementsRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisualElementsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ISecondaryTile2 {
    #[inline] pub fn set_phonetic_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PhoneticName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_phonetic_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PhoneticName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_visual_elements(&self) -> Result<Option<ComPtr<SecondaryTileVisualElements>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisualElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_roaming_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RoamingEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_roaming_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RoamingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_visual_elements_requested(&self, handler: &foundation::TypedEventHandler<SecondaryTile, VisualElementsRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VisualElementsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_visual_elements_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_VisualElementsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISecondaryTileFactory, 1475685536, 20924, 19135, 142, 191, 98, 122, 3, 152, 176, 90);
RT_INTERFACE!{static interface ISecondaryTileFactory(ISecondaryTileFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileFactory] {
    fn CreateTile(&self, tileId: HSTRING, shortName: HSTRING, displayName: HSTRING, arguments: HSTRING, tileOptions: TileOptions, logoReference: *mut foundation::Uri, out: *mut *mut SecondaryTile) -> HRESULT,
    fn CreateWideTile(&self, tileId: HSTRING, shortName: HSTRING, displayName: HSTRING, arguments: HSTRING, tileOptions: TileOptions, logoReference: *mut foundation::Uri, wideLogoReference: *mut foundation::Uri, out: *mut *mut SecondaryTile) -> HRESULT,
    fn CreateWithId(&self, tileId: HSTRING, out: *mut *mut SecondaryTile) -> HRESULT
}}
impl ISecondaryTileFactory {
    #[inline] pub fn create_tile(&self, tileId: &HStringArg, shortName: &HStringArg, displayName: &HStringArg, arguments: &HStringArg, tileOptions: TileOptions, logoReference: &foundation::Uri) -> Result<ComPtr<SecondaryTile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateTile)(self as *const _ as *mut _, tileId.get(), shortName.get(), displayName.get(), arguments.get(), tileOptions, logoReference as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_wide_tile(&self, tileId: &HStringArg, shortName: &HStringArg, displayName: &HStringArg, arguments: &HStringArg, tileOptions: TileOptions, logoReference: &foundation::Uri, wideLogoReference: &foundation::Uri) -> Result<ComPtr<SecondaryTile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWideTile)(self as *const _ as *mut _, tileId.get(), shortName.get(), displayName.get(), arguments.get(), tileOptions, logoReference as *const _ as *mut _, wideLogoReference as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_id(&self, tileId: &HStringArg) -> Result<ComPtr<SecondaryTile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithId)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISecondaryTileFactory2, 659262011, 21037, 17550, 158, 178, 208, 103, 42, 179, 69, 200);
RT_INTERFACE!{static interface ISecondaryTileFactory2(ISecondaryTileFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileFactory2] {
    fn CreateMinimalTile(&self, tileId: HSTRING, displayName: HSTRING, arguments: HSTRING, square150x150Logo: *mut foundation::Uri, desiredSize: TileSize, out: *mut *mut SecondaryTile) -> HRESULT
}}
impl ISecondaryTileFactory2 {
    #[inline] pub fn create_minimal_tile(&self, tileId: &HStringArg, displayName: &HStringArg, arguments: &HStringArg, square150x150Logo: &foundation::Uri, desiredSize: TileSize) -> Result<ComPtr<SecondaryTile>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateMinimalTile)(self as *const _ as *mut _, tileId.get(), displayName.get(), arguments.get(), square150x150Logo as *const _ as *mut _, desiredSize, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISecondaryTileStatics, 2576387502, 53329, 18038, 135, 254, 158, 194, 66, 216, 60, 116);
RT_INTERFACE!{static interface ISecondaryTileStatics(ISecondaryTileStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileStatics] {
    fn Exists(&self, tileId: HSTRING, out: *mut bool) -> HRESULT,
    fn FindAllAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>) -> HRESULT,
    fn FindAllForApplicationAsync(&self, applicationId: HSTRING, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>) -> HRESULT,
    fn FindAllForPackageAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>) -> HRESULT
}}
impl ISecondaryTileStatics {
    #[inline] pub fn exists(&self, tileId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Exists)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_for_application_async(&self, applicationId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllForApplicationAsync)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_for_package_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SecondaryTile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllForPackageAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISecondaryTileVisualElements, 495842099, 33118, 16703, 159, 80, 168, 29, 167, 10, 150, 178);
RT_INTERFACE!{interface ISecondaryTileVisualElements(ISecondaryTileVisualElementsVtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileVisualElements] {
    fn put_Square30x30Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Square30x30Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Square70x70Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Square70x70Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Square150x150Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Square150x150Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Wide310x150Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Wide310x150Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Square310x310Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Square310x310Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_ForegroundText(&self, value: ForegroundText) -> HRESULT,
    fn get_ForegroundText(&self, out: *mut ForegroundText) -> HRESULT,
    fn put_BackgroundColor(&self, value: super::Color) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut super::Color) -> HRESULT,
    fn put_ShowNameOnSquare150x150Logo(&self, value: bool) -> HRESULT,
    fn get_ShowNameOnSquare150x150Logo(&self, out: *mut bool) -> HRESULT,
    fn put_ShowNameOnWide310x150Logo(&self, value: bool) -> HRESULT,
    fn get_ShowNameOnWide310x150Logo(&self, out: *mut bool) -> HRESULT,
    fn put_ShowNameOnSquare310x310Logo(&self, value: bool) -> HRESULT,
    fn get_ShowNameOnSquare310x310Logo(&self, out: *mut bool) -> HRESULT
}}
impl ISecondaryTileVisualElements {
    #[inline] pub fn set_square_30x30_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Square30x30Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_square_30x30_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square30x30Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_square_70x70_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Square70x70Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_square_70x70_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square70x70Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_square_150x150_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Square150x150Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_square_150x150_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square150x150Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_wide_310x150_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Wide310x150Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wide_310x150_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Wide310x150Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_square_310x310_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Square310x310Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_square_310x310_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square310x310Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_foreground_text(&self, value: ForegroundText) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ForegroundText)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_foreground_text(&self) -> Result<ForegroundText> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForegroundText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_background_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_show_name_on_square_150x150_logo(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShowNameOnSquare150x150Logo)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_show_name_on_square_150x150_logo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowNameOnSquare150x150Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_show_name_on_wide_310x150_logo(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShowNameOnWide310x150Logo)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_show_name_on_wide_310x150_logo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowNameOnWide310x150Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_show_name_on_square_310x310_logo(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShowNameOnSquare310x310Logo)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_show_name_on_square_310x310_logo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowNameOnSquare310x310Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SecondaryTileVisualElements: ISecondaryTileVisualElements}
DEFINE_IID!(IID_ISecondaryTileVisualElements2, 4247663056, 22492, 18324, 142, 207, 86, 130, 245, 243, 230, 239);
RT_INTERFACE!{interface ISecondaryTileVisualElements2(ISecondaryTileVisualElements2Vtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileVisualElements2] {
    fn put_Square71x71Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Square71x71Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT
}}
impl ISecondaryTileVisualElements2 {
    #[inline] pub fn set_square_71x71_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Square71x71Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_square_71x71_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square71x71Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISecondaryTileVisualElements3, 1454725846, 53596, 16628, 129, 231, 87, 255, 216, 248, 164, 233);
RT_INTERFACE!{interface ISecondaryTileVisualElements3(ISecondaryTileVisualElements3Vtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileVisualElements3] {
    fn put_Square44x44Logo(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Square44x44Logo(&self, out: *mut *mut foundation::Uri) -> HRESULT
}}
impl ISecondaryTileVisualElements3 {
    #[inline] pub fn set_square_44x44_logo(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Square44x44Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_square_44x44_logo(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square44x44Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISecondaryTileVisualElements4, 1716936983, 46404, 16594, 141, 18, 116, 212, 236, 36, 208, 76);
RT_INTERFACE!{interface ISecondaryTileVisualElements4(ISecondaryTileVisualElements4Vtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryTileVisualElements4] {
    fn get_MixedRealityModel(&self, out: *mut *mut TileMixedRealityModel) -> HRESULT
}}
impl ISecondaryTileVisualElements4 {
    #[inline] pub fn get_mixed_reality_model(&self) -> Result<Option<ComPtr<TileMixedRealityModel>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MixedRealityModel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStartScreenManager, 1243466699, 9961, 20148, 137, 51, 133, 158, 182, 236, 219, 41);
RT_INTERFACE!{interface IStartScreenManager(IStartScreenManagerVtbl): IInspectable(IInspectableVtbl) [IID_IStartScreenManager] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn SupportsAppListEntry(&self, appListEntry: *mut super::super::applicationmodel::core::AppListEntry, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn ContainsAppListEntryAsync(&self, appListEntry: *mut super::super::applicationmodel::core::AppListEntry, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-applicationmodel")] fn RequestAddAppListEntryAsync(&self, appListEntry: *mut super::super::applicationmodel::core::AppListEntry, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IStartScreenManager {
    #[cfg(feature="windows-system")] #[inline] pub fn get_user(&self) -> Result<Option<ComPtr<super::super::system::User>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn supports_app_list_entry(&self, appListEntry: &super::super::applicationmodel::core::AppListEntry) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).SupportsAppListEntry)(self as *const _ as *mut _, appListEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn contains_app_list_entry_async(&self, appListEntry: &super::super::applicationmodel::core::AppListEntry) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ContainsAppListEntryAsync)(self as *const _ as *mut _, appListEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn request_add_app_list_entry_async(&self, appListEntry: &super::super::applicationmodel::core::AppListEntry) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAddAppListEntryAsync)(self as *const _ as *mut _, appListEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class StartScreenManager: IStartScreenManager}
impl RtActivatable<IStartScreenManagerStatics> for StartScreenManager {}
impl StartScreenManager {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<StartScreenManager>>> {
        <Self as RtActivatable<IStartScreenManagerStatics>>::get_activation_factory().get_default()
    }
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<Option<ComPtr<StartScreenManager>>> {
        <Self as RtActivatable<IStartScreenManagerStatics>>::get_activation_factory().get_for_user(user)
    }
}
DEFINE_CLSID!(StartScreenManager(&[87,105,110,100,111,119,115,46,85,73,46,83,116,97,114,116,83,99,114,101,101,110,46,83,116,97,114,116,83,99,114,101,101,110,77,97,110,97,103,101,114,0]) [CLSID_StartScreenManager]);
DEFINE_IID!(IID_IStartScreenManager2, 145168054, 12651, 19161, 172, 184, 254, 156, 240, 11, 214, 8);
RT_INTERFACE!{interface IStartScreenManager2(IStartScreenManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IStartScreenManager2] {
    fn ContainsSecondaryTileAsync(&self, tileId: HSTRING, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryRemoveSecondaryTileAsync(&self, tileId: HSTRING, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IStartScreenManager2 {
    #[inline] pub fn contains_secondary_tile_async(&self, tileId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ContainsSecondaryTileAsync)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_remove_secondary_tile_async(&self, tileId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryRemoveSecondaryTileAsync)(self as *const _ as *mut _, tileId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IStartScreenManagerStatics, 2019946255, 46469, 17998, 137, 147, 52, 232, 248, 115, 141, 72);
RT_INTERFACE!{static interface IStartScreenManagerStatics(IStartScreenManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStartScreenManagerStatics] {
    fn GetDefault(&self, out: *mut *mut StartScreenManager) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut StartScreenManager) -> HRESULT
}}
impl IStartScreenManagerStatics {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<StartScreenManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(&self, user: &super::super::system::User) -> Result<Option<ComPtr<StartScreenManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITileMixedRealityModel, 2960543323, 34941, 16962, 154, 25, 61, 10, 78, 167, 128, 49);
RT_INTERFACE!{interface ITileMixedRealityModel(ITileMixedRealityModelVtbl): IInspectable(IInspectableVtbl) [IID_ITileMixedRealityModel] {
    fn put_Uri(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_Uri(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    #[cfg(feature="windows-perception")] fn put_BoundingBox(&self, value: *mut foundation::IReference<super::super::perception::spatial::SpatialBoundingBox>) -> HRESULT,
    #[cfg(feature="windows-perception")] fn get_BoundingBox(&self, out: *mut *mut foundation::IReference<super::super::perception::spatial::SpatialBoundingBox>) -> HRESULT
}}
impl ITileMixedRealityModel {
    #[inline] pub fn set_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Uri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn set_bounding_box(&self, value: &foundation::IReference<super::super::perception::spatial::SpatialBoundingBox>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BoundingBox)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-perception")] #[inline] pub fn get_bounding_box(&self) -> Result<Option<ComPtr<foundation::IReference<super::super::perception::spatial::SpatialBoundingBox>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BoundingBox)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class TileMixedRealityModel: ITileMixedRealityModel}
DEFINE_IID!(IID_ITileMixedRealityModel2, 1133801650, 55237, 16651, 131, 25, 148, 134, 162, 123, 108, 103);
RT_INTERFACE!{interface ITileMixedRealityModel2(ITileMixedRealityModel2Vtbl): IInspectable(IInspectableVtbl) [IID_ITileMixedRealityModel2] {
    fn put_ActivationBehavior(&self, value: TileMixedRealityModelActivationBehavior) -> HRESULT,
    fn get_ActivationBehavior(&self, out: *mut TileMixedRealityModelActivationBehavior) -> HRESULT
}}
impl ITileMixedRealityModel2 {
    #[inline] pub fn set_activation_behavior(&self, value: TileMixedRealityModelActivationBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ActivationBehavior)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_activation_behavior(&self) -> Result<TileMixedRealityModelActivationBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivationBehavior)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum TileMixedRealityModelActivationBehavior: i32 {
    Default = 0, None = 1,
}}
RT_ENUM! { enum TileOptions: u32 {
    None = 0, ShowNameOnLogo = 1, ShowNameOnWideLogo = 2, CopyOnDeployment = 4,
}}
RT_ENUM! { enum TileSize: i32 {
    Default = 0, Square30x30 = 1, Square70x70 = 2, Square150x150 = 3, Wide310x150 = 4, Square310x310 = 5, Square71x71 = 6, Square44x44 = 7,
}}
DEFINE_IID!(IID_IVisualElementsRequest, 3241685818, 37640, 16498, 136, 204, 208, 104, 219, 52, 124, 104);
RT_INTERFACE!{interface IVisualElementsRequest(IVisualElementsRequestVtbl): IInspectable(IInspectableVtbl) [IID_IVisualElementsRequest] {
    fn get_VisualElements(&self, out: *mut *mut SecondaryTileVisualElements) -> HRESULT,
    fn get_AlternateVisualElements(&self, out: *mut *mut foundation::collections::IVectorView<SecondaryTileVisualElements>) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut VisualElementsRequestDeferral) -> HRESULT
}}
impl IVisualElementsRequest {
    #[inline] pub fn get_visual_elements(&self) -> Result<Option<ComPtr<SecondaryTileVisualElements>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisualElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_alternate_visual_elements(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SecondaryTileVisualElements>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlternateVisualElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Deadline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<VisualElementsRequestDeferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VisualElementsRequest: IVisualElementsRequest}
DEFINE_IID!(IID_IVisualElementsRequestDeferral, 2707779248, 294, 17239, 130, 4, 189, 130, 187, 42, 4, 109);
RT_INTERFACE!{interface IVisualElementsRequestDeferral(IVisualElementsRequestDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IVisualElementsRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IVisualElementsRequestDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class VisualElementsRequestDeferral: IVisualElementsRequestDeferral}
DEFINE_IID!(IID_IVisualElementsRequestedEventArgs, 2070923650, 14861, 20174, 175, 150, 205, 23, 225, 176, 11, 45);
RT_INTERFACE!{interface IVisualElementsRequestedEventArgs(IVisualElementsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IVisualElementsRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut VisualElementsRequest) -> HRESULT
}}
impl IVisualElementsRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<VisualElementsRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VisualElementsRequestedEventArgs: IVisualElementsRequestedEventArgs}
} // Windows.UI.StartScreen
pub mod text { // Windows.UI.Text
use crate::prelude::*;
RT_ENUM! { enum CaretType: i32 {
    Normal = 0, Null = 1,
}}
DEFINE_IID!(IID_IContentLinkInfo, 517285157, 7263, 18635, 179, 53, 120, 181, 10, 46, 230, 66);
RT_INTERFACE!{interface IContentLinkInfo(IContentLinkInfoVtbl): IInspectable(IInspectableVtbl) [IID_IContentLinkInfo] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn put_Id(&self, value: u32) -> HRESULT,
    fn get_DisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayText(&self, value: HSTRING) -> HRESULT,
    fn get_SecondaryText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SecondaryText(&self, value: HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_Uri(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_LinkContentKind(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LinkContentKind(&self, value: HSTRING) -> HRESULT
}}
impl IContentLinkInfo {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DisplayText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_secondary_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_secondary_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SecondaryText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uri(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_uri(&self, value: &foundation::Uri) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Uri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_link_content_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinkContentKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_link_content_kind(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LinkContentKind)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ContentLinkInfo: IContentLinkInfo}
impl RtActivatable<IActivationFactory> for ContentLinkInfo {}
DEFINE_CLSID!(ContentLinkInfo(&[87,105,110,100,111,119,115,46,85,73,46,84,101,120,116,46,67,111,110,116,101,110,116,76,105,110,107,73,110,102,111,0]) [CLSID_ContentLinkInfo]);
RT_ENUM! { enum FindOptions: u32 {
    None = 0, Word = 2, Case = 4,
}}
RT_ENUM! { enum FontStretch: i32 {
    Undefined = 0, UltraCondensed = 1, ExtraCondensed = 2, Condensed = 3, SemiCondensed = 4, Normal = 5, SemiExpanded = 6, Expanded = 7, ExtraExpanded = 8, UltraExpanded = 9,
}}
RT_ENUM! { enum FontStyle: i32 {
    Normal = 0, Oblique = 1, Italic = 2,
}}
RT_STRUCT! { struct FontWeight {
    Weight: u16,
}}
DEFINE_IID!(IID_IFontWeights, 2021696580, 427, 18839, 133, 23, 223, 130, 42, 12, 69, 241);
RT_INTERFACE!{interface IFontWeights(IFontWeightsVtbl): IInspectable(IInspectableVtbl) [IID_IFontWeights] {
    
}}
RT_CLASS!{class FontWeights: IFontWeights}
impl RtActivatable<IFontWeightsStatics> for FontWeights {}
impl FontWeights {
    #[inline] pub fn get_black() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_black()
    }
    #[inline] pub fn get_bold() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_bold()
    }
    #[inline] pub fn get_extra_black() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_extra_black()
    }
    #[inline] pub fn get_extra_bold() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_extra_bold()
    }
    #[inline] pub fn get_extra_light() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_extra_light()
    }
    #[inline] pub fn get_light() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_light()
    }
    #[inline] pub fn get_medium() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_medium()
    }
    #[inline] pub fn get_normal() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_normal()
    }
    #[inline] pub fn get_semi_bold() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_semi_bold()
    }
    #[inline] pub fn get_semi_light() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_semi_light()
    }
    #[inline] pub fn get_thin() -> Result<FontWeight> {
        <Self as RtActivatable<IFontWeightsStatics>>::get_activation_factory().get_thin()
    }
}
DEFINE_CLSID!(FontWeights(&[87,105,110,100,111,119,115,46,85,73,46,84,101,120,116,46,70,111,110,116,87,101,105,103,104,116,115,0]) [CLSID_FontWeights]);
DEFINE_IID!(IID_IFontWeightsStatics, 3015014869, 7081, 18667, 157, 173, 192, 149, 232, 194, 59, 163);
RT_INTERFACE!{static interface IFontWeightsStatics(IFontWeightsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFontWeightsStatics] {
    fn get_Black(&self, out: *mut FontWeight) -> HRESULT,
    fn get_Bold(&self, out: *mut FontWeight) -> HRESULT,
    fn get_ExtraBlack(&self, out: *mut FontWeight) -> HRESULT,
    fn get_ExtraBold(&self, out: *mut FontWeight) -> HRESULT,
    fn get_ExtraLight(&self, out: *mut FontWeight) -> HRESULT,
    fn get_Light(&self, out: *mut FontWeight) -> HRESULT,
    fn get_Medium(&self, out: *mut FontWeight) -> HRESULT,
    fn get_Normal(&self, out: *mut FontWeight) -> HRESULT,
    fn get_SemiBold(&self, out: *mut FontWeight) -> HRESULT,
    fn get_SemiLight(&self, out: *mut FontWeight) -> HRESULT,
    fn get_Thin(&self, out: *mut FontWeight) -> HRESULT
}}
impl IFontWeightsStatics {
    #[inline] pub fn get_black(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Black)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bold(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bold)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extra_black(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtraBlack)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extra_bold(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtraBold)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extra_light(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtraLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_light(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Light)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_medium(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Medium)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_normal(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Normal)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_semi_bold(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SemiBold)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_semi_light(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SemiLight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thin(&self) -> Result<FontWeight> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Thin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum FormatEffect: i32 {
    Off = 0, On = 1, Toggle = 2, Undefined = 3,
}}
RT_ENUM! { enum HorizontalCharacterAlignment: i32 {
    Left = 0, Right = 1, Center = 2,
}}
RT_ENUM! { enum LetterCase: i32 {
    Lower = 0, Upper = 1,
}}
RT_ENUM! { enum LineSpacingRule: i32 {
    Undefined = 0, Single = 1, OneAndHalf = 2, Double = 3, AtLeast = 4, Exactly = 5, Multiple = 6, Percent = 7,
}}
RT_ENUM! { enum LinkType: i32 {
    Undefined = 0, NotALink = 1, ClientLink = 2, FriendlyLinkName = 3, FriendlyLinkAddress = 4, AutoLink = 5, AutoLinkEmail = 6, AutoLinkPhone = 7, AutoLinkPath = 8,
}}
RT_ENUM! { enum MarkerAlignment: i32 {
    Undefined = 0, Left = 1, Center = 2, Right = 3,
}}
RT_ENUM! { enum MarkerStyle: i32 {
    Undefined = 0, Parenthesis = 1, Parentheses = 2, Period = 3, Plain = 4, Minus = 5, NoNumber = 6,
}}
RT_ENUM! { enum MarkerType: i32 {
    Undefined = 0, None = 1, Bullet = 2, Arabic = 3, LowercaseEnglishLetter = 4, UppercaseEnglishLetter = 5, LowercaseRoman = 6, UppercaseRoman = 7, UnicodeSequence = 8, CircledNumber = 9, BlackCircleWingding = 10, WhiteCircleWingding = 11, ArabicWide = 12, SimplifiedChinese = 13, TraditionalChinese = 14, JapanSimplifiedChinese = 15, JapanKorea = 16, ArabicDictionary = 17, ArabicAbjad = 18, Hebrew = 19, ThaiAlphabetic = 20, ThaiNumeric = 21, DevanagariVowel = 22, DevanagariConsonant = 23, DevanagariNumeric = 24,
}}
RT_ENUM! { enum ParagraphAlignment: i32 {
    Undefined = 0, Left = 1, Center = 2, Right = 3, Justify = 4,
}}
RT_ENUM! { enum ParagraphStyle: i32 {
    Undefined = 0, None = 1, Normal = 2, Heading1 = 3, Heading2 = 4, Heading3 = 5, Heading4 = 6, Heading5 = 7, Heading6 = 8, Heading7 = 9, Heading8 = 10, Heading9 = 11,
}}
RT_ENUM! { enum PointOptions: u32 {
    None = 0, IncludeInset = 1, Start = 32, ClientCoordinates = 256, AllowOffClient = 512, Transform = 1024, NoHorizontalScroll = 65536, NoVerticalScroll = 262144,
}}
RT_ENUM! { enum RangeGravity: i32 {
    UIBehavior = 0, Backward = 1, Forward = 2, Inward = 3, Outward = 4,
}}
RT_CLASS!{class RichEditTextDocument: ITextDocument}
DEFINE_IID!(IID_IRichEditTextRange, 927872277, 47754, 19054, 140, 89, 13, 222, 61, 12, 245, 205);
RT_INTERFACE!{interface IRichEditTextRange(IRichEditTextRangeVtbl): IInspectable(IInspectableVtbl) [IID_IRichEditTextRange] {
    fn get_ContentLinkInfo(&self, out: *mut *mut ContentLinkInfo) -> HRESULT,
    fn put_ContentLinkInfo(&self, value: *mut ContentLinkInfo) -> HRESULT
}}
impl IRichEditTextRange {
    #[inline] pub fn get_content_link_info(&self) -> Result<Option<ComPtr<ContentLinkInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentLinkInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_content_link_info(&self, value: &ContentLinkInfo) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ContentLinkInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RichEditTextRange: ITextRange}
RT_ENUM! { enum SelectionOptions: u32 {
    StartActive = 1, AtEndOfLine = 2, Overtype = 4, Active = 8, Replace = 16,
}}
RT_ENUM! { enum SelectionType: i32 {
    None = 0, InsertionPoint = 1, Normal = 2, InlineShape = 7, Shape = 8,
}}
RT_ENUM! { enum TabAlignment: i32 {
    Left = 0, Center = 1, Right = 2, Decimal = 3, Bar = 4,
}}
RT_ENUM! { enum TabLeader: i32 {
    Spaces = 0, Dots = 1, Dashes = 2, Lines = 3, ThickLines = 4, Equals = 5,
}}
DEFINE_IID!(IID_ITextCharacterFormat, 1524560859, 1531, 17453, 128, 101, 100, 42, 254, 160, 44, 237);
RT_INTERFACE!{interface ITextCharacterFormat(ITextCharacterFormatVtbl): IInspectable(IInspectableVtbl) [IID_ITextCharacterFormat] {
    fn get_AllCaps(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_AllCaps(&self, value: FormatEffect) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut super::Color) -> HRESULT,
    fn put_BackgroundColor(&self, value: super::Color) -> HRESULT,
    fn get_Bold(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Bold(&self, value: FormatEffect) -> HRESULT,
    fn get_FontStretch(&self, out: *mut FontStretch) -> HRESULT,
    fn put_FontStretch(&self, value: FontStretch) -> HRESULT,
    fn get_FontStyle(&self, out: *mut FontStyle) -> HRESULT,
    fn put_FontStyle(&self, value: FontStyle) -> HRESULT,
    fn get_ForegroundColor(&self, out: *mut super::Color) -> HRESULT,
    fn put_ForegroundColor(&self, value: super::Color) -> HRESULT,
    fn get_Hidden(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Hidden(&self, value: FormatEffect) -> HRESULT,
    fn get_Italic(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Italic(&self, value: FormatEffect) -> HRESULT,
    fn get_Kerning(&self, out: *mut f32) -> HRESULT,
    fn put_Kerning(&self, value: f32) -> HRESULT,
    fn get_LanguageTag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LanguageTag(&self, value: HSTRING) -> HRESULT,
    fn get_LinkType(&self, out: *mut LinkType) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Outline(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Outline(&self, value: FormatEffect) -> HRESULT,
    fn get_Position(&self, out: *mut f32) -> HRESULT,
    fn put_Position(&self, value: f32) -> HRESULT,
    fn get_ProtectedText(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_ProtectedText(&self, value: FormatEffect) -> HRESULT,
    fn get_Size(&self, out: *mut f32) -> HRESULT,
    fn put_Size(&self, value: f32) -> HRESULT,
    fn get_SmallCaps(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_SmallCaps(&self, value: FormatEffect) -> HRESULT,
    fn get_Spacing(&self, out: *mut f32) -> HRESULT,
    fn put_Spacing(&self, value: f32) -> HRESULT,
    fn get_Strikethrough(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Strikethrough(&self, value: FormatEffect) -> HRESULT,
    fn get_Subscript(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Subscript(&self, value: FormatEffect) -> HRESULT,
    fn get_Superscript(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_Superscript(&self, value: FormatEffect) -> HRESULT,
    fn get_TextScript(&self, out: *mut TextScript) -> HRESULT,
    fn put_TextScript(&self, value: TextScript) -> HRESULT,
    fn get_Underline(&self, out: *mut UnderlineType) -> HRESULT,
    fn put_Underline(&self, value: UnderlineType) -> HRESULT,
    fn get_Weight(&self, out: *mut i32) -> HRESULT,
    fn put_Weight(&self, value: i32) -> HRESULT,
    fn SetClone(&self, value: *mut ITextCharacterFormat) -> HRESULT,
    fn GetClone(&self, out: *mut *mut ITextCharacterFormat) -> HRESULT,
    fn IsEqual(&self, format: *mut ITextCharacterFormat, out: *mut bool) -> HRESULT
}}
impl ITextCharacterFormat {
    #[inline] pub fn get_all_caps(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllCaps)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_all_caps(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AllCaps)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_background_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bold(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Bold)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bold(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Bold)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_font_stretch(&self) -> Result<FontStretch> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_font_stretch(&self, value: FontStretch) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FontStretch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_font_style(&self) -> Result<FontStyle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_font_style(&self, value: FontStyle) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FontStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_foreground_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_foreground_color(&self, value: super::Color) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ForegroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hidden(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Hidden)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_hidden(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Hidden)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_italic(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Italic)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_italic(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Italic)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_kerning(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kerning)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_kerning(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Kerning)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_language_tag(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LanguageTag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_language_tag(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LanguageTag)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_link_type(&self) -> Result<LinkType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LinkType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_outline(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Outline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_outline(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Outline)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Position)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protected_text(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProtectedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protected_text(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ProtectedText)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_size(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_size(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Size)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_small_caps(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SmallCaps)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_small_caps(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SmallCaps)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_spacing(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Spacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_spacing(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Spacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_strikethrough(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Strikethrough)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_strikethrough(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Strikethrough)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subscript(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Subscript)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_subscript(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Subscript)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_superscript(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Superscript)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_superscript(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Superscript)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_text_script(&self) -> Result<TextScript> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextScript)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_text_script(&self, value: TextScript) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TextScript)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_underline(&self) -> Result<UnderlineType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Underline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_underline(&self, value: UnderlineType) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Underline)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_weight(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Weight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_weight(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Weight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_clone(&self, value: &ITextCharacterFormat) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetClone)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clone(&self) -> Result<Option<ComPtr<ITextCharacterFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetClone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, format: &ITextCharacterFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsEqual)(self as *const _ as *mut _, format as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class TextConstants}
impl RtActivatable<ITextConstantsStatics> for TextConstants {}
impl TextConstants {
    #[inline] pub fn get_auto_color() -> Result<super::Color> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_auto_color()
    }
    #[inline] pub fn get_min_unit_count() -> Result<i32> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_min_unit_count()
    }
    #[inline] pub fn get_max_unit_count() -> Result<i32> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_max_unit_count()
    }
    #[inline] pub fn get_undefined_color() -> Result<super::Color> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_undefined_color()
    }
    #[inline] pub fn get_undefined_float_value() -> Result<f32> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_undefined_float_value()
    }
    #[inline] pub fn get_undefined_int32_value() -> Result<i32> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_undefined_int32_value()
    }
    #[inline] pub fn get_undefined_font_stretch() -> Result<FontStretch> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_undefined_font_stretch()
    }
    #[inline] pub fn get_undefined_font_style() -> Result<FontStyle> {
        <Self as RtActivatable<ITextConstantsStatics>>::get_activation_factory().get_undefined_font_style()
    }
}
DEFINE_CLSID!(TextConstants(&[87,105,110,100,111,119,115,46,85,73,46,84,101,120,116,46,84,101,120,116,67,111,110,115,116,97,110,116,115,0]) [CLSID_TextConstants]);
DEFINE_IID!(IID_ITextConstantsStatics, 2006875187, 6301, 19450, 151, 200, 16, 219, 19, 93, 151, 110);
RT_INTERFACE!{static interface ITextConstantsStatics(ITextConstantsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ITextConstantsStatics] {
    fn get_AutoColor(&self, out: *mut super::Color) -> HRESULT,
    fn get_MinUnitCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxUnitCount(&self, out: *mut i32) -> HRESULT,
    fn get_UndefinedColor(&self, out: *mut super::Color) -> HRESULT,
    fn get_UndefinedFloatValue(&self, out: *mut f32) -> HRESULT,
    fn get_UndefinedInt32Value(&self, out: *mut i32) -> HRESULT,
    fn get_UndefinedFontStretch(&self, out: *mut FontStretch) -> HRESULT,
    fn get_UndefinedFontStyle(&self, out: *mut FontStyle) -> HRESULT
}}
impl ITextConstantsStatics {
    #[inline] pub fn get_auto_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_unit_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinUnitCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_unit_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxUnitCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_undefined_color(&self) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UndefinedColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_undefined_float_value(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UndefinedFloatValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_undefined_int32_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UndefinedInt32Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_undefined_font_stretch(&self) -> Result<FontStretch> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UndefinedFontStretch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_undefined_font_style(&self) -> Result<FontStyle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UndefinedFontStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum TextDecorations: u32 {
    None = 0, Underline = 1, Strikethrough = 2,
}}
DEFINE_IID!(IID_ITextDocument, 3203288539, 37042, 16524, 162, 246, 10, 10, 195, 30, 51, 228);
RT_INTERFACE!{interface ITextDocument(ITextDocumentVtbl): IInspectable(IInspectableVtbl) [IID_ITextDocument] {
    fn get_CaretType(&self, out: *mut CaretType) -> HRESULT,
    fn put_CaretType(&self, value: CaretType) -> HRESULT,
    fn get_DefaultTabStop(&self, out: *mut f32) -> HRESULT,
    fn put_DefaultTabStop(&self, value: f32) -> HRESULT,
    fn get_Selection(&self, out: *mut *mut ITextSelection) -> HRESULT,
    fn get_UndoLimit(&self, out: *mut u32) -> HRESULT,
    fn put_UndoLimit(&self, value: u32) -> HRESULT,
    fn CanCopy(&self, out: *mut bool) -> HRESULT,
    fn CanPaste(&self, out: *mut bool) -> HRESULT,
    fn CanRedo(&self, out: *mut bool) -> HRESULT,
    fn CanUndo(&self, out: *mut bool) -> HRESULT,
    fn ApplyDisplayUpdates(&self, out: *mut i32) -> HRESULT,
    fn BatchDisplayUpdates(&self, out: *mut i32) -> HRESULT,
    fn BeginUndoGroup(&self) -> HRESULT,
    fn EndUndoGroup(&self) -> HRESULT,
    fn GetDefaultCharacterFormat(&self, out: *mut *mut ITextCharacterFormat) -> HRESULT,
    fn GetDefaultParagraphFormat(&self, out: *mut *mut ITextParagraphFormat) -> HRESULT,
    fn GetRange(&self, startPosition: i32, endPosition: i32, out: *mut *mut ITextRange) -> HRESULT,
    fn GetRangeFromPoint(&self, point: foundation::Point, options: PointOptions, out: *mut *mut ITextRange) -> HRESULT,
    fn GetText(&self, options: TextGetOptions, value: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-storage")] fn LoadFromStream(&self, options: TextSetOptions, value: *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn Redo(&self) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy22(&self) -> (),
    #[cfg(feature="windows-storage")] fn SaveToStream(&self, options: TextGetOptions, value: *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn SetDefaultCharacterFormat(&self, value: *mut ITextCharacterFormat) -> HRESULT,
    fn SetDefaultParagraphFormat(&self, value: *mut ITextParagraphFormat) -> HRESULT,
    fn SetText(&self, options: TextSetOptions, value: HSTRING) -> HRESULT,
    fn Undo(&self) -> HRESULT
}}
impl ITextDocument {
    #[inline] pub fn get_caret_type(&self) -> Result<CaretType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CaretType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_caret_type(&self, value: CaretType) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CaretType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_tab_stop(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DefaultTabStop)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_tab_stop(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_DefaultTabStop)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_selection(&self) -> Result<Option<ComPtr<ITextSelection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Selection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_undo_limit(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UndoLimit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_undo_limit(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_UndoLimit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn can_copy(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanCopy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn can_paste(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanPaste)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn can_redo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanRedo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn can_undo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanUndo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn apply_display_updates(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ApplyDisplayUpdates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn batch_display_updates(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).BatchDisplayUpdates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn begin_undo_group(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).BeginUndoGroup)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn end_undo_group(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EndUndoGroup)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_character_format(&self) -> Result<Option<ComPtr<ITextCharacterFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefaultCharacterFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_paragraph_format(&self) -> Result<Option<ComPtr<ITextParagraphFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefaultParagraphFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_range(&self, startPosition: i32, endPosition: i32) -> Result<Option<ComPtr<ITextRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRange)(self as *const _ as *mut _, startPosition, endPosition, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_range_from_point(&self, point: foundation::Point, options: PointOptions) -> Result<Option<ComPtr<ITextRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRangeFromPoint)(self as *const _ as *mut _, point, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self, options: TextGetOptions) -> Result<HString> { unsafe { 
        let mut value = null_mut();
        let hr = ((*self.lpVtbl).GetText)(self as *const _ as *mut _, options, &mut value);
        if hr == S_OK { Ok(HString::wrap(value)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn load_from_stream(&self, options: TextSetOptions, value: &super::super::storage::streams::IRandomAccessStream) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).LoadFromStream)(self as *const _ as *mut _, options, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn redo(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Redo)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn save_to_stream(&self, options: TextGetOptions, value: &super::super::storage::streams::IRandomAccessStream) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SaveToStream)(self as *const _ as *mut _, options, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_default_character_format(&self, value: &ITextCharacterFormat) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDefaultCharacterFormat)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_default_paragraph_format(&self, value: &ITextParagraphFormat) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetDefaultParagraphFormat)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, options: TextSetOptions, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetText)(self as *const _ as *mut _, options, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn undo(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Undo)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITextDocument2, 4063301906, 35977, 18889, 145, 24, 240, 87, 203, 184, 20, 238);
RT_INTERFACE!{interface ITextDocument2(ITextDocument2Vtbl): IInspectable(IInspectableVtbl) [IID_ITextDocument2] {
    fn get_AlignmentIncludesTrailingWhitespace(&self, out: *mut bool) -> HRESULT,
    fn put_AlignmentIncludesTrailingWhitespace(&self, value: bool) -> HRESULT,
    fn get_IgnoreTrailingCharacterSpacing(&self, out: *mut bool) -> HRESULT,
    fn put_IgnoreTrailingCharacterSpacing(&self, value: bool) -> HRESULT
}}
impl ITextDocument2 {
    #[inline] pub fn get_alignment_includes_trailing_whitespace(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AlignmentIncludesTrailingWhitespace)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_alignment_includes_trailing_whitespace(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_AlignmentIncludesTrailingWhitespace)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ignore_trailing_character_spacing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IgnoreTrailingCharacterSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ignore_trailing_character_spacing(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IgnoreTrailingCharacterSpacing)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITextDocument3, 1974141857, 42744, 17437, 170, 24, 10, 133, 29, 110, 94, 60);
RT_INTERFACE!{interface ITextDocument3(ITextDocument3Vtbl): IInspectable(IInspectableVtbl) [IID_ITextDocument3] {
    fn ClearUndoRedoHistory(&self) -> HRESULT
}}
impl ITextDocument3 {
    #[inline] pub fn clear_undo_redo_history(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearUndoRedoHistory)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum TextGetOptions: u32 {
    None = 0, AdjustCrlf = 1, UseCrlf = 2, UseObjectText = 4, AllowFinalEop = 8, NoHidden = 32, IncludeNumbering = 64, FormatRtf = 8192, UseLf = 16777216,
}}
DEFINE_IID!(IID_ITextParagraphFormat, 754503590, 18038, 18826, 147, 245, 187, 219, 252, 11, 216, 131);
RT_INTERFACE!{interface ITextParagraphFormat(ITextParagraphFormatVtbl): IInspectable(IInspectableVtbl) [IID_ITextParagraphFormat] {
    fn get_Alignment(&self, out: *mut ParagraphAlignment) -> HRESULT,
    fn put_Alignment(&self, value: ParagraphAlignment) -> HRESULT,
    fn get_FirstLineIndent(&self, out: *mut f32) -> HRESULT,
    fn get_KeepTogether(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_KeepTogether(&self, value: FormatEffect) -> HRESULT,
    fn get_KeepWithNext(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_KeepWithNext(&self, value: FormatEffect) -> HRESULT,
    fn get_LeftIndent(&self, out: *mut f32) -> HRESULT,
    fn get_LineSpacing(&self, out: *mut f32) -> HRESULT,
    fn get_LineSpacingRule(&self, out: *mut LineSpacingRule) -> HRESULT,
    fn get_ListAlignment(&self, out: *mut MarkerAlignment) -> HRESULT,
    fn put_ListAlignment(&self, value: MarkerAlignment) -> HRESULT,
    fn get_ListLevelIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ListLevelIndex(&self, value: i32) -> HRESULT,
    fn get_ListStart(&self, out: *mut i32) -> HRESULT,
    fn put_ListStart(&self, value: i32) -> HRESULT,
    fn get_ListStyle(&self, out: *mut MarkerStyle) -> HRESULT,
    fn put_ListStyle(&self, value: MarkerStyle) -> HRESULT,
    fn get_ListTab(&self, out: *mut f32) -> HRESULT,
    fn put_ListTab(&self, value: f32) -> HRESULT,
    fn get_ListType(&self, out: *mut MarkerType) -> HRESULT,
    fn put_ListType(&self, value: MarkerType) -> HRESULT,
    fn get_NoLineNumber(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_NoLineNumber(&self, value: FormatEffect) -> HRESULT,
    fn get_PageBreakBefore(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_PageBreakBefore(&self, value: FormatEffect) -> HRESULT,
    fn get_RightIndent(&self, out: *mut f32) -> HRESULT,
    fn put_RightIndent(&self, value: f32) -> HRESULT,
    fn get_RightToLeft(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_RightToLeft(&self, value: FormatEffect) -> HRESULT,
    fn get_Style(&self, out: *mut ParagraphStyle) -> HRESULT,
    fn put_Style(&self, value: ParagraphStyle) -> HRESULT,
    fn get_SpaceAfter(&self, out: *mut f32) -> HRESULT,
    fn put_SpaceAfter(&self, value: f32) -> HRESULT,
    fn get_SpaceBefore(&self, out: *mut f32) -> HRESULT,
    fn put_SpaceBefore(&self, value: f32) -> HRESULT,
    fn get_WidowControl(&self, out: *mut FormatEffect) -> HRESULT,
    fn put_WidowControl(&self, value: FormatEffect) -> HRESULT,
    fn get_TabCount(&self, out: *mut i32) -> HRESULT,
    fn AddTab(&self, position: f32, align: TabAlignment, leader: TabLeader) -> HRESULT,
    fn ClearAllTabs(&self) -> HRESULT,
    fn DeleteTab(&self, position: f32) -> HRESULT,
    fn GetClone(&self, out: *mut *mut ITextParagraphFormat) -> HRESULT,
    fn GetTab(&self, index: i32, position: *mut f32, align: *mut TabAlignment, leader: *mut TabLeader) -> HRESULT,
    fn IsEqual(&self, format: *mut ITextParagraphFormat, out: *mut bool) -> HRESULT,
    fn SetClone(&self, format: *mut ITextParagraphFormat) -> HRESULT,
    fn SetIndents(&self, start: f32, left: f32, right: f32) -> HRESULT,
    fn SetLineSpacing(&self, rule: LineSpacingRule, spacing: f32) -> HRESULT
}}
impl ITextParagraphFormat {
    #[inline] pub fn get_alignment(&self) -> Result<ParagraphAlignment> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Alignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_alignment(&self, value: ParagraphAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Alignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_first_line_indent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FirstLineIndent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_keep_together(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeepTogether)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_keep_together(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_KeepTogether)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_keep_with_next(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeepWithNext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_keep_with_next(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_KeepWithNext)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_indent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftIndent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_line_spacing(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineSpacing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_line_spacing_rule(&self) -> Result<LineSpacingRule> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineSpacingRule)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_list_alignment(&self) -> Result<MarkerAlignment> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListAlignment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_list_alignment(&self, value: MarkerAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ListAlignment)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_list_level_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListLevelIndex)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_list_level_index(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ListLevelIndex)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_list_start(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_list_start(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ListStart)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_list_style(&self) -> Result<MarkerStyle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_list_style(&self, value: MarkerStyle) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ListStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_list_tab(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListTab)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_list_tab(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ListTab)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_list_type(&self) -> Result<MarkerType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ListType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_list_type(&self, value: MarkerType) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ListType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_no_line_number(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NoLineNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_no_line_number(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_NoLineNumber)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_page_break_before(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PageBreakBefore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_page_break_before(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PageBreakBefore)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_indent(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightIndent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_indent(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightIndent)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_to_left(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightToLeft)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_to_left(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightToLeft)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_style(&self) -> Result<ParagraphStyle> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Style)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_style(&self, value: ParagraphStyle) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Style)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_space_after(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpaceAfter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_space_after(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SpaceAfter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_space_before(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SpaceBefore)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_space_before(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SpaceBefore)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_widow_control(&self) -> Result<FormatEffect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WidowControl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_widow_control(&self, value: FormatEffect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_WidowControl)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tab_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TabCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_tab(&self, position: f32, align: TabAlignment, leader: TabLeader) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).AddTab)(self as *const _ as *mut _, position, align, leader);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear_all_tabs(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ClearAllTabs)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn delete_tab(&self, position: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).DeleteTab)(self as *const _ as *mut _, position);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clone(&self) -> Result<Option<ComPtr<ITextParagraphFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetClone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tab(&self, index: i32) -> Result<(f32, TabAlignment, TabLeader)> { unsafe { 
        let mut position = zeroed(); let mut align = zeroed(); let mut leader = zeroed();
        let hr = ((*self.lpVtbl).GetTab)(self as *const _ as *mut _, index, &mut position, &mut align, &mut leader);
        if hr == S_OK { Ok((position, align, leader)) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, format: &ITextParagraphFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsEqual)(self as *const _ as *mut _, format as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_clone(&self, format: &ITextParagraphFormat) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetClone)(self as *const _ as *mut _, format as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_indents(&self, start: f32, left: f32, right: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetIndents)(self as *const _ as *mut _, start, left, right);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_line_spacing(&self, rule: LineSpacingRule, spacing: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetLineSpacing)(self as *const _ as *mut _, rule, spacing);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ITextRange, 1537101399, 49266, 17056, 137, 69, 175, 80, 62, 229, 71, 104);
RT_INTERFACE!{interface ITextRange(ITextRangeVtbl): IInspectable(IInspectableVtbl) [IID_ITextRange] {
    fn get_Character(&self, out: *mut Char) -> HRESULT,
    fn put_Character(&self, value: Char) -> HRESULT,
    fn get_CharacterFormat(&self, out: *mut *mut ITextCharacterFormat) -> HRESULT,
    fn put_CharacterFormat(&self, value: *mut ITextCharacterFormat) -> HRESULT,
    fn get_FormattedText(&self, out: *mut *mut ITextRange) -> HRESULT,
    fn put_FormattedText(&self, value: *mut ITextRange) -> HRESULT,
    fn get_EndPosition(&self, out: *mut i32) -> HRESULT,
    fn put_EndPosition(&self, value: i32) -> HRESULT,
    fn get_Gravity(&self, out: *mut RangeGravity) -> HRESULT,
    fn put_Gravity(&self, value: RangeGravity) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT,
    fn get_Link(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Link(&self, value: HSTRING) -> HRESULT,
    fn get_ParagraphFormat(&self, out: *mut *mut ITextParagraphFormat) -> HRESULT,
    fn put_ParagraphFormat(&self, value: *mut ITextParagraphFormat) -> HRESULT,
    fn get_StartPosition(&self, out: *mut i32) -> HRESULT,
    fn put_StartPosition(&self, value: i32) -> HRESULT,
    fn get_StoryLength(&self, out: *mut i32) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn CanPaste(&self, format: i32, out: *mut bool) -> HRESULT,
    fn ChangeCase(&self, value: LetterCase) -> HRESULT,
    fn Collapse(&self, value: bool) -> HRESULT,
    fn Copy(&self) -> HRESULT,
    fn Cut(&self) -> HRESULT,
    fn Delete(&self, unit: TextRangeUnit, count: i32, out: *mut i32) -> HRESULT,
    fn EndOf(&self, unit: TextRangeUnit, extend: bool, out: *mut i32) -> HRESULT,
    fn Expand(&self, unit: TextRangeUnit, out: *mut i32) -> HRESULT,
    fn FindText(&self, value: HSTRING, scanLength: i32, options: FindOptions, out: *mut i32) -> HRESULT,
    fn GetCharacterUtf32(&self, value: *mut u32, offset: i32) -> HRESULT,
    fn GetClone(&self, out: *mut *mut ITextRange) -> HRESULT,
    fn GetIndex(&self, unit: TextRangeUnit, out: *mut i32) -> HRESULT,
    fn GetPoint(&self, horizontalAlign: HorizontalCharacterAlignment, verticalAlign: VerticalCharacterAlignment, options: PointOptions, point: *mut foundation::Point) -> HRESULT,
    fn GetRect(&self, options: PointOptions, rect: *mut foundation::Rect, hit: *mut i32) -> HRESULT,
    fn GetText(&self, options: TextGetOptions, value: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy35(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetTextViaStream(&self, options: TextGetOptions, value: *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn InRange(&self, range: *mut ITextRange, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy37(&self) -> (),
    #[cfg(feature="windows-storage")] fn InsertImage(&self, width: i32, height: i32, ascent: i32, verticalAlign: VerticalCharacterAlignment, alternateText: HSTRING, value: *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn InStory(&self, range: *mut ITextRange, out: *mut bool) -> HRESULT,
    fn IsEqual(&self, range: *mut ITextRange, out: *mut bool) -> HRESULT,
    fn Move(&self, unit: TextRangeUnit, count: i32, out: *mut i32) -> HRESULT,
    fn MoveEnd(&self, unit: TextRangeUnit, count: i32, out: *mut i32) -> HRESULT,
    fn MoveStart(&self, unit: TextRangeUnit, count: i32, out: *mut i32) -> HRESULT,
    fn Paste(&self, format: i32) -> HRESULT,
    fn ScrollIntoView(&self, value: PointOptions) -> HRESULT,
    fn MatchSelection(&self) -> HRESULT,
    fn SetIndex(&self, unit: TextRangeUnit, index: i32, extend: bool) -> HRESULT,
    fn SetPoint(&self, point: foundation::Point, options: PointOptions, extend: bool) -> HRESULT,
    fn SetRange(&self, startPosition: i32, endPosition: i32) -> HRESULT,
    fn SetText(&self, options: TextSetOptions, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy50(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetTextViaStream(&self, options: TextSetOptions, value: *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn StartOf(&self, unit: TextRangeUnit, extend: bool, out: *mut i32) -> HRESULT
}}
impl ITextRange {
    #[inline] pub fn get_character(&self) -> Result<Char> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Character)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_character(&self, value: Char) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Character)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_character_format(&self) -> Result<Option<ComPtr<ITextCharacterFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CharacterFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_character_format(&self, value: &ITextCharacterFormat) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CharacterFormat)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_formatted_text(&self) -> Result<Option<ComPtr<ITextRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormattedText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_formatted_text(&self, value: &ITextRange) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FormattedText)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_end_position(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EndPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_end_position(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_EndPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_gravity(&self) -> Result<RangeGravity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Gravity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_gravity(&self, value: RangeGravity) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Gravity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Length)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_link(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Link)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_link(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Link)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_paragraph_format(&self) -> Result<Option<ComPtr<ITextParagraphFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ParagraphFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_paragraph_format(&self, value: &ITextParagraphFormat) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ParagraphFormat)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_position(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_position(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_StartPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_story_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StoryLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text_(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text_(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn can_paste(&self, format: i32) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).CanPaste)(self as *const _ as *mut _, format, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn change_case(&self, value: LetterCase) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ChangeCase)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn collapse(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Collapse)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn copy(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Copy)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cut(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Cut)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn delete(&self, unit: TextRangeUnit, count: i32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Delete)(self as *const _ as *mut _, unit, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn end_of(&self, unit: TextRangeUnit, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).EndOf)(self as *const _ as *mut _, unit, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn expand(&self, unit: TextRangeUnit) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Expand)(self as *const _ as *mut _, unit, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn find_text(&self, value: &HStringArg, scanLength: i32, options: FindOptions) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).FindText)(self as *const _ as *mut _, value.get(), scanLength, options, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_character_utf32(&self, offset: i32) -> Result<u32> { unsafe { 
        let mut value = zeroed();
        let hr = ((*self.lpVtbl).GetCharacterUtf32)(self as *const _ as *mut _, &mut value, offset);
        if hr == S_OK { Ok(value) } else { err(hr) }
    }}
    #[inline] pub fn get_clone(&self) -> Result<Option<ComPtr<ITextRange>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetClone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_index(&self, unit: TextRangeUnit) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetIndex)(self as *const _ as *mut _, unit, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_point(&self, horizontalAlign: HorizontalCharacterAlignment, verticalAlign: VerticalCharacterAlignment, options: PointOptions) -> Result<foundation::Point> { unsafe { 
        let mut point = zeroed();
        let hr = ((*self.lpVtbl).GetPoint)(self as *const _ as *mut _, horizontalAlign, verticalAlign, options, &mut point);
        if hr == S_OK { Ok(point) } else { err(hr) }
    }}
    #[inline] pub fn get_rect(&self, options: PointOptions) -> Result<(foundation::Rect, i32)> { unsafe { 
        let mut rect = zeroed(); let mut hit = zeroed();
        let hr = ((*self.lpVtbl).GetRect)(self as *const _ as *mut _, options, &mut rect, &mut hit);
        if hr == S_OK { Ok((rect, hit)) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self, options: TextGetOptions) -> Result<HString> { unsafe { 
        let mut value = null_mut();
        let hr = ((*self.lpVtbl).GetText)(self as *const _ as *mut _, options, &mut value);
        if hr == S_OK { Ok(HString::wrap(value)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_text_via_stream(&self, options: TextGetOptions, value: &super::super::storage::streams::IRandomAccessStream) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).GetTextViaStream)(self as *const _ as *mut _, options, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn in_range(&self, range: &ITextRange) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).InRange)(self as *const _ as *mut _, range as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn insert_image(&self, width: i32, height: i32, ascent: i32, verticalAlign: VerticalCharacterAlignment, alternateText: &HStringArg, value: &super::super::storage::streams::IRandomAccessStream) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).InsertImage)(self as *const _ as *mut _, width, height, ascent, verticalAlign, alternateText.get(), value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn in_story(&self, range: &ITextRange) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).InStory)(self as *const _ as *mut _, range as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, range: &ITextRange) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsEqual)(self as *const _ as *mut _, range as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_(&self, unit: TextRangeUnit, count: i32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Move)(self as *const _ as *mut _, unit, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_end(&self, unit: TextRangeUnit, count: i32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveEnd)(self as *const _ as *mut _, unit, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_start(&self, unit: TextRangeUnit, count: i32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveStart)(self as *const _ as *mut _, unit, count, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn paste(&self, format: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Paste)(self as *const _ as *mut _, format);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn scroll_into_view(&self, value: PointOptions) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ScrollIntoView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn match_selection(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).MatchSelection)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_index(&self, unit: TextRangeUnit, index: i32, extend: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetIndex)(self as *const _ as *mut _, unit, index, extend);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_point(&self, point: foundation::Point, options: PointOptions, extend: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetPoint)(self as *const _ as *mut _, point, options, extend);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_range(&self, startPosition: i32, endPosition: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetRange)(self as *const _ as *mut _, startPosition, endPosition);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, options: TextSetOptions, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetText)(self as *const _ as *mut _, options, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_text_via_stream(&self, options: TextSetOptions, value: &super::super::storage::streams::IRandomAccessStream) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetTextViaStream)(self as *const _ as *mut _, options, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_of(&self, unit: TextRangeUnit, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).StartOf)(self as *const _ as *mut _, unit, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum TextRangeUnit: i32 {
    Character = 0, Word = 1, Sentence = 2, Paragraph = 3, Line = 4, Story = 5, Screen = 6, Section = 7, Window = 8, CharacterFormat = 9, ParagraphFormat = 10, Object = 11, HardParagraph = 12, Cluster = 13, Bold = 14, Italic = 15, Underline = 16, Strikethrough = 17, ProtectedText = 18, Link = 19, SmallCaps = 20, AllCaps = 21, Hidden = 22, Outline = 23, Shadow = 24, Imprint = 25, Disabled = 26, Revised = 27, Subscript = 28, Superscript = 29, FontBound = 30, LinkProtected = 31, ContentLink = 32,
}}
RT_ENUM! { enum TextScript: i32 {
    Undefined = 0, Ansi = 1, EastEurope = 2, Cyrillic = 3, Greek = 4, Turkish = 5, Hebrew = 6, Arabic = 7, Baltic = 8, Vietnamese = 9, Default = 10, Symbol = 11, Thai = 12, ShiftJis = 13, GB2312 = 14, Hangul = 15, Big5 = 16, PC437 = 17, Oem = 18, Mac = 19, Armenian = 20, Syriac = 21, Thaana = 22, Devanagari = 23, Bengali = 24, Gurmukhi = 25, Gujarati = 26, Oriya = 27, Tamil = 28, Telugu = 29, Kannada = 30, Malayalam = 31, Sinhala = 32, Lao = 33, Tibetan = 34, Myanmar = 35, Georgian = 36, Jamo = 37, Ethiopic = 38, Cherokee = 39, Aboriginal = 40, Ogham = 41, Runic = 42, Khmer = 43, Mongolian = 44, Braille = 45, Yi = 46, Limbu = 47, TaiLe = 48, NewTaiLue = 49, SylotiNagri = 50, Kharoshthi = 51, Kayahli = 52, UnicodeSymbol = 53, Emoji = 54, Glagolitic = 55, Lisu = 56, Vai = 57, NKo = 58, Osmanya = 59, PhagsPa = 60, Gothic = 61, Deseret = 62, Tifinagh = 63,
}}
DEFINE_IID!(IID_ITextSelection, 2798872356, 62095, 17162, 178, 207, 195, 67, 103, 30, 192, 233);
RT_INTERFACE!{interface ITextSelection(ITextSelectionVtbl): IInspectable(IInspectableVtbl) [IID_ITextSelection] {
    fn get_Options(&self, out: *mut SelectionOptions) -> HRESULT,
    fn put_Options(&self, value: SelectionOptions) -> HRESULT,
    fn get_Type(&self, out: *mut SelectionType) -> HRESULT,
    fn EndKey(&self, unit: TextRangeUnit, extend: bool, out: *mut i32) -> HRESULT,
    fn HomeKey(&self, unit: TextRangeUnit, extend: bool, out: *mut i32) -> HRESULT,
    fn MoveDown(&self, unit: TextRangeUnit, count: i32, extend: bool, out: *mut i32) -> HRESULT,
    fn MoveLeft(&self, unit: TextRangeUnit, count: i32, extend: bool, out: *mut i32) -> HRESULT,
    fn MoveRight(&self, unit: TextRangeUnit, count: i32, extend: bool, out: *mut i32) -> HRESULT,
    fn MoveUp(&self, unit: TextRangeUnit, count: i32, extend: bool, out: *mut i32) -> HRESULT,
    fn TypeText(&self, value: HSTRING) -> HRESULT
}}
impl ITextSelection {
    #[inline] pub fn get_options(&self) -> Result<SelectionOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Options)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_options(&self, value: SelectionOptions) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Options)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<SelectionType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn end_key(&self, unit: TextRangeUnit, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).EndKey)(self as *const _ as *mut _, unit, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn home_key(&self, unit: TextRangeUnit, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HomeKey)(self as *const _ as *mut _, unit, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_down(&self, unit: TextRangeUnit, count: i32, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveDown)(self as *const _ as *mut _, unit, count, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_left(&self, unit: TextRangeUnit, count: i32, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveLeft)(self as *const _ as *mut _, unit, count, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_right(&self, unit: TextRangeUnit, count: i32, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveRight)(self as *const _ as *mut _, unit, count, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn move_up(&self, unit: TextRangeUnit, count: i32, extend: bool) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).MoveUp)(self as *const _ as *mut _, unit, count, extend, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn type_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).TypeText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum TextSetOptions: u32 {
    None = 0, UnicodeBidi = 1, Unlink = 8, Unhide = 16, CheckTextLimit = 32, FormatRtf = 8192, ApplyRtfDocumentDefaults = 16384,
}}
RT_ENUM! { enum UnderlineType: i32 {
    Undefined = 0, None = 1, Single = 2, Words = 3, Double = 4, Dotted = 5, Dash = 6, DashDot = 7, DashDotDot = 8, Wave = 9, Thick = 10, Thin = 11, DoubleWave = 12, HeavyWave = 13, LongDash = 14, ThickDash = 15, ThickDashDot = 16, ThickDashDotDot = 17, ThickDotted = 18, ThickLongDash = 19,
}}
RT_ENUM! { enum VerticalCharacterAlignment: i32 {
    Top = 0, Baseline = 1, Bottom = 2,
}}
pub mod core { // Windows.UI.Text.Core
use crate::prelude::*;
DEFINE_IID!(IID_ICoreTextCompositionCompletedEventArgs, 523561910, 47007, 16673, 165, 231, 253, 169, 184, 97, 110, 48);
RT_INTERFACE!{interface ICoreTextCompositionCompletedEventArgs(ICoreTextCompositionCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextCompositionCompletedEventArgs] {
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn get_CompositionSegments(&self, out: *mut *mut foundation::collections::IVectorView<CoreTextCompositionSegment>) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextCompositionCompletedEventArgs {
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_composition_segments(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<CoreTextCompositionSegment>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompositionSegments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextCompositionCompletedEventArgs: ICoreTextCompositionCompletedEventArgs}
DEFINE_IID!(IID_ICoreTextCompositionSegment, 2003594201, 20141, 19879, 143, 71, 58, 136, 181, 35, 204, 52);
RT_INTERFACE!{interface ICoreTextCompositionSegment(ICoreTextCompositionSegmentVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextCompositionSegment] {
    fn get_PreconversionString(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Range(&self, out: *mut CoreTextRange) -> HRESULT
}}
impl ICoreTextCompositionSegment {
    #[inline] pub fn get_preconversion_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PreconversionString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_range(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Range)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextCompositionSegment: ICoreTextCompositionSegment}
DEFINE_IID!(IID_ICoreTextCompositionStartedEventArgs, 661329577, 25831, 19120, 188, 75, 160, 45, 115, 131, 91, 251);
RT_INTERFACE!{interface ICoreTextCompositionStartedEventArgs(ICoreTextCompositionStartedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextCompositionStartedEventArgs] {
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextCompositionStartedEventArgs {
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextCompositionStartedEventArgs: ICoreTextCompositionStartedEventArgs}
DEFINE_IID!(IID_ICoreTextEditContext, 3211135151, 16449, 18371, 178, 99, 169, 24, 235, 94, 174, 242);
RT_INTERFACE!{interface ICoreTextEditContext(ICoreTextEditContextVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextEditContext] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_InputScope(&self, out: *mut CoreTextInputScope) -> HRESULT,
    fn put_InputScope(&self, value: CoreTextInputScope) -> HRESULT,
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn put_IsReadOnly(&self, value: bool) -> HRESULT,
    fn get_InputPaneDisplayPolicy(&self, out: *mut CoreTextInputPaneDisplayPolicy) -> HRESULT,
    fn put_InputPaneDisplayPolicy(&self, value: CoreTextInputPaneDisplayPolicy) -> HRESULT,
    fn add_TextRequested(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextTextRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SelectionRequested(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextSelectionRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_LayoutRequested(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextLayoutRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LayoutRequested(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TextUpdating(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextTextUpdatingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextUpdating(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SelectionUpdating(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextSelectionUpdatingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SelectionUpdating(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_FormatUpdating(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextFormatUpdatingEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FormatUpdating(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CompositionStarted(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextCompositionStartedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CompositionStarted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CompositionCompleted(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, CoreTextCompositionCompletedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CompositionCompleted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_FocusRemoved(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FocusRemoved(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn NotifyFocusEnter(&self) -> HRESULT,
    fn NotifyFocusLeave(&self) -> HRESULT,
    fn NotifyTextChanged(&self, modifiedRange: CoreTextRange, newLength: i32, newSelection: CoreTextRange) -> HRESULT,
    fn NotifySelectionChanged(&self, selection: CoreTextRange) -> HRESULT,
    fn NotifyLayoutChanged(&self) -> HRESULT
}}
impl ICoreTextEditContext {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_input_scope(&self) -> Result<CoreTextInputScope> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_input_scope(&self, value: CoreTextInputScope) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InputScope)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_read_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReadOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_read_only(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsReadOnly)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_input_pane_display_policy(&self) -> Result<CoreTextInputPaneDisplayPolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InputPaneDisplayPolicy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_input_pane_display_policy(&self, value: CoreTextInputPaneDisplayPolicy) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InputPaneDisplayPolicy)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_text_requested(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextTextRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_text_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_TextRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_selection_requested(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextSelectionRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_selection_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SelectionRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_layout_requested(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextLayoutRequestedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LayoutRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_layout_requested(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_LayoutRequested)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_text_updating(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextTextUpdatingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextUpdating)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_text_updating(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_TextUpdating)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_selection_updating(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextSelectionUpdatingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SelectionUpdating)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_selection_updating(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_SelectionUpdating)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_format_updating(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextFormatUpdatingEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FormatUpdating)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_format_updating(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_FormatUpdating)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_composition_started(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextCompositionStartedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CompositionStarted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_composition_started(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CompositionStarted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_composition_completed(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, CoreTextCompositionCompletedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CompositionCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_composition_completed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_CompositionCompleted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_focus_removed(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_FocusRemoved)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_focus_removed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_FocusRemoved)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_focus_enter(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).NotifyFocusEnter)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_focus_leave(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).NotifyFocusLeave)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_text_changed(&self, modifiedRange: CoreTextRange, newLength: i32, newSelection: CoreTextRange) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).NotifyTextChanged)(self as *const _ as *mut _, modifiedRange, newLength, newSelection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_selection_changed(&self, selection: CoreTextRange) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).NotifySelectionChanged)(self as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn notify_layout_changed(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).NotifyLayoutChanged)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextEditContext: ICoreTextEditContext}
DEFINE_IID!(IID_ICoreTextEditContext2, 2978381243, 2107, 18913, 178, 129, 43, 53, 214, 43, 244, 102);
RT_INTERFACE!{interface ICoreTextEditContext2(ICoreTextEditContext2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextEditContext2] {
    fn add_NotifyFocusLeaveCompleted(&self, handler: *mut foundation::TypedEventHandler<CoreTextEditContext, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NotifyFocusLeaveCompleted(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreTextEditContext2 {
    #[inline] pub fn add_notify_focus_leave_completed(&self, handler: &foundation::TypedEventHandler<CoreTextEditContext, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NotifyFocusLeaveCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_notify_focus_leave_completed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NotifyFocusLeaveCompleted)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreTextFormatUpdatingEventArgs, 1930476851, 46248, 17329, 179, 123, 7, 36, 212, 172, 167, 171);
RT_INTERFACE!{interface ICoreTextFormatUpdatingEventArgs(ICoreTextFormatUpdatingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextFormatUpdatingEventArgs] {
    fn get_Range(&self, out: *mut CoreTextRange) -> HRESULT,
    fn get_TextColor(&self, out: *mut *mut foundation::IReference<super::super::viewmanagement::UIElementType>) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut *mut foundation::IReference<super::super::viewmanagement::UIElementType>) -> HRESULT,
    fn get_UnderlineColor(&self, out: *mut *mut foundation::IReference<super::super::viewmanagement::UIElementType>) -> HRESULT,
    fn get_UnderlineType(&self, out: *mut *mut foundation::IReference<super::UnderlineType>) -> HRESULT,
    fn get_Reason(&self, out: *mut CoreTextFormatUpdatingReason) -> HRESULT,
    fn get_Result(&self, out: *mut CoreTextFormatUpdatingResult) -> HRESULT,
    fn put_Result(&self, value: CoreTextFormatUpdatingResult) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextFormatUpdatingEventArgs {
    #[inline] pub fn get_range(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Range)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::super::viewmanagement::UIElementType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::super::viewmanagement::UIElementType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_underline_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::super::viewmanagement::UIElementType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnderlineColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_underline_type(&self) -> Result<Option<ComPtr<foundation::IReference<super::UnderlineType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnderlineType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_reason(&self) -> Result<CoreTextFormatUpdatingReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_result(&self) -> Result<CoreTextFormatUpdatingResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Result)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_result(&self, value: CoreTextFormatUpdatingResult) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Result)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextFormatUpdatingEventArgs: ICoreTextFormatUpdatingEventArgs}
RT_ENUM! { enum CoreTextFormatUpdatingReason: i32 {
    None = 0, CompositionUnconverted = 1, CompositionConverted = 2, CompositionTargetUnconverted = 3, CompositionTargetConverted = 4,
}}
RT_ENUM! { enum CoreTextFormatUpdatingResult: i32 {
    Succeeded = 0, Failed = 1,
}}
RT_ENUM! { enum CoreTextInputPaneDisplayPolicy: i32 {
    Automatic = 0, Manual = 1,
}}
RT_ENUM! { enum CoreTextInputScope: i32 {
    Default = 0, Url = 1, FilePath = 2, FileName = 3, EmailUserName = 4, EmailAddress = 5, UserName = 6, PersonalFullName = 7, PersonalNamePrefix = 8, PersonalGivenName = 9, PersonalMiddleName = 10, PersonalSurname = 11, PersonalNameSuffix = 12, Address = 13, AddressPostalCode = 14, AddressStreet = 15, AddressStateOrProvince = 16, AddressCity = 17, AddressCountryName = 18, AddressCountryShortName = 19, CurrencyAmountAndSymbol = 20, CurrencyAmount = 21, Date = 22, DateMonth = 23, DateDay = 24, DateYear = 25, DateMonthName = 26, DateDayName = 27, Number = 29, SingleCharacter = 30, Password = 31, TelephoneNumber = 32, TelephoneCountryCode = 33, TelephoneAreaCode = 34, TelephoneLocalNumber = 35, Time = 36, TimeHour = 37, TimeMinuteOrSecond = 38, NumberFullWidth = 39, AlphanumericHalfWidth = 40, AlphanumericFullWidth = 41, CurrencyChinese = 42, Bopomofo = 43, Hiragana = 44, KatakanaHalfWidth = 45, KatakanaFullWidth = 46, Hanja = 47, HangulHalfWidth = 48, HangulFullWidth = 49, Search = 50, Formula = 51, SearchIncremental = 52, ChineseHalfWidth = 53, ChineseFullWidth = 54, NativeScript = 55, Text = 57, Chat = 58, NameOrPhoneNumber = 59, EmailUserNameOrAddress = 60, Private = 61, Maps = 62, PasswordNumeric = 63, FormulaNumber = 67, ChatWithoutEmoji = 68, Digits = 28, PinNumeric = 64, PinAlphanumeric = 65,
}}
DEFINE_IID!(IID_ICoreTextLayoutBounds, 3916614004, 17462, 18711, 128, 208, 165, 37, 228, 202, 103, 128);
RT_INTERFACE!{interface ICoreTextLayoutBounds(ICoreTextLayoutBoundsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextLayoutBounds] {
    fn get_TextBounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_TextBounds(&self, value: foundation::Rect) -> HRESULT,
    fn get_ControlBounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_ControlBounds(&self, value: foundation::Rect) -> HRESULT
}}
impl ICoreTextLayoutBounds {
    #[inline] pub fn get_text_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_text_bounds(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TextBounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ControlBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_control_bounds(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ControlBounds)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextLayoutBounds: ICoreTextLayoutBounds}
DEFINE_IID!(IID_ICoreTextLayoutRequest, 626370764, 20989, 20227, 152, 191, 172, 120, 23, 77, 104, 224);
RT_INTERFACE!{interface ICoreTextLayoutRequest(ICoreTextLayoutRequestVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextLayoutRequest] {
    fn get_Range(&self, out: *mut CoreTextRange) -> HRESULT,
    fn get_LayoutBounds(&self, out: *mut *mut CoreTextLayoutBounds) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextLayoutRequest {
    #[inline] pub fn get_range(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Range)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_layout_bounds(&self) -> Result<Option<ComPtr<CoreTextLayoutBounds>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LayoutBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextLayoutRequest: ICoreTextLayoutRequest}
DEFINE_IID!(IID_ICoreTextLayoutRequest2, 1735255588, 52541, 19405, 191, 1, 127, 113, 16, 149, 69, 17);
RT_INTERFACE!{interface ICoreTextLayoutRequest2(ICoreTextLayoutRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextLayoutRequest2] {
    fn get_LayoutBoundsVisualPixels(&self, out: *mut *mut CoreTextLayoutBounds) -> HRESULT
}}
impl ICoreTextLayoutRequest2 {
    #[inline] pub fn get_layout_bounds_visual_pixels(&self) -> Result<Option<ComPtr<CoreTextLayoutBounds>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LayoutBoundsVisualPixels)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreTextLayoutRequestedEventArgs, 2984012512, 39547, 20126, 165, 102, 74, 107, 95, 138, 214, 118);
RT_INTERFACE!{interface ICoreTextLayoutRequestedEventArgs(ICoreTextLayoutRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextLayoutRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut CoreTextLayoutRequest) -> HRESULT
}}
impl ICoreTextLayoutRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<CoreTextLayoutRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextLayoutRequestedEventArgs: ICoreTextLayoutRequestedEventArgs}
RT_STRUCT! { struct CoreTextRange {
    StartCaretPosition: i32, EndCaretPosition: i32,
}}
DEFINE_IID!(IID_ICoreTextSelectionRequest, 4037477379, 8331, 17153, 136, 60, 116, 202, 116, 133, 253, 141);
RT_INTERFACE!{interface ICoreTextSelectionRequest(ICoreTextSelectionRequestVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextSelectionRequest] {
    fn get_Selection(&self, out: *mut CoreTextRange) -> HRESULT,
    fn put_Selection(&self, value: CoreTextRange) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextSelectionRequest {
    #[inline] pub fn get_selection(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Selection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selection(&self, value: CoreTextRange) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Selection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextSelectionRequest: ICoreTextSelectionRequest}
DEFINE_IID!(IID_ICoreTextSelectionRequestedEventArgs, 331769899, 62996, 16922, 143, 75, 158, 200, 165, 163, 127, 205);
RT_INTERFACE!{interface ICoreTextSelectionRequestedEventArgs(ICoreTextSelectionRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextSelectionRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut CoreTextSelectionRequest) -> HRESULT
}}
impl ICoreTextSelectionRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<CoreTextSelectionRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextSelectionRequestedEventArgs: ICoreTextSelectionRequestedEventArgs}
DEFINE_IID!(IID_ICoreTextSelectionUpdatingEventArgs, 3561325471, 65151, 19413, 138, 38, 9, 34, 193, 179, 230, 57);
RT_INTERFACE!{interface ICoreTextSelectionUpdatingEventArgs(ICoreTextSelectionUpdatingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextSelectionUpdatingEventArgs] {
    fn get_Selection(&self, out: *mut CoreTextRange) -> HRESULT,
    fn get_Result(&self, out: *mut CoreTextSelectionUpdatingResult) -> HRESULT,
    fn put_Result(&self, value: CoreTextSelectionUpdatingResult) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextSelectionUpdatingEventArgs {
    #[inline] pub fn get_selection(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Selection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_result(&self) -> Result<CoreTextSelectionUpdatingResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Result)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_result(&self, value: CoreTextSelectionUpdatingResult) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Result)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextSelectionUpdatingEventArgs: ICoreTextSelectionUpdatingEventArgs}
RT_ENUM! { enum CoreTextSelectionUpdatingResult: i32 {
    Succeeded = 0, Failed = 1,
}}
RT_CLASS!{static class CoreTextServicesConstants}
impl RtActivatable<ICoreTextServicesStatics> for CoreTextServicesConstants {}
impl CoreTextServicesConstants {
    #[inline] pub fn get_hidden_character() -> Result<Char> {
        <Self as RtActivatable<ICoreTextServicesStatics>>::get_activation_factory().get_hidden_character()
    }
}
DEFINE_CLSID!(CoreTextServicesConstants(&[87,105,110,100,111,119,115,46,85,73,46,84,101,120,116,46,67,111,114,101,46,67,111,114,101,84,101,120,116,83,101,114,118,105,99,101,115,67,111,110,115,116,97,110,116,115,0]) [CLSID_CoreTextServicesConstants]);
DEFINE_IID!(IID_ICoreTextServicesManager, 3260054915, 28170, 19082, 189, 248, 25, 72, 135, 72, 84, 186);
RT_INTERFACE!{interface ICoreTextServicesManager(ICoreTextServicesManagerVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextServicesManager] {
    #[cfg(not(feature="windows-globalization"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_InputLanguage(&self, out: *mut *mut crate::windows::globalization::Language) -> HRESULT,
    fn add_InputLanguageChanged(&self, handler: *mut foundation::TypedEventHandler<CoreTextServicesManager, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InputLanguageChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn CreateEditContext(&self, out: *mut *mut CoreTextEditContext) -> HRESULT
}}
impl ICoreTextServicesManager {
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_input_language(&self) -> Result<Option<ComPtr<crate::windows::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputLanguage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_input_language_changed(&self, handler: &foundation::TypedEventHandler<CoreTextServicesManager, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_InputLanguageChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_input_language_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_InputLanguageChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_edit_context(&self) -> Result<Option<ComPtr<CoreTextEditContext>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateEditContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextServicesManager: ICoreTextServicesManager}
impl RtActivatable<ICoreTextServicesManagerStatics> for CoreTextServicesManager {}
impl CoreTextServicesManager {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<CoreTextServicesManager>>> {
        <Self as RtActivatable<ICoreTextServicesManagerStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(CoreTextServicesManager(&[87,105,110,100,111,119,115,46,85,73,46,84,101,120,116,46,67,111,114,101,46,67,111,114,101,84,101,120,116,83,101,114,118,105,99,101,115,77,97,110,97,103,101,114,0]) [CLSID_CoreTextServicesManager]);
DEFINE_IID!(IID_ICoreTextServicesManagerStatics, 354460552, 58063, 19813, 174, 185, 179, 45, 134, 254, 57, 185);
RT_INTERFACE!{static interface ICoreTextServicesManagerStatics(ICoreTextServicesManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextServicesManagerStatics] {
    fn GetForCurrentView(&self, out: *mut *mut CoreTextServicesManager) -> HRESULT
}}
impl ICoreTextServicesManagerStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<CoreTextServicesManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreTextServicesStatics, 2441452102, 60623, 18340, 138, 231, 9, 138, 156, 111, 187, 21);
RT_INTERFACE!{static interface ICoreTextServicesStatics(ICoreTextServicesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextServicesStatics] {
    fn get_HiddenCharacter(&self, out: *mut Char) -> HRESULT
}}
impl ICoreTextServicesStatics {
    #[inline] pub fn get_hidden_character(&self) -> Result<Char> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HiddenCharacter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreTextTextRequest, 1356419241, 62750, 19649, 140, 161, 230, 52, 109, 26, 97, 190);
RT_INTERFACE!{interface ICoreTextTextRequest(ICoreTextTextRequestVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextTextRequest] {
    fn get_Range(&self, out: *mut CoreTextRange) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextTextRequest {
    #[inline] pub fn get_range(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Range)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_text(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextTextRequest: ICoreTextTextRequest}
DEFINE_IID!(IID_ICoreTextTextRequestedEventArgs, 4036403920, 16838, 19458, 139, 26, 217, 83, 176, 12, 171, 179);
RT_INTERFACE!{interface ICoreTextTextRequestedEventArgs(ICoreTextTextRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextTextRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut CoreTextTextRequest) -> HRESULT
}}
impl ICoreTextTextRequestedEventArgs {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<CoreTextTextRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextTextRequestedEventArgs: ICoreTextTextRequestedEventArgs}
DEFINE_IID!(IID_ICoreTextTextUpdatingEventArgs, 4003959181, 52267, 20227, 143, 246, 2, 253, 33, 125, 180, 80);
RT_INTERFACE!{interface ICoreTextTextUpdatingEventArgs(ICoreTextTextUpdatingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreTextTextUpdatingEventArgs] {
    fn get_Range(&self, out: *mut CoreTextRange) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewSelection(&self, out: *mut CoreTextRange) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_InputLanguage(&self, out: *mut *mut crate::windows::globalization::Language) -> HRESULT,
    fn get_Result(&self, out: *mut CoreTextTextUpdatingResult) -> HRESULT,
    fn put_Result(&self, value: CoreTextTextUpdatingResult) -> HRESULT,
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ICoreTextTextUpdatingEventArgs {
    #[inline] pub fn get_range(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Range)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_new_selection(&self) -> Result<CoreTextRange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewSelection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_input_language(&self) -> Result<Option<ComPtr<crate::windows::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InputLanguage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_result(&self) -> Result<CoreTextTextUpdatingResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Result)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_result(&self, value: CoreTextTextUpdatingResult) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Result)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_canceled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreTextTextUpdatingEventArgs: ICoreTextTextUpdatingEventArgs}
RT_ENUM! { enum CoreTextTextUpdatingResult: i32 {
    Succeeded = 0, Failed = 1,
}}
} // Windows.UI.Text.Core
} // Windows.UI.Text
pub mod viewmanagement { // Windows.UI.ViewManagement
use crate::prelude::*;
DEFINE_IID!(IID_IAccessibilitySettings, 4262363463, 50368, 17762, 185, 98, 19, 39, 181, 42, 213, 185);
RT_INTERFACE!{interface IAccessibilitySettings(IAccessibilitySettingsVtbl): IInspectable(IInspectableVtbl) [IID_IAccessibilitySettings] {
    fn get_HighContrast(&self, out: *mut bool) -> HRESULT,
    fn get_HighContrastScheme(&self, out: *mut HSTRING) -> HRESULT,
    fn add_HighContrastChanged(&self, handler: *mut foundation::TypedEventHandler<AccessibilitySettings, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HighContrastChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IAccessibilitySettings {
    #[inline] pub fn get_high_contrast(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HighContrast)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_high_contrast_scheme(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HighContrastScheme)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_high_contrast_changed(&self, handler: &foundation::TypedEventHandler<AccessibilitySettings, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HighContrastChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_high_contrast_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_HighContrastChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AccessibilitySettings: IAccessibilitySettings}
impl RtActivatable<IActivationFactory> for AccessibilitySettings {}
DEFINE_CLSID!(AccessibilitySettings(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,65,99,99,101,115,115,105,98,105,108,105,116,121,83,101,116,116,105,110,103,115,0]) [CLSID_AccessibilitySettings]);
DEFINE_IID!(IID_IActivationViewSwitcher, 3701939126, 29520, 18731, 170, 199, 200, 161, 61, 114, 36, 173);
RT_INTERFACE!{interface IActivationViewSwitcher(IActivationViewSwitcherVtbl): IInspectable(IInspectableVtbl) [IID_IActivationViewSwitcher] {
    fn ShowAsStandaloneAsync(&self, viewId: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ShowAsStandaloneWithSizePreferenceAsync(&self, viewId: i32, sizePreference: ViewSizePreference, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn IsViewPresentedOnActivationVirtualDesktop(&self, viewId: i32, out: *mut bool) -> HRESULT
}}
impl IActivationViewSwitcher {
    #[inline] pub fn show_as_standalone_async(&self, viewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsStandaloneAsync)(self as *const _ as *mut _, viewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn show_as_standalone_with_size_preference_async(&self, viewId: i32, sizePreference: ViewSizePreference) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsStandaloneWithSizePreferenceAsync)(self as *const _ as *mut _, viewId, sizePreference, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_view_presented_on_activation_virtual_desktop(&self, viewId: i32) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsViewPresentedOnActivationVirtualDesktop)(self as *const _ as *mut _, viewId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivationViewSwitcher: IActivationViewSwitcher}
DEFINE_IID!(IID_IApplicationView, 3525498137, 17249, 17694, 150, 196, 96, 244, 249, 116, 45, 176);
RT_INTERFACE!{interface IApplicationView(IApplicationViewVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationView] {
    fn get_Orientation(&self, out: *mut ApplicationViewOrientation) -> HRESULT,
    fn get_AdjacentToLeftDisplayEdge(&self, out: *mut bool) -> HRESULT,
    fn get_AdjacentToRightDisplayEdge(&self, out: *mut bool) -> HRESULT,
    fn get_IsFullScreen(&self, out: *mut bool) -> HRESULT,
    fn get_IsOnLockScreen(&self, out: *mut bool) -> HRESULT,
    fn get_IsScreenCaptureEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsScreenCaptureEnabled(&self, value: bool) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut i32) -> HRESULT,
    fn add_Consolidated(&self, handler: *mut foundation::TypedEventHandler<ApplicationView, ApplicationViewConsolidatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Consolidated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IApplicationView {
    #[inline] pub fn get_orientation(&self) -> Result<ApplicationViewOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Orientation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_adjacent_to_left_display_edge(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AdjacentToLeftDisplayEdge)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_adjacent_to_right_display_edge(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AdjacentToRightDisplayEdge)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_full_screen(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullScreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_on_lock_screen(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOnLockScreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_screen_capture_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsScreenCaptureEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_screen_capture_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IsScreenCaptureEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_consolidated(&self, handler: &foundation::TypedEventHandler<ApplicationView, ApplicationViewConsolidatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Consolidated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_consolidated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Consolidated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ApplicationView: IApplicationView}
impl RtActivatable<IApplicationViewFullscreenStatics> for ApplicationView {}
impl RtActivatable<IApplicationViewInteropStatics> for ApplicationView {}
impl RtActivatable<IApplicationViewStatics> for ApplicationView {}
impl RtActivatable<IApplicationViewStatics2> for ApplicationView {}
impl RtActivatable<IApplicationViewStatics3> for ApplicationView {}
impl ApplicationView {
    #[inline] pub fn try_unsnap_to_fullscreen() -> Result<bool> {
        <Self as RtActivatable<IApplicationViewFullscreenStatics>>::get_activation_factory().try_unsnap_to_fullscreen()
    }
    #[inline] pub fn get_application_view_id_for_window(window: &super::core::ICoreWindow) -> Result<i32> {
        <Self as RtActivatable<IApplicationViewInteropStatics>>::get_activation_factory().get_application_view_id_for_window(window)
    }
    #[inline] pub fn get_value() -> Result<ApplicationViewState> {
        <Self as RtActivatable<IApplicationViewStatics>>::get_activation_factory().get_value()
    }
    #[inline] pub fn try_unsnap() -> Result<bool> {
        <Self as RtActivatable<IApplicationViewStatics>>::get_activation_factory().try_unsnap()
    }
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<ApplicationView>>> {
        <Self as RtActivatable<IApplicationViewStatics2>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn get_terminate_app_on_final_view_close() -> Result<bool> {
        <Self as RtActivatable<IApplicationViewStatics2>>::get_activation_factory().get_terminate_app_on_final_view_close()
    }
    #[inline] pub fn set_terminate_app_on_final_view_close(value: bool) -> Result<()> {
        <Self as RtActivatable<IApplicationViewStatics2>>::get_activation_factory().set_terminate_app_on_final_view_close(value)
    }
    #[inline] pub fn get_preferred_launch_windowing_mode() -> Result<ApplicationViewWindowingMode> {
        <Self as RtActivatable<IApplicationViewStatics3>>::get_activation_factory().get_preferred_launch_windowing_mode()
    }
    #[inline] pub fn set_preferred_launch_windowing_mode(value: ApplicationViewWindowingMode) -> Result<()> {
        <Self as RtActivatable<IApplicationViewStatics3>>::get_activation_factory().set_preferred_launch_windowing_mode(value)
    }
    #[inline] pub fn get_preferred_launch_view_size() -> Result<foundation::Size> {
        <Self as RtActivatable<IApplicationViewStatics3>>::get_activation_factory().get_preferred_launch_view_size()
    }
    #[inline] pub fn set_preferred_launch_view_size(value: foundation::Size) -> Result<()> {
        <Self as RtActivatable<IApplicationViewStatics3>>::get_activation_factory().set_preferred_launch_view_size(value)
    }
}
DEFINE_CLSID!(ApplicationView(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,65,112,112,108,105,99,97,116,105,111,110,86,105,101,119,0]) [CLSID_ApplicationView]);
DEFINE_IID!(IID_IApplicationView2, 3900092822, 42309, 16604, 181, 148, 69, 12, 186, 104, 204, 0);
RT_INTERFACE!{interface IApplicationView2(IApplicationView2Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationView2] {
    fn get_SuppressSystemOverlays(&self, out: *mut bool) -> HRESULT,
    fn put_SuppressSystemOverlays(&self, value: bool) -> HRESULT,
    fn get_VisibleBounds(&self, out: *mut foundation::Rect) -> HRESULT,
    fn add_VisibleBoundsChanged(&self, handler: *mut foundation::TypedEventHandler<ApplicationView, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisibleBoundsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn SetDesiredBoundsMode(&self, boundsMode: ApplicationViewBoundsMode, out: *mut bool) -> HRESULT,
    fn get_DesiredBoundsMode(&self, out: *mut ApplicationViewBoundsMode) -> HRESULT
}}
impl IApplicationView2 {
    #[inline] pub fn get_suppress_system_overlays(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SuppressSystemOverlays)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_suppress_system_overlays(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_SuppressSystemOverlays)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_visible_bounds(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VisibleBounds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_visible_bounds_changed(&self, handler: &foundation::TypedEventHandler<ApplicationView, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VisibleBoundsChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_visible_bounds_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_VisibleBoundsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_bounds_mode(&self, boundsMode: ApplicationViewBoundsMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).SetDesiredBoundsMode)(self as *const _ as *mut _, boundsMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_bounds_mode(&self) -> Result<ApplicationViewBoundsMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredBoundsMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationView3, 2419891429, 31034, 20447, 162, 178, 175, 26, 194, 30, 49, 8);
RT_INTERFACE!{interface IApplicationView3(IApplicationView3Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationView3] {
    fn get_TitleBar(&self, out: *mut *mut ApplicationViewTitleBar) -> HRESULT,
    fn get_FullScreenSystemOverlayMode(&self, out: *mut FullScreenSystemOverlayMode) -> HRESULT,
    fn put_FullScreenSystemOverlayMode(&self, value: FullScreenSystemOverlayMode) -> HRESULT,
    fn get_IsFullScreenMode(&self, out: *mut bool) -> HRESULT,
    fn TryEnterFullScreenMode(&self, out: *mut bool) -> HRESULT,
    fn ExitFullScreenMode(&self) -> HRESULT,
    fn ShowStandardSystemOverlays(&self) -> HRESULT,
    fn TryResizeView(&self, value: foundation::Size, out: *mut bool) -> HRESULT,
    fn SetPreferredMinSize(&self, minSize: foundation::Size) -> HRESULT
}}
impl IApplicationView3 {
    #[inline] pub fn get_title_bar(&self) -> Result<Option<ComPtr<ApplicationViewTitleBar>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleBar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_full_screen_system_overlay_mode(&self) -> Result<FullScreenSystemOverlayMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FullScreenSystemOverlayMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_full_screen_system_overlay_mode(&self, value: FullScreenSystemOverlayMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_FullScreenSystemOverlayMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_full_screen_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFullScreenMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_enter_full_screen_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryEnterFullScreenMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn exit_full_screen_mode(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ExitFullScreenMode)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show_standard_system_overlays(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).ShowStandardSystemOverlays)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_resize_view(&self, value: foundation::Size) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryResizeView)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_min_size(&self, minSize: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).SetPreferredMinSize)(self as *const _ as *mut _, minSize);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationView4, 367381484, 40463, 18101, 188, 63, 155, 246, 83, 231, 75, 94);
RT_INTERFACE!{interface IApplicationView4(IApplicationView4Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationView4] {
    fn get_ViewMode(&self, out: *mut ApplicationViewMode) -> HRESULT,
    fn IsViewModeSupported(&self, viewMode: ApplicationViewMode, out: *mut bool) -> HRESULT,
    fn TryEnterViewModeAsync(&self, viewMode: ApplicationViewMode, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryEnterViewModeWithPreferencesAsync(&self, viewMode: ApplicationViewMode, viewModePreferences: *mut ViewModePreferences, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryConsolidateAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IApplicationView4 {
    #[inline] pub fn get_view_mode(&self) -> Result<ApplicationViewMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_view_mode_supported(&self, viewMode: ApplicationViewMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsViewModeSupported)(self as *const _ as *mut _, viewMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_enter_view_mode_async(&self, viewMode: ApplicationViewMode) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryEnterViewModeAsync)(self as *const _ as *mut _, viewMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_enter_view_mode_with_preferences_async(&self, viewMode: ApplicationViewMode, viewModePreferences: &ViewModePreferences) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryEnterViewModeWithPreferencesAsync)(self as *const _ as *mut _, viewMode, viewModePreferences as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_consolidate_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryConsolidateAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ApplicationViewBoundsMode: i32 {
    UseVisible = 0, UseCoreWindow = 1,
}}
DEFINE_IID!(IID_IApplicationViewConsolidatedEventArgs, 1363429868, 32418, 19943, 166, 166, 125, 251, 170, 235, 182, 251);
RT_INTERFACE!{interface IApplicationViewConsolidatedEventArgs(IApplicationViewConsolidatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewConsolidatedEventArgs] {
    fn get_IsUserInitiated(&self, out: *mut bool) -> HRESULT
}}
impl IApplicationViewConsolidatedEventArgs {
    #[inline] pub fn get_is_user_initiated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsUserInitiated)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ApplicationViewConsolidatedEventArgs: IApplicationViewConsolidatedEventArgs}
DEFINE_IID!(IID_IApplicationViewConsolidatedEventArgs2, 471441100, 28097, 16628, 175, 238, 7, 217, 234, 41, 100, 48);
RT_INTERFACE!{interface IApplicationViewConsolidatedEventArgs2(IApplicationViewConsolidatedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewConsolidatedEventArgs2] {
    fn get_IsAppInitiated(&self, out: *mut bool) -> HRESULT
}}
impl IApplicationViewConsolidatedEventArgs2 {
    #[inline] pub fn get_is_app_initiated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAppInitiated)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationViewFullscreenStatics, 3162058429, 25854, 19301, 160, 192, 144, 28, 226, 182, 134, 54);
RT_INTERFACE!{static interface IApplicationViewFullscreenStatics(IApplicationViewFullscreenStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewFullscreenStatics] {
    fn TryUnsnapToFullscreen(&self, out: *mut bool) -> HRESULT
}}
impl IApplicationViewFullscreenStatics {
    #[inline] pub fn try_unsnap_to_fullscreen(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUnsnapToFullscreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationViewInteropStatics, 3292986205, 18323, 18582, 168, 226, 190, 87, 168, 187, 15, 80);
RT_INTERFACE!{static interface IApplicationViewInteropStatics(IApplicationViewInteropStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewInteropStatics] {
    fn GetApplicationViewIdForWindow(&self, window: *mut super::core::ICoreWindow, out: *mut i32) -> HRESULT
}}
impl IApplicationViewInteropStatics {
    #[inline] pub fn get_application_view_id_for_window(&self, window: &super::core::ICoreWindow) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetApplicationViewIdForWindow)(self as *const _ as *mut _, window as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum ApplicationViewMode: i32 {
    Default = 0, CompactOverlay = 1,
}}
RT_ENUM! { enum ApplicationViewOrientation: i32 {
    Landscape = 0, Portrait = 1,
}}
DEFINE_IID!(IID_IApplicationViewScaling, 487447587, 9203, 19245, 132, 254, 116, 191, 55, 180, 139, 102);
RT_INTERFACE!{interface IApplicationViewScaling(IApplicationViewScalingVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewScaling] {
    
}}
RT_CLASS!{class ApplicationViewScaling: IApplicationViewScaling}
impl RtActivatable<IApplicationViewScalingStatics> for ApplicationViewScaling {}
impl ApplicationViewScaling {
    #[inline] pub fn get_disable_layout_scaling() -> Result<bool> {
        <Self as RtActivatable<IApplicationViewScalingStatics>>::get_activation_factory().get_disable_layout_scaling()
    }
    #[inline] pub fn try_set_disable_layout_scaling(disableLayoutScaling: bool) -> Result<bool> {
        <Self as RtActivatable<IApplicationViewScalingStatics>>::get_activation_factory().try_set_disable_layout_scaling(disableLayoutScaling)
    }
}
DEFINE_CLSID!(ApplicationViewScaling(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,65,112,112,108,105,99,97,116,105,111,110,86,105,101,119,83,99,97,108,105,110,103,0]) [CLSID_ApplicationViewScaling]);
DEFINE_IID!(IID_IApplicationViewScalingStatics, 2962222320, 47430, 17864, 165, 227, 113, 245, 170, 120, 248, 97);
RT_INTERFACE!{static interface IApplicationViewScalingStatics(IApplicationViewScalingStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewScalingStatics] {
    fn get_DisableLayoutScaling(&self, out: *mut bool) -> HRESULT,
    fn TrySetDisableLayoutScaling(&self, disableLayoutScaling: bool, out: *mut bool) -> HRESULT
}}
impl IApplicationViewScalingStatics {
    #[inline] pub fn get_disable_layout_scaling(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisableLayoutScaling)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_set_disable_layout_scaling(&self, disableLayoutScaling: bool) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySetDisableLayoutScaling)(self as *const _ as *mut _, disableLayoutScaling, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum ApplicationViewState: i32 {
    FullScreenLandscape = 0, Filled = 1, Snapped = 2, FullScreenPortrait = 3,
}}
DEFINE_IID!(IID_IApplicationViewStatics, 17457926, 50227, 17637, 169, 242, 189, 132, 212, 3, 10, 149);
RT_INTERFACE!{static interface IApplicationViewStatics(IApplicationViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewStatics] {
    fn get_Value(&self, out: *mut ApplicationViewState) -> HRESULT,
    fn TryUnsnap(&self, out: *mut bool) -> HRESULT
}}
impl IApplicationViewStatics {
    #[inline] pub fn get_value(&self) -> Result<ApplicationViewState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_unsnap(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryUnsnap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationViewStatics2, 2939390693, 53092, 16956, 133, 229, 243, 231, 36, 72, 251, 35);
RT_INTERFACE!{static interface IApplicationViewStatics2(IApplicationViewStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewStatics2] {
    fn GetForCurrentView(&self, out: *mut *mut ApplicationView) -> HRESULT,
    fn get_TerminateAppOnFinalViewClose(&self, out: *mut bool) -> HRESULT,
    fn put_TerminateAppOnFinalViewClose(&self, value: bool) -> HRESULT
}}
impl IApplicationViewStatics2 {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<ApplicationView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_terminate_app_on_final_view_close(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TerminateAppOnFinalViewClose)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_terminate_app_on_final_view_close(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TerminateAppOnFinalViewClose)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationViewStatics3, 2727179668, 35905, 19987, 151, 25, 81, 100, 121, 111, 228, 199);
RT_INTERFACE!{static interface IApplicationViewStatics3(IApplicationViewStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewStatics3] {
    fn get_PreferredLaunchWindowingMode(&self, out: *mut ApplicationViewWindowingMode) -> HRESULT,
    fn put_PreferredLaunchWindowingMode(&self, value: ApplicationViewWindowingMode) -> HRESULT,
    fn get_PreferredLaunchViewSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_PreferredLaunchViewSize(&self, value: foundation::Size) -> HRESULT
}}
impl IApplicationViewStatics3 {
    #[inline] pub fn get_preferred_launch_windowing_mode(&self) -> Result<ApplicationViewWindowingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreferredLaunchWindowingMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_launch_windowing_mode(&self, value: ApplicationViewWindowingMode) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PreferredLaunchWindowingMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preferred_launch_view_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreferredLaunchViewSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_launch_view_size(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PreferredLaunchViewSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class ApplicationViewSwitcher}
impl RtActivatable<IApplicationViewSwitcherStatics> for ApplicationViewSwitcher {}
impl RtActivatable<IApplicationViewSwitcherStatics2> for ApplicationViewSwitcher {}
impl RtActivatable<IApplicationViewSwitcherStatics3> for ApplicationViewSwitcher {}
impl ApplicationViewSwitcher {
    #[inline] pub fn disable_showing_main_view_on_activation() -> Result<()> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().disable_showing_main_view_on_activation()
    }
    #[inline] pub fn try_show_as_standalone_async(viewId: i32) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().try_show_as_standalone_async(viewId)
    }
    #[inline] pub fn try_show_as_standalone_with_size_preference_async(viewId: i32, sizePreference: ViewSizePreference) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().try_show_as_standalone_with_size_preference_async(viewId, sizePreference)
    }
    #[inline] pub fn try_show_as_standalone_with_anchor_view_and_size_preference_async(viewId: i32, sizePreference: ViewSizePreference, anchorViewId: i32, anchorSizePreference: ViewSizePreference) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().try_show_as_standalone_with_anchor_view_and_size_preference_async(viewId, sizePreference, anchorViewId, anchorSizePreference)
    }
    #[inline] pub fn switch_async(viewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().switch_async(viewId)
    }
    #[inline] pub fn switch_from_view_async(toViewId: i32, fromViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().switch_from_view_async(toViewId, fromViewId)
    }
    #[inline] pub fn switch_from_view_with_options_async(toViewId: i32, fromViewId: i32, options: ApplicationViewSwitchingOptions) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().switch_from_view_with_options_async(toViewId, fromViewId, options)
    }
    #[inline] pub fn prepare_for_custom_animated_switch_async(toViewId: i32, fromViewId: i32, options: ApplicationViewSwitchingOptions) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics>>::get_activation_factory().prepare_for_custom_animated_switch_async(toViewId, fromViewId, options)
    }
    #[inline] pub fn disable_system_view_activation_policy() -> Result<()> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics2>>::get_activation_factory().disable_system_view_activation_policy()
    }
    #[inline] pub fn try_show_as_view_mode_async(viewId: i32, viewMode: ApplicationViewMode) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics3>>::get_activation_factory().try_show_as_view_mode_async(viewId, viewMode)
    }
    #[inline] pub fn try_show_as_view_mode_with_preferences_async(viewId: i32, viewMode: ApplicationViewMode, viewModePreferences: &ViewModePreferences) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IApplicationViewSwitcherStatics3>>::get_activation_factory().try_show_as_view_mode_with_preferences_async(viewId, viewMode, viewModePreferences)
    }
}
DEFINE_CLSID!(ApplicationViewSwitcher(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,65,112,112,108,105,99,97,116,105,111,110,86,105,101,119,83,119,105,116,99,104,101,114,0]) [CLSID_ApplicationViewSwitcher]);
DEFINE_IID!(IID_IApplicationViewSwitcherStatics, 2539597598, 58966, 19550, 160, 161, 113, 124, 111, 250, 125, 100);
RT_INTERFACE!{static interface IApplicationViewSwitcherStatics(IApplicationViewSwitcherStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewSwitcherStatics] {
    fn DisableShowingMainViewOnActivation(&self) -> HRESULT,
    fn TryShowAsStandaloneAsync(&self, viewId: i32, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryShowAsStandaloneWithSizePreferenceAsync(&self, viewId: i32, sizePreference: ViewSizePreference, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryShowAsStandaloneWithAnchorViewAndSizePreferenceAsync(&self, viewId: i32, sizePreference: ViewSizePreference, anchorViewId: i32, anchorSizePreference: ViewSizePreference, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn SwitchAsync(&self, viewId: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn SwitchFromViewAsync(&self, toViewId: i32, fromViewId: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn SwitchFromViewWithOptionsAsync(&self, toViewId: i32, fromViewId: i32, options: ApplicationViewSwitchingOptions, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn PrepareForCustomAnimatedSwitchAsync(&self, toViewId: i32, fromViewId: i32, options: ApplicationViewSwitchingOptions, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IApplicationViewSwitcherStatics {
    #[inline] pub fn disable_showing_main_view_on_activation(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).DisableShowingMainViewOnActivation)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_show_as_standalone_async(&self, viewId: i32) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryShowAsStandaloneAsync)(self as *const _ as *mut _, viewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_show_as_standalone_with_size_preference_async(&self, viewId: i32, sizePreference: ViewSizePreference) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryShowAsStandaloneWithSizePreferenceAsync)(self as *const _ as *mut _, viewId, sizePreference, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_show_as_standalone_with_anchor_view_and_size_preference_async(&self, viewId: i32, sizePreference: ViewSizePreference, anchorViewId: i32, anchorSizePreference: ViewSizePreference) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryShowAsStandaloneWithAnchorViewAndSizePreferenceAsync)(self as *const _ as *mut _, viewId, sizePreference, anchorViewId, anchorSizePreference, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn switch_async(&self, viewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SwitchAsync)(self as *const _ as *mut _, viewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn switch_from_view_async(&self, toViewId: i32, fromViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SwitchFromViewAsync)(self as *const _ as *mut _, toViewId, fromViewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn switch_from_view_with_options_async(&self, toViewId: i32, fromViewId: i32, options: ApplicationViewSwitchingOptions) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SwitchFromViewWithOptionsAsync)(self as *const _ as *mut _, toViewId, fromViewId, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn prepare_for_custom_animated_switch_async(&self, toViewId: i32, fromViewId: i32, options: ApplicationViewSwitchingOptions) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PrepareForCustomAnimatedSwitchAsync)(self as *const _ as *mut _, toViewId, fromViewId, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationViewSwitcherStatics2, 1625920973, 20418, 18628, 184, 227, 57, 95, 43, 159, 15, 193);
RT_INTERFACE!{static interface IApplicationViewSwitcherStatics2(IApplicationViewSwitcherStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewSwitcherStatics2] {
    fn DisableSystemViewActivationPolicy(&self) -> HRESULT
}}
impl IApplicationViewSwitcherStatics2 {
    #[inline] pub fn disable_system_view_activation_policy(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).DisableSystemViewActivationPolicy)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IApplicationViewSwitcherStatics3, 2449839136, 32935, 18541, 178, 31, 199, 164, 162, 66, 163, 131);
RT_INTERFACE!{static interface IApplicationViewSwitcherStatics3(IApplicationViewSwitcherStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewSwitcherStatics3] {
    fn TryShowAsViewModeAsync(&self, viewId: i32, viewMode: ApplicationViewMode, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryShowAsViewModeWithPreferencesAsync(&self, viewId: i32, viewMode: ApplicationViewMode, viewModePreferences: *mut ViewModePreferences, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IApplicationViewSwitcherStatics3 {
    #[inline] pub fn try_show_as_view_mode_async(&self, viewId: i32, viewMode: ApplicationViewMode) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryShowAsViewModeAsync)(self as *const _ as *mut _, viewId, viewMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_show_as_view_mode_with_preferences_async(&self, viewId: i32, viewMode: ApplicationViewMode, viewModePreferences: &ViewModePreferences) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryShowAsViewModeWithPreferencesAsync)(self as *const _ as *mut _, viewId, viewMode, viewModePreferences as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ApplicationViewSwitchingOptions: u32 {
    Default = 0, SkipAnimation = 1, ConsolidateViews = 2,
}}
DEFINE_IID!(IID_IApplicationViewTitleBar, 9587392, 37675, 19051, 156, 75, 220, 56, 200, 36, 120, 206);
RT_INTERFACE!{interface IApplicationViewTitleBar(IApplicationViewTitleBarVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewTitleBar] {
    fn put_ForegroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ForegroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_BackgroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_BackgroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonForegroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonForegroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonBackgroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonBackgroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonHoverForegroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonHoverForegroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonHoverBackgroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonHoverBackgroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonPressedForegroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonPressedForegroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonPressedBackgroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonPressedBackgroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_InactiveForegroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_InactiveForegroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_InactiveBackgroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_InactiveBackgroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonInactiveForegroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonInactiveForegroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT,
    fn put_ButtonInactiveBackgroundColor(&self, value: *mut foundation::IReference<super::Color>) -> HRESULT,
    fn get_ButtonInactiveBackgroundColor(&self, out: *mut *mut foundation::IReference<super::Color>) -> HRESULT
}}
impl IApplicationViewTitleBar {
    #[inline] pub fn set_foreground_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ForegroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_foreground_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_background_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BackgroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_foreground_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonForegroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_foreground_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_background_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonBackgroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_hover_foreground_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonHoverForegroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_hover_foreground_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonHoverForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_hover_background_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonHoverBackgroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_hover_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonHoverBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_pressed_foreground_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonPressedForegroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_pressed_foreground_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonPressedForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_pressed_background_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonPressedBackgroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_pressed_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonPressedBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_inactive_foreground_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InactiveForegroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inactive_foreground_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InactiveForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_inactive_background_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_InactiveBackgroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_inactive_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InactiveBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_inactive_foreground_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonInactiveForegroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_inactive_foreground_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonInactiveForegroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_button_inactive_background_color(&self, value: &foundation::IReference<super::Color>) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ButtonInactiveBackgroundColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_button_inactive_background_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ButtonInactiveBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ApplicationViewTitleBar: IApplicationViewTitleBar}
DEFINE_IID!(IID_IApplicationViewTransferContext, 2239020131, 15383, 16526, 148, 8, 138, 26, 158, 168, 27, 250);
RT_INTERFACE!{interface IApplicationViewTransferContext(IApplicationViewTransferContextVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewTransferContext] {
    fn get_ViewId(&self, out: *mut i32) -> HRESULT,
    fn put_ViewId(&self, value: i32) -> HRESULT
}}
impl IApplicationViewTransferContext {
    #[inline] pub fn get_view_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_view_id(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ViewId)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ApplicationViewTransferContext: IApplicationViewTransferContext}
impl RtActivatable<IApplicationViewTransferContextStatics> for ApplicationViewTransferContext {}
impl RtActivatable<IActivationFactory> for ApplicationViewTransferContext {}
impl ApplicationViewTransferContext {
    #[inline] pub fn get_data_package_format_id() -> Result<HString> {
        <Self as RtActivatable<IApplicationViewTransferContextStatics>>::get_activation_factory().get_data_package_format_id()
    }
}
DEFINE_CLSID!(ApplicationViewTransferContext(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,65,112,112,108,105,99,97,116,105,111,110,86,105,101,119,84,114,97,110,115,102,101,114,67,111,110,116,101,120,116,0]) [CLSID_ApplicationViewTransferContext]);
DEFINE_IID!(IID_IApplicationViewTransferContextStatics, 363371922, 56697, 19211, 188, 71, 213, 241, 149, 241, 70, 97);
RT_INTERFACE!{static interface IApplicationViewTransferContextStatics(IApplicationViewTransferContextStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewTransferContextStatics] {
    fn get_DataPackageFormatId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IApplicationViewTransferContextStatics {
    #[inline] pub fn get_data_package_format_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataPackageFormatId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ApplicationViewWindowingMode: i32 {
    Auto = 0, PreferredLaunchViewSize = 1, FullScreen = 2, CompactOverlay = 3, Maximized = 4,
}}
RT_ENUM! { enum FullScreenSystemOverlayMode: i32 {
    Standard = 0, Minimal = 1,
}}
RT_ENUM! { enum HandPreference: i32 {
    LeftHanded = 0, RightHanded = 1,
}}
DEFINE_IID!(IID_IInputPane, 1678432880, 1779, 19591, 166, 120, 152, 41, 201, 18, 124, 40);
RT_INTERFACE!{interface IInputPane(IInputPaneVtbl): IInspectable(IInspectableVtbl) [IID_IInputPane] {
    fn add_Showing(&self, handler: *mut foundation::TypedEventHandler<InputPane, InputPaneVisibilityEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Showing(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Hiding(&self, handler: *mut foundation::TypedEventHandler<InputPane, InputPaneVisibilityEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Hiding(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_OccludedRect(&self, out: *mut foundation::Rect) -> HRESULT
}}
impl IInputPane {
    #[inline] pub fn add_showing(&self, handler: &foundation::TypedEventHandler<InputPane, InputPaneVisibilityEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Showing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_showing(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Showing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hiding(&self, handler: &foundation::TypedEventHandler<InputPane, InputPaneVisibilityEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Hiding)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hiding(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Hiding)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occluded_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OccludedRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InputPane: IInputPane}
impl RtActivatable<IInputPaneStatics> for InputPane {}
impl InputPane {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<InputPane>>> {
        <Self as RtActivatable<IInputPaneStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(InputPane(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,73,110,112,117,116,80,97,110,101,0]) [CLSID_InputPane]);
DEFINE_IID!(IID_IInputPane2, 2322284326, 28816, 18323, 148, 76, 195, 242, 205, 226, 98, 118);
RT_INTERFACE!{interface IInputPane2(IInputPane2Vtbl): IInspectable(IInspectableVtbl) [IID_IInputPane2] {
    fn TryShow(&self, out: *mut bool) -> HRESULT,
    fn TryHide(&self, out: *mut bool) -> HRESULT
}}
impl IInputPane2 {
    #[inline] pub fn try_show(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryShow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_hide(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryHide)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInputPaneControl, 143372879, 38447, 18589, 170, 110, 198, 190, 26, 10, 110, 82);
RT_INTERFACE!{interface IInputPaneControl(IInputPaneControlVtbl): IInspectable(IInspectableVtbl) [IID_IInputPaneControl] {
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn put_Visible(&self, value: bool) -> HRESULT
}}
impl IInputPaneControl {
    #[inline] pub fn get_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Visible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInputPaneStatics, 2515840826, 61255, 16970, 151, 65, 253, 40, 21, 235, 162, 189);
RT_INTERFACE!{static interface IInputPaneStatics(IInputPaneStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInputPaneStatics] {
    fn GetForCurrentView(&self, out: *mut *mut InputPane) -> HRESULT
}}
impl IInputPaneStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<InputPane>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInputPaneVisibilityEventArgs, 3527663638, 55559, 20428, 187, 141, 247, 123, 170, 80, 40, 241);
RT_INTERFACE!{interface IInputPaneVisibilityEventArgs(IInputPaneVisibilityEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInputPaneVisibilityEventArgs] {
    fn get_OccludedRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_EnsuredFocusedElementInView(&self, value: bool) -> HRESULT,
    fn get_EnsuredFocusedElementInView(&self, out: *mut bool) -> HRESULT
}}
impl IInputPaneVisibilityEventArgs {
    #[inline] pub fn get_occluded_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OccludedRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ensured_focused_element_in_view(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_EnsuredFocusedElementInView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ensured_focused_element_in_view(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnsuredFocusedElementInView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InputPaneVisibilityEventArgs: IInputPaneVisibilityEventArgs}
RT_CLASS!{static class ProjectionManager}
impl RtActivatable<IProjectionManagerStatics> for ProjectionManager {}
impl RtActivatable<IProjectionManagerStatics2> for ProjectionManager {}
impl ProjectionManager {
    #[inline] pub fn start_projecting_async(projectionViewId: i32, anchorViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IProjectionManagerStatics>>::get_activation_factory().start_projecting_async(projectionViewId, anchorViewId)
    }
    #[inline] pub fn swap_displays_for_views_async(projectionViewId: i32, anchorViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IProjectionManagerStatics>>::get_activation_factory().swap_displays_for_views_async(projectionViewId, anchorViewId)
    }
    #[inline] pub fn stop_projecting_async(projectionViewId: i32, anchorViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IProjectionManagerStatics>>::get_activation_factory().stop_projecting_async(projectionViewId, anchorViewId)
    }
    #[inline] pub fn get_projection_display_available() -> Result<bool> {
        <Self as RtActivatable<IProjectionManagerStatics>>::get_activation_factory().get_projection_display_available()
    }
    #[inline] pub fn add_projection_display_available_changed(handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IProjectionManagerStatics>>::get_activation_factory().add_projection_display_available_changed(handler)
    }
    #[inline] pub fn remove_projection_display_available_changed(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IProjectionManagerStatics>>::get_activation_factory().remove_projection_display_available_changed(token)
    }
    #[cfg(feature="windows-devices")] #[inline] pub fn start_projecting_with_device_info_async(projectionViewId: i32, anchorViewId: i32, displayDeviceInfo: &super::super::devices::enumeration::DeviceInformation) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<IProjectionManagerStatics2>>::get_activation_factory().start_projecting_with_device_info_async(projectionViewId, anchorViewId, displayDeviceInfo)
    }
    #[inline] pub fn request_start_projecting_async(projectionViewId: i32, anchorViewId: i32, selection: foundation::Rect) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IProjectionManagerStatics2>>::get_activation_factory().request_start_projecting_async(projectionViewId, anchorViewId, selection)
    }
    #[inline] pub fn request_start_projecting_with_placement_async(projectionViewId: i32, anchorViewId: i32, selection: foundation::Rect, prefferedPlacement: super::popups::Placement) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<IProjectionManagerStatics2>>::get_activation_factory().request_start_projecting_with_placement_async(projectionViewId, anchorViewId, selection, prefferedPlacement)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IProjectionManagerStatics2>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(ProjectionManager(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,80,114,111,106,101,99,116,105,111,110,77,97,110,97,103,101,114,0]) [CLSID_ProjectionManager]);
DEFINE_IID!(IID_IProjectionManagerStatics, 3059716413, 58096, 20477, 186, 149, 52, 36, 22, 71, 228, 92);
RT_INTERFACE!{static interface IProjectionManagerStatics(IProjectionManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IProjectionManagerStatics] {
    fn StartProjectingAsync(&self, projectionViewId: i32, anchorViewId: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn SwapDisplaysForViewsAsync(&self, projectionViewId: i32, anchorViewId: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn StopProjectingAsync(&self, projectionViewId: i32, anchorViewId: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn get_ProjectionDisplayAvailable(&self, out: *mut bool) -> HRESULT,
    fn add_ProjectionDisplayAvailableChanged(&self, handler: *mut foundation::EventHandler<IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProjectionDisplayAvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IProjectionManagerStatics {
    #[inline] pub fn start_projecting_async(&self, projectionViewId: i32, anchorViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartProjectingAsync)(self as *const _ as *mut _, projectionViewId, anchorViewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn swap_displays_for_views_async(&self, projectionViewId: i32, anchorViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SwapDisplaysForViewsAsync)(self as *const _ as *mut _, projectionViewId, anchorViewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_projecting_async(&self, projectionViewId: i32, anchorViewId: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StopProjectingAsync)(self as *const _ as *mut _, projectionViewId, anchorViewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_projection_display_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProjectionDisplayAvailable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_projection_display_available_changed(&self, handler: &foundation::EventHandler<IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ProjectionDisplayAvailableChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_projection_display_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ProjectionDisplayAvailableChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProjectionManagerStatics2, 4080873283, 10057, 19678, 185, 119, 192, 196, 30, 116, 21, 209);
RT_INTERFACE!{static interface IProjectionManagerStatics2(IProjectionManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IProjectionManagerStatics2] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn StartProjectingWithDeviceInfoAsync(&self, projectionViewId: i32, anchorViewId: i32, displayDeviceInfo: *mut super::super::devices::enumeration::DeviceInformation, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn RequestStartProjectingAsync(&self, projectionViewId: i32, anchorViewId: i32, selection: foundation::Rect, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestStartProjectingWithPlacementAsync(&self, projectionViewId: i32, anchorViewId: i32, selection: foundation::Rect, prefferedPlacement: super::popups::Placement, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl IProjectionManagerStatics2 {
    #[cfg(feature="windows-devices")] #[inline] pub fn start_projecting_with_device_info_async(&self, projectionViewId: i32, anchorViewId: i32, displayDeviceInfo: &super::super::devices::enumeration::DeviceInformation) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartProjectingWithDeviceInfoAsync)(self as *const _ as *mut _, projectionViewId, anchorViewId, displayDeviceInfo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_start_projecting_async(&self, projectionViewId: i32, anchorViewId: i32, selection: foundation::Rect) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStartProjectingAsync)(self as *const _ as *mut _, projectionViewId, anchorViewId, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_start_projecting_with_placement_async(&self, projectionViewId: i32, anchorViewId: i32, selection: foundation::Rect, prefferedPlacement: super::popups::Placement) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStartProjectingWithPlacementAsync)(self as *const _ as *mut _, projectionViewId, anchorViewId, selection, prefferedPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeviceSelector)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UIColorType: i32 {
    Background = 0, Foreground = 1, AccentDark3 = 2, AccentDark2 = 3, AccentDark1 = 4, Accent = 5, AccentLight1 = 6, AccentLight2 = 7, AccentLight3 = 8, Complement = 9,
}}
RT_ENUM! { enum UIElementType: i32 {
    ActiveCaption = 0, Background = 1, ButtonFace = 2, ButtonText = 3, CaptionText = 4, GrayText = 5, Highlight = 6, HighlightText = 7, Hotlight = 8, InactiveCaption = 9, InactiveCaptionText = 10, Window = 11, WindowText = 12, AccentColor = 1000, TextHigh = 1001, TextMedium = 1002, TextLow = 1003, TextContrastWithHigh = 1004, NonTextHigh = 1005, NonTextMediumHigh = 1006, NonTextMedium = 1007, NonTextMediumLow = 1008, NonTextLow = 1009, PageBackground = 1010, PopupBackground = 1011, OverlayOutsidePopup = 1012,
}}
DEFINE_IID!(IID_IUISettings, 2234914304, 7267, 17959, 188, 177, 58, 137, 224, 188, 156, 85);
RT_INTERFACE!{interface IUISettings(IUISettingsVtbl): IInspectable(IInspectableVtbl) [IID_IUISettings] {
    fn get_HandPreference(&self, out: *mut HandPreference) -> HRESULT,
    fn get_CursorSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_ScrollBarSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_ScrollBarArrowSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_ScrollBarThumbBoxSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_MessageDuration(&self, out: *mut u32) -> HRESULT,
    fn get_AnimationsEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_CaretBrowsingEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_CaretBlinkRate(&self, out: *mut u32) -> HRESULT,
    fn get_CaretWidth(&self, out: *mut u32) -> HRESULT,
    fn get_DoubleClickTime(&self, out: *mut u32) -> HRESULT,
    fn get_MouseHoverTime(&self, out: *mut u32) -> HRESULT,
    fn UIElementColor(&self, desiredElement: UIElementType, out: *mut super::Color) -> HRESULT
}}
impl IUISettings {
    #[inline] pub fn get_hand_preference(&self) -> Result<HandPreference> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HandPreference)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cursor_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CursorSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scroll_bar_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollBarSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scroll_bar_arrow_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollBarArrowSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scroll_bar_thumb_box_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ScrollBarThumbBoxSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_duration(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MessageDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_animations_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AnimationsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_caret_browsing_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CaretBrowsingEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_caret_blink_rate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CaretBlinkRate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_caret_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CaretWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_double_click_time(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DoubleClickTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mouse_hover_time(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MouseHoverTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn uielement_color(&self, desiredElement: UIElementType) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).UIElementColor)(self as *const _ as *mut _, desiredElement, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UISettings: IUISettings}
impl RtActivatable<IActivationFactory> for UISettings {}
DEFINE_CLSID!(UISettings(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,85,73,83,101,116,116,105,110,103,115,0]) [CLSID_UISettings]);
DEFINE_IID!(IID_IUISettings2, 3134727169, 10017, 17657, 187, 145, 43, 178, 40, 190, 68, 47);
RT_INTERFACE!{interface IUISettings2(IUISettings2Vtbl): IInspectable(IInspectableVtbl) [IID_IUISettings2] {
    fn get_TextScaleFactor(&self, out: *mut f64) -> HRESULT,
    fn add_TextScaleFactorChanged(&self, handler: *mut foundation::TypedEventHandler<UISettings, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TextScaleFactorChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUISettings2 {
    #[inline] pub fn get_text_scale_factor(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TextScaleFactor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_text_scale_factor_changed(&self, handler: &foundation::TypedEventHandler<UISettings, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TextScaleFactorChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_text_scale_factor_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_TextScaleFactorChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUISettings3, 50469860, 21076, 18305, 129, 148, 81, 104, 247, 208, 109, 123);
RT_INTERFACE!{interface IUISettings3(IUISettings3Vtbl): IInspectable(IInspectableVtbl) [IID_IUISettings3] {
    fn GetColorValue(&self, desiredColor: UIColorType, out: *mut super::Color) -> HRESULT,
    fn add_ColorValuesChanged(&self, handler: *mut foundation::TypedEventHandler<UISettings, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ColorValuesChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUISettings3 {
    #[inline] pub fn get_color_value(&self, desiredColor: UIColorType) -> Result<super::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetColorValue)(self as *const _ as *mut _, desiredColor, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_color_values_changed(&self, handler: &foundation::TypedEventHandler<UISettings, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ColorValuesChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_color_values_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_ColorValuesChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUISettings4, 1387999234, 37275, 19819, 155, 120, 141, 214, 111, 244, 185, 59);
RT_INTERFACE!{interface IUISettings4(IUISettings4Vtbl): IInspectable(IInspectableVtbl) [IID_IUISettings4] {
    fn get_AdvancedEffectsEnabled(&self, out: *mut bool) -> HRESULT,
    fn add_AdvancedEffectsEnabledChanged(&self, handler: *mut foundation::TypedEventHandler<UISettings, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AdvancedEffectsEnabledChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl IUISettings4 {
    #[inline] pub fn get_advanced_effects_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AdvancedEffectsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_advanced_effects_enabled_changed(&self, handler: &foundation::TypedEventHandler<UISettings, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AdvancedEffectsEnabledChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_advanced_effects_enabled_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_AdvancedEffectsEnabledChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUIViewSettings, 3325450230, 34896, 18189, 136, 248, 69, 94, 22, 234, 44, 38);
RT_INTERFACE!{interface IUIViewSettings(IUIViewSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IUIViewSettings] {
    fn get_UserInteractionMode(&self, out: *mut UserInteractionMode) -> HRESULT
}}
impl IUIViewSettings {
    #[inline] pub fn get_user_interaction_mode(&self) -> Result<UserInteractionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UserInteractionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UIViewSettings: IUIViewSettings}
impl RtActivatable<IUIViewSettingsStatics> for UIViewSettings {}
impl UIViewSettings {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<UIViewSettings>>> {
        <Self as RtActivatable<IUIViewSettingsStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(UIViewSettings(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,85,73,86,105,101,119,83,101,116,116,105,110,103,115,0]) [CLSID_UIViewSettings]);
DEFINE_IID!(IID_IUIViewSettingsStatics, 1499240357, 63734, 16847, 176, 251, 170, 205, 184, 31, 213, 246);
RT_INTERFACE!{static interface IUIViewSettingsStatics(IUIViewSettingsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUIViewSettingsStatics] {
    fn GetForCurrentView(&self, out: *mut *mut UIViewSettings) -> HRESULT
}}
impl IUIViewSettingsStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<UIViewSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UserInteractionMode: i32 {
    Mouse = 0, Touch = 1,
}}
DEFINE_IID!(IID_IViewModePreferences, 2274348346, 2969, 17097, 132, 208, 211, 241, 212, 3, 85, 75);
RT_INTERFACE!{interface IViewModePreferences(IViewModePreferencesVtbl): IInspectable(IInspectableVtbl) [IID_IViewModePreferences] {
    fn get_ViewSizePreference(&self, out: *mut ViewSizePreference) -> HRESULT,
    fn put_ViewSizePreference(&self, value: ViewSizePreference) -> HRESULT,
    fn get_CustomSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_CustomSize(&self, value: foundation::Size) -> HRESULT
}}
impl IViewModePreferences {
    #[inline] pub fn get_view_size_preference(&self) -> Result<ViewSizePreference> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewSizePreference)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_view_size_preference(&self, value: ViewSizePreference) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ViewSizePreference)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CustomSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_size(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_CustomSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ViewModePreferences: IViewModePreferences}
impl RtActivatable<IViewModePreferencesStatics> for ViewModePreferences {}
impl ViewModePreferences {
    #[inline] pub fn create_default(mode: ApplicationViewMode) -> Result<Option<ComPtr<ViewModePreferences>>> {
        <Self as RtActivatable<IViewModePreferencesStatics>>::get_activation_factory().create_default(mode)
    }
}
DEFINE_CLSID!(ViewModePreferences(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,86,105,101,119,77,111,100,101,80,114,101,102,101,114,101,110,99,101,115,0]) [CLSID_ViewModePreferences]);
DEFINE_IID!(IID_IViewModePreferencesStatics, 1773537893, 24037, 16600, 131, 6, 56, 51, 223, 122, 34, 116);
RT_INTERFACE!{static interface IViewModePreferencesStatics(IViewModePreferencesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IViewModePreferencesStatics] {
    fn CreateDefault(&self, mode: ApplicationViewMode, out: *mut *mut ViewModePreferences) -> HRESULT
}}
impl IViewModePreferencesStatics {
    #[inline] pub fn create_default(&self, mode: ApplicationViewMode) -> Result<Option<ComPtr<ViewModePreferences>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDefault)(self as *const _ as *mut _, mode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ViewSizePreference: i32 {
    Default = 0, UseLess = 1, UseHalf = 2, UseMore = 3, UseMinimum = 4, UseNone = 5, Custom = 6,
}}
pub mod core { // Windows.UI.ViewManagement.Core
use crate::prelude::*;
DEFINE_IID!(IID_ICoreInputView, 3346058618, 28673, 19506, 191, 148, 37, 193, 245, 84, 203, 241);
RT_INTERFACE!{interface ICoreInputView(ICoreInputViewVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputView] {
    fn add_OcclusionsChanged(&self, handler: *mut foundation::TypedEventHandler<CoreInputView, CoreInputViewOcclusionsChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OcclusionsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetCoreInputViewOcclusions(&self, out: *mut *mut foundation::collections::IVectorView<CoreInputViewOcclusion>) -> HRESULT,
    fn TryShowPrimaryView(&self, out: *mut bool) -> HRESULT,
    fn TryHidePrimaryView(&self, out: *mut bool) -> HRESULT
}}
impl ICoreInputView {
    #[inline] pub fn add_occlusions_changed(&self, handler: &foundation::TypedEventHandler<CoreInputView, CoreInputViewOcclusionsChangedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_OcclusionsChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_occlusions_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_OcclusionsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_core_input_view_occlusions(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<CoreInputViewOcclusion>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCoreInputViewOcclusions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_show_primary_view(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryShowPrimaryView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_hide_primary_view(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryHidePrimaryView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreInputView: ICoreInputView}
impl RtActivatable<ICoreInputViewStatics> for CoreInputView {}
impl CoreInputView {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<CoreInputView>>> {
        <Self as RtActivatable<ICoreInputViewStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(CoreInputView(&[87,105,110,100,111,119,115,46,85,73,46,86,105,101,119,77,97,110,97,103,101,109,101,110,116,46,67,111,114,101,46,67,111,114,101,73,110,112,117,116,86,105,101,119,0]) [CLSID_CoreInputView]);
DEFINE_IID!(IID_ICoreInputView2, 248981185, 57498, 19176, 174, 223, 223, 164, 133, 125, 26, 1);
RT_INTERFACE!{interface ICoreInputView2(ICoreInputView2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputView2] {
    fn add_XYFocusTransferringFromPrimaryView(&self, handler: *mut foundation::TypedEventHandler<CoreInputView, CoreInputViewTransferringXYFocusEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_XYFocusTransferringFromPrimaryView(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_XYFocusTransferredToPrimaryView(&self, handler: *mut foundation::TypedEventHandler<CoreInputView, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_XYFocusTransferredToPrimaryView(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn TryTransferXYFocusToPrimaryView(&self, origin: foundation::Rect, direction: CoreInputViewXYFocusTransferDirection, out: *mut bool) -> HRESULT
}}
impl ICoreInputView2 {
    #[inline] pub fn add_xy_focus_transferring_from_primary_view(&self, handler: &foundation::TypedEventHandler<CoreInputView, CoreInputViewTransferringXYFocusEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_XYFocusTransferringFromPrimaryView)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_xy_focus_transferring_from_primary_view(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_XYFocusTransferringFromPrimaryView)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_xy_focus_transferred_to_primary_view(&self, handler: &foundation::TypedEventHandler<CoreInputView, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_XYFocusTransferredToPrimaryView)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_xy_focus_transferred_to_primary_view(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_XYFocusTransferredToPrimaryView)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_transfer_xy_focus_to_primary_view(&self, origin: foundation::Rect, direction: CoreInputViewXYFocusTransferDirection) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryTransferXYFocusToPrimaryView)(self as *const _ as *mut _, origin, direction, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreInputView3, 3163821651, 15033, 18505, 143, 88, 70, 231, 240, 53, 60, 252);
RT_INTERFACE!{interface ICoreInputView3(ICoreInputView3Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputView3] {
    fn TryShow(&self, out: *mut bool) -> HRESULT,
    fn TryShowWithKind(&self, type_: CoreInputViewKind, out: *mut bool) -> HRESULT,
    fn TryHide(&self, out: *mut bool) -> HRESULT
}}
impl ICoreInputView3 {
    #[inline] pub fn try_show(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryShow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_show_with_kind(&self, type_: CoreInputViewKind) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryShowWithKind)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_hide(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TryHide)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum CoreInputViewKind: i32 {
    Default = 0, Keyboard = 1, Handwriting = 2, Emoji = 3,
}}
DEFINE_IID!(IID_ICoreInputViewOcclusion, 3426143750, 14437, 16759, 181, 245, 139, 101, 224, 185, 206, 132);
RT_INTERFACE!{interface ICoreInputViewOcclusion(ICoreInputViewOcclusionVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputViewOcclusion] {
    fn get_OccludingRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_OcclusionKind(&self, out: *mut CoreInputViewOcclusionKind) -> HRESULT
}}
impl ICoreInputViewOcclusion {
    #[inline] pub fn get_occluding_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OccludingRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_occlusion_kind(&self) -> Result<CoreInputViewOcclusionKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OcclusionKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreInputViewOcclusion: ICoreInputViewOcclusion}
RT_ENUM! { enum CoreInputViewOcclusionKind: i32 {
    Docked = 0, Floating = 1, Overlay = 2,
}}
DEFINE_IID!(IID_ICoreInputViewOcclusionsChangedEventArgs, 3188729832, 46062, 19959, 149, 84, 137, 205, 198, 96, 130, 194);
RT_INTERFACE!{interface ICoreInputViewOcclusionsChangedEventArgs(ICoreInputViewOcclusionsChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputViewOcclusionsChangedEventArgs] {
    fn get_Occlusions(&self, out: *mut *mut foundation::collections::IVectorView<CoreInputViewOcclusion>) -> HRESULT,
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl ICoreInputViewOcclusionsChangedEventArgs {
    #[inline] pub fn get_occlusions(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<CoreInputViewOcclusion>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Occlusions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreInputViewOcclusionsChangedEventArgs: ICoreInputViewOcclusionsChangedEventArgs}
DEFINE_IID!(IID_ICoreInputViewStatics, 2107348941, 60862, 18895, 165, 79, 51, 125, 224, 82, 144, 127);
RT_INTERFACE!{static interface ICoreInputViewStatics(ICoreInputViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputViewStatics] {
    fn GetForCurrentView(&self, out: *mut *mut CoreInputView) -> HRESULT
}}
impl ICoreInputViewStatics {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<CoreInputView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICoreInputViewTransferringXYFocusEventArgs, 81663647, 47618, 18512, 139, 85, 216, 45, 3, 186, 109, 127);
RT_INTERFACE!{interface ICoreInputViewTransferringXYFocusEventArgs(ICoreInputViewTransferringXYFocusEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreInputViewTransferringXYFocusEventArgs] {
    fn get_Origin(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_Direction(&self, out: *mut CoreInputViewXYFocusTransferDirection) -> HRESULT,
    fn put_TransferHandled(&self, value: bool) -> HRESULT,
    fn get_TransferHandled(&self, out: *mut bool) -> HRESULT,
    fn put_KeepPrimaryViewVisible(&self, value: bool) -> HRESULT,
    fn get_KeepPrimaryViewVisible(&self, out: *mut bool) -> HRESULT
}}
impl ICoreInputViewTransferringXYFocusEventArgs {
    #[inline] pub fn get_origin(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Origin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_direction(&self) -> Result<CoreInputViewXYFocusTransferDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Direction)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_transfer_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TransferHandled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_transfer_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransferHandled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_keep_primary_view_visible(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_KeepPrimaryViewVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_keep_primary_view_visible(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_KeepPrimaryViewVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CoreInputViewTransferringXYFocusEventArgs: ICoreInputViewTransferringXYFocusEventArgs}
RT_ENUM! { enum CoreInputViewXYFocusTransferDirection: i32 {
    Up = 0, Right = 1, Down = 2, Left = 3,
}}
} // Windows.UI.ViewManagement.Core
} // Windows.UI.ViewManagement
pub mod webui { // Windows.UI.WebUI
use crate::prelude::*;
DEFINE_IID!(IID_IActivatedDeferral, 3283949944, 42033, 18904, 167, 106, 57, 90, 78, 3, 220, 243);
RT_INTERFACE!{interface IActivatedDeferral(IActivatedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IActivatedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IActivatedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivatedDeferral: IActivatedDeferral}
DEFINE_IID!(IID_IActivatedEventArgsDeferral, 3396165492, 25538, 17574, 185, 123, 217, 160, 60, 32, 188, 155);
RT_INTERFACE!{interface IActivatedEventArgsDeferral(IActivatedEventArgsDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IActivatedEventArgsDeferral] {
    fn get_ActivatedOperation(&self, out: *mut *mut ActivatedOperation) -> HRESULT
}}
impl IActivatedEventArgsDeferral {
    #[inline] pub fn get_activated_operation(&self) -> Result<Option<ComPtr<ActivatedOperation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActivatedOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ActivatedEventHandler, 1358030640, 50641, 19307, 154, 219, 138, 17, 117, 107, 226, 156);
RT_DELEGATE!{delegate ActivatedEventHandler(ActivatedEventHandlerVtbl, ActivatedEventHandlerImpl) [IID_ActivatedEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, eventArgs: *mut super::super::applicationmodel::activation::IActivatedEventArgs) -> HRESULT
}}
impl ActivatedEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn invoke(&self, sender: &IInspectable, eventArgs: &super::super::applicationmodel::activation::IActivatedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, eventArgs as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IActivatedOperation, 3063985340, 50890, 17149, 152, 24, 113, 144, 78, 69, 254, 215);
RT_INTERFACE!{interface IActivatedOperation(IActivatedOperationVtbl): IInspectable(IInspectableVtbl) [IID_IActivatedOperation] {
    fn GetDeferral(&self, out: *mut *mut ActivatedDeferral) -> HRESULT
}}
impl IActivatedOperation {
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<ActivatedDeferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivatedOperation: IActivatedOperation}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class BackgroundActivatedEventArgs: super::super::applicationmodel::activation::IBackgroundActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class BackgroundActivatedEventArgs: IInspectable}
DEFINE_IID!(IID_BackgroundActivatedEventHandler, 3987840955, 1889, 18380, 154, 119, 36, 215, 7, 41, 101, 202);
RT_DELEGATE!{delegate BackgroundActivatedEventHandler(BackgroundActivatedEventHandlerVtbl, BackgroundActivatedEventHandlerImpl) [IID_BackgroundActivatedEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, eventArgs: *mut super::super::applicationmodel::activation::IBackgroundActivatedEventArgs) -> HRESULT
}}
impl BackgroundActivatedEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn invoke(&self, sender: &IInspectable, eventArgs: &super::super::applicationmodel::activation::IBackgroundActivatedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, eventArgs as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class EnteredBackgroundEventArgs: super::super::applicationmodel::IEnteredBackgroundEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class EnteredBackgroundEventArgs: IInspectable}
DEFINE_IID!(IID_EnteredBackgroundEventHandler, 722051443, 46734, 19951, 136, 193, 141, 232, 78, 90, 171, 47);
RT_DELEGATE!{delegate EnteredBackgroundEventHandler(EnteredBackgroundEventHandlerVtbl, EnteredBackgroundEventHandlerImpl) [IID_EnteredBackgroundEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::super::applicationmodel::IEnteredBackgroundEventArgs) -> HRESULT
}}
impl EnteredBackgroundEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn invoke(&self, sender: &IInspectable, e: &super::super::applicationmodel::IEnteredBackgroundEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHtmlPrintDocumentSource, 3467003546, 3589, 18042, 171, 201, 54, 236, 29, 76, 220, 182);
RT_INTERFACE!{interface IHtmlPrintDocumentSource(IHtmlPrintDocumentSourceVtbl): IInspectable(IInspectableVtbl) [IID_IHtmlPrintDocumentSource] {
    fn get_Content(&self, out: *mut PrintContent) -> HRESULT,
    fn put_Content(&self, value: PrintContent) -> HRESULT,
    fn get_LeftMargin(&self, out: *mut f32) -> HRESULT,
    fn put_LeftMargin(&self, value: f32) -> HRESULT,
    fn get_TopMargin(&self, out: *mut f32) -> HRESULT,
    fn put_TopMargin(&self, value: f32) -> HRESULT,
    fn get_RightMargin(&self, out: *mut f32) -> HRESULT,
    fn put_RightMargin(&self, value: f32) -> HRESULT,
    fn get_BottomMargin(&self, out: *mut f32) -> HRESULT,
    fn put_BottomMargin(&self, value: f32) -> HRESULT,
    fn get_EnableHeaderFooter(&self, out: *mut bool) -> HRESULT,
    fn put_EnableHeaderFooter(&self, value: bool) -> HRESULT,
    fn get_ShrinkToFit(&self, out: *mut bool) -> HRESULT,
    fn put_ShrinkToFit(&self, value: bool) -> HRESULT,
    fn get_PercentScale(&self, out: *mut f32) -> HRESULT,
    fn put_PercentScale(&self, scalePercent: f32) -> HRESULT,
    fn get_PageRange(&self, out: *mut HSTRING) -> HRESULT,
    fn TrySetPageRange(&self, strPageRange: HSTRING, out: *mut bool) -> HRESULT
}}
impl IHtmlPrintDocumentSource {
    #[inline] pub fn get_content(&self) -> Result<PrintContent> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_content(&self, value: PrintContent) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_left_margin(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LeftMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_left_margin(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_LeftMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_top_margin(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TopMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_top_margin(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_TopMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_right_margin(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RightMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_right_margin(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_RightMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bottom_margin(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BottomMargin)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bottom_margin(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_BottomMargin)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_enable_header_footer(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EnableHeaderFooter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_enable_header_footer(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_EnableHeaderFooter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_shrink_to_fit(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShrinkToFit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_shrink_to_fit(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_ShrinkToFit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_percent_scale(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PercentScale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_percent_scale(&self, scalePercent: f32) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_PercentScale)(self as *const _ as *mut _, scalePercent);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_page_range(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PageRange)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_page_range(&self, strPageRange: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySetPageRange)(self as *const _ as *mut _, strPageRange.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class HtmlPrintDocumentSource: IHtmlPrintDocumentSource}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class LeavingBackgroundEventArgs: super::super::applicationmodel::ILeavingBackgroundEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class LeavingBackgroundEventArgs: IInspectable}
DEFINE_IID!(IID_LeavingBackgroundEventHandler, 11848921, 31388, 19307, 154, 196, 19, 71, 79, 38, 139, 196);
RT_DELEGATE!{delegate LeavingBackgroundEventHandler(LeavingBackgroundEventHandlerVtbl, LeavingBackgroundEventHandlerImpl) [IID_LeavingBackgroundEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::super::applicationmodel::ILeavingBackgroundEventArgs) -> HRESULT
}}
impl LeavingBackgroundEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn invoke(&self, sender: &IInspectable, e: &super::super::applicationmodel::ILeavingBackgroundEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_NavigatedEventHandler, 2062839782, 16586, 20041, 167, 214, 219, 219, 51, 12, 209, 163);
RT_DELEGATE!{delegate NavigatedEventHandler(NavigatedEventHandlerVtbl, NavigatedEventHandlerImpl) [IID_NavigatedEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable, e: *mut IWebUINavigatedEventArgs) -> HRESULT
}}
impl NavigatedEventHandler {
    #[inline] pub fn invoke(&self, sender: &IInspectable, e: &IWebUINavigatedEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_INewWebUIViewCreatedEventArgs, 3907105302, 48683, 19614, 133, 231, 8, 49, 67, 236, 75, 231);
RT_INTERFACE!{interface INewWebUIViewCreatedEventArgs(INewWebUIViewCreatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INewWebUIViewCreatedEventArgs] {
    fn get_WebUIView(&self, out: *mut *mut WebUIView) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn get_ActivatedEventArgs(&self, out: *mut *mut super::super::applicationmodel::activation::IActivatedEventArgs) -> HRESULT,
    fn get_HasPendingNavigate(&self, out: *mut bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl INewWebUIViewCreatedEventArgs {
    #[inline] pub fn get_web_ui_view(&self) -> Result<Option<ComPtr<WebUIView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebUIView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn get_activated_event_args(&self) -> Result<Option<ComPtr<super::super::applicationmodel::activation::IActivatedEventArgs>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActivatedEventArgs)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_has_pending_navigate(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasPendingNavigate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class NewWebUIViewCreatedEventArgs: INewWebUIViewCreatedEventArgs}
RT_ENUM! { enum PrintContent: i32 {
    AllPages = 0, CurrentPage = 1, CustomPageRange = 2, CurrentSelection = 3,
}}
DEFINE_IID!(IID_ResumingEventHandler, 643406761, 41517, 18438, 167, 40, 172, 173, 193, 208, 117, 250);
RT_DELEGATE!{delegate ResumingEventHandler(ResumingEventHandlerVtbl, ResumingEventHandlerImpl) [IID_ResumingEventHandler] {
    fn Invoke(&self, sender: *mut IInspectable) -> HRESULT
}}
impl ResumingEventHandler {
    #[inline] pub fn invoke(&self, sender: &IInspectable) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class SuspendingDeferral: super::super::applicationmodel::ISuspendingDeferral}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class SuspendingDeferral: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class SuspendingEventArgs: super::super::applicationmodel::ISuspendingEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class SuspendingEventArgs: IInspectable}
DEFINE_IID!(IID_SuspendingEventHandler, 1352417948, 30946, 18563, 171, 200, 137, 96, 220, 222, 27, 92);
RT_DELEGATE!{delegate SuspendingEventHandler(SuspendingEventHandlerVtbl, SuspendingEventHandlerImpl) [IID_SuspendingEventHandler] {
    #[cfg(feature="windows-applicationmodel")] fn Invoke(&self, sender: *mut IInspectable, e: *mut super::super::applicationmodel::ISuspendingEventArgs) -> HRESULT
}}
impl SuspendingEventHandler {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn invoke(&self, sender: &IInspectable, e: &super::super::applicationmodel::ISuspendingEventArgs) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, e as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class SuspendingOperation: super::super::applicationmodel::ISuspendingOperation}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class SuspendingOperation: IInspectable}
DEFINE_IID!(IID_IWebUIActivationStatics, 890996413, 17331, 18475, 133, 219, 53, 216, 123, 81, 122, 217);
RT_INTERFACE!{static interface IWebUIActivationStatics(IWebUIActivationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWebUIActivationStatics] {
    fn add_Activated(&self, handler: *mut ActivatedEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Suspending(&self, handler: *mut SuspendingEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Suspending(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Resuming(&self, handler: *mut ResumingEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Resuming(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Navigated(&self, handler: *mut NavigatedEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Navigated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IWebUIActivationStatics {
    #[inline] pub fn add_activated(&self, handler: &ActivatedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Activated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Activated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_suspending(&self, handler: &SuspendingEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Suspending)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_suspending(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Suspending)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_resuming(&self, handler: &ResumingEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Resuming)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_resuming(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Resuming)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_navigated(&self, handler: &NavigatedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Navigated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_navigated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Navigated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWebUIActivationStatics2, 3370682006, 19832, 19108, 143, 6, 42, 158, 173, 198, 196, 10);
RT_INTERFACE!{static interface IWebUIActivationStatics2(IWebUIActivationStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IWebUIActivationStatics2] {
    fn add_LeavingBackground(&self, handler: *mut LeavingBackgroundEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LeavingBackground(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnteredBackground(&self, handler: *mut EnteredBackgroundEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnteredBackground(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn EnablePrelaunch(&self, value: bool) -> HRESULT
}}
impl IWebUIActivationStatics2 {
    #[inline] pub fn add_leaving_background(&self, handler: &LeavingBackgroundEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LeavingBackground)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_leaving_background(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_LeavingBackground)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_entered_background(&self, handler: &EnteredBackgroundEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EnteredBackground)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_entered_background(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_EnteredBackground)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_prelaunch(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).EnablePrelaunch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWebUIActivationStatics3, 2443949702, 6901, 17477, 180, 159, 148, 89, 244, 15, 200, 222);
RT_INTERFACE!{static interface IWebUIActivationStatics3(IWebUIActivationStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IWebUIActivationStatics3] {
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn RequestRestartAsync(&self, launchArguments: HSTRING, out: *mut *mut foundation::IAsyncOperation<super::super::applicationmodel::core::AppRestartFailureReason>) -> HRESULT,
    #[cfg(all(feature="windows-applicationmodel",feature="windows-system"))] fn RequestRestartForUserAsync(&self, user: *mut super::super::system::User, launchArguments: HSTRING, out: *mut *mut foundation::IAsyncOperation<super::super::applicationmodel::core::AppRestartFailureReason>) -> HRESULT
}}
impl IWebUIActivationStatics3 {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn request_restart_async(&self, launchArguments: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<super::super::applicationmodel::core::AppRestartFailureReason>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestRestartAsync)(self as *const _ as *mut _, launchArguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-applicationmodel",feature="windows-system"))] #[inline] pub fn request_restart_for_user_async(&self, user: &super::super::system::User, launchArguments: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<super::super::applicationmodel::core::AppRestartFailureReason>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestRestartForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, launchArguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWebUIActivationStatics4, 1580799017, 6207, 18317, 138, 37, 103, 248, 13, 3, 147, 91);
RT_INTERFACE!{static interface IWebUIActivationStatics4(IWebUIActivationStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IWebUIActivationStatics4] {
    fn add_NewWebUIViewCreated(&self, handler: *mut foundation::EventHandler<NewWebUIViewCreatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NewWebUIViewCreated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_BackgroundActivated(&self, handler: *mut BackgroundActivatedEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackgroundActivated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl IWebUIActivationStatics4 {
    #[inline] pub fn add_new_web_ui_view_created(&self, handler: &foundation::EventHandler<NewWebUIViewCreatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NewWebUIViewCreated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_new_web_ui_view_created(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_NewWebUIViewCreated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_background_activated(&self, handler: &BackgroundActivatedEventHandler) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BackgroundActivated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_background_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_BackgroundActivated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class WebUIApplication}
impl RtActivatable<IWebUIActivationStatics> for WebUIApplication {}
impl RtActivatable<IWebUIActivationStatics2> for WebUIApplication {}
impl RtActivatable<IWebUIActivationStatics3> for WebUIApplication {}
impl RtActivatable<IWebUIActivationStatics4> for WebUIApplication {}
impl WebUIApplication {
    #[inline] pub fn add_activated(handler: &ActivatedEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().add_activated(handler)
    }
    #[inline] pub fn remove_activated(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().remove_activated(token)
    }
    #[inline] pub fn add_suspending(handler: &SuspendingEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().add_suspending(handler)
    }
    #[inline] pub fn remove_suspending(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().remove_suspending(token)
    }
    #[inline] pub fn add_resuming(handler: &ResumingEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().add_resuming(handler)
    }
    #[inline] pub fn remove_resuming(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().remove_resuming(token)
    }
    #[inline] pub fn add_navigated(handler: &NavigatedEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().add_navigated(handler)
    }
    #[inline] pub fn remove_navigated(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics>>::get_activation_factory().remove_navigated(token)
    }
    #[inline] pub fn add_leaving_background(handler: &LeavingBackgroundEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics2>>::get_activation_factory().add_leaving_background(handler)
    }
    #[inline] pub fn remove_leaving_background(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics2>>::get_activation_factory().remove_leaving_background(token)
    }
    #[inline] pub fn add_entered_background(handler: &EnteredBackgroundEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics2>>::get_activation_factory().add_entered_background(handler)
    }
    #[inline] pub fn remove_entered_background(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics2>>::get_activation_factory().remove_entered_background(token)
    }
    #[inline] pub fn enable_prelaunch(value: bool) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics2>>::get_activation_factory().enable_prelaunch(value)
    }
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn request_restart_async(launchArguments: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<super::super::applicationmodel::core::AppRestartFailureReason>>> {
        <Self as RtActivatable<IWebUIActivationStatics3>>::get_activation_factory().request_restart_async(launchArguments)
    }
    #[cfg(all(feature="windows-applicationmodel",feature="windows-system"))] #[inline] pub fn request_restart_for_user_async(user: &super::super::system::User, launchArguments: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<super::super::applicationmodel::core::AppRestartFailureReason>>> {
        <Self as RtActivatable<IWebUIActivationStatics3>>::get_activation_factory().request_restart_for_user_async(user, launchArguments)
    }
    #[inline] pub fn add_new_web_ui_view_created(handler: &foundation::EventHandler<NewWebUIViewCreatedEventArgs>) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics4>>::get_activation_factory().add_new_web_ui_view_created(handler)
    }
    #[inline] pub fn remove_new_web_ui_view_created(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics4>>::get_activation_factory().remove_new_web_ui_view_created(token)
    }
    #[inline] pub fn add_background_activated(handler: &BackgroundActivatedEventHandler) -> Result<foundation::EventRegistrationToken> {
        <Self as RtActivatable<IWebUIActivationStatics4>>::get_activation_factory().add_background_activated(handler)
    }
    #[inline] pub fn remove_background_activated(token: foundation::EventRegistrationToken) -> Result<()> {
        <Self as RtActivatable<IWebUIActivationStatics4>>::get_activation_factory().remove_background_activated(token)
    }
}
DEFINE_CLSID!(WebUIApplication(&[87,105,110,100,111,119,115,46,85,73,46,87,101,98,85,73,46,87,101,98,85,73,65,112,112,108,105,99,97,116,105,111,110,0]) [CLSID_WebUIApplication]);
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIAppointmentsProviderAddAppointmentActivatedEventArgs: super::super::applicationmodel::activation::IAppointmentsProviderAddAppointmentActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIAppointmentsProviderAddAppointmentActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs: super::super::applicationmodel::activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIAppointmentsProviderRemoveAppointmentActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs: super::super::applicationmodel::activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIAppointmentsProviderReplaceAppointmentActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs: super::super::applicationmodel::activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIAppointmentsProviderShowAppointmentDetailsActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs: super::super::applicationmodel::activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIAppointmentsProviderShowTimeFrameActivatedEventArgs: IInspectable}
DEFINE_IID!(IID_IWebUIBackgroundTaskInstance, 603008037, 58103, 18241, 188, 156, 57, 69, 149, 222, 36, 220);
RT_INTERFACE!{interface IWebUIBackgroundTaskInstance(IWebUIBackgroundTaskInstanceVtbl): IInspectable(IInspectableVtbl) [IID_IWebUIBackgroundTaskInstance] {
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT,
    fn put_Succeeded(&self, succeeded: bool) -> HRESULT
}}
impl IWebUIBackgroundTaskInstance {
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Succeeded)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_succeeded(&self, succeeded: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_Succeeded)(self as *const _ as *mut _, succeeded);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{static class WebUIBackgroundTaskInstance}
impl RtActivatable<IWebUIBackgroundTaskInstanceStatics> for WebUIBackgroundTaskInstance {}
impl WebUIBackgroundTaskInstance {
    #[inline] pub fn get_current() -> Result<Option<ComPtr<IWebUIBackgroundTaskInstance>>> {
        <Self as RtActivatable<IWebUIBackgroundTaskInstanceStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(WebUIBackgroundTaskInstance(&[87,105,110,100,111,119,115,46,85,73,46,87,101,98,85,73,46,87,101,98,85,73,66,97,99,107,103,114,111,117,110,100,84,97,115,107,73,110,115,116,97,110,99,101,0]) [CLSID_WebUIBackgroundTaskInstance]);
RT_CLASS!{class WebUIBackgroundTaskInstanceRuntimeClass: IWebUIBackgroundTaskInstance}
DEFINE_IID!(IID_IWebUIBackgroundTaskInstanceStatics, 2625262225, 6574, 19619, 185, 75, 254, 78, 199, 68, 167, 64);
RT_INTERFACE!{static interface IWebUIBackgroundTaskInstanceStatics(IWebUIBackgroundTaskInstanceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWebUIBackgroundTaskInstanceStatics] {
    fn get_Current(&self, out: *mut *mut IWebUIBackgroundTaskInstance) -> HRESULT
}}
impl IWebUIBackgroundTaskInstanceStatics {
    #[inline] pub fn get_current(&self) -> Result<Option<ComPtr<IWebUIBackgroundTaskInstance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIBarcodeScannerPreviewActivatedEventArgs: super::super::applicationmodel::activation::IBarcodeScannerPreviewActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIBarcodeScannerPreviewActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUICachedFileUpdaterActivatedEventArgs: super::super::applicationmodel::activation::ICachedFileUpdaterActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUICachedFileUpdaterActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUICameraSettingsActivatedEventArgs: super::super::applicationmodel::activation::ICameraSettingsActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUICameraSettingsActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUICommandLineActivatedEventArgs: super::super::applicationmodel::activation::ICommandLineActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUICommandLineActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactCallActivatedEventArgs: super::super::applicationmodel::activation::IContactCallActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactCallActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactMapActivatedEventArgs: super::super::applicationmodel::activation::IContactMapActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactMapActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactMessageActivatedEventArgs: super::super::applicationmodel::activation::IContactMessageActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactMessageActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactPanelActivatedEventArgs: super::super::applicationmodel::activation::IContactPanelActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactPanelActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactPickerActivatedEventArgs: super::super::applicationmodel::activation::IContactPickerActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactPickerActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactPostActivatedEventArgs: super::super::applicationmodel::activation::IContactPostActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactPostActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIContactVideoCallActivatedEventArgs: super::super::applicationmodel::activation::IContactVideoCallActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIContactVideoCallActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIDeviceActivatedEventArgs: super::super::applicationmodel::activation::IDeviceActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIDeviceActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIDevicePairingActivatedEventArgs: super::super::applicationmodel::activation::IDevicePairingActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIDevicePairingActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIDialReceiverActivatedEventArgs: super::super::applicationmodel::activation::IDialReceiverActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIDialReceiverActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIFileActivatedEventArgs: super::super::applicationmodel::activation::IFileActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIFileActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIFileOpenPickerActivatedEventArgs: super::super::applicationmodel::activation::IFileOpenPickerActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIFileOpenPickerActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIFileOpenPickerContinuationEventArgs: super::super::applicationmodel::activation::IFileOpenPickerContinuationEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIFileOpenPickerContinuationEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIFileSavePickerActivatedEventArgs: super::super::applicationmodel::activation::IFileSavePickerActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIFileSavePickerActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIFileSavePickerContinuationEventArgs: super::super::applicationmodel::activation::IFileSavePickerContinuationEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIFileSavePickerContinuationEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIFolderPickerContinuationEventArgs: super::super::applicationmodel::activation::IFolderPickerContinuationEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIFolderPickerContinuationEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUILaunchActivatedEventArgs: super::super::applicationmodel::activation::ILaunchActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUILaunchActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUILockScreenActivatedEventArgs: super::super::applicationmodel::activation::ILockScreenActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUILockScreenActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUILockScreenCallActivatedEventArgs: super::super::applicationmodel::activation::ILockScreenCallActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUILockScreenCallActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUILockScreenComponentActivatedEventArgs: super::super::applicationmodel::activation::IActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUILockScreenComponentActivatedEventArgs: IInspectable}
DEFINE_IID!(IID_IWebUINavigatedDeferral, 3624149069, 33567, 18146, 180, 50, 58, 252, 226, 17, 249, 98);
RT_INTERFACE!{interface IWebUINavigatedDeferral(IWebUINavigatedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IWebUINavigatedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IWebUINavigatedDeferral {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WebUINavigatedDeferral: IWebUINavigatedDeferral}
DEFINE_IID!(IID_IWebUINavigatedEventArgs, 2807579064, 9369, 16432, 166, 157, 21, 210, 217, 207, 229, 36);
RT_INTERFACE!{interface IWebUINavigatedEventArgs(IWebUINavigatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebUINavigatedEventArgs] {
    fn get_NavigatedOperation(&self, out: *mut *mut WebUINavigatedOperation) -> HRESULT
}}
impl IWebUINavigatedEventArgs {
    #[inline] pub fn get_navigated_operation(&self) -> Result<Option<ComPtr<WebUINavigatedOperation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NavigatedOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WebUINavigatedEventArgs: IWebUINavigatedEventArgs}
DEFINE_IID!(IID_IWebUINavigatedOperation, 2056675080, 33154, 19081, 171, 103, 132, 146, 232, 117, 13, 75);
RT_INTERFACE!{interface IWebUINavigatedOperation(IWebUINavigatedOperationVtbl): IInspectable(IInspectableVtbl) [IID_IWebUINavigatedOperation] {
    fn GetDeferral(&self, out: *mut *mut WebUINavigatedDeferral) -> HRESULT
}}
impl IWebUINavigatedOperation {
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<WebUINavigatedDeferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WebUINavigatedOperation: IWebUINavigatedOperation}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIPrint3DWorkflowActivatedEventArgs: super::super::applicationmodel::activation::IPrint3DWorkflowActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIPrint3DWorkflowActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIPrintTaskSettingsActivatedEventArgs: super::super::applicationmodel::activation::IPrintTaskSettingsActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIPrintTaskSettingsActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIPrintWorkflowForegroundTaskActivatedEventArgs: super::super::applicationmodel::activation::IActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIPrintWorkflowForegroundTaskActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIProtocolActivatedEventArgs: super::super::applicationmodel::activation::IProtocolActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIProtocolActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIProtocolForResultsActivatedEventArgs: super::super::applicationmodel::activation::IProtocolForResultsActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIProtocolForResultsActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIRestrictedLaunchActivatedEventArgs: super::super::applicationmodel::activation::IRestrictedLaunchActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIRestrictedLaunchActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUISearchActivatedEventArgs: super::super::applicationmodel::activation::ISearchActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUISearchActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIShareTargetActivatedEventArgs: super::super::applicationmodel::activation::IShareTargetActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIShareTargetActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIStartupTaskActivatedEventArgs: super::super::applicationmodel::activation::IStartupTaskActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIStartupTaskActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIToastNotificationActivatedEventArgs: super::super::applicationmodel::activation::IToastNotificationActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIToastNotificationActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIUserDataAccountProviderActivatedEventArgs: super::super::applicationmodel::activation::IUserDataAccountProviderActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIUserDataAccountProviderActivatedEventArgs: IInspectable}
DEFINE_IID!(IID_IWebUIView, 1736701519, 21210, 20439, 190, 105, 142, 246, 40, 75, 66, 60);
RT_INTERFACE!{interface IWebUIView(IWebUIViewVtbl): IInspectable(IInspectableVtbl) [IID_IWebUIView] {
    fn get_ApplicationViewId(&self, out: *mut i32) -> HRESULT,
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<WebUIView, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-applicationmodel"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-applicationmodel")] fn add_Activated(&self, handler: *mut foundation::TypedEventHandler<WebUIView, super::super::applicationmodel::activation::IActivatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_IgnoreApplicationContentUriRulesNavigationRestrictions(&self, out: *mut bool) -> HRESULT,
    fn put_IgnoreApplicationContentUriRulesNavigationRestrictions(&self, value: bool) -> HRESULT
}}
impl IWebUIView {
    #[inline] pub fn get_application_view_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ApplicationViewId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_closed(&self, handler: &foundation::TypedEventHandler<WebUIView, IInspectable>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn add_activated(&self, handler: &foundation::TypedEventHandler<WebUIView, super::super::applicationmodel::activation::IActivatedEventArgs>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Activated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_activated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).remove_Activated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ignore_application_content_uri_rules_navigation_restrictions(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IgnoreApplicationContentUriRulesNavigationRestrictions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ignore_application_content_uri_rules_navigation_restrictions(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.lpVtbl).put_IgnoreApplicationContentUriRulesNavigationRestrictions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WebUIView: IWebUIView}
impl RtActivatable<IWebUIViewStatics> for WebUIView {}
impl WebUIView {
    #[inline] pub fn create_async() -> Result<ComPtr<foundation::IAsyncOperation<WebUIView>>> {
        <Self as RtActivatable<IWebUIViewStatics>>::get_activation_factory().create_async()
    }
    #[inline] pub fn create_with_uri_async(uri: &foundation::Uri) -> Result<ComPtr<foundation::IAsyncOperation<WebUIView>>> {
        <Self as RtActivatable<IWebUIViewStatics>>::get_activation_factory().create_with_uri_async(uri)
    }
}
DEFINE_CLSID!(WebUIView(&[87,105,110,100,111,119,115,46,85,73,46,87,101,98,85,73,46,87,101,98,85,73,86,105,101,119,0]) [CLSID_WebUIView]);
DEFINE_IID!(IID_IWebUIViewStatics, 3046237800, 36441, 17657, 136, 3, 27, 36, 201, 20, 157, 48);
RT_INTERFACE!{static interface IWebUIViewStatics(IWebUIViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWebUIViewStatics] {
    fn CreateAsync(&self, out: *mut *mut foundation::IAsyncOperation<WebUIView>) -> HRESULT,
    fn CreateWithUriAsync(&self, uri: *mut foundation::Uri, out: *mut *mut foundation::IAsyncOperation<WebUIView>) -> HRESULT
}}
impl IWebUIViewStatics {
    #[inline] pub fn create_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<WebUIView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_uri_async(&self, uri: &foundation::Uri) -> Result<ComPtr<foundation::IAsyncOperation<WebUIView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithUriAsync)(self as *const _ as *mut _, uri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIVoiceCommandActivatedEventArgs: super::super::applicationmodel::activation::IVoiceCommandActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIVoiceCommandActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIWalletActionActivatedEventArgs: super::super::applicationmodel::activation::IWalletActionActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIWalletActionActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIWebAccountProviderActivatedEventArgs: super::super::applicationmodel::activation::IWebAccountProviderActivatedEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIWebAccountProviderActivatedEventArgs: IInspectable}
#[cfg(feature="windows-applicationmodel")] RT_CLASS!{class WebUIWebAuthenticationBrokerContinuationEventArgs: super::super::applicationmodel::activation::IWebAuthenticationBrokerContinuationEventArgs}
#[cfg(not(feature="windows-applicationmodel"))] RT_CLASS!{class WebUIWebAuthenticationBrokerContinuationEventArgs: IInspectable}
} // Windows.UI.WebUI
#[cfg(feature="windows-ui-xaml")] pub mod xaml; // Windows.UI.Xaml
