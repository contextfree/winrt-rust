use crate::prelude::*;
DEFINE_IID!(IID_ILowLevelDevicesAggregateProvider, 2805880348, 43713, 20167, 168, 82, 71, 159, 112, 96, 208, 31);
RT_INTERFACE!{interface ILowLevelDevicesAggregateProvider(ILowLevelDevicesAggregateProviderVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesAggregateProvider] {
    fn get_AdcControllerProvider(&self, out: *mut *mut adc::provider::IAdcControllerProvider) -> HRESULT,
    fn get_PwmControllerProvider(&self, out: *mut *mut pwm::provider::IPwmControllerProvider) -> HRESULT,
    fn get_GpioControllerProvider(&self, out: *mut *mut gpio::provider::IGpioControllerProvider) -> HRESULT,
    fn get_I2cControllerProvider(&self, out: *mut *mut i2c::provider::II2cControllerProvider) -> HRESULT,
    fn get_SpiControllerProvider(&self, out: *mut *mut spi::provider::ISpiControllerProvider) -> HRESULT
}}
impl ComPtr<ILowLevelDevicesAggregateProvider> {
    #[inline] pub fn get_adc_controller_provider(&self) -> Result<Option<ComPtr<adc::provider::IAdcControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AdcControllerProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pwm_controller_provider(&self) -> Result<Option<ComPtr<pwm::provider::IPwmControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PwmControllerProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gpio_controller_provider(&self) -> Result<Option<ComPtr<gpio::provider::IGpioControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_GpioControllerProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_i2c_controller_provider(&self) -> Result<Option<ComPtr<i2c::provider::II2cControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_I2cControllerProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_spi_controller_provider(&self) -> Result<Option<ComPtr<spi::provider::ISpiControllerProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SpiControllerProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LowLevelDevicesAggregateProvider: ILowLevelDevicesAggregateProvider}
impl RtActivatable<ILowLevelDevicesAggregateProviderFactory> for LowLevelDevicesAggregateProvider {}
impl LowLevelDevicesAggregateProvider {
    #[inline] pub fn create(adc: &ComPtr<adc::provider::IAdcControllerProvider>, pwm: &ComPtr<pwm::provider::IPwmControllerProvider>, gpio: &ComPtr<gpio::provider::IGpioControllerProvider>, i2c: &ComPtr<i2c::provider::II2cControllerProvider>, spi: &ComPtr<spi::provider::ISpiControllerProvider>) -> Result<ComPtr<LowLevelDevicesAggregateProvider>> {
        <Self as RtActivatable<ILowLevelDevicesAggregateProviderFactory>>::get_activation_factory().create(adc, pwm, gpio, i2c, spi)
    }
}
DEFINE_CLSID!(LowLevelDevicesAggregateProvider(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,111,119,76,101,118,101,108,68,101,118,105,99,101,115,65,103,103,114,101,103,97,116,101,80,114,111,118,105,100,101,114,0]) [CLSID_LowLevelDevicesAggregateProvider]);
DEFINE_IID!(IID_ILowLevelDevicesAggregateProviderFactory, 2596580086, 13427, 18014, 150, 213, 54, 40, 26, 44, 87, 175);
RT_INTERFACE!{static interface ILowLevelDevicesAggregateProviderFactory(ILowLevelDevicesAggregateProviderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesAggregateProviderFactory] {
    fn Create(&self, adc: *mut adc::provider::IAdcControllerProvider, pwm: *mut pwm::provider::IPwmControllerProvider, gpio: *mut gpio::provider::IGpioControllerProvider, i2c: *mut i2c::provider::II2cControllerProvider, spi: *mut spi::provider::ISpiControllerProvider, out: *mut *mut LowLevelDevicesAggregateProvider) -> HRESULT
}}
impl ComPtr<ILowLevelDevicesAggregateProviderFactory> {
    #[inline] pub fn create(&self, adc: &ComPtr<adc::provider::IAdcControllerProvider>, pwm: &ComPtr<pwm::provider::IPwmControllerProvider>, gpio: &ComPtr<gpio::provider::IGpioControllerProvider>, i2c: &ComPtr<i2c::provider::II2cControllerProvider>, spi: &ComPtr<spi::provider::ISpiControllerProvider>) -> Result<ComPtr<LowLevelDevicesAggregateProvider>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, adc.deref() as *const _ as *mut _, pwm.deref() as *const _ as *mut _, gpio.deref() as *const _ as *mut _, i2c.deref() as *const _ as *mut _, spi.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILowLevelDevicesController, 784481748, 6043, 17886, 155, 57, 58, 224, 37, 39, 222, 82);
RT_INTERFACE!{interface ILowLevelDevicesController(ILowLevelDevicesControllerVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesController] {
    
}}
RT_CLASS!{class LowLevelDevicesController: ILowLevelDevicesController}
impl RtActivatable<ILowLevelDevicesControllerStatics> for LowLevelDevicesController {}
impl LowLevelDevicesController {
    #[inline] pub fn get_default_provider() -> Result<Option<ComPtr<ILowLevelDevicesAggregateProvider>>> {
        <Self as RtActivatable<ILowLevelDevicesControllerStatics>>::get_activation_factory().get_default_provider()
    }
    #[inline] pub fn set_default_provider(value: &ComPtr<ILowLevelDevicesAggregateProvider>) -> Result<()> {
        <Self as RtActivatable<ILowLevelDevicesControllerStatics>>::get_activation_factory().set_default_provider(value)
    }
}
DEFINE_CLSID!(LowLevelDevicesController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,111,119,76,101,118,101,108,68,101,118,105,99,101,115,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_LowLevelDevicesController]);
DEFINE_IID!(IID_ILowLevelDevicesControllerStatics, 155095658, 64715, 17300, 166, 151, 25, 222, 99, 124, 45, 179);
RT_INTERFACE!{static interface ILowLevelDevicesControllerStatics(ILowLevelDevicesControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILowLevelDevicesControllerStatics] {
    fn get_DefaultProvider(&self, out: *mut *mut ILowLevelDevicesAggregateProvider) -> HRESULT,
    fn put_DefaultProvider(&self, value: *mut ILowLevelDevicesAggregateProvider) -> HRESULT
}}
impl ComPtr<ILowLevelDevicesControllerStatics> {
    #[inline] pub fn get_default_provider(&self) -> Result<Option<ComPtr<ILowLevelDevicesAggregateProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_provider(&self, value: &ComPtr<ILowLevelDevicesAggregateProvider>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DefaultProvider)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
pub mod adc { // Windows.Devices.Adc
use crate::prelude::*;
DEFINE_IID!(IID_IAdcChannel, 67892244, 9608, 19030, 171, 239, 115, 162, 96, 172, 198, 10);
RT_INTERFACE!{interface IAdcChannel(IAdcChannelVtbl): IInspectable(IInspectableVtbl) [IID_IAdcChannel] {
    fn get_Controller(&self, out: *mut *mut AdcController) -> HRESULT,
    fn ReadValue(&self, out: *mut i32) -> HRESULT,
    fn ReadRatio(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IAdcChannel> {
    #[inline] pub fn get_controller(&self) -> Result<Option<ComPtr<AdcController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Controller)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ReadValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read_ratio(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ReadRatio)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AdcChannel: IAdcChannel}
RT_ENUM! { enum AdcChannelMode: i32 {
    SingleEnded = 0, Differential = 1,
}}
DEFINE_IID!(IID_IAdcController, 712434864, 43158, 16921, 134, 182, 234, 140, 220, 233, 143, 86);
RT_INTERFACE!{interface IAdcController(IAdcControllerVtbl): IInspectable(IInspectableVtbl) [IID_IAdcController] {
    fn get_ChannelCount(&self, out: *mut i32) -> HRESULT,
    fn get_ResolutionInBits(&self, out: *mut i32) -> HRESULT,
    fn get_MinValue(&self, out: *mut i32) -> HRESULT,
    fn get_MaxValue(&self, out: *mut i32) -> HRESULT,
    fn get_ChannelMode(&self, out: *mut AdcChannelMode) -> HRESULT,
    fn put_ChannelMode(&self, value: AdcChannelMode) -> HRESULT,
    fn IsChannelModeSupported(&self, channelMode: AdcChannelMode, out: *mut bool) -> HRESULT,
    fn OpenChannel(&self, channelNumber: i32, out: *mut *mut AdcChannel) -> HRESULT
}}
impl ComPtr<IAdcController> {
    #[inline] pub fn get_channel_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChannelCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resolution_in_bits(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ResolutionInBits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_mode(&self) -> Result<AdcChannelMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChannelMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_channel_mode(&self, value: AdcChannelMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ChannelMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_channel_mode_supported(&self, channelMode: AdcChannelMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsChannelModeSupported)(self.deref() as *const _ as *mut _, channelMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_channel(&self, channelNumber: i32) -> Result<Option<ComPtr<AdcChannel>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenChannel)(self.deref() as *const _ as *mut _, channelNumber, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AdcController: IAdcController}
impl RtActivatable<IAdcControllerStatics> for AdcController {}
impl RtActivatable<IAdcControllerStatics2> for AdcController {}
impl AdcController {
    #[inline] pub fn get_controllers_async(provider: &ComPtr<provider::IAdcProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<AdcController>>>> {
        <Self as RtActivatable<IAdcControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<AdcController>>> {
        <Self as RtActivatable<IAdcControllerStatics2>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(AdcController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,100,99,46,65,100,99,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_AdcController]);
DEFINE_IID!(IID_IAdcControllerStatics, 3437858316, 504, 18577, 188, 59, 190, 83, 239, 39, 156, 164);
RT_INTERFACE!{static interface IAdcControllerStatics(IAdcControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAdcControllerStatics] {
    fn GetControllersAsync(&self, provider: *mut provider::IAdcProvider, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<AdcController>>) -> HRESULT
}}
impl ComPtr<IAdcControllerStatics> {
    #[inline] pub fn get_controllers_async(&self, provider: &ComPtr<provider::IAdcProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<AdcController>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdcControllerStatics2, 2730048285, 38779, 20314, 165, 254, 166, 171, 175, 254, 100, 132);
RT_INTERFACE!{static interface IAdcControllerStatics2(IAdcControllerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAdcControllerStatics2] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<AdcController>) -> HRESULT
}}
impl ComPtr<IAdcControllerStatics2> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<AdcController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
pub mod provider { // Windows.Devices.Adc.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IAdcControllerProvider, 3193198632, 33133, 19941, 160, 72, 171, 160, 105, 88, 170, 168);
RT_INTERFACE!{interface IAdcControllerProvider(IAdcControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IAdcControllerProvider] {
    fn get_ChannelCount(&self, out: *mut i32) -> HRESULT,
    fn get_ResolutionInBits(&self, out: *mut i32) -> HRESULT,
    fn get_MinValue(&self, out: *mut i32) -> HRESULT,
    fn get_MaxValue(&self, out: *mut i32) -> HRESULT,
    fn get_ChannelMode(&self, out: *mut ProviderAdcChannelMode) -> HRESULT,
    fn put_ChannelMode(&self, value: ProviderAdcChannelMode) -> HRESULT,
    fn IsChannelModeSupported(&self, channelMode: ProviderAdcChannelMode, out: *mut bool) -> HRESULT,
    fn AcquireChannel(&self, channel: i32) -> HRESULT,
    fn ReleaseChannel(&self, channel: i32) -> HRESULT,
    fn ReadValue(&self, channelNumber: i32, out: *mut i32) -> HRESULT
}}
impl ComPtr<IAdcControllerProvider> {
    #[inline] pub fn get_channel_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChannelCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_resolution_in_bits(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ResolutionInBits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_value(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_mode(&self) -> Result<ProviderAdcChannelMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChannelMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_channel_mode(&self, value: ProviderAdcChannelMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ChannelMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_channel_mode_supported(&self, channelMode: ProviderAdcChannelMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsChannelModeSupported)(self.deref() as *const _ as *mut _, channelMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn acquire_channel(&self, channel: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).AcquireChannel)(self.deref() as *const _ as *mut _, channel);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn release_channel(&self, channel: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ReleaseChannel)(self.deref() as *const _ as *mut _, channel);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_value(&self, channelNumber: i32) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ReadValue)(self.deref() as *const _ as *mut _, channelNumber, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAdcProvider, 680867432, 37721, 19543, 188, 136, 226, 117, 232, 22, 56, 201);
RT_INTERFACE!{interface IAdcProvider(IAdcProviderVtbl): IInspectable(IInspectableVtbl) [IID_IAdcProvider] {
    fn GetControllers(&self, out: *mut *mut foundation::collections::IVectorView<IAdcControllerProvider>) -> HRESULT
}}
impl ComPtr<IAdcProvider> {
    #[inline] pub fn get_controllers(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<IAdcControllerProvider>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderAdcChannelMode: i32 {
    SingleEnded = 0, Differential = 1,
}}
} // Windows.Devices.Adc.Provider
} // Windows.Devices.Adc
pub mod alljoyn { // Windows.Devices.AllJoyn
use crate::prelude::*;
DEFINE_IID!(IID_IAllJoynAboutData, 3853106944, 8098, 18489, 147, 239, 249, 223, 64, 72, 144, 247);
RT_INTERFACE!{interface IAllJoynAboutData(IAllJoynAboutDataVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutData] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_DefaultAppName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DefaultAppName(&self, value: HSTRING) -> HRESULT,
    fn get_AppNames(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT,
    fn get_DateOfManufacture(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn put_DateOfManufacture(&self, value: *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    fn get_DefaultDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DefaultDescription(&self, value: HSTRING) -> HRESULT,
    fn get_Descriptions(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT,
    fn get_DefaultManufacturer(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DefaultManufacturer(&self, value: HSTRING) -> HRESULT,
    fn get_Manufacturers(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT,
    fn get_ModelNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ModelNumber(&self, value: HSTRING) -> HRESULT,
    fn get_SoftwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SoftwareVersion(&self, value: HSTRING) -> HRESULT,
    fn get_SupportUrl(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn put_SupportUrl(&self, value: *mut foundation::Uri) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn put_AppId(&self, value: Guid) -> HRESULT
}}
impl ComPtr<IAllJoynAboutData> {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_app_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultAppName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_app_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DefaultAppName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_names(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AppNames)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_of_manufacture(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DateOfManufacture)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_date_of_manufacture(&self, value: &ComPtr<foundation::IReference<foundation::DateTime>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DateOfManufacture)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DefaultDescription)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptions(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_manufacturer(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultManufacturer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_default_manufacturer(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DefaultManufacturer)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturers(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Manufacturers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ModelNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_model_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ModelNumber)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_software_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SoftwareVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_software_version(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SoftwareVersion)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_support_url(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportUrl)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_support_url(&self, value: &ComPtr<foundation::Uri>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SupportUrl)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AppId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_app_id(&self, value: Guid) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AppId)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAboutData: IAllJoynAboutData}
DEFINE_IID!(IID_IAllJoynAboutDataView, 1747128607, 25106, 18740, 156, 72, 225, 156, 164, 152, 66, 136);
RT_INTERFACE!{interface IAllJoynAboutDataView(IAllJoynAboutDataViewVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutDataView] {
    fn get_Status(&self, out: *mut i32) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn get_AJSoftwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn get_DateOfManufacture(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_DefaultLanguage(&self, out: *mut *mut super::super::globalization::Language) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HardwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ModelNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SoftwareVersion(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_SupportedLanguages(&self, out: *mut *mut foundation::collections::IVectorView<super::super::globalization::Language>) -> HRESULT,
    fn get_SupportUrl(&self, out: *mut *mut foundation::Uri) -> HRESULT,
    fn get_AppName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Manufacturer(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAllJoynAboutDataView> {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_aj_software_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AJSoftwareVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AppId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date_of_manufacture(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DateOfManufacture)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_default_language(&self) -> Result<Option<ComPtr<super::super::globalization::Language>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultLanguage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HardwareVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ModelNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_software_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SoftwareVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_supported_languages(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::globalization::Language>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedLanguages)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_support_url(&self) -> Result<Option<ComPtr<foundation::Uri>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportUrl)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AppName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Description)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Manufacturer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAboutDataView: IAllJoynAboutDataView}
impl RtActivatable<IAllJoynAboutDataViewStatics> for AllJoynAboutDataView {}
impl AllJoynAboutDataView {
    #[inline] pub fn get_data_by_session_port_async(uniqueName: &HStringArg, busAttachment: &ComPtr<AllJoynBusAttachment>, sessionPort: u16) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynAboutDataView>>> {
        <Self as RtActivatable<IAllJoynAboutDataViewStatics>>::get_activation_factory().get_data_by_session_port_async(uniqueName, busAttachment, sessionPort)
    }
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_data_by_session_port_with_language_async(uniqueName: &HStringArg, busAttachment: &ComPtr<AllJoynBusAttachment>, sessionPort: u16, language: &ComPtr<super::super::globalization::Language>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynAboutDataView>>> {
        <Self as RtActivatable<IAllJoynAboutDataViewStatics>>::get_activation_factory().get_data_by_session_port_with_language_async(uniqueName, busAttachment, sessionPort, language)
    }
}
DEFINE_CLSID!(AllJoynAboutDataView(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,65,98,111,117,116,68,97,116,97,86,105,101,119,0]) [CLSID_AllJoynAboutDataView]);
DEFINE_IID!(IID_IAllJoynAboutDataViewStatics, 1475196552, 3166, 16750, 136, 181, 57, 179, 45, 37, 196, 125);
RT_INTERFACE!{static interface IAllJoynAboutDataViewStatics(IAllJoynAboutDataViewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAboutDataViewStatics] {
    fn GetDataBySessionPortAsync(&self, uniqueName: HSTRING, busAttachment: *mut AllJoynBusAttachment, sessionPort: u16, out: *mut *mut foundation::IAsyncOperation<AllJoynAboutDataView>) -> HRESULT,
    #[cfg(feature="windows-globalization")] fn GetDataBySessionPortWithLanguageAsync(&self, uniqueName: HSTRING, busAttachment: *mut AllJoynBusAttachment, sessionPort: u16, language: *mut super::super::globalization::Language, out: *mut *mut foundation::IAsyncOperation<AllJoynAboutDataView>) -> HRESULT
}}
impl ComPtr<IAllJoynAboutDataViewStatics> {
    #[inline] pub fn get_data_by_session_port_async(&self, uniqueName: &HStringArg, busAttachment: &ComPtr<AllJoynBusAttachment>, sessionPort: u16) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynAboutDataView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDataBySessionPortAsync)(self.deref() as *const _ as *mut _, uniqueName.get(), busAttachment.deref() as *const _ as *mut _, sessionPort, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_data_by_session_port_with_language_async(&self, uniqueName: &HStringArg, busAttachment: &ComPtr<AllJoynBusAttachment>, sessionPort: u16, language: &ComPtr<super::super::globalization::Language>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynAboutDataView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDataBySessionPortWithLanguageAsync)(self.deref() as *const _ as *mut _, uniqueName.get(), busAttachment.deref() as *const _ as *mut _, sessionPort, language.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynAcceptSessionJoiner, 1302861778, 52509, 16419, 167, 196, 22, 222, 248, 156, 40, 223);
RT_INTERFACE!{interface IAllJoynAcceptSessionJoiner(IAllJoynAcceptSessionJoinerVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoiner] {
    fn Accept(&self) -> HRESULT
}}
impl ComPtr<IAllJoynAcceptSessionJoiner> {
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Accept)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynAcceptSessionJoinerEventArgs, 1325093733, 16010, 16983, 143, 16, 83, 156, 224, 213, 108, 15);
RT_INTERFACE!{interface IAllJoynAcceptSessionJoinerEventArgs(IAllJoynAcceptSessionJoinerEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoinerEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SessionPort(&self, out: *mut u16) -> HRESULT,
    fn get_TrafficType(&self, out: *mut AllJoynTrafficType) -> HRESULT,
    fn get_SamePhysicalNode(&self, out: *mut bool) -> HRESULT,
    fn get_SameNetwork(&self, out: *mut bool) -> HRESULT,
    fn Accept(&self) -> HRESULT
}}
impl ComPtr<IAllJoynAcceptSessionJoinerEventArgs> {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_port(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SessionPort)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_traffic_type(&self) -> Result<AllJoynTrafficType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TrafficType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_same_physical_node(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SamePhysicalNode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_same_network(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SameNetwork)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Accept)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAcceptSessionJoinerEventArgs: IAllJoynAcceptSessionJoinerEventArgs}
impl RtActivatable<IAllJoynAcceptSessionJoinerEventArgsFactory> for AllJoynAcceptSessionJoinerEventArgs {}
impl AllJoynAcceptSessionJoinerEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: &ComPtr<IAllJoynAcceptSessionJoiner>) -> Result<ComPtr<AllJoynAcceptSessionJoinerEventArgs>> {
        <Self as RtActivatable<IAllJoynAcceptSessionJoinerEventArgsFactory>>::get_activation_factory().create(uniqueName, sessionPort, trafficType, proximity, acceptSessionJoiner)
    }
}
DEFINE_CLSID!(AllJoynAcceptSessionJoinerEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,65,99,99,101,112,116,83,101,115,115,105,111,110,74,111,105,110,101,114,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynAcceptSessionJoinerEventArgs]);
DEFINE_IID!(IID_IAllJoynAcceptSessionJoinerEventArgsFactory, 3024313280, 24901, 17054, 132, 219, 213, 191, 231, 114, 177, 79);
RT_INTERFACE!{static interface IAllJoynAcceptSessionJoinerEventArgsFactory(IAllJoynAcceptSessionJoinerEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAcceptSessionJoinerEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: *mut IAllJoynAcceptSessionJoiner, out: *mut *mut AllJoynAcceptSessionJoinerEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynAcceptSessionJoinerEventArgsFactory> {
    #[inline] pub fn create(&self, uniqueName: &HStringArg, sessionPort: u16, trafficType: AllJoynTrafficType, proximity: u8, acceptSessionJoiner: &ComPtr<IAllJoynAcceptSessionJoiner>) -> Result<ComPtr<AllJoynAcceptSessionJoinerEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, uniqueName.get(), sessionPort, trafficType, proximity, acceptSessionJoiner.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynAuthenticationCompleteEventArgs, 2545184796, 5596, 19283, 182, 164, 125, 19, 67, 0, 215, 191);
RT_INTERFACE!{interface IAllJoynAuthenticationCompleteEventArgs(IAllJoynAuthenticationCompleteEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynAuthenticationCompleteEventArgs] {
    fn get_AuthenticationMechanism(&self, out: *mut AllJoynAuthenticationMechanism) -> HRESULT,
    fn get_PeerUniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IAllJoynAuthenticationCompleteEventArgs> {
    #[inline] pub fn get_authentication_mechanism(&self) -> Result<AllJoynAuthenticationMechanism> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationMechanism)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_peer_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PeerUniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Succeeded)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynAuthenticationCompleteEventArgs: IAllJoynAuthenticationCompleteEventArgs}
RT_ENUM! { enum AllJoynAuthenticationMechanism: i32 {
    None = 0, SrpAnonymous = 1, SrpLogon = 2, EcdheNull = 3, EcdhePsk = 4, EcdheEcdsa = 5, EcdheSpeke = 6,
}}
DEFINE_IID!(IID_IAllJoynBusAttachment, 4077515091, 7917, 17091, 162, 14, 67, 109, 65, 254, 98, 246);
RT_INTERFACE!{interface IAllJoynBusAttachment(IAllJoynBusAttachmentVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachment] {
    fn get_AboutData(&self, out: *mut *mut AllJoynAboutData) -> HRESULT,
    fn get_ConnectionSpecification(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut AllJoynBusAttachmentState) -> HRESULT,
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn PingAsync(&self, uniqueName: HSTRING, out: *mut *mut foundation::IAsyncOperation<i32>) -> HRESULT,
    fn Connect(&self) -> HRESULT,
    fn Disconnect(&self) -> HRESULT,
    fn add_StateChanged(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynBusAttachmentStateChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_AuthenticationMechanisms(&self, out: *mut *mut foundation::collections::IVector<AllJoynAuthenticationMechanism>) -> HRESULT,
    fn add_CredentialsRequested(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CredentialsRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CredentialsVerificationRequested(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsVerificationRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CredentialsVerificationRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AuthenticationComplete(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAuthenticationCompleteEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AuthenticationComplete(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IAllJoynBusAttachment> {
    #[inline] pub fn get_about_data(&self) -> Result<Option<ComPtr<AllJoynAboutData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AboutData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_specification(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionSpecification)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<AllJoynBusAttachmentState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn ping_async(&self, uniqueName: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PingAsync)(self.deref() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Connect)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn disconnect(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Disconnect)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynBusAttachmentStateChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StateChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StateChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_mechanisms(&self) -> Result<Option<ComPtr<foundation::collections::IVector<AllJoynAuthenticationMechanism>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationMechanisms)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_credentials_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CredentialsRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_credentials_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CredentialsRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_credentials_verification_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynCredentialsVerificationRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CredentialsVerificationRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_credentials_verification_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CredentialsVerificationRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_authentication_complete(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAuthenticationCompleteEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AuthenticationComplete)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_authentication_complete(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AuthenticationComplete)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusAttachment: IAllJoynBusAttachment}
impl RtActivatable<IAllJoynBusAttachmentFactory> for AllJoynBusAttachment {}
impl RtActivatable<IAllJoynBusAttachmentStatics> for AllJoynBusAttachment {}
impl RtActivatable<IActivationFactory> for AllJoynBusAttachment {}
impl AllJoynBusAttachment {
    #[inline] pub fn create(connectionSpecification: &HStringArg) -> Result<ComPtr<AllJoynBusAttachment>> {
        <Self as RtActivatable<IAllJoynBusAttachmentFactory>>::get_activation_factory().create(connectionSpecification)
    }
    #[inline] pub fn get_default() -> Result<Option<ComPtr<AllJoynBusAttachment>>> {
        <Self as RtActivatable<IAllJoynBusAttachmentStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_watcher(requiredInterfaces: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<Option<ComPtr<super::enumeration::DeviceWatcher>>> {
        <Self as RtActivatable<IAllJoynBusAttachmentStatics>>::get_activation_factory().get_watcher(requiredInterfaces)
    }
}
DEFINE_CLSID!(AllJoynBusAttachment(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,65,116,116,97,99,104,109,101,110,116,0]) [CLSID_AllJoynBusAttachment]);
DEFINE_IID!(IID_IAllJoynBusAttachment2, 880069406, 9064, 17330, 180, 62, 106, 58, 193, 39, 141, 152);
RT_INTERFACE!{interface IAllJoynBusAttachment2(IAllJoynBusAttachment2Vtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachment2] {
    fn GetAboutDataAsync(&self, serviceInfo: *mut AllJoynServiceInfo, out: *mut *mut foundation::IAsyncOperation<AllJoynAboutDataView>) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-globalization")] fn GetAboutDataWithLanguageAsync(&self, serviceInfo: *mut AllJoynServiceInfo, language: *mut super::super::globalization::Language, out: *mut *mut foundation::IAsyncOperation<AllJoynAboutDataView>) -> HRESULT,
    fn add_AcceptSessionJoinerRequested(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAcceptSessionJoinerEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AcceptSessionJoinerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SessionJoined(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynSessionJoinedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionJoined(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IAllJoynBusAttachment2> {
    #[inline] pub fn get_about_data_async(&self, serviceInfo: &ComPtr<AllJoynServiceInfo>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynAboutDataView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAboutDataAsync)(self.deref() as *const _ as *mut _, serviceInfo.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-globalization")] #[inline] pub fn get_about_data_with_language_async(&self, serviceInfo: &ComPtr<AllJoynServiceInfo>, language: &ComPtr<super::super::globalization::Language>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynAboutDataView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAboutDataWithLanguageAsync)(self.deref() as *const _ as *mut _, serviceInfo.deref() as *const _ as *mut _, language.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_accept_session_joiner_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynAcceptSessionJoinerEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AcceptSessionJoinerRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_accept_session_joiner_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AcceptSessionJoinerRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_session_joined(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusAttachment, AllJoynSessionJoinedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SessionJoined)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_joined(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SessionJoined)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynBusAttachmentFactory, 1680798116, 44421, 19935, 144, 174, 96, 68, 82, 178, 34, 136);
RT_INTERFACE!{static interface IAllJoynBusAttachmentFactory(IAllJoynBusAttachmentFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentFactory] {
    fn Create(&self, connectionSpecification: HSTRING, out: *mut *mut AllJoynBusAttachment) -> HRESULT
}}
impl ComPtr<IAllJoynBusAttachmentFactory> {
    #[inline] pub fn create(&self, connectionSpecification: &HStringArg) -> Result<ComPtr<AllJoynBusAttachment>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, connectionSpecification.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AllJoynBusAttachmentState: i32 {
    Disconnected = 0, Connecting = 1, Connected = 2, Disconnecting = 3,
}}
DEFINE_IID!(IID_IAllJoynBusAttachmentStateChangedEventArgs, 3626923508, 49194, 16876, 168, 213, 234, 177, 85, 137, 83, 170);
RT_INTERFACE!{interface IAllJoynBusAttachmentStateChangedEventArgs(IAllJoynBusAttachmentStateChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentStateChangedEventArgs] {
    fn get_State(&self, out: *mut AllJoynBusAttachmentState) -> HRESULT,
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<IAllJoynBusAttachmentStateChangedEventArgs> {
    #[inline] pub fn get_state(&self) -> Result<AllJoynBusAttachmentState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusAttachmentStateChangedEventArgs: IAllJoynBusAttachmentStateChangedEventArgs}
DEFINE_IID!(IID_IAllJoynBusAttachmentStatics, 2208124221, 4177, 16599, 135, 42, 141, 1, 65, 17, 91, 31);
RT_INTERFACE!{static interface IAllJoynBusAttachmentStatics(IAllJoynBusAttachmentStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusAttachmentStatics] {
    fn GetDefault(&self, out: *mut *mut AllJoynBusAttachment) -> HRESULT,
    fn GetWatcher(&self, requiredInterfaces: *mut foundation::collections::IIterable<HString>, out: *mut *mut super::enumeration::DeviceWatcher) -> HRESULT
}}
impl ComPtr<IAllJoynBusAttachmentStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<AllJoynBusAttachment>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_watcher(&self, requiredInterfaces: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<Option<ComPtr<super::enumeration::DeviceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetWatcher)(self.deref() as *const _ as *mut _, requiredInterfaces.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynBusObject, 3908928094, 63290, 18700, 136, 4, 4, 224, 38, 100, 48, 71);
RT_INTERFACE!{interface IAllJoynBusObject(IAllJoynBusObjectVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObject] {
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn AddProducer(&self, producer: *mut IAllJoynProducer) -> HRESULT,
    fn get_BusAttachment(&self, out: *mut *mut AllJoynBusAttachment) -> HRESULT,
    fn get_Session(&self, out: *mut *mut AllJoynSession) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<AllJoynBusObject, AllJoynBusObjectStoppedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IAllJoynBusObject> {
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_producer(&self, producer: &ComPtr<IAllJoynProducer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).AddProducer)(self.deref() as *const _ as *mut _, producer.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_attachment(&self) -> Result<Option<ComPtr<AllJoynBusAttachment>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BusAttachment)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<AllJoynSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynBusObject, AllJoynBusObjectStoppedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusObject: IAllJoynBusObject}
impl RtActivatable<IAllJoynBusObjectFactory> for AllJoynBusObject {}
impl RtActivatable<IActivationFactory> for AllJoynBusObject {}
impl AllJoynBusObject {
    #[inline] pub fn create(objectPath: &HStringArg) -> Result<ComPtr<AllJoynBusObject>> {
        <Self as RtActivatable<IAllJoynBusObjectFactory>>::get_activation_factory().create(objectPath)
    }
    #[inline] pub fn create_with_bus_attachment(objectPath: &HStringArg, busAttachment: &ComPtr<AllJoynBusAttachment>) -> Result<ComPtr<AllJoynBusObject>> {
        <Self as RtActivatable<IAllJoynBusObjectFactory>>::get_activation_factory().create_with_bus_attachment(objectPath, busAttachment)
    }
}
DEFINE_CLSID!(AllJoynBusObject(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,79,98,106,101,99,116,0]) [CLSID_AllJoynBusObject]);
DEFINE_IID!(IID_IAllJoynBusObjectFactory, 741318411, 36354, 20380, 172, 39, 234, 109, 173, 93, 59, 80);
RT_INTERFACE!{static interface IAllJoynBusObjectFactory(IAllJoynBusObjectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectFactory] {
    fn Create(&self, objectPath: HSTRING, out: *mut *mut AllJoynBusObject) -> HRESULT,
    fn CreateWithBusAttachment(&self, objectPath: HSTRING, busAttachment: *mut AllJoynBusAttachment, out: *mut *mut AllJoynBusObject) -> HRESULT
}}
impl ComPtr<IAllJoynBusObjectFactory> {
    #[inline] pub fn create(&self, objectPath: &HStringArg) -> Result<ComPtr<AllJoynBusObject>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, objectPath.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_bus_attachment(&self, objectPath: &HStringArg, busAttachment: &ComPtr<AllJoynBusAttachment>) -> Result<ComPtr<AllJoynBusObject>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithBusAttachment)(self.deref() as *const _ as *mut _, objectPath.get(), busAttachment.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynBusObjectStoppedEventArgs, 3725598997, 61326, 19778, 185, 59, 162, 174, 116, 81, 151, 102);
RT_INTERFACE!{interface IAllJoynBusObjectStoppedEventArgs(IAllJoynBusObjectStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectStoppedEventArgs] {
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<IAllJoynBusObjectStoppedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynBusObjectStoppedEventArgs: IAllJoynBusObjectStoppedEventArgs}
impl RtActivatable<IAllJoynBusObjectStoppedEventArgsFactory> for AllJoynBusObjectStoppedEventArgs {}
impl AllJoynBusObjectStoppedEventArgs {
    #[inline] pub fn create(status: i32) -> Result<ComPtr<AllJoynBusObjectStoppedEventArgs>> {
        <Self as RtActivatable<IAllJoynBusObjectStoppedEventArgsFactory>>::get_activation_factory().create(status)
    }
}
DEFINE_CLSID!(AllJoynBusObjectStoppedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,66,117,115,79,98,106,101,99,116,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynBusObjectStoppedEventArgs]);
DEFINE_IID!(IID_IAllJoynBusObjectStoppedEventArgsFactory, 1797455176, 53411, 16981, 149, 58, 71, 114, 180, 2, 128, 115);
RT_INTERFACE!{static interface IAllJoynBusObjectStoppedEventArgsFactory(IAllJoynBusObjectStoppedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynBusObjectStoppedEventArgsFactory] {
    fn Create(&self, status: i32, out: *mut *mut AllJoynBusObjectStoppedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynBusObjectStoppedEventArgsFactory> {
    #[inline] pub fn create(&self, status: i32) -> Result<ComPtr<AllJoynBusObjectStoppedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynCredentials, 2185646322, 41360, 16561, 171, 171, 52, 158, 194, 68, 223, 170);
RT_INTERFACE!{interface IAllJoynCredentials(IAllJoynCredentialsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentials] {
    fn get_AuthenticationMechanism(&self, out: *mut AllJoynAuthenticationMechanism) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn get_Certificate(&self, out: *mut *mut super::super::security::cryptography::certificates::Certificate) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-security")] fn put_Certificate(&self, value: *mut super::super::security::cryptography::certificates::Certificate) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PasswordCredential(&self, out: *mut *mut super::super::security::credentials::PasswordCredential) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-security")] fn put_PasswordCredential(&self, value: *mut super::super::security::credentials::PasswordCredential) -> HRESULT,
    fn get_Timeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Timeout(&self, value: foundation::TimeSpan) -> HRESULT
}}
impl ComPtr<IAllJoynCredentials> {
    #[inline] pub fn get_authentication_mechanism(&self) -> Result<AllJoynAuthenticationMechanism> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationMechanism)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_certificate(&self) -> Result<Option<ComPtr<super::super::security::cryptography::certificates::Certificate>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Certificate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_certificate(&self, value: &ComPtr<super::super::security::cryptography::certificates::Certificate>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Certificate)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_password_credential(&self) -> Result<Option<ComPtr<super::super::security::credentials::PasswordCredential>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PasswordCredential)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_password_credential(&self, value: &ComPtr<super::super::security::credentials::PasswordCredential>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PasswordCredential)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Timeout)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynCredentials: IAllJoynCredentials}
DEFINE_IID!(IID_IAllJoynCredentialsRequestedEventArgs, 1787290446, 45161, 19328, 158, 26, 65, 188, 131, 124, 101, 210);
RT_INTERFACE!{interface IAllJoynCredentialsRequestedEventArgs(IAllJoynCredentialsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentialsRequestedEventArgs] {
    fn get_AttemptCount(&self, out: *mut u16) -> HRESULT,
    fn get_Credentials(&self, out: *mut *mut AllJoynCredentials) -> HRESULT,
    fn get_PeerUniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RequestedUserName(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IAllJoynCredentialsRequestedEventArgs> {
    #[inline] pub fn get_attempt_count(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttemptCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_credentials(&self) -> Result<Option<ComPtr<AllJoynCredentials>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Credentials)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_peer_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PeerUniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_user_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RequestedUserName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynCredentialsRequestedEventArgs: IAllJoynCredentialsRequestedEventArgs}
DEFINE_IID!(IID_IAllJoynCredentialsVerificationRequestedEventArgs, 2148169234, 47109, 17583, 162, 225, 121, 42, 182, 85, 162, 208);
RT_INTERFACE!{interface IAllJoynCredentialsVerificationRequestedEventArgs(IAllJoynCredentialsVerificationRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynCredentialsVerificationRequestedEventArgs] {
    fn get_AuthenticationMechanism(&self, out: *mut AllJoynAuthenticationMechanism) -> HRESULT,
    fn get_PeerUniqueName(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PeerCertificate(&self, out: *mut *mut super::super::security::cryptography::certificates::Certificate) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_PeerCertificateErrorSeverity(&self, out: *mut super::super::networking::sockets::SocketSslErrorSeverity) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PeerCertificateErrors(&self, out: *mut *mut foundation::collections::IVectorView<super::super::security::cryptography::certificates::ChainValidationResult>) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PeerIntermediateCertificates(&self, out: *mut *mut foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>) -> HRESULT,
    fn Accept(&self) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IAllJoynCredentialsVerificationRequestedEventArgs> {
    #[inline] pub fn get_authentication_mechanism(&self) -> Result<AllJoynAuthenticationMechanism> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationMechanism)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_peer_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PeerUniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_peer_certificate(&self) -> Result<Option<ComPtr<super::super::security::cryptography::certificates::Certificate>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PeerCertificate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_peer_certificate_error_severity(&self) -> Result<super::super::networking::sockets::SocketSslErrorSeverity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PeerCertificateErrorSeverity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_peer_certificate_errors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::security::cryptography::certificates::ChainValidationResult>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PeerCertificateErrors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_peer_intermediate_certificates(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PeerIntermediateCertificates)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Accept)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynCredentialsVerificationRequestedEventArgs: IAllJoynCredentialsVerificationRequestedEventArgs}
DEFINE_IID!(IID_IAllJoynMessageInfo, 4281008423, 11282, 18521, 170, 58, 199, 68, 97, 238, 129, 76);
RT_INTERFACE!{interface IAllJoynMessageInfo(IAllJoynMessageInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynMessageInfo] {
    fn get_SenderUniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAllJoynMessageInfo> {
    #[inline] pub fn get_sender_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SenderUniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynMessageInfo: IAllJoynMessageInfo}
impl RtActivatable<IAllJoynMessageInfoFactory> for AllJoynMessageInfo {}
impl AllJoynMessageInfo {
    #[inline] pub fn create(senderUniqueName: &HStringArg) -> Result<ComPtr<AllJoynMessageInfo>> {
        <Self as RtActivatable<IAllJoynMessageInfoFactory>>::get_activation_factory().create(senderUniqueName)
    }
}
DEFINE_CLSID!(AllJoynMessageInfo(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,77,101,115,115,97,103,101,73,110,102,111,0]) [CLSID_AllJoynMessageInfo]);
DEFINE_IID!(IID_IAllJoynMessageInfoFactory, 879119402, 33417, 17364, 180, 168, 63, 77, 227, 89, 240, 67);
RT_INTERFACE!{static interface IAllJoynMessageInfoFactory(IAllJoynMessageInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynMessageInfoFactory] {
    fn Create(&self, senderUniqueName: HSTRING, out: *mut *mut AllJoynMessageInfo) -> HRESULT
}}
impl ComPtr<IAllJoynMessageInfoFactory> {
    #[inline] pub fn create(&self, senderUniqueName: &HStringArg) -> Result<ComPtr<AllJoynMessageInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, senderUniqueName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynProducer, 2634565241, 18075, 18778, 167, 16, 172, 80, 241, 35, 6, 159);
RT_INTERFACE!{interface IAllJoynProducer(IAllJoynProducerVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynProducer] {
    fn SetBusObject(&self, busObject: *mut AllJoynBusObject) -> HRESULT
}}
impl ComPtr<IAllJoynProducer> {
    #[inline] pub fn set_bus_object(&self, busObject: &ComPtr<AllJoynBusObject>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetBusObject)(self.deref() as *const _ as *mut _, busObject.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynProducerStoppedEventArgs, 1362138992, 18743, 18733, 128, 128, 35, 100, 57, 152, 124, 235);
RT_INTERFACE!{interface IAllJoynProducerStoppedEventArgs(IAllJoynProducerStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynProducerStoppedEventArgs] {
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<IAllJoynProducerStoppedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynProducerStoppedEventArgs: IAllJoynProducerStoppedEventArgs}
impl RtActivatable<IAllJoynProducerStoppedEventArgsFactory> for AllJoynProducerStoppedEventArgs {}
impl AllJoynProducerStoppedEventArgs {
    #[inline] pub fn create(status: i32) -> Result<ComPtr<AllJoynProducerStoppedEventArgs>> {
        <Self as RtActivatable<IAllJoynProducerStoppedEventArgsFactory>>::get_activation_factory().create(status)
    }
}
DEFINE_CLSID!(AllJoynProducerStoppedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,80,114,111,100,117,99,101,114,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynProducerStoppedEventArgs]);
DEFINE_IID!(IID_IAllJoynProducerStoppedEventArgsFactory, 1448253793, 45593, 19822, 159, 120, 250, 63, 153, 250, 143, 229);
RT_INTERFACE!{static interface IAllJoynProducerStoppedEventArgsFactory(IAllJoynProducerStoppedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynProducerStoppedEventArgsFactory] {
    fn Create(&self, status: i32, out: *mut *mut AllJoynProducerStoppedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynProducerStoppedEventArgsFactory> {
    #[inline] pub fn create(&self, status: i32) -> Result<ComPtr<AllJoynProducerStoppedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynServiceInfo, 1287553545, 47422, 16770, 153, 155, 221, 208, 0, 249, 197, 117);
RT_INTERFACE!{interface IAllJoynServiceInfo(IAllJoynServiceInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfo] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ObjectPath(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SessionPort(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IAllJoynServiceInfo> {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_object_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ObjectPath)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_port(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SessionPort)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynServiceInfo: IAllJoynServiceInfo}
impl RtActivatable<IAllJoynServiceInfoFactory> for AllJoynServiceInfo {}
impl RtActivatable<IAllJoynServiceInfoStatics> for AllJoynServiceInfo {}
impl AllJoynServiceInfo {
    #[inline] pub fn create(uniqueName: &HStringArg, objectPath: &HStringArg, sessionPort: u16) -> Result<ComPtr<AllJoynServiceInfo>> {
        <Self as RtActivatable<IAllJoynServiceInfoFactory>>::get_activation_factory().create(uniqueName, objectPath, sessionPort)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynServiceInfo>>> {
        <Self as RtActivatable<IAllJoynServiceInfoStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(AllJoynServiceInfo(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,114,118,105,99,101,73,110,102,111,0]) [CLSID_AllJoynServiceInfo]);
DEFINE_IID!(IID_IAllJoynServiceInfoFactory, 1971444413, 65027, 20299, 148, 164, 240, 47, 220, 189, 17, 184);
RT_INTERFACE!{static interface IAllJoynServiceInfoFactory(IAllJoynServiceInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoFactory] {
    fn Create(&self, uniqueName: HSTRING, objectPath: HSTRING, sessionPort: u16, out: *mut *mut AllJoynServiceInfo) -> HRESULT
}}
impl ComPtr<IAllJoynServiceInfoFactory> {
    #[inline] pub fn create(&self, uniqueName: &HStringArg, objectPath: &HStringArg, sessionPort: u16) -> Result<ComPtr<AllJoynServiceInfo>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, uniqueName.get(), objectPath.get(), sessionPort, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynServiceInfoRemovedEventArgs, 811051359, 7487, 16883, 137, 105, 227, 39, 146, 98, 115, 150);
RT_INTERFACE!{interface IAllJoynServiceInfoRemovedEventArgs(IAllJoynServiceInfoRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoRemovedEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAllJoynServiceInfoRemovedEventArgs> {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynServiceInfoRemovedEventArgs: IAllJoynServiceInfoRemovedEventArgs}
impl RtActivatable<IAllJoynServiceInfoRemovedEventArgsFactory> for AllJoynServiceInfoRemovedEventArgs {}
impl AllJoynServiceInfoRemovedEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg) -> Result<ComPtr<AllJoynServiceInfoRemovedEventArgs>> {
        <Self as RtActivatable<IAllJoynServiceInfoRemovedEventArgsFactory>>::get_activation_factory().create(uniqueName)
    }
}
DEFINE_CLSID!(AllJoynServiceInfoRemovedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,114,118,105,99,101,73,110,102,111,82,101,109,111,118,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynServiceInfoRemovedEventArgs]);
DEFINE_IID!(IID_IAllJoynServiceInfoRemovedEventArgsFactory, 230655527, 39679, 18773, 146, 39, 105, 83, 186, 244, 21, 105);
RT_INTERFACE!{static interface IAllJoynServiceInfoRemovedEventArgsFactory(IAllJoynServiceInfoRemovedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoRemovedEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, out: *mut *mut AllJoynServiceInfoRemovedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynServiceInfoRemovedEventArgsFactory> {
    #[inline] pub fn create(&self, uniqueName: &HStringArg) -> Result<ComPtr<AllJoynServiceInfoRemovedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynServiceInfoStatics, 1450727178, 24634, 18940, 183, 80, 14, 241, 54, 9, 33, 60);
RT_INTERFACE!{static interface IAllJoynServiceInfoStatics(IAllJoynServiceInfoStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynServiceInfoStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<AllJoynServiceInfo>) -> HRESULT
}}
impl ComPtr<IAllJoynServiceInfoStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynServiceInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSession, 3906018060, 49364, 16492, 136, 169, 169, 62, 250, 133, 212, 177);
RT_INTERFACE!{interface IAllJoynSession(IAllJoynSessionVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSession] {
    fn get_Id(&self, out: *mut i32) -> HRESULT,
    fn get_Status(&self, out: *mut i32) -> HRESULT,
    fn RemoveMemberAsync(&self, uniqueName: HSTRING, out: *mut *mut foundation::IAsyncOperation<i32>) -> HRESULT,
    fn add_MemberAdded(&self, handler: *mut foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberAddedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MemberAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_MemberRemoved(&self, handler: *mut foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberRemovedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MemberRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Lost(&self, handler: *mut foundation::TypedEventHandler<AllJoynSession, AllJoynSessionLostEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Lost(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IAllJoynSession> {
    #[inline] pub fn get_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_member_async(&self, uniqueName: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RemoveMemberAsync)(self.deref() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_member_added(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberAddedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MemberAdded)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_member_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MemberAdded)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_member_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynSession, AllJoynSessionMemberRemovedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MemberRemoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_member_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MemberRemoved)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_lost(&self, handler: &ComPtr<foundation::TypedEventHandler<AllJoynSession, AllJoynSessionLostEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Lost)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_lost(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Lost)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSession: IAllJoynSession}
impl RtActivatable<IAllJoynSessionStatics> for AllJoynSession {}
impl AllJoynSession {
    #[inline] pub fn get_from_service_info_async(serviceInfo: &ComPtr<AllJoynServiceInfo>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynSession>>> {
        <Self as RtActivatable<IAllJoynSessionStatics>>::get_activation_factory().get_from_service_info_async(serviceInfo)
    }
    #[inline] pub fn get_from_service_info_and_bus_attachment_async(serviceInfo: &ComPtr<AllJoynServiceInfo>, busAttachment: &ComPtr<AllJoynBusAttachment>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynSession>>> {
        <Self as RtActivatable<IAllJoynSessionStatics>>::get_activation_factory().get_from_service_info_and_bus_attachment_async(serviceInfo, busAttachment)
    }
}
DEFINE_CLSID!(AllJoynSession(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,0]) [CLSID_AllJoynSession]);
DEFINE_IID!(IID_IAllJoynSessionJoinedEventArgs, 2661243856, 46551, 18373, 141, 171, 176, 64, 204, 25, 40, 113);
RT_INTERFACE!{interface IAllJoynSessionJoinedEventArgs(IAllJoynSessionJoinedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionJoinedEventArgs] {
    fn get_Session(&self, out: *mut *mut AllJoynSession) -> HRESULT
}}
impl ComPtr<IAllJoynSessionJoinedEventArgs> {
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<AllJoynSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionJoinedEventArgs: IAllJoynSessionJoinedEventArgs}
impl RtActivatable<IAllJoynSessionJoinedEventArgsFactory> for AllJoynSessionJoinedEventArgs {}
impl AllJoynSessionJoinedEventArgs {
    #[inline] pub fn create(session: &ComPtr<AllJoynSession>) -> Result<ComPtr<AllJoynSessionJoinedEventArgs>> {
        <Self as RtActivatable<IAllJoynSessionJoinedEventArgsFactory>>::get_activation_factory().create(session)
    }
}
DEFINE_CLSID!(AllJoynSessionJoinedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,74,111,105,110,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionJoinedEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionJoinedEventArgsFactory, 1747244681, 54987, 19870, 160, 158, 53, 128, 104, 112, 177, 127);
RT_INTERFACE!{static interface IAllJoynSessionJoinedEventArgsFactory(IAllJoynSessionJoinedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionJoinedEventArgsFactory] {
    fn Create(&self, session: *mut AllJoynSession, out: *mut *mut AllJoynSessionJoinedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynSessionJoinedEventArgsFactory> {
    #[inline] pub fn create(&self, session: &ComPtr<AllJoynSession>) -> Result<ComPtr<AllJoynSessionJoinedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, session.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSessionLostEventArgs, 3882263690, 35768, 18772, 174, 103, 210, 250, 67, 209, 249, 107);
RT_INTERFACE!{interface IAllJoynSessionLostEventArgs(IAllJoynSessionLostEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionLostEventArgs] {
    fn get_Reason(&self, out: *mut AllJoynSessionLostReason) -> HRESULT
}}
impl ComPtr<IAllJoynSessionLostEventArgs> {
    #[inline] pub fn get_reason(&self) -> Result<AllJoynSessionLostReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Reason)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionLostEventArgs: IAllJoynSessionLostEventArgs}
impl RtActivatable<IAllJoynSessionLostEventArgsFactory> for AllJoynSessionLostEventArgs {}
impl AllJoynSessionLostEventArgs {
    #[inline] pub fn create(reason: AllJoynSessionLostReason) -> Result<ComPtr<AllJoynSessionLostEventArgs>> {
        <Self as RtActivatable<IAllJoynSessionLostEventArgsFactory>>::get_activation_factory().create(reason)
    }
}
DEFINE_CLSID!(AllJoynSessionLostEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,76,111,115,116,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionLostEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionLostEventArgsFactory, 331087154, 54004, 18889, 152, 14, 40, 5, 225, 53, 134, 177);
RT_INTERFACE!{static interface IAllJoynSessionLostEventArgsFactory(IAllJoynSessionLostEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionLostEventArgsFactory] {
    fn Create(&self, reason: AllJoynSessionLostReason, out: *mut *mut AllJoynSessionLostEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynSessionLostEventArgsFactory> {
    #[inline] pub fn create(&self, reason: AllJoynSessionLostReason) -> Result<ComPtr<AllJoynSessionLostEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum AllJoynSessionLostReason: i32 {
    None = 0, ProducerLeftSession = 1, ProducerClosedAbruptly = 2, RemovedByProducer = 3, LinkTimeout = 4, Other = 5,
}}
DEFINE_IID!(IID_IAllJoynSessionMemberAddedEventArgs, 1235384714, 3537, 18113, 156, 214, 39, 25, 14, 80, 58, 94);
RT_INTERFACE!{interface IAllJoynSessionMemberAddedEventArgs(IAllJoynSessionMemberAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberAddedEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAllJoynSessionMemberAddedEventArgs> {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionMemberAddedEventArgs: IAllJoynSessionMemberAddedEventArgs}
impl RtActivatable<IAllJoynSessionMemberAddedEventArgsFactory> for AllJoynSessionMemberAddedEventArgs {}
impl AllJoynSessionMemberAddedEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg) -> Result<ComPtr<AllJoynSessionMemberAddedEventArgs>> {
        <Self as RtActivatable<IAllJoynSessionMemberAddedEventArgsFactory>>::get_activation_factory().create(uniqueName)
    }
}
DEFINE_CLSID!(AllJoynSessionMemberAddedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,77,101,109,98,101,114,65,100,100,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionMemberAddedEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionMemberAddedEventArgsFactory, 874373970, 7475, 16545, 161, 211, 229, 119, 112, 32, 225, 241);
RT_INTERFACE!{static interface IAllJoynSessionMemberAddedEventArgsFactory(IAllJoynSessionMemberAddedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberAddedEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, out: *mut *mut AllJoynSessionMemberAddedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynSessionMemberAddedEventArgsFactory> {
    #[inline] pub fn create(&self, uniqueName: &HStringArg) -> Result<ComPtr<AllJoynSessionMemberAddedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSessionMemberRemovedEventArgs, 1083842975, 43594, 18579, 180, 48, 186, 161, 182, 60, 98, 25);
RT_INTERFACE!{interface IAllJoynSessionMemberRemovedEventArgs(IAllJoynSessionMemberRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberRemovedEventArgs] {
    fn get_UniqueName(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAllJoynSessionMemberRemovedEventArgs> {
    #[inline] pub fn get_unique_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UniqueName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynSessionMemberRemovedEventArgs: IAllJoynSessionMemberRemovedEventArgs}
impl RtActivatable<IAllJoynSessionMemberRemovedEventArgsFactory> for AllJoynSessionMemberRemovedEventArgs {}
impl AllJoynSessionMemberRemovedEventArgs {
    #[inline] pub fn create(uniqueName: &HStringArg) -> Result<ComPtr<AllJoynSessionMemberRemovedEventArgs>> {
        <Self as RtActivatable<IAllJoynSessionMemberRemovedEventArgsFactory>>::get_activation_factory().create(uniqueName)
    }
}
DEFINE_CLSID!(AllJoynSessionMemberRemovedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,101,115,115,105,111,110,77,101,109,98,101,114,82,101,109,111,118,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynSessionMemberRemovedEventArgs]);
DEFINE_IID!(IID_IAllJoynSessionMemberRemovedEventArgsFactory, 3302184424, 17080, 19303, 183, 87, 208, 207, 202, 213, 146, 128);
RT_INTERFACE!{static interface IAllJoynSessionMemberRemovedEventArgsFactory(IAllJoynSessionMemberRemovedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionMemberRemovedEventArgsFactory] {
    fn Create(&self, uniqueName: HSTRING, out: *mut *mut AllJoynSessionMemberRemovedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynSessionMemberRemovedEventArgsFactory> {
    #[inline] pub fn create(&self, uniqueName: &HStringArg) -> Result<ComPtr<AllJoynSessionMemberRemovedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, uniqueName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAllJoynSessionStatics, 2651182596, 41068, 18132, 180, 108, 11, 11, 84, 16, 91, 68);
RT_INTERFACE!{static interface IAllJoynSessionStatics(IAllJoynSessionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynSessionStatics] {
    fn GetFromServiceInfoAsync(&self, serviceInfo: *mut AllJoynServiceInfo, out: *mut *mut foundation::IAsyncOperation<AllJoynSession>) -> HRESULT,
    fn GetFromServiceInfoAndBusAttachmentAsync(&self, serviceInfo: *mut AllJoynServiceInfo, busAttachment: *mut AllJoynBusAttachment, out: *mut *mut foundation::IAsyncOperation<AllJoynSession>) -> HRESULT
}}
impl ComPtr<IAllJoynSessionStatics> {
    #[inline] pub fn get_from_service_info_async(&self, serviceInfo: &ComPtr<AllJoynServiceInfo>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetFromServiceInfoAsync)(self.deref() as *const _ as *mut _, serviceInfo.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_from_service_info_and_bus_attachment_async(&self, serviceInfo: &ComPtr<AllJoynServiceInfo>, busAttachment: &ComPtr<AllJoynBusAttachment>) -> Result<ComPtr<foundation::IAsyncOperation<AllJoynSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetFromServiceInfoAndBusAttachmentAsync)(self.deref() as *const _ as *mut _, serviceInfo.deref() as *const _ as *mut _, busAttachment.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class AllJoynStatus}
impl RtActivatable<IAllJoynStatusStatics> for AllJoynStatus {}
impl AllJoynStatus {
    #[inline] pub fn get_ok() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_ok()
    }
    #[inline] pub fn get_fail() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_fail()
    }
    #[inline] pub fn get_operation_timed_out() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_operation_timed_out()
    }
    #[inline] pub fn get_other_end_closed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_other_end_closed()
    }
    #[inline] pub fn get_connection_refused() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_connection_refused()
    }
    #[inline] pub fn get_authentication_failed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_authentication_failed()
    }
    #[inline] pub fn get_authentication_rejected_by_user() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_authentication_rejected_by_user()
    }
    #[inline] pub fn get_ssl_connect_failed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_ssl_connect_failed()
    }
    #[inline] pub fn get_ssl_identity_verification_failed() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_ssl_identity_verification_failed()
    }
    #[inline] pub fn get_insufficient_security() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_insufficient_security()
    }
    #[inline] pub fn get_invalid_argument1() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument1()
    }
    #[inline] pub fn get_invalid_argument2() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument2()
    }
    #[inline] pub fn get_invalid_argument3() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument3()
    }
    #[inline] pub fn get_invalid_argument4() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument4()
    }
    #[inline] pub fn get_invalid_argument5() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument5()
    }
    #[inline] pub fn get_invalid_argument6() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument6()
    }
    #[inline] pub fn get_invalid_argument7() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument7()
    }
    #[inline] pub fn get_invalid_argument8() -> Result<i32> {
        <Self as RtActivatable<IAllJoynStatusStatics>>::get_activation_factory().get_invalid_argument8()
    }
}
DEFINE_CLSID!(AllJoynStatus(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,83,116,97,116,117,115,0]) [CLSID_AllJoynStatus]);
DEFINE_IID!(IID_IAllJoynStatusStatics, 3501695358, 3369, 19881, 138, 198, 84, 197, 84, 190, 219, 197);
RT_INTERFACE!{static interface IAllJoynStatusStatics(IAllJoynStatusStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynStatusStatics] {
    fn get_Ok(&self, out: *mut i32) -> HRESULT,
    fn get_Fail(&self, out: *mut i32) -> HRESULT,
    fn get_OperationTimedOut(&self, out: *mut i32) -> HRESULT,
    fn get_OtherEndClosed(&self, out: *mut i32) -> HRESULT,
    fn get_ConnectionRefused(&self, out: *mut i32) -> HRESULT,
    fn get_AuthenticationFailed(&self, out: *mut i32) -> HRESULT,
    fn get_AuthenticationRejectedByUser(&self, out: *mut i32) -> HRESULT,
    fn get_SslConnectFailed(&self, out: *mut i32) -> HRESULT,
    fn get_SslIdentityVerificationFailed(&self, out: *mut i32) -> HRESULT,
    fn get_InsufficientSecurity(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument1(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument2(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument3(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument4(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument5(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument6(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument7(&self, out: *mut i32) -> HRESULT,
    fn get_InvalidArgument8(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<IAllJoynStatusStatics> {
    #[inline] pub fn get_ok(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ok)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_fail(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Fail)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_operation_timed_out(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OperationTimedOut)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_other_end_closed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OtherEndClosed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_refused(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConnectionRefused)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_failed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationFailed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_rejected_by_user(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationRejectedByUser)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ssl_connect_failed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SslConnectFailed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ssl_identity_verification_failed(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SslIdentityVerificationFailed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_security(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InsufficientSecurity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument1(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument1)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument2(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument3(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument3)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument4(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument4)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument5(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument6(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument6)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument7(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument7)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_argument8(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidArgument8)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum AllJoynTrafficType: i32 {
    Unknown = 0, Messages = 1, RawUnreliable = 2, RawReliable = 4,
}}
DEFINE_IID!(IID_IAllJoynWatcherStoppedEventArgs, 3388776507, 28701, 19112, 151, 221, 162, 187, 10, 143, 95, 163);
RT_INTERFACE!{interface IAllJoynWatcherStoppedEventArgs(IAllJoynWatcherStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynWatcherStoppedEventArgs] {
    fn get_Status(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<IAllJoynWatcherStoppedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AllJoynWatcherStoppedEventArgs: IAllJoynWatcherStoppedEventArgs}
impl RtActivatable<IAllJoynWatcherStoppedEventArgsFactory> for AllJoynWatcherStoppedEventArgs {}
impl AllJoynWatcherStoppedEventArgs {
    #[inline] pub fn create(status: i32) -> Result<ComPtr<AllJoynWatcherStoppedEventArgs>> {
        <Self as RtActivatable<IAllJoynWatcherStoppedEventArgsFactory>>::get_activation_factory().create(status)
    }
}
DEFINE_CLSID!(AllJoynWatcherStoppedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,65,108,108,74,111,121,110,46,65,108,108,74,111,121,110,87,97,116,99,104,101,114,83,116,111,112,112,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_AllJoynWatcherStoppedEventArgs]);
DEFINE_IID!(IID_IAllJoynWatcherStoppedEventArgsFactory, 2274338216, 11600, 18401, 144, 74, 32, 191, 13, 72, 199, 130);
RT_INTERFACE!{static interface IAllJoynWatcherStoppedEventArgsFactory(IAllJoynWatcherStoppedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAllJoynWatcherStoppedEventArgsFactory] {
    fn Create(&self, status: i32, out: *mut *mut AllJoynWatcherStoppedEventArgs) -> HRESULT
}}
impl ComPtr<IAllJoynWatcherStoppedEventArgsFactory> {
    #[inline] pub fn create(&self, status: i32) -> Result<ComPtr<AllJoynWatcherStoppedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.AllJoyn
pub mod background { // Windows.Devices.Background
use crate::prelude::*;
DEFINE_IID!(IID_IDeviceServicingDetails, 1252781609, 9028, 19140, 133, 39, 74, 142, 246, 144, 86, 69);
RT_INTERFACE!{interface IDeviceServicingDetails(IDeviceServicingDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceServicingDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExpectedDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ComPtr<IDeviceServicingDetails> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Arguments)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expected_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExpectedDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceServicingDetails: IDeviceServicingDetails}
DEFINE_IID!(IID_IDeviceUseDetails, 2102808897, 21886, 16724, 185, 148, 228, 247, 161, 31, 179, 35);
RT_INTERFACE!{interface IDeviceUseDetails(IDeviceUseDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceUseDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IDeviceUseDetails> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_arguments(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Arguments)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceUseDetails: IDeviceUseDetails}
} // Windows.Devices.Background
pub mod bluetooth { // Windows.Devices.Bluetooth
use crate::prelude::*;
DEFINE_IID!(IID_IBluetoothAdapter, 2037706828, 24442, 18996, 146, 37, 168, 85, 248, 75, 26, 139);
RT_INTERFACE!{interface IBluetoothAdapter(IBluetoothAdapterVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothAdapter] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn get_IsClassicSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsLowEnergySupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPeripheralRoleSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsCentralRoleSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsAdvertisementOffloadSupported(&self, out: *mut bool) -> HRESULT,
    fn GetRadioAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::radios::Radio>) -> HRESULT
}}
impl ComPtr<IBluetoothAdapter> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluetoothAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_classic_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsClassicSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_low_energy_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsLowEnergySupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_peripheral_role_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPeripheralRoleSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_central_role_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCentralRoleSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_advertisement_offload_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsAdvertisementOffloadSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_radio_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::radios::Radio>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRadioAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothAdapter: IBluetoothAdapter}
impl RtActivatable<IBluetoothAdapterStatics> for BluetoothAdapter {}
impl BluetoothAdapter {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBluetoothAdapterStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothAdapter>>> {
        <Self as RtActivatable<IBluetoothAdapterStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<BluetoothAdapter>>> {
        <Self as RtActivatable<IBluetoothAdapterStatics>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(BluetoothAdapter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,65,100,97,112,116,101,114,0]) [CLSID_BluetoothAdapter]);
DEFINE_IID!(IID_IBluetoothAdapter2, 2895433420, 9429, 16819, 145, 109, 16, 151, 197, 11, 16, 43);
RT_INTERFACE!{interface IBluetoothAdapter2(IBluetoothAdapter2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothAdapter2] {
    fn get_AreClassicSecureConnectionsSupported(&self, out: *mut bool) -> HRESULT,
    fn get_AreLowEnergySecureConnectionsSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBluetoothAdapter2> {
    #[inline] pub fn get_are_classic_secure_connections_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AreClassicSecureConnectionsSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_are_low_energy_secure_connections_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AreLowEnergySecureConnectionsSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothAdapterStatics, 2332228458, 44108, 18241, 134, 97, 142, 171, 125, 23, 234, 159);
RT_INTERFACE!{static interface IBluetoothAdapterStatics(IBluetoothAdapterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothAdapterStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<BluetoothAdapter>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<BluetoothAdapter>) -> HRESULT
}}
impl ComPtr<IBluetoothAdapterStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothAddressType: i32 {
    Public = 0, Random = 1, Unspecified = 2,
}}
RT_ENUM! { enum BluetoothCacheMode: i32 {
    Cached = 0, Uncached = 1,
}}
DEFINE_IID!(IID_IBluetoothClassOfDevice, 3594527358, 55255, 18017, 148, 84, 101, 3, 156, 161, 122, 43);
RT_INTERFACE!{interface IBluetoothClassOfDevice(IBluetoothClassOfDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothClassOfDevice] {
    fn get_RawValue(&self, out: *mut u32) -> HRESULT,
    fn get_MajorClass(&self, out: *mut BluetoothMajorClass) -> HRESULT,
    fn get_MinorClass(&self, out: *mut BluetoothMinorClass) -> HRESULT,
    fn get_ServiceCapabilities(&self, out: *mut BluetoothServiceCapabilities) -> HRESULT
}}
impl ComPtr<IBluetoothClassOfDevice> {
    #[inline] pub fn get_raw_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RawValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_major_class(&self) -> Result<BluetoothMajorClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MajorClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_minor_class(&self) -> Result<BluetoothMinorClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinorClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_capabilities(&self) -> Result<BluetoothServiceCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceCapabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothClassOfDevice: IBluetoothClassOfDevice}
impl RtActivatable<IBluetoothClassOfDeviceStatics> for BluetoothClassOfDevice {}
impl BluetoothClassOfDevice {
    #[inline] pub fn from_raw_value(rawValue: u32) -> Result<Option<ComPtr<BluetoothClassOfDevice>>> {
        <Self as RtActivatable<IBluetoothClassOfDeviceStatics>>::get_activation_factory().from_raw_value(rawValue)
    }
    #[inline] pub fn from_parts(majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities) -> Result<Option<ComPtr<BluetoothClassOfDevice>>> {
        <Self as RtActivatable<IBluetoothClassOfDeviceStatics>>::get_activation_factory().from_parts(majorClass, minorClass, serviceCapabilities)
    }
}
DEFINE_CLSID!(BluetoothClassOfDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,67,108,97,115,115,79,102,68,101,118,105,99,101,0]) [CLSID_BluetoothClassOfDevice]);
DEFINE_IID!(IID_IBluetoothClassOfDeviceStatics, 3831575997, 4002, 16748, 145, 180, 193, 228, 140, 160, 97, 193);
RT_INTERFACE!{static interface IBluetoothClassOfDeviceStatics(IBluetoothClassOfDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothClassOfDeviceStatics] {
    fn FromRawValue(&self, rawValue: u32, out: *mut *mut BluetoothClassOfDevice) -> HRESULT,
    fn FromParts(&self, majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities, out: *mut *mut BluetoothClassOfDevice) -> HRESULT
}}
impl ComPtr<IBluetoothClassOfDeviceStatics> {
    #[inline] pub fn from_raw_value(&self, rawValue: u32) -> Result<Option<ComPtr<BluetoothClassOfDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromRawValue)(self.deref() as *const _ as *mut _, rawValue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_parts(&self, majorClass: BluetoothMajorClass, minorClass: BluetoothMinorClass, serviceCapabilities: BluetoothServiceCapabilities) -> Result<Option<ComPtr<BluetoothClassOfDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromParts)(self.deref() as *const _ as *mut _, majorClass, minorClass, serviceCapabilities, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothConnectionStatus: i32 {
    Disconnected = 0, Connected = 1,
}}
DEFINE_IID!(IID_IBluetoothDevice, 590721366, 37074, 18948, 174, 245, 14, 32, 185, 230, 183, 7);
RT_INTERFACE!{interface IBluetoothDevice(IBluetoothDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_HostName(&self, out: *mut *mut super::super::networking::HostName) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ClassOfDevice(&self, out: *mut *mut BluetoothClassOfDevice) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SdpRecords(&self, out: *mut *mut foundation::collections::IVectorView<super::super::storage::streams::IBuffer>) -> HRESULT,
    fn get_RfcommServices(&self, out: *mut *mut foundation::collections::IVectorView<rfcomm::RfcommDeviceService>) -> HRESULT,
    fn get_ConnectionStatus(&self, out: *mut BluetoothConnectionStatus) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn add_NameChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NameChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SdpRecordsChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SdpRecordsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ConnectionStatusChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBluetoothDevice> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_host_name(&self) -> Result<Option<ComPtr<super::super::networking::HostName>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HostName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_class_of_device(&self) -> Result<Option<ComPtr<BluetoothClassOfDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ClassOfDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_records(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::storage::streams::IBuffer>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SdpRecords)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<rfcomm::RfcommDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RfcommServices)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_status(&self) -> Result<BluetoothConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConnectionStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluetoothAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_name_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_NameChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_name_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_NameChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sdp_records_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SdpRecordsChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sdp_records_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SdpRecordsChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ConnectionStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ConnectionStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothDevice: IBluetoothDevice}
impl RtActivatable<IBluetoothDeviceStatics> for BluetoothDevice {}
impl RtActivatable<IBluetoothDeviceStatics2> for BluetoothDevice {}
impl BluetoothDevice {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothDevice>>> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[cfg(feature="windows-networking")] #[inline] pub fn from_host_name_async(hostName: &ComPtr<super::super::networking::HostName>) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothDevice>>> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().from_host_name_async(hostName)
    }
    #[inline] pub fn from_bluetooth_address_async(address: u64) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothDevice>>> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().from_bluetooth_address_async(address)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_pairing_state(pairingState: bool) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_pairing_state(pairingState)
    }
    #[inline] pub fn get_device_selector_from_connection_status(connectionStatus: BluetoothConnectionStatus) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_connection_status(connectionStatus)
    }
    #[inline] pub fn get_device_selector_from_device_name(deviceName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_device_name(deviceName)
    }
    #[inline] pub fn get_device_selector_from_bluetooth_address(bluetoothAddress: u64) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_bluetooth_address(bluetoothAddress)
    }
    #[inline] pub fn get_device_selector_from_class_of_device(classOfDevice: &ComPtr<BluetoothClassOfDevice>) -> Result<HString> {
        <Self as RtActivatable<IBluetoothDeviceStatics2>>::get_activation_factory().get_device_selector_from_class_of_device(classOfDevice)
    }
}
DEFINE_CLSID!(BluetoothDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,68,101,118,105,99,101,0]) [CLSID_BluetoothDevice]);
DEFINE_IID!(IID_IBluetoothDevice2, 20183380, 45398, 19920, 177, 245, 193, 27, 195, 26, 81, 99);
RT_INTERFACE!{interface IBluetoothDevice2(IBluetoothDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice2] {
    fn get_DeviceInformation(&self, out: *mut *mut super::enumeration::DeviceInformation) -> HRESULT
}}
impl ComPtr<IBluetoothDevice2> {
    #[inline] pub fn get_device_information(&self) -> Result<Option<ComPtr<super::enumeration::DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDevice3, 1476392843, 25882, 17492, 185, 15, 235, 33, 239, 11, 13, 113);
RT_INTERFACE!{interface IBluetoothDevice3(IBluetoothDevice3Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice3] {
    fn get_DeviceAccessInformation(&self, out: *mut *mut super::enumeration::DeviceAccessInformation) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>) -> HRESULT,
    fn GetRfcommServicesAsync(&self, out: *mut *mut foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> HRESULT,
    fn GetRfcommServicesWithCacheModeAsync(&self, cacheMode: BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> HRESULT,
    fn GetRfcommServicesForIdAsync(&self, serviceId: *mut rfcomm::RfcommServiceId, out: *mut *mut foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> HRESULT,
    fn GetRfcommServicesForIdWithCacheModeAsync(&self, serviceId: *mut rfcomm::RfcommServiceId, cacheMode: BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>) -> HRESULT
}}
impl ComPtr<IBluetoothDevice3> {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<ComPtr<super::enumeration::DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceAccessInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRfcommServicesAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_with_cache_mode_async(&self, cacheMode: BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRfcommServicesWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_for_id_async(&self, serviceId: &ComPtr<rfcomm::RfcommServiceId>) -> Result<ComPtr<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRfcommServicesForIdAsync)(self.deref() as *const _ as *mut _, serviceId.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_rfcomm_services_for_id_with_cache_mode_async(&self, serviceId: &ComPtr<rfcomm::RfcommServiceId>, cacheMode: BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<rfcomm::RfcommDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRfcommServicesForIdWithCacheModeAsync)(self.deref() as *const _ as *mut _, serviceId.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDevice4, 2172400813, 3740, 17074, 168, 220, 62, 128, 148, 148, 13, 18);
RT_INTERFACE!{interface IBluetoothDevice4(IBluetoothDevice4Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice4] {
    fn get_BluetoothDeviceId(&self, out: *mut *mut BluetoothDeviceId) -> HRESULT
}}
impl ComPtr<IBluetoothDevice4> {
    #[inline] pub fn get_bluetooth_device_id(&self) -> Result<Option<ComPtr<BluetoothDeviceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BluetoothDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDevice5, 3051402117, 24197, 17753, 161, 13, 28, 114, 129, 55, 159, 150);
RT_INTERFACE!{interface IBluetoothDevice5(IBluetoothDevice5Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDevice5] {
    fn get_WasSecureConnectionUsedForPairing(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBluetoothDevice5> {
    #[inline] pub fn get_was_secure_connection_used_for_pairing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WasSecureConnectionUsedForPairing)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDeviceId, 3245951407, 22465, 17986, 188, 206, 230, 192, 107, 32, 174, 118);
RT_INTERFACE!{interface IBluetoothDeviceId(IBluetoothDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceId] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsClassicDevice(&self, out: *mut bool) -> HRESULT,
    fn get_IsLowEnergyDevice(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBluetoothDeviceId> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_classic_device(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsClassicDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_low_energy_device(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsLowEnergyDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothDeviceId: IBluetoothDeviceId}
impl RtActivatable<IBluetoothDeviceIdStatics> for BluetoothDeviceId {}
impl BluetoothDeviceId {
    #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<ComPtr<BluetoothDeviceId>>> {
        <Self as RtActivatable<IBluetoothDeviceIdStatics>>::get_activation_factory().from_id(deviceId)
    }
}
DEFINE_CLSID!(BluetoothDeviceId(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,68,101,118,105,99,101,73,100,0]) [CLSID_BluetoothDeviceId]);
DEFINE_IID!(IID_IBluetoothDeviceIdStatics, 2810728039, 16123, 20273, 187, 194, 129, 14, 9, 151, 116, 4);
RT_INTERFACE!{static interface IBluetoothDeviceIdStatics(IBluetoothDeviceIdStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceIdStatics] {
    fn FromId(&self, deviceId: HSTRING, out: *mut *mut BluetoothDeviceId) -> HRESULT
}}
impl ComPtr<IBluetoothDeviceIdStatics> {
    #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<ComPtr<BluetoothDeviceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromId)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDeviceStatics, 160554833, 22491, 18213, 187, 215, 132, 246, 67, 39, 236, 44);
RT_INTERFACE!{static interface IBluetoothDeviceStatics(IBluetoothDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<BluetoothDevice>) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-networking")] fn FromHostNameAsync(&self, hostName: *mut super::super::networking::HostName, out: *mut *mut foundation::IAsyncOperation<BluetoothDevice>) -> HRESULT,
    fn FromBluetoothAddressAsync(&self, address: u64, out: *mut *mut foundation::IAsyncOperation<BluetoothDevice>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBluetoothDeviceStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn from_host_name_async(&self, hostName: &ComPtr<super::super::networking::HostName>) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromHostNameAsync)(self.deref() as *const _ as *mut _, hostName.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_bluetooth_address_async(&self, address: u64) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromBluetoothAddressAsync)(self.deref() as *const _ as *mut _, address, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothDeviceStatics2, 3265170991, 19988, 17527, 170, 27, 184, 180, 126, 91, 126, 206);
RT_INTERFACE!{static interface IBluetoothDeviceStatics2(IBluetoothDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothDeviceStatics2] {
    fn GetDeviceSelectorFromPairingState(&self, pairingState: bool, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromConnectionStatus(&self, connectionStatus: BluetoothConnectionStatus, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromDeviceName(&self, deviceName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromBluetoothAddress(&self, bluetoothAddress: u64, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromClassOfDevice(&self, classOfDevice: *mut BluetoothClassOfDevice, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBluetoothDeviceStatics2> {
    #[inline] pub fn get_device_selector_from_pairing_state(&self, pairingState: bool) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromPairingState)(self.deref() as *const _ as *mut _, pairingState, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_connection_status(&self, connectionStatus: BluetoothConnectionStatus) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromConnectionStatus)(self.deref() as *const _ as *mut _, connectionStatus, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_device_name(&self, deviceName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromDeviceName)(self.deref() as *const _ as *mut _, deviceName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_bluetooth_address(&self, bluetoothAddress: u64) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromBluetoothAddress)(self.deref() as *const _ as *mut _, bluetoothAddress, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_class_of_device(&self, classOfDevice: &ComPtr<BluetoothClassOfDevice>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromClassOfDevice)(self.deref() as *const _ as *mut _, classOfDevice.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothError: i32 {
    Success = 0, RadioNotAvailable = 1, ResourceInUse = 2, DeviceNotConnected = 3, OtherError = 4, DisabledByPolicy = 5, NotSupported = 6, DisabledByUser = 7, ConsentRequired = 8, TransportNotSupported = 9,
}}
DEFINE_IID!(IID_IBluetoothLEAppearance, 1562409458, 26280, 16984, 152, 94, 2, 180, 217, 80, 159, 24);
RT_INTERFACE!{interface IBluetoothLEAppearance(IBluetoothLEAppearanceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearance] {
    fn get_RawValue(&self, out: *mut u16) -> HRESULT,
    fn get_Category(&self, out: *mut u16) -> HRESULT,
    fn get_SubCategory(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IBluetoothLEAppearance> {
    #[inline] pub fn get_raw_value(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RawValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_category(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Category)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sub_category(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SubCategory)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAppearance: IBluetoothLEAppearance}
impl RtActivatable<IBluetoothLEAppearanceStatics> for BluetoothLEAppearance {}
impl BluetoothLEAppearance {
    #[inline] pub fn from_raw_value(rawValue: u16) -> Result<Option<ComPtr<BluetoothLEAppearance>>> {
        <Self as RtActivatable<IBluetoothLEAppearanceStatics>>::get_activation_factory().from_raw_value(rawValue)
    }
    #[inline] pub fn from_parts(appearanceCategory: u16, appearanceSubCategory: u16) -> Result<Option<ComPtr<BluetoothLEAppearance>>> {
        <Self as RtActivatable<IBluetoothLEAppearanceStatics>>::get_activation_factory().from_parts(appearanceCategory, appearanceSubCategory)
    }
}
DEFINE_CLSID!(BluetoothLEAppearance(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,0]) [CLSID_BluetoothLEAppearance]);
RT_CLASS!{static class BluetoothLEAppearanceCategories}
impl RtActivatable<IBluetoothLEAppearanceCategoriesStatics> for BluetoothLEAppearanceCategories {}
impl BluetoothLEAppearanceCategories {
    #[inline] pub fn get_uncategorized() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_uncategorized()
    }
    #[inline] pub fn get_phone() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_phone()
    }
    #[inline] pub fn get_computer() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_computer()
    }
    #[inline] pub fn get_watch() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_watch()
    }
    #[inline] pub fn get_clock() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_clock()
    }
    #[inline] pub fn get_display() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_display()
    }
    #[inline] pub fn get_remote_control() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_remote_control()
    }
    #[inline] pub fn get_eye_glasses() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_eye_glasses()
    }
    #[inline] pub fn get_tag() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_tag()
    }
    #[inline] pub fn get_keyring() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_keyring()
    }
    #[inline] pub fn get_media_player() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_media_player()
    }
    #[inline] pub fn get_barcode_scanner() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_barcode_scanner()
    }
    #[inline] pub fn get_thermometer() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_thermometer()
    }
    #[inline] pub fn get_heart_rate() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_heart_rate()
    }
    #[inline] pub fn get_blood_pressure() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_blood_pressure()
    }
    #[inline] pub fn get_human_interface_device() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_human_interface_device()
    }
    #[inline] pub fn get_glucose_meter() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_glucose_meter()
    }
    #[inline] pub fn get_running_walking() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_running_walking()
    }
    #[inline] pub fn get_cycling() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_cycling()
    }
    #[inline] pub fn get_pulse_oximeter() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_pulse_oximeter()
    }
    #[inline] pub fn get_weight_scale() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_weight_scale()
    }
    #[inline] pub fn get_outdoor_sport_activity() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceCategoriesStatics>>::get_activation_factory().get_outdoor_sport_activity()
    }
}
DEFINE_CLSID!(BluetoothLEAppearanceCategories(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,67,97,116,101,103,111,114,105,101,115,0]) [CLSID_BluetoothLEAppearanceCategories]);
DEFINE_IID!(IID_IBluetoothLEAppearanceCategoriesStatics, 1833784574, 1130, 16773, 170, 182, 130, 76, 240, 97, 8, 97);
RT_INTERFACE!{static interface IBluetoothLEAppearanceCategoriesStatics(IBluetoothLEAppearanceCategoriesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceCategoriesStatics] {
    fn get_Uncategorized(&self, out: *mut u16) -> HRESULT,
    fn get_Phone(&self, out: *mut u16) -> HRESULT,
    fn get_Computer(&self, out: *mut u16) -> HRESULT,
    fn get_Watch(&self, out: *mut u16) -> HRESULT,
    fn get_Clock(&self, out: *mut u16) -> HRESULT,
    fn get_Display(&self, out: *mut u16) -> HRESULT,
    fn get_RemoteControl(&self, out: *mut u16) -> HRESULT,
    fn get_EyeGlasses(&self, out: *mut u16) -> HRESULT,
    fn get_Tag(&self, out: *mut u16) -> HRESULT,
    fn get_Keyring(&self, out: *mut u16) -> HRESULT,
    fn get_MediaPlayer(&self, out: *mut u16) -> HRESULT,
    fn get_BarcodeScanner(&self, out: *mut u16) -> HRESULT,
    fn get_Thermometer(&self, out: *mut u16) -> HRESULT,
    fn get_HeartRate(&self, out: *mut u16) -> HRESULT,
    fn get_BloodPressure(&self, out: *mut u16) -> HRESULT,
    fn get_HumanInterfaceDevice(&self, out: *mut u16) -> HRESULT,
    fn get_GlucoseMeter(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalking(&self, out: *mut u16) -> HRESULT,
    fn get_Cycling(&self, out: *mut u16) -> HRESULT,
    fn get_PulseOximeter(&self, out: *mut u16) -> HRESULT,
    fn get_WeightScale(&self, out: *mut u16) -> HRESULT,
    fn get_OutdoorSportActivity(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IBluetoothLEAppearanceCategoriesStatics> {
    #[inline] pub fn get_uncategorized(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uncategorized)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phone(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Phone)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_computer(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Computer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_watch(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Watch)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_clock(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Clock)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Display)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_control(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RemoteControl)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eye_glasses(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EyeGlasses)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tag(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Tag)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_keyring(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Keyring)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_media_player(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MediaPlayer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_barcode_scanner(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BarcodeScanner)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thermometer(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Thermometer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeartRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BloodPressure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_human_interface_device(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HumanInterfaceDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_meter(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GlucoseMeter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RunningWalking)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Cycling)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pulse_oximeter(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PulseOximeter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_weight_scale(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WeightScale)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_outdoor_sport_activity(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OutdoorSportActivity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEAppearanceStatics, 2710814919, 17668, 20298, 155, 165, 205, 16, 84, 229, 224, 101);
RT_INTERFACE!{static interface IBluetoothLEAppearanceStatics(IBluetoothLEAppearanceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceStatics] {
    fn FromRawValue(&self, rawValue: u16, out: *mut *mut BluetoothLEAppearance) -> HRESULT,
    fn FromParts(&self, appearanceCategory: u16, appearanceSubCategory: u16, out: *mut *mut BluetoothLEAppearance) -> HRESULT
}}
impl ComPtr<IBluetoothLEAppearanceStatics> {
    #[inline] pub fn from_raw_value(&self, rawValue: u16) -> Result<Option<ComPtr<BluetoothLEAppearance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromRawValue)(self.deref() as *const _ as *mut _, rawValue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_parts(&self, appearanceCategory: u16, appearanceSubCategory: u16) -> Result<Option<ComPtr<BluetoothLEAppearance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromParts)(self.deref() as *const _ as *mut _, appearanceCategory, appearanceSubCategory, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class BluetoothLEAppearanceSubcategories}
impl RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics> for BluetoothLEAppearanceSubcategories {}
impl BluetoothLEAppearanceSubcategories {
    #[inline] pub fn get_generic() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_generic()
    }
    #[inline] pub fn get_sports_watch() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_sports_watch()
    }
    #[inline] pub fn get_thermometer_ear() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_thermometer_ear()
    }
    #[inline] pub fn get_heart_rate_belt() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_heart_rate_belt()
    }
    #[inline] pub fn get_blood_pressure_arm() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_blood_pressure_arm()
    }
    #[inline] pub fn get_blood_pressure_wrist() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_blood_pressure_wrist()
    }
    #[inline] pub fn get_keyboard() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_keyboard()
    }
    #[inline] pub fn get_mouse() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_mouse()
    }
    #[inline] pub fn get_joystick() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_joystick()
    }
    #[inline] pub fn get_gamepad() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_gamepad()
    }
    #[inline] pub fn get_digitizer_tablet() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_digitizer_tablet()
    }
    #[inline] pub fn get_card_reader() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_card_reader()
    }
    #[inline] pub fn get_digital_pen() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_digital_pen()
    }
    #[inline] pub fn get_barcode_scanner() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_barcode_scanner()
    }
    #[inline] pub fn get_running_walking_in_shoe() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_running_walking_in_shoe()
    }
    #[inline] pub fn get_running_walking_on_shoe() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_running_walking_on_shoe()
    }
    #[inline] pub fn get_running_walking_on_hip() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_running_walking_on_hip()
    }
    #[inline] pub fn get_cycling_computer() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_computer()
    }
    #[inline] pub fn get_cycling_speed_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_speed_sensor()
    }
    #[inline] pub fn get_cycling_cadence_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_cadence_sensor()
    }
    #[inline] pub fn get_cycling_power_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_power_sensor()
    }
    #[inline] pub fn get_cycling_speed_cadence_sensor() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_cycling_speed_cadence_sensor()
    }
    #[inline] pub fn get_oximeter_fingertip() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_oximeter_fingertip()
    }
    #[inline] pub fn get_oximeter_wrist_worn() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_oximeter_wrist_worn()
    }
    #[inline] pub fn get_location_display() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_display()
    }
    #[inline] pub fn get_location_navigation_display() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_navigation_display()
    }
    #[inline] pub fn get_location_pod() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_pod()
    }
    #[inline] pub fn get_location_navigation_pod() -> Result<u16> {
        <Self as RtActivatable<IBluetoothLEAppearanceSubcategoriesStatics>>::get_activation_factory().get_location_navigation_pod()
    }
}
DEFINE_CLSID!(BluetoothLEAppearanceSubcategories(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,65,112,112,101,97,114,97,110,99,101,83,117,98,99,97,116,101,103,111,114,105,101,115,0]) [CLSID_BluetoothLEAppearanceSubcategories]);
DEFINE_IID!(IID_IBluetoothLEAppearanceSubcategoriesStatics, 3850085894, 8516, 16730, 131, 18, 113, 204, 242, 145, 248, 209);
RT_INTERFACE!{static interface IBluetoothLEAppearanceSubcategoriesStatics(IBluetoothLEAppearanceSubcategoriesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAppearanceSubcategoriesStatics] {
    fn get_Generic(&self, out: *mut u16) -> HRESULT,
    fn get_SportsWatch(&self, out: *mut u16) -> HRESULT,
    fn get_ThermometerEar(&self, out: *mut u16) -> HRESULT,
    fn get_HeartRateBelt(&self, out: *mut u16) -> HRESULT,
    fn get_BloodPressureArm(&self, out: *mut u16) -> HRESULT,
    fn get_BloodPressureWrist(&self, out: *mut u16) -> HRESULT,
    fn get_Keyboard(&self, out: *mut u16) -> HRESULT,
    fn get_Mouse(&self, out: *mut u16) -> HRESULT,
    fn get_Joystick(&self, out: *mut u16) -> HRESULT,
    fn get_Gamepad(&self, out: *mut u16) -> HRESULT,
    fn get_DigitizerTablet(&self, out: *mut u16) -> HRESULT,
    fn get_CardReader(&self, out: *mut u16) -> HRESULT,
    fn get_DigitalPen(&self, out: *mut u16) -> HRESULT,
    fn get_BarcodeScanner(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalkingInShoe(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalkingOnShoe(&self, out: *mut u16) -> HRESULT,
    fn get_RunningWalkingOnHip(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingComputer(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingSpeedSensor(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingCadenceSensor(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingPowerSensor(&self, out: *mut u16) -> HRESULT,
    fn get_CyclingSpeedCadenceSensor(&self, out: *mut u16) -> HRESULT,
    fn get_OximeterFingertip(&self, out: *mut u16) -> HRESULT,
    fn get_OximeterWristWorn(&self, out: *mut u16) -> HRESULT,
    fn get_LocationDisplay(&self, out: *mut u16) -> HRESULT,
    fn get_LocationNavigationDisplay(&self, out: *mut u16) -> HRESULT,
    fn get_LocationPod(&self, out: *mut u16) -> HRESULT,
    fn get_LocationNavigationPod(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IBluetoothLEAppearanceSubcategoriesStatics> {
    #[inline] pub fn get_generic(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Generic)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sports_watch(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SportsWatch)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_thermometer_ear(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ThermometerEar)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate_belt(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeartRateBelt)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_arm(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BloodPressureArm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_wrist(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BloodPressureWrist)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_keyboard(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Keyboard)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mouse(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Mouse)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_joystick(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Joystick)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gamepad(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gamepad)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_digitizer_tablet(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DigitizerTablet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_card_reader(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CardReader)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_digital_pen(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DigitalPen)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_barcode_scanner(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BarcodeScanner)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking_in_shoe(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RunningWalkingInShoe)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking_on_shoe(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RunningWalkingOnShoe)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_walking_on_hip(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RunningWalkingOnHip)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_computer(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingComputer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_speed_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingSpeedSensor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_cadence_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingCadenceSensor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingPowerSensor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_speed_cadence_sensor(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingSpeedCadenceSensor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_oximeter_fingertip(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OximeterFingertip)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_oximeter_wrist_worn(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OximeterWristWorn)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_display(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationDisplay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_navigation_display(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationNavigationDisplay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_pod(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationPod)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_navigation_pod(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationNavigationPod)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice, 3052285819, 19160, 17986, 172, 72, 128, 160, 181, 0, 232, 135);
RT_INTERFACE!{interface IBluetoothLEDevice(IBluetoothLEDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_GattServices(&self, out: *mut *mut foundation::collections::IVectorView<genericattributeprofile::GattDeviceService>) -> HRESULT,
    fn get_ConnectionStatus(&self, out: *mut BluetoothConnectionStatus) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn GetGattService(&self, serviceUuid: Guid, out: *mut *mut genericattributeprofile::GattDeviceService) -> HRESULT,
    fn add_NameChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NameChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GattServicesChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GattServicesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ConnectionStatusChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBluetoothLEDevice> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<genericattributeprofile::GattDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_GattServices)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_status(&self) -> Result<BluetoothConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConnectionStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluetoothAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_service(&self, serviceUuid: Guid) -> Result<Option<ComPtr<genericattributeprofile::GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGattService)(self.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_name_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_NameChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_name_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_NameChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_gatt_services_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_GattServicesChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gatt_services_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_GattServicesChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothLEDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ConnectionStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ConnectionStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEDevice: IBluetoothLEDevice}
impl RtActivatable<IBluetoothLEDeviceStatics> for BluetoothLEDevice {}
impl RtActivatable<IBluetoothLEDeviceStatics2> for BluetoothLEDevice {}
impl BluetoothLEDevice {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothLEDevice>>> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn from_bluetooth_address_async(bluetoothAddress: u64) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothLEDevice>>> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics>>::get_activation_factory().from_bluetooth_address_async(bluetoothAddress)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_pairing_state(pairingState: bool) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_pairing_state(pairingState)
    }
    #[inline] pub fn get_device_selector_from_connection_status(connectionStatus: BluetoothConnectionStatus) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_connection_status(connectionStatus)
    }
    #[inline] pub fn get_device_selector_from_device_name(deviceName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_device_name(deviceName)
    }
    #[inline] pub fn get_device_selector_from_bluetooth_address(bluetoothAddress: u64) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_bluetooth_address(bluetoothAddress)
    }
    #[inline] pub fn get_device_selector_from_bluetooth_address_with_bluetooth_address_type(bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_bluetooth_address_with_bluetooth_address_type(bluetoothAddress, bluetoothAddressType)
    }
    #[inline] pub fn get_device_selector_from_appearance(appearance: &ComPtr<BluetoothLEAppearance>) -> Result<HString> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().get_device_selector_from_appearance(appearance)
    }
    #[inline] pub fn from_bluetooth_address_with_bluetooth_address_type_async(bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothLEDevice>>> {
        <Self as RtActivatable<IBluetoothLEDeviceStatics2>>::get_activation_factory().from_bluetooth_address_with_bluetooth_address_type_async(bluetoothAddress, bluetoothAddressType)
    }
}
DEFINE_CLSID!(BluetoothLEDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,76,69,68,101,118,105,99,101,0]) [CLSID_BluetoothLEDevice]);
DEFINE_IID!(IID_IBluetoothLEDevice2, 653288115, 31470, 19761, 186, 186, 177, 185, 119, 95, 89, 22);
RT_INTERFACE!{interface IBluetoothLEDevice2(IBluetoothLEDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice2] {
    fn get_DeviceInformation(&self, out: *mut *mut super::enumeration::DeviceInformation) -> HRESULT,
    fn get_Appearance(&self, out: *mut *mut BluetoothLEAppearance) -> HRESULT,
    fn get_BluetoothAddressType(&self, out: *mut BluetoothAddressType) -> HRESULT
}}
impl ComPtr<IBluetoothLEDevice2> {
    #[inline] pub fn get_device_information(&self) -> Result<Option<ComPtr<super::enumeration::DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appearance(&self) -> Result<Option<ComPtr<BluetoothLEAppearance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Appearance)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address_type(&self) -> Result<BluetoothAddressType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluetoothAddressType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice3, 2934563987, 17580, 16604, 175, 51, 178, 193, 60, 1, 202, 70);
RT_INTERFACE!{interface IBluetoothLEDevice3(IBluetoothLEDevice3Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice3] {
    fn get_DeviceAccessInformation(&self, out: *mut *mut super::enumeration::DeviceAccessInformation) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>) -> HRESULT,
    fn GetGattServicesAsync(&self, out: *mut *mut foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>) -> HRESULT,
    fn GetGattServicesWithCacheModeAsync(&self, cacheMode: BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>) -> HRESULT,
    fn GetGattServicesForUuidAsync(&self, serviceUuid: Guid, out: *mut *mut foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>) -> HRESULT,
    fn GetGattServicesForUuidWithCacheModeAsync(&self, serviceUuid: Guid, cacheMode: BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>) -> HRESULT
}}
impl ComPtr<IBluetoothLEDevice3> {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<ComPtr<super::enumeration::DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceAccessInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::enumeration::DeviceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGattServicesAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_with_cache_mode_async(&self, cacheMode: BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGattServicesWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_for_uuid_async(&self, serviceUuid: Guid) -> Result<ComPtr<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGattServicesForUuidAsync)(self.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_services_for_uuid_with_cache_mode_async(&self, serviceUuid: Guid, cacheMode: BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<genericattributeprofile::GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGattServicesForUuidWithCacheModeAsync)(self.deref() as *const _ as *mut _, serviceUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice4, 727732273, 8776, 19247, 172, 240, 124, 238, 54, 252, 88, 112);
RT_INTERFACE!{interface IBluetoothLEDevice4(IBluetoothLEDevice4Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice4] {
    fn get_BluetoothDeviceId(&self, out: *mut *mut BluetoothDeviceId) -> HRESULT
}}
impl ComPtr<IBluetoothLEDevice4> {
    #[inline] pub fn get_bluetooth_device_id(&self) -> Result<Option<ComPtr<BluetoothDeviceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BluetoothDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDevice5, 2640974432, 21127, 17806, 149, 186, 23, 200, 183, 187, 50, 110);
RT_INTERFACE!{interface IBluetoothLEDevice5(IBluetoothLEDevice5Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDevice5] {
    fn get_WasSecureConnectionUsedForPairing(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBluetoothLEDevice5> {
    #[inline] pub fn get_was_secure_connection_used_for_pairing(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WasSecureConnectionUsedForPairing)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDeviceStatics, 3369015833, 61622, 19440, 134, 137, 65, 48, 61, 226, 217, 244);
RT_INTERFACE!{static interface IBluetoothLEDeviceStatics(IBluetoothLEDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDeviceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<BluetoothLEDevice>) -> HRESULT,
    fn FromBluetoothAddressAsync(&self, bluetoothAddress: u64, out: *mut *mut foundation::IAsyncOperation<BluetoothLEDevice>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBluetoothLEDeviceStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothLEDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_bluetooth_address_async(&self, bluetoothAddress: u64) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothLEDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromBluetoothAddressAsync)(self.deref() as *const _ as *mut _, bluetoothAddress, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEDeviceStatics2, 1595064427, 15276, 17384, 173, 22, 86, 50, 113, 189, 65, 194);
RT_INTERFACE!{static interface IBluetoothLEDeviceStatics2(IBluetoothLEDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEDeviceStatics2] {
    fn GetDeviceSelectorFromPairingState(&self, pairingState: bool, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromConnectionStatus(&self, connectionStatus: BluetoothConnectionStatus, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromDeviceName(&self, deviceName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromBluetoothAddress(&self, bluetoothAddress: u64, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromBluetoothAddressWithBluetoothAddressType(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromAppearance(&self, appearance: *mut BluetoothLEAppearance, out: *mut HSTRING) -> HRESULT,
    fn FromBluetoothAddressWithBluetoothAddressTypeAsync(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType, out: *mut *mut foundation::IAsyncOperation<BluetoothLEDevice>) -> HRESULT
}}
impl ComPtr<IBluetoothLEDeviceStatics2> {
    #[inline] pub fn get_device_selector_from_pairing_state(&self, pairingState: bool) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromPairingState)(self.deref() as *const _ as *mut _, pairingState, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_connection_status(&self, connectionStatus: BluetoothConnectionStatus) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromConnectionStatus)(self.deref() as *const _ as *mut _, connectionStatus, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_device_name(&self, deviceName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromDeviceName)(self.deref() as *const _ as *mut _, deviceName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_bluetooth_address(&self, bluetoothAddress: u64) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromBluetoothAddress)(self.deref() as *const _ as *mut _, bluetoothAddress, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_bluetooth_address_with_bluetooth_address_type(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromBluetoothAddressWithBluetoothAddressType)(self.deref() as *const _ as *mut _, bluetoothAddress, bluetoothAddressType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_appearance(&self, appearance: &ComPtr<BluetoothLEAppearance>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromAppearance)(self.deref() as *const _ as *mut _, appearance.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_bluetooth_address_with_bluetooth_address_type_async(&self, bluetoothAddress: u64, bluetoothAddressType: BluetoothAddressType) -> Result<ComPtr<foundation::IAsyncOperation<BluetoothLEDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromBluetoothAddressWithBluetoothAddressTypeAsync)(self.deref() as *const _ as *mut _, bluetoothAddress, bluetoothAddressType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothMajorClass: i32 {
    Miscellaneous = 0, Computer = 1, Phone = 2, NetworkAccessPoint = 3, AudioVideo = 4, Peripheral = 5, Imaging = 6, Wearable = 7, Toy = 8, Health = 9,
}}
RT_ENUM! { enum BluetoothMinorClass: i32 {
    Uncategorized = 0, ComputerDesktop = 1, ComputerServer = 2, ComputerLaptop = 3, ComputerHandheld = 4, ComputerPalmSize = 5, ComputerWearable = 6, ComputerTablet = 7, PhoneCellular = 1, PhoneCordless = 2, PhoneSmartPhone = 3, PhoneWired = 4, PhoneIsdn = 5, NetworkFullyAvailable = 0, NetworkUsed01To17Percent = 8, NetworkUsed17To33Percent = 16, NetworkUsed33To50Percent = 24, NetworkUsed50To67Percent = 32, NetworkUsed67To83Percent = 40, NetworkUsed83To99Percent = 48, NetworkNoServiceAvailable = 56, AudioVideoWearableHeadset = 1, AudioVideoHandsFree = 2, AudioVideoMicrophone = 4, AudioVideoLoudspeaker = 5, AudioVideoHeadphones = 6, AudioVideoPortableAudio = 7, AudioVideoCarAudio = 8, AudioVideoSetTopBox = 9, AudioVideoHifiAudioDevice = 10, AudioVideoVcr = 11, AudioVideoVideoCamera = 12, AudioVideoCamcorder = 13, AudioVideoVideoMonitor = 14, AudioVideoVideoDisplayAndLoudspeaker = 15, AudioVideoVideoConferencing = 16, AudioVideoGamingOrToy = 18, PeripheralJoystick = 1, PeripheralGamepad = 2, PeripheralRemoteControl = 3, PeripheralSensing = 4, PeripheralDigitizerTablet = 5, PeripheralCardReader = 6, PeripheralDigitalPen = 7, PeripheralHandheldScanner = 8, PeripheralHandheldGesture = 9, WearableWristwatch = 1, WearablePager = 2, WearableJacket = 3, WearableHelmet = 4, WearableGlasses = 5, ToyRobot = 1, ToyVehicle = 2, ToyDoll = 3, ToyController = 4, ToyGame = 5, HealthBloodPressureMonitor = 1, HealthThermometer = 2, HealthWeighingScale = 3, HealthGlucoseMeter = 4, HealthPulseOximeter = 5, HealthHeartRateMonitor = 6, HealthHealthDataDisplay = 7, HealthStepCounter = 8, HealthBodyCompositionAnalyzer = 9, HealthPeakFlowMonitor = 10, HealthMedicationMonitor = 11, HealthKneeProsthesis = 12, HealthAnkleProsthesis = 13, HealthGenericHealthManager = 14, HealthPersonalMobilityDevice = 15,
}}
RT_ENUM! { enum BluetoothServiceCapabilities: u32 {
    None = 0, LimitedDiscoverableMode = 1, PositioningService = 8, NetworkingService = 16, RenderingService = 32, CapturingService = 64, ObjectTransferService = 128, AudioService = 256, TelephoneService = 512, InformationService = 1024,
}}
DEFINE_IID!(IID_IBluetoothSignalStrengthFilter, 3749409681, 27573, 19710, 144, 177, 93, 115, 36, 237, 207, 127);
RT_INTERFACE!{interface IBluetoothSignalStrengthFilter(IBluetoothSignalStrengthFilterVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothSignalStrengthFilter] {
    fn get_InRangeThresholdInDBm(&self, out: *mut *mut foundation::IReference<i16>) -> HRESULT,
    fn put_InRangeThresholdInDBm(&self, value: *mut foundation::IReference<i16>) -> HRESULT,
    fn get_OutOfRangeThresholdInDBm(&self, out: *mut *mut foundation::IReference<i16>) -> HRESULT,
    fn put_OutOfRangeThresholdInDBm(&self, value: *mut foundation::IReference<i16>) -> HRESULT,
    fn get_OutOfRangeTimeout(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn put_OutOfRangeTimeout(&self, value: *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_SamplingInterval(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn put_SamplingInterval(&self, value: *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT
}}
impl ComPtr<IBluetoothSignalStrengthFilter> {
    #[inline] pub fn get_in_range_threshold_in_dbm(&self) -> Result<Option<ComPtr<foundation::IReference<i16>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InRangeThresholdInDBm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_in_range_threshold_in_dbm(&self, value: &ComPtr<foundation::IReference<i16>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_InRangeThresholdInDBm)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_out_of_range_threshold_in_dbm(&self) -> Result<Option<ComPtr<foundation::IReference<i16>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutOfRangeThresholdInDBm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_out_of_range_threshold_in_dbm(&self, value: &ComPtr<foundation::IReference<i16>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_OutOfRangeThresholdInDBm)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_out_of_range_timeout(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutOfRangeTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_out_of_range_timeout(&self, value: &ComPtr<foundation::IReference<foundation::TimeSpan>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_OutOfRangeTimeout)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sampling_interval(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SamplingInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_sampling_interval(&self, value: &ComPtr<foundation::IReference<foundation::TimeSpan>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SamplingInterval)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothSignalStrengthFilter: IBluetoothSignalStrengthFilter}
impl RtActivatable<IActivationFactory> for BluetoothSignalStrengthFilter {}
DEFINE_CLSID!(BluetoothSignalStrengthFilter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,83,105,103,110,97,108,83,116,114,101,110,103,116,104,70,105,108,116,101,114,0]) [CLSID_BluetoothSignalStrengthFilter]);
RT_CLASS!{static class BluetoothUuidHelper}
impl RtActivatable<IBluetoothUuidHelperStatics> for BluetoothUuidHelper {}
impl BluetoothUuidHelper {
    #[inline] pub fn from_short_id(shortId: u32) -> Result<Guid> {
        <Self as RtActivatable<IBluetoothUuidHelperStatics>>::get_activation_factory().from_short_id(shortId)
    }
    #[inline] pub fn try_get_short_id(uuid: Guid) -> Result<Option<ComPtr<foundation::IReference<u32>>>> {
        <Self as RtActivatable<IBluetoothUuidHelperStatics>>::get_activation_factory().try_get_short_id(uuid)
    }
}
DEFINE_CLSID!(BluetoothUuidHelper(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,108,117,101,116,111,111,116,104,85,117,105,100,72,101,108,112,101,114,0]) [CLSID_BluetoothUuidHelper]);
DEFINE_IID!(IID_IBluetoothUuidHelperStatics, 400493784, 53108, 19233, 175, 230, 245, 122, 17, 188, 222, 160);
RT_INTERFACE!{static interface IBluetoothUuidHelperStatics(IBluetoothUuidHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothUuidHelperStatics] {
    fn FromShortId(&self, shortId: u32, out: *mut Guid) -> HRESULT,
    fn TryGetShortId(&self, uuid: Guid, out: *mut *mut foundation::IReference<u32>) -> HRESULT
}}
impl ComPtr<IBluetoothUuidHelperStatics> {
    #[inline] pub fn from_short_id(&self, shortId: u32) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).FromShortId)(self.deref() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_short_id(&self, uuid: Guid) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetShortId)(self.deref() as *const _ as *mut _, uuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
pub mod advertisement { // Windows.Devices.Bluetooth.Advertisement
use crate::prelude::*;
DEFINE_IID!(IID_IBluetoothLEAdvertisement, 107983543, 13265, 20093, 131, 103, 207, 129, 208, 247, 150, 83);
RT_INTERFACE!{interface IBluetoothLEAdvertisement(IBluetoothLEAdvertisementVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisement] {
    fn get_Flags(&self, out: *mut *mut foundation::IReference<BluetoothLEAdvertisementFlags>) -> HRESULT,
    fn put_Flags(&self, value: *mut foundation::IReference<BluetoothLEAdvertisementFlags>) -> HRESULT,
    fn get_LocalName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LocalName(&self, value: HSTRING) -> HRESULT,
    fn get_ServiceUuids(&self, out: *mut *mut foundation::collections::IVector<Guid>) -> HRESULT,
    fn get_ManufacturerData(&self, out: *mut *mut foundation::collections::IVector<BluetoothLEManufacturerData>) -> HRESULT,
    fn get_DataSections(&self, out: *mut *mut foundation::collections::IVector<BluetoothLEAdvertisementDataSection>) -> HRESULT,
    fn GetManufacturerDataByCompanyId(&self, companyId: u16, out: *mut *mut foundation::collections::IVectorView<BluetoothLEManufacturerData>) -> HRESULT,
    fn GetSectionsByType(&self, type_: u8, out: *mut *mut foundation::collections::IVectorView<BluetoothLEAdvertisementDataSection>) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisement> {
    #[inline] pub fn get_flags(&self) -> Result<Option<ComPtr<foundation::IReference<BluetoothLEAdvertisementFlags>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Flags)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_flags(&self, value: &ComPtr<foundation::IReference<BluetoothLEAdvertisementFlags>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Flags)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_local_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_LocalName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_local_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_LocalName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_uuids(&self) -> Result<Option<ComPtr<foundation::collections::IVector<Guid>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_data(&self) -> Result<Option<ComPtr<foundation::collections::IVector<BluetoothLEManufacturerData>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ManufacturerData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_data_sections(&self) -> Result<Option<ComPtr<foundation::collections::IVector<BluetoothLEAdvertisementDataSection>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DataSections)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_data_by_company_id(&self, companyId: u16) -> Result<Option<ComPtr<foundation::collections::IVectorView<BluetoothLEManufacturerData>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetManufacturerDataByCompanyId)(self.deref() as *const _ as *mut _, companyId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sections_by_type(&self, type_: u8) -> Result<Option<ComPtr<foundation::collections::IVectorView<BluetoothLEAdvertisementDataSection>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSectionsByType)(self.deref() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisement: IBluetoothLEAdvertisement}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisement {}
DEFINE_CLSID!(BluetoothLEAdvertisement(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,0]) [CLSID_BluetoothLEAdvertisement]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementBytePattern, 4227520498, 47557, 18952, 188, 81, 80, 47, 142, 246, 138, 121);
RT_INTERFACE!{interface IBluetoothLEAdvertisementBytePattern(IBluetoothLEAdvertisementBytePatternVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementBytePattern] {
    fn get_DataType(&self, out: *mut u8) -> HRESULT,
    fn put_DataType(&self, value: u8) -> HRESULT,
    fn get_Offset(&self, out: *mut i16) -> HRESULT,
    fn put_Offset(&self, value: i16) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementBytePattern> {
    #[inline] pub fn get_data_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_type(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DataType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<i16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Offset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_offset(&self, value: i16) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Offset)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Data)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementBytePattern: IBluetoothLEAdvertisementBytePattern}
impl RtActivatable<IBluetoothLEAdvertisementBytePatternFactory> for BluetoothLEAdvertisementBytePattern {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementBytePattern {}
impl BluetoothLEAdvertisementBytePattern {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(dataType: u8, offset: i16, data: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<BluetoothLEAdvertisementBytePattern>> {
        <Self as RtActivatable<IBluetoothLEAdvertisementBytePatternFactory>>::get_activation_factory().create(dataType, offset, data)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementBytePattern(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,66,121,116,101,80,97,116,116,101,114,110,0]) [CLSID_BluetoothLEAdvertisementBytePattern]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementBytePatternFactory, 3269610867, 64860, 20163, 190, 42, 156, 166, 250, 17, 183, 189);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementBytePatternFactory(IBluetoothLEAdvertisementBytePatternFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementBytePatternFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, dataType: u8, offset: i16, data: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut BluetoothLEAdvertisementBytePattern) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementBytePatternFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, dataType: u8, offset: i16, data: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<BluetoothLEAdvertisementBytePattern>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, dataType, offset, data.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEAdvertisementDataSection, 3609277204, 14915, 16633, 182, 240, 146, 191, 239, 195, 74, 227);
RT_INTERFACE!{interface IBluetoothLEAdvertisementDataSection(IBluetoothLEAdvertisementDataSectionVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataSection] {
    fn get_DataType(&self, out: *mut u8) -> HRESULT,
    fn put_DataType(&self, value: u8) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementDataSection> {
    #[inline] pub fn get_data_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_type(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DataType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Data)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementDataSection: IBluetoothLEAdvertisementDataSection}
impl RtActivatable<IBluetoothLEAdvertisementDataSectionFactory> for BluetoothLEAdvertisementDataSection {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementDataSection {}
impl BluetoothLEAdvertisementDataSection {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(dataType: u8, data: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<BluetoothLEAdvertisementDataSection>> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataSectionFactory>>::get_activation_factory().create(dataType, data)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementDataSection(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,68,97,116,97,83,101,99,116,105,111,110,0]) [CLSID_BluetoothLEAdvertisementDataSection]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementDataSectionFactory, 3886287170, 43077, 16453, 191, 126, 62, 153, 113, 219, 138, 107);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementDataSectionFactory(IBluetoothLEAdvertisementDataSectionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataSectionFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, dataType: u8, data: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut BluetoothLEAdvertisementDataSection) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementDataSectionFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, dataType: u8, data: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<BluetoothLEAdvertisementDataSection>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, dataType, data.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class BluetoothLEAdvertisementDataTypes}
impl RtActivatable<IBluetoothLEAdvertisementDataTypesStatics> for BluetoothLEAdvertisementDataTypes {}
impl BluetoothLEAdvertisementDataTypes {
    #[inline] pub fn get_flags() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_flags()
    }
    #[inline] pub fn get_incomplete_service_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_incomplete_service_16_bit_uuids()
    }
    #[inline] pub fn get_complete_service_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_service_16_bit_uuids()
    }
    #[inline] pub fn get_incomplete_service_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_incomplete_service_32_bit_uuids()
    }
    #[inline] pub fn get_complete_service_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_service_32_bit_uuids()
    }
    #[inline] pub fn get_incomplete_service_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_incomplete_service_128_bit_uuids()
    }
    #[inline] pub fn get_complete_service_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_service_128_bit_uuids()
    }
    #[inline] pub fn get_shortened_local_name() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_shortened_local_name()
    }
    #[inline] pub fn get_complete_local_name() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_complete_local_name()
    }
    #[inline] pub fn get_tx_power_level() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_tx_power_level()
    }
    #[inline] pub fn get_slave_connection_interval_range() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_slave_connection_interval_range()
    }
    #[inline] pub fn get_service_solicitation_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_solicitation_16_bit_uuids()
    }
    #[inline] pub fn get_service_solicitation_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_solicitation_32_bit_uuids()
    }
    #[inline] pub fn get_service_solicitation_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_solicitation_128_bit_uuids()
    }
    #[inline] pub fn get_service_data_16_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_data_16_bit_uuids()
    }
    #[inline] pub fn get_service_data_32_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_data_32_bit_uuids()
    }
    #[inline] pub fn get_service_data_128_bit_uuids() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_service_data_128_bit_uuids()
    }
    #[inline] pub fn get_public_target_address() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_public_target_address()
    }
    #[inline] pub fn get_random_target_address() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_random_target_address()
    }
    #[inline] pub fn get_appearance() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_appearance()
    }
    #[inline] pub fn get_advertising_interval() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_advertising_interval()
    }
    #[inline] pub fn get_manufacturer_specific_data() -> Result<u8> {
        <Self as RtActivatable<IBluetoothLEAdvertisementDataTypesStatics>>::get_activation_factory().get_manufacturer_specific_data()
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementDataTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,68,97,116,97,84,121,112,101,115,0]) [CLSID_BluetoothLEAdvertisementDataTypes]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementDataTypesStatics, 1001801519, 1542, 17227, 167, 110, 116, 21, 159, 6, 132, 211);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementDataTypesStatics(IBluetoothLEAdvertisementDataTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementDataTypesStatics] {
    fn get_Flags(&self, out: *mut u8) -> HRESULT,
    fn get_IncompleteService16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteService16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_IncompleteService32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteService32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_IncompleteService128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteService128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ShortenedLocalName(&self, out: *mut u8) -> HRESULT,
    fn get_CompleteLocalName(&self, out: *mut u8) -> HRESULT,
    fn get_TxPowerLevel(&self, out: *mut u8) -> HRESULT,
    fn get_SlaveConnectionIntervalRange(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceSolicitation16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceSolicitation32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceSolicitation128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceData16BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceData32BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_ServiceData128BitUuids(&self, out: *mut u8) -> HRESULT,
    fn get_PublicTargetAddress(&self, out: *mut u8) -> HRESULT,
    fn get_RandomTargetAddress(&self, out: *mut u8) -> HRESULT,
    fn get_Appearance(&self, out: *mut u8) -> HRESULT,
    fn get_AdvertisingInterval(&self, out: *mut u8) -> HRESULT,
    fn get_ManufacturerSpecificData(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementDataTypesStatics> {
    #[inline] pub fn get_flags(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Flags)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_incomplete_service_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IncompleteService16BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_service_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompleteService16BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_incomplete_service_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IncompleteService32BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_service_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompleteService32BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_incomplete_service_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IncompleteService128BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_service_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompleteService128BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_shortened_local_name(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ShortenedLocalName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_complete_local_name(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompleteLocalName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tx_power_level(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TxPowerLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_slave_connection_interval_range(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SlaveConnectionIntervalRange)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_solicitation_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceSolicitation16BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_solicitation_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceSolicitation32BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_solicitation_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceSolicitation128BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_data_16_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceData16BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_data_32_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceData32BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_data_128_bit_uuids(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceData128BitUuids)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_public_target_address(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PublicTargetAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_random_target_address(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RandomTargetAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_appearance(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Appearance)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertising_interval(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdvertisingInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_specific_data(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ManufacturerSpecificData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBluetoothLEAdvertisementFilter, 320778451, 53326, 18353, 131, 126, 73, 64, 91, 246, 248, 15);
RT_INTERFACE!{interface IBluetoothLEAdvertisementFilter(IBluetoothLEAdvertisementFilterVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementFilter] {
    fn get_Advertisement(&self, out: *mut *mut BluetoothLEAdvertisement) -> HRESULT,
    fn put_Advertisement(&self, value: *mut BluetoothLEAdvertisement) -> HRESULT,
    fn get_BytePatterns(&self, out: *mut *mut foundation::collections::IVector<BluetoothLEAdvertisementBytePattern>) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementFilter> {
    #[inline] pub fn get_advertisement(&self) -> Result<Option<ComPtr<BluetoothLEAdvertisement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Advertisement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_advertisement(&self, value: &ComPtr<BluetoothLEAdvertisement>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Advertisement)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_byte_patterns(&self) -> Result<Option<ComPtr<foundation::collections::IVector<BluetoothLEAdvertisementBytePattern>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BytePatterns)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementFilter: IBluetoothLEAdvertisementFilter}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementFilter {}
DEFINE_CLSID!(BluetoothLEAdvertisementFilter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,70,105,108,116,101,114,0]) [CLSID_BluetoothLEAdvertisementFilter]);
RT_ENUM! { enum BluetoothLEAdvertisementFlags: u32 {
    None = 0, LimitedDiscoverableMode = 1, GeneralDiscoverableMode = 2, ClassicNotSupported = 4, DualModeControllerCapable = 8, DualModeHostCapable = 16,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisher, 3454542073, 55802, 17366, 162, 100, 221, 216, 183, 218, 139, 120);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisher(IBluetoothLEAdvertisementPublisherVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisher] {
    fn get_Status(&self, out: *mut BluetoothLEAdvertisementPublisherStatus) -> HRESULT,
    fn get_Advertisement(&self, out: *mut *mut BluetoothLEAdvertisement) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_StatusChanged(&self, handler: *mut foundation::TypedEventHandler<BluetoothLEAdvertisementPublisher, BluetoothLEAdvertisementPublisherStatusChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementPublisher> {
    #[inline] pub fn get_status(&self) -> Result<BluetoothLEAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement(&self) -> Result<Option<ComPtr<BluetoothLEAdvertisement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Advertisement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothLEAdvertisementPublisher, BluetoothLEAdvertisementPublisherStatusChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisher: IBluetoothLEAdvertisementPublisher}
impl RtActivatable<IBluetoothLEAdvertisementPublisherFactory> for BluetoothLEAdvertisementPublisher {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementPublisher {}
impl BluetoothLEAdvertisementPublisher {
    #[inline] pub fn create(advertisement: &ComPtr<BluetoothLEAdvertisement>) -> Result<ComPtr<BluetoothLEAdvertisementPublisher>> {
        <Self as RtActivatable<IBluetoothLEAdvertisementPublisherFactory>>::get_activation_factory().create(advertisement)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementPublisher(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,80,117,98,108,105,115,104,101,114,0]) [CLSID_BluetoothLEAdvertisementPublisher]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherFactory, 1549731422, 47203, 18817, 161, 175, 28, 84, 77, 139, 12, 13);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementPublisherFactory(IBluetoothLEAdvertisementPublisherFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherFactory] {
    fn Create(&self, advertisement: *mut BluetoothLEAdvertisement, out: *mut *mut BluetoothLEAdvertisementPublisher) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementPublisherFactory> {
    #[inline] pub fn create(&self, advertisement: &ComPtr<BluetoothLEAdvertisement>) -> Result<ComPtr<BluetoothLEAdvertisementPublisher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, advertisement.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothLEAdvertisementPublisherStatus: i32 {
    Created = 0, Waiting = 1, Started = 2, Stopping = 3, Stopped = 4, Aborted = 5,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherStatusChangedEventArgs, 163757471, 11775, 19235, 134, 238, 13, 20, 251, 148, 174, 174);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherStatusChangedEventArgs(IBluetoothLEAdvertisementPublisherStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherStatusChangedEventArgs] {
    fn get_Status(&self, out: *mut BluetoothLEAdvertisementPublisherStatus) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementPublisherStatusChangedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<BluetoothLEAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisherStatusChangedEventArgs: IBluetoothLEAdvertisementPublisherStatusChangedEventArgs}
DEFINE_IID!(IID_IBluetoothLEAdvertisementReceivedEventArgs, 664305119, 58774, 16830, 141, 67, 158, 103, 49, 212, 169, 19);
RT_INTERFACE!{interface IBluetoothLEAdvertisementReceivedEventArgs(IBluetoothLEAdvertisementReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementReceivedEventArgs] {
    fn get_RawSignalStrengthInDBm(&self, out: *mut i16) -> HRESULT,
    fn get_BluetoothAddress(&self, out: *mut u64) -> HRESULT,
    fn get_AdvertisementType(&self, out: *mut BluetoothLEAdvertisementType) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Advertisement(&self, out: *mut *mut BluetoothLEAdvertisement) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementReceivedEventArgs> {
    #[inline] pub fn get_raw_signal_strength_in_dbm(&self) -> Result<i16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RawSignalStrengthInDBm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bluetooth_address(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluetoothAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_type(&self) -> Result<BluetoothLEAdvertisementType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdvertisementType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement(&self) -> Result<Option<ComPtr<BluetoothLEAdvertisement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Advertisement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementReceivedEventArgs: IBluetoothLEAdvertisementReceivedEventArgs}
RT_ENUM! { enum BluetoothLEAdvertisementType: i32 {
    ConnectableUndirected = 0, ConnectableDirected = 1, ScannableUndirected = 2, NonConnectableUndirected = 3, ScanResponse = 4,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcher, 2796303215, 62419, 17047, 141, 108, 200, 30, 166, 98, 63, 64);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcher(IBluetoothLEAdvertisementWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcher] {
    fn get_MinSamplingInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxSamplingInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MinOutOfRangeTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_MaxOutOfRangeTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Status(&self, out: *mut BluetoothLEAdvertisementWatcherStatus) -> HRESULT,
    fn get_ScanningMode(&self, out: *mut BluetoothLEScanningMode) -> HRESULT,
    fn put_ScanningMode(&self, value: BluetoothLEScanningMode) -> HRESULT,
    fn get_SignalStrengthFilter(&self, out: *mut *mut super::BluetoothSignalStrengthFilter) -> HRESULT,
    fn put_SignalStrengthFilter(&self, value: *mut super::BluetoothSignalStrengthFilter) -> HRESULT,
    fn get_AdvertisementFilter(&self, out: *mut *mut BluetoothLEAdvertisementFilter) -> HRESULT,
    fn put_AdvertisementFilter(&self, value: *mut BluetoothLEAdvertisementFilter) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_Received(&self, handler: *mut foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Received(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementWatcherStoppedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementWatcher> {
    #[inline] pub fn get_min_sampling_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinSamplingInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_sampling_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxSamplingInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_out_of_range_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinOutOfRangeTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_out_of_range_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxOutOfRangeTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<BluetoothLEAdvertisementWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scanning_mode(&self) -> Result<BluetoothLEScanningMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScanningMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scanning_mode(&self, value: BluetoothLEScanningMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ScanningMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_strength_filter(&self) -> Result<Option<ComPtr<super::BluetoothSignalStrengthFilter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SignalStrengthFilter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_signal_strength_filter(&self, value: &ComPtr<super::BluetoothSignalStrengthFilter>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SignalStrengthFilter)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_filter(&self) -> Result<Option<ComPtr<BluetoothLEAdvertisementFilter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AdvertisementFilter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_advertisement_filter(&self, value: &ComPtr<BluetoothLEAdvertisementFilter>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AdvertisementFilter)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_received(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Received)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Received)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<BluetoothLEAdvertisementWatcher, BluetoothLEAdvertisementWatcherStoppedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcher: IBluetoothLEAdvertisementWatcher}
impl RtActivatable<IBluetoothLEAdvertisementWatcherFactory> for BluetoothLEAdvertisementWatcher {}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementWatcher {}
impl BluetoothLEAdvertisementWatcher {
    #[inline] pub fn create(advertisementFilter: &ComPtr<BluetoothLEAdvertisementFilter>) -> Result<ComPtr<BluetoothLEAdvertisementWatcher>> {
        <Self as RtActivatable<IBluetoothLEAdvertisementWatcherFactory>>::get_activation_factory().create(advertisementFilter)
    }
}
DEFINE_CLSID!(BluetoothLEAdvertisementWatcher(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,65,100,118,101,114,116,105,115,101,109,101,110,116,87,97,116,99,104,101,114,0]) [CLSID_BluetoothLEAdvertisementWatcher]);
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherFactory, 2595171670, 14764, 17726, 179, 42, 133, 198, 87, 224, 23, 241);
RT_INTERFACE!{static interface IBluetoothLEAdvertisementWatcherFactory(IBluetoothLEAdvertisementWatcherFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherFactory] {
    fn Create(&self, advertisementFilter: *mut BluetoothLEAdvertisementFilter, out: *mut *mut BluetoothLEAdvertisementWatcher) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementWatcherFactory> {
    #[inline] pub fn create(&self, advertisementFilter: &ComPtr<BluetoothLEAdvertisementFilter>) -> Result<ComPtr<BluetoothLEAdvertisementWatcher>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, advertisementFilter.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothLEAdvertisementWatcherStatus: i32 {
    Created = 0, Started = 1, Stopping = 2, Stopped = 3, Aborted = 4,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherStoppedEventArgs, 3712022605, 59321, 17379, 156, 4, 6, 133, 208, 133, 253, 140);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherStoppedEventArgs(IBluetoothLEAdvertisementWatcherStoppedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherStoppedEventArgs] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementWatcherStoppedEventArgs> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcherStoppedEventArgs: IBluetoothLEAdvertisementWatcherStoppedEventArgs}
DEFINE_IID!(IID_IBluetoothLEManufacturerData, 2435693080, 26979, 17715, 176, 97, 70, 148, 218, 251, 52, 229);
RT_INTERFACE!{interface IBluetoothLEManufacturerData(IBluetoothLEManufacturerDataVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEManufacturerData] {
    fn get_CompanyId(&self, out: *mut u16) -> HRESULT,
    fn put_CompanyId(&self, value: u16) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IBluetoothLEManufacturerData> {
    #[inline] pub fn get_company_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompanyId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_company_id(&self, value: u16) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CompanyId)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Data)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEManufacturerData: IBluetoothLEManufacturerData}
impl RtActivatable<IBluetoothLEManufacturerDataFactory> for BluetoothLEManufacturerData {}
impl RtActivatable<IActivationFactory> for BluetoothLEManufacturerData {}
impl BluetoothLEManufacturerData {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(companyId: u16, data: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<BluetoothLEManufacturerData>> {
        <Self as RtActivatable<IBluetoothLEManufacturerDataFactory>>::get_activation_factory().create(companyId, data)
    }
}
DEFINE_CLSID!(BluetoothLEManufacturerData(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,65,100,118,101,114,116,105,115,101,109,101,110,116,46,66,108,117,101,116,111,111,116,104,76,69,77,97,110,117,102,97,99,116,117,114,101,114,68,97,116,97,0]) [CLSID_BluetoothLEManufacturerData]);
DEFINE_IID!(IID_IBluetoothLEManufacturerDataFactory, 3231398392, 12698, 17438, 141, 229, 102, 168, 30, 135, 122, 108);
RT_INTERFACE!{static interface IBluetoothLEManufacturerDataFactory(IBluetoothLEManufacturerDataFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEManufacturerDataFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, companyId: u16, data: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut BluetoothLEManufacturerData) -> HRESULT
}}
impl ComPtr<IBluetoothLEManufacturerDataFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, companyId: u16, data: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<BluetoothLEManufacturerData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, companyId, data.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BluetoothLEScanningMode: i32 {
    Passive = 0, Active = 1,
}}
} // Windows.Devices.Bluetooth.Advertisement
pub mod background { // Windows.Devices.Bluetooth.Background
use crate::prelude::*;
RT_ENUM! { enum BluetoothEventTriggeringMode: i32 {
    Serial = 0, Batch = 1, KeepLatest = 2,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherTriggerDetails, 1628359302, 13440, 16841, 169, 24, 125, 218, 223, 32, 126, 0);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherTriggerDetails(IBluetoothLEAdvertisementPublisherTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherTriggerDetails] {
    fn get_Status(&self, out: *mut super::advertisement::BluetoothLEAdvertisementPublisherStatus) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementPublisherTriggerDetails> {
    #[inline] pub fn get_status(&self) -> Result<super::advertisement::BluetoothLEAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementPublisherTriggerDetails: IBluetoothLEAdvertisementPublisherTriggerDetails}
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherTriggerDetails, 2816170711, 8791, 20073, 151, 132, 254, 230, 69, 193, 220, 224);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherTriggerDetails(IBluetoothLEAdvertisementWatcherTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherTriggerDetails] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Advertisements(&self, out: *mut *mut foundation::collections::IVectorView<super::advertisement::BluetoothLEAdvertisementReceivedEventArgs>) -> HRESULT,
    fn get_SignalStrengthFilter(&self, out: *mut *mut super::BluetoothSignalStrengthFilter) -> HRESULT
}}
impl ComPtr<IBluetoothLEAdvertisementWatcherTriggerDetails> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisements(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::advertisement::BluetoothLEAdvertisementReceivedEventArgs>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Advertisements)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_strength_filter(&self) -> Result<Option<ComPtr<super::BluetoothSignalStrengthFilter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SignalStrengthFilter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BluetoothLEAdvertisementWatcherTriggerDetails: IBluetoothLEAdvertisementWatcherTriggerDetails}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerDetails, 2610969368, 4076, 17258, 147, 177, 244, 108, 105, 117, 50, 162);
RT_INTERFACE!{interface IGattCharacteristicNotificationTriggerDetails(IGattCharacteristicNotificationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerDetails] {
    fn get_Characteristic(&self, out: *mut *mut super::genericattributeprofile::GattCharacteristic) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IGattCharacteristicNotificationTriggerDetails> {
    #[inline] pub fn get_characteristic(&self) -> Result<Option<ComPtr<super::genericattributeprofile::GattCharacteristic>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristic)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristicNotificationTriggerDetails: IGattCharacteristicNotificationTriggerDetails}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerDetails2, 1920618716, 38045, 17738, 177, 146, 152, 52, 103, 227, 213, 15);
RT_INTERFACE!{interface IGattCharacteristicNotificationTriggerDetails2(IGattCharacteristicNotificationTriggerDetails2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerDetails2] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_EventTriggeringMode(&self, out: *mut BluetoothEventTriggeringMode) -> HRESULT,
    fn get_ValueChangedEvents(&self, out: *mut *mut foundation::collections::IVectorView<super::genericattributeprofile::GattValueChangedEventArgs>) -> HRESULT
}}
impl ComPtr<IGattCharacteristicNotificationTriggerDetails2> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_event_triggering_mode(&self) -> Result<BluetoothEventTriggeringMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EventTriggeringMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value_changed_events(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::genericattributeprofile::GattValueChangedEventArgs>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ValueChangedEvents)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceProviderConnection, 2141305273, 12051, 16565, 149, 130, 142, 183, 142, 152, 239, 19);
RT_INTERFACE!{interface IGattServiceProviderConnection(IGattServiceProviderConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderConnection] {
    fn get_TriggerId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Service(&self, out: *mut *mut super::genericattributeprofile::GattLocalService) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl ComPtr<IGattServiceProviderConnection> {
    #[inline] pub fn get_trigger_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TriggerId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service(&self) -> Result<Option<ComPtr<super::genericattributeprofile::GattLocalService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Service)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderConnection: IGattServiceProviderConnection}
impl RtActivatable<IGattServiceProviderConnectionStatics> for GattServiceProviderConnection {}
impl GattServiceProviderConnection {
    #[inline] pub fn get_all_services() -> Result<Option<ComPtr<foundation::collections::IMapView<HString, GattServiceProviderConnection>>>> {
        <Self as RtActivatable<IGattServiceProviderConnectionStatics>>::get_activation_factory().get_all_services()
    }
}
DEFINE_CLSID!(GattServiceProviderConnection(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,66,97,99,107,103,114,111,117,110,100,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,67,111,110,110,101,99,116,105,111,110,0]) [CLSID_GattServiceProviderConnection]);
DEFINE_IID!(IID_IGattServiceProviderConnectionStatics, 1028693835, 2830, 17510, 184, 205, 110, 189, 218, 31, 161, 125);
RT_INTERFACE!{static interface IGattServiceProviderConnectionStatics(IGattServiceProviderConnectionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderConnectionStatics] {
    fn get_AllServices(&self, out: *mut *mut foundation::collections::IMapView<HString, GattServiceProviderConnection>) -> HRESULT
}}
impl ComPtr<IGattServiceProviderConnectionStatics> {
    #[inline] pub fn get_all_services(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, GattServiceProviderConnection>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AllServices)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceProviderTriggerDetails, 2928412197, 1535, 19195, 177, 106, 222, 149, 243, 207, 1, 88);
RT_INTERFACE!{interface IGattServiceProviderTriggerDetails(IGattServiceProviderTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut *mut GattServiceProviderConnection) -> HRESULT
}}
impl ComPtr<IGattServiceProviderTriggerDetails> {
    #[inline] pub fn get_connection(&self) -> Result<Option<ComPtr<GattServiceProviderConnection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Connection)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderTriggerDetails: IGattServiceProviderTriggerDetails}
DEFINE_IID!(IID_IRfcommConnectionTriggerDetails, 4179784525, 11836, 20220, 171, 89, 252, 92, 249, 111, 151, 227);
RT_INTERFACE!{interface IRfcommConnectionTriggerDetails(IRfcommConnectionTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommConnectionTriggerDetails] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_Socket(&self, out: *mut *mut crate::windows::networking::sockets::StreamSocket) -> HRESULT,
    fn get_Incoming(&self, out: *mut bool) -> HRESULT,
    fn get_RemoteDevice(&self, out: *mut *mut super::BluetoothDevice) -> HRESULT
}}
impl ComPtr<IRfcommConnectionTriggerDetails> {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_socket(&self) -> Result<Option<ComPtr<crate::windows::networking::sockets::StreamSocket>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Socket)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_incoming(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Incoming)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_device(&self) -> Result<Option<ComPtr<super::BluetoothDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RemoteDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommConnectionTriggerDetails: IRfcommConnectionTriggerDetails}
DEFINE_IID!(IID_IRfcommInboundConnectionInformation, 1832809896, 21545, 16473, 146, 227, 30, 139, 101, 82, 135, 7);
RT_INTERFACE!{interface IRfcommInboundConnectionInformation(IRfcommInboundConnectionInformationVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommInboundConnectionInformation] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SdpRecord(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SdpRecord(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_LocalServiceId(&self, out: *mut *mut super::rfcomm::RfcommServiceId) -> HRESULT,
    fn put_LocalServiceId(&self, value: *mut super::rfcomm::RfcommServiceId) -> HRESULT,
    fn get_ServiceCapabilities(&self, out: *mut super::BluetoothServiceCapabilities) -> HRESULT,
    fn put_ServiceCapabilities(&self, value: super::BluetoothServiceCapabilities) -> HRESULT
}}
impl ComPtr<IRfcommInboundConnectionInformation> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_record(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SdpRecord)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_sdp_record(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SdpRecord)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_local_service_id(&self) -> Result<Option<ComPtr<super::rfcomm::RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_LocalServiceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_local_service_id(&self, value: &ComPtr<super::rfcomm::RfcommServiceId>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_LocalServiceId)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_capabilities(&self) -> Result<super::BluetoothServiceCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceCapabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_service_capabilities(&self, value: super::BluetoothServiceCapabilities) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ServiceCapabilities)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommInboundConnectionInformation: IRfcommInboundConnectionInformation}
DEFINE_IID!(IID_IRfcommOutboundConnectionInformation, 2962301563, 62516, 19632, 153, 177, 74, 184, 206, 218, 237, 215);
RT_INTERFACE!{interface IRfcommOutboundConnectionInformation(IRfcommOutboundConnectionInformationVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommOutboundConnectionInformation] {
    fn get_RemoteServiceId(&self, out: *mut *mut super::rfcomm::RfcommServiceId) -> HRESULT,
    fn put_RemoteServiceId(&self, value: *mut super::rfcomm::RfcommServiceId) -> HRESULT
}}
impl ComPtr<IRfcommOutboundConnectionInformation> {
    #[inline] pub fn get_remote_service_id(&self) -> Result<Option<ComPtr<super::rfcomm::RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RemoteServiceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_remote_service_id(&self, value: &ComPtr<super::rfcomm::RfcommServiceId>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RemoteServiceId)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommOutboundConnectionInformation: IRfcommOutboundConnectionInformation}
} // Windows.Devices.Bluetooth.Background
pub mod genericattributeprofile { // Windows.Devices.Bluetooth.GenericAttributeProfile
use crate::prelude::*;
DEFINE_IID!(IID_IGattCharacteristic, 1506496705, 22836, 20328, 161, 152, 235, 134, 79, 164, 78, 107);
RT_INTERFACE!{interface IGattCharacteristic(IGattCharacteristicVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic] {
    fn GetDescriptors(&self, descriptorUuid: Guid, out: *mut *mut foundation::collections::IVectorView<GattDescriptor>) -> HRESULT,
    fn get_CharacteristicProperties(&self, out: *mut GattCharacteristicProperties) -> HRESULT,
    fn get_ProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_ProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_UserDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn get_AttributeHandle(&self, out: *mut u16) -> HRESULT,
    fn get_PresentationFormats(&self, out: *mut *mut foundation::collections::IVectorView<GattPresentationFormat>) -> HRESULT,
    fn ReadValueAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattReadResult>) -> HRESULT,
    fn ReadValueWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattReadResult>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<GattCommunicationStatus>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueWithOptionAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, writeOption: GattWriteOption, out: *mut *mut foundation::IAsyncOperation<GattCommunicationStatus>) -> HRESULT,
    fn ReadClientCharacteristicConfigurationDescriptorAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattReadClientCharacteristicConfigurationDescriptorResult>) -> HRESULT,
    fn WriteClientCharacteristicConfigurationDescriptorAsync(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue, out: *mut *mut foundation::IAsyncOperation<GattCommunicationStatus>) -> HRESULT,
    fn add_ValueChanged(&self, valueChangedHandler: *mut foundation::TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, valueChangedEventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGattCharacteristic> {
    #[inline] pub fn get_descriptors(&self, descriptorUuid: Guid) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDescriptors)(self.deref() as *const _ as *mut _, descriptorUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_properties(&self) -> Result<GattCharacteristicProperties> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ProtectionLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UserDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_handle(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttributeHandle)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_formats(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattPresentationFormat>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PresentationFormats)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattReadResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadValueAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattReadResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadValueWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<GattCommunicationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteValueAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_option_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>, writeOption: GattWriteOption) -> Result<ComPtr<foundation::IAsyncOperation<GattCommunicationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteValueWithOptionAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, writeOption, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_client_characteristic_configuration_descriptor_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattReadClientCharacteristicConfigurationDescriptorResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadClientCharacteristicConfigurationDescriptorAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write_client_characteristic_configuration_descriptor_async(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue) -> Result<ComPtr<foundation::IAsyncOperation<GattCommunicationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteClientCharacteristicConfigurationDescriptorAsync)(self.deref() as *const _ as *mut _, clientCharacteristicConfigurationDescriptorValue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_value_changed(&self, valueChangedHandler: &ComPtr<foundation::TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ValueChanged)(self.deref() as *const _ as *mut _, valueChangedHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_value_changed(&self, valueChangedEventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ValueChanged)(self.deref() as *const _ as *mut _, valueChangedEventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristic: IGattCharacteristic}
impl RtActivatable<IGattCharacteristicStatics> for GattCharacteristic {}
impl GattCharacteristic {
    #[inline] pub fn convert_short_id_to_uuid(shortId: u16) -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicStatics>>::get_activation_factory().convert_short_id_to_uuid(shortId)
    }
}
DEFINE_CLSID!(GattCharacteristic(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,0]) [CLSID_GattCharacteristic]);
DEFINE_IID!(IID_IGattCharacteristic2, 2920985976, 60422, 18276, 183, 128, 152, 53, 161, 211, 93, 110);
RT_INTERFACE!{interface IGattCharacteristic2(IGattCharacteristic2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic2] {
    fn get_Service(&self, out: *mut *mut GattDeviceService) -> HRESULT,
    fn GetAllDescriptors(&self, out: *mut *mut foundation::collections::IVectorView<GattDescriptor>) -> HRESULT
}}
impl ComPtr<IGattCharacteristic2> {
    #[inline] pub fn get_service(&self) -> Result<Option<ComPtr<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Service)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_descriptors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllDescriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattCharacteristic3, 1060922942, 37844, 16491, 184, 23, 219, 129, 248, 237, 83, 179);
RT_INTERFACE!{interface IGattCharacteristic3(IGattCharacteristic3Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristic3] {
    fn GetDescriptorsAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattDescriptorsResult>) -> HRESULT,
    fn GetDescriptorsWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattDescriptorsResult>) -> HRESULT,
    fn GetDescriptorsForUuidAsync(&self, descriptorUuid: Guid, out: *mut *mut foundation::IAsyncOperation<GattDescriptorsResult>) -> HRESULT,
    fn GetDescriptorsForUuidWithCacheModeAsync(&self, descriptorUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattDescriptorsResult>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueWithResultAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<GattWriteResult>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValueWithResultAndOptionAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, writeOption: GattWriteOption, out: *mut *mut foundation::IAsyncOperation<GattWriteResult>) -> HRESULT,
    fn WriteClientCharacteristicConfigurationDescriptorWithResultAsync(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue, out: *mut *mut foundation::IAsyncOperation<GattWriteResult>) -> HRESULT
}}
impl ComPtr<IGattCharacteristic3> {
    #[inline] pub fn get_descriptors_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattDescriptorsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDescriptorsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattDescriptorsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDescriptorsWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors_for_uuid_async(&self, descriptorUuid: Guid) -> Result<ComPtr<foundation::IAsyncOperation<GattDescriptorsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDescriptorsForUuidAsync)(self.deref() as *const _ as *mut _, descriptorUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors_for_uuid_with_cache_mode_async(&self, descriptorUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattDescriptorsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDescriptorsForUuidWithCacheModeAsync)(self.deref() as *const _ as *mut _, descriptorUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_result_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<GattWriteResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteValueWithResultAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_result_and_option_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>, writeOption: GattWriteOption) -> Result<ComPtr<foundation::IAsyncOperation<GattWriteResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteValueWithResultAndOptionAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, writeOption, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write_client_characteristic_configuration_descriptor_with_result_async(&self, clientCharacteristicConfigurationDescriptorValue: GattClientCharacteristicConfigurationDescriptorValue) -> Result<ComPtr<foundation::IAsyncOperation<GattWriteResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteClientCharacteristicConfigurationDescriptorWithResultAsync)(self.deref() as *const _ as *mut _, clientCharacteristicConfigurationDescriptorValue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattCharacteristicProperties: u32 {
    None = 0, Broadcast = 1, Read = 2, WriteWithoutResponse = 4, Write = 8, Notify = 16, Indicate = 32, AuthenticatedSignedWrites = 64, ExtendedProperties = 128, ReliableWrites = 256, WritableAuxiliaries = 512,
}}
DEFINE_IID!(IID_IGattCharacteristicsResult, 294949980, 45655, 20286, 157, 183, 246, 139, 201, 169, 174, 242);
RT_INTERFACE!{interface IGattCharacteristicsResult(IGattCharacteristicsResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicsResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT,
    fn get_Characteristics(&self, out: *mut *mut foundation::collections::IVectorView<GattCharacteristic>) -> HRESULT
}}
impl ComPtr<IGattCharacteristicsResult> {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattCharacteristic>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattCharacteristicsResult: IGattCharacteristicsResult}
DEFINE_IID!(IID_IGattCharacteristicStatics, 1506496707, 22836, 20328, 161, 152, 235, 134, 79, 164, 78, 107);
RT_INTERFACE!{static interface IGattCharacteristicStatics(IGattCharacteristicStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicStatics] {
    fn ConvertShortIdToUuid(&self, shortId: u16, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattCharacteristicStatics> {
    #[inline] pub fn convert_short_id_to_uuid(&self, shortId: u16) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ConvertShortIdToUuid)(self.deref() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattCharacteristicUuids}
impl RtActivatable<IGattCharacteristicUuidsStatics> for GattCharacteristicUuids {}
impl RtActivatable<IGattCharacteristicUuidsStatics2> for GattCharacteristicUuids {}
impl GattCharacteristicUuids {
    #[inline] pub fn get_battery_level() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_battery_level()
    }
    #[inline] pub fn get_blood_pressure_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_blood_pressure_feature()
    }
    #[inline] pub fn get_blood_pressure_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_blood_pressure_measurement()
    }
    #[inline] pub fn get_body_sensor_location() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_body_sensor_location()
    }
    #[inline] pub fn get_csc_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_csc_feature()
    }
    #[inline] pub fn get_csc_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_csc_measurement()
    }
    #[inline] pub fn get_glucose_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_glucose_feature()
    }
    #[inline] pub fn get_glucose_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_glucose_measurement()
    }
    #[inline] pub fn get_glucose_measurement_context() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_glucose_measurement_context()
    }
    #[inline] pub fn get_heart_rate_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_heart_rate_control_point()
    }
    #[inline] pub fn get_heart_rate_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_heart_rate_measurement()
    }
    #[inline] pub fn get_intermediate_cuff_pressure() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_intermediate_cuff_pressure()
    }
    #[inline] pub fn get_intermediate_temperature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_intermediate_temperature()
    }
    #[inline] pub fn get_measurement_interval() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_measurement_interval()
    }
    #[inline] pub fn get_record_access_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_record_access_control_point()
    }
    #[inline] pub fn get_rsc_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_rsc_feature()
    }
    #[inline] pub fn get_rsc_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_rsc_measurement()
    }
    #[inline] pub fn get_sc_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_sc_control_point()
    }
    #[inline] pub fn get_sensor_location() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_sensor_location()
    }
    #[inline] pub fn get_temperature_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_temperature_measurement()
    }
    #[inline] pub fn get_temperature_type() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics>>::get_activation_factory().get_temperature_type()
    }
    #[inline] pub fn get_alert_category_id() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_category_id()
    }
    #[inline] pub fn get_alert_category_id_bit_mask() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_category_id_bit_mask()
    }
    #[inline] pub fn get_alert_level() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_level()
    }
    #[inline] pub fn get_alert_notification_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_notification_control_point()
    }
    #[inline] pub fn get_alert_status() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_alert_status()
    }
    #[inline] pub fn get_gap_appearance() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_appearance()
    }
    #[inline] pub fn get_boot_keyboard_input_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_boot_keyboard_input_report()
    }
    #[inline] pub fn get_boot_keyboard_output_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_boot_keyboard_output_report()
    }
    #[inline] pub fn get_boot_mouse_input_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_boot_mouse_input_report()
    }
    #[inline] pub fn get_current_time() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_current_time()
    }
    #[inline] pub fn get_cycling_power_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_control_point()
    }
    #[inline] pub fn get_cycling_power_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_feature()
    }
    #[inline] pub fn get_cycling_power_measurement() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_measurement()
    }
    #[inline] pub fn get_cycling_power_vector() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_cycling_power_vector()
    }
    #[inline] pub fn get_date_time() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_date_time()
    }
    #[inline] pub fn get_day_date_time() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_day_date_time()
    }
    #[inline] pub fn get_day_of_week() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_day_of_week()
    }
    #[inline] pub fn get_gap_device_name() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_device_name()
    }
    #[inline] pub fn get_dst_offset() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_dst_offset()
    }
    #[inline] pub fn get_exact_time_256() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_exact_time_256()
    }
    #[inline] pub fn get_firmware_revision_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_firmware_revision_string()
    }
    #[inline] pub fn get_hardware_revision_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_hardware_revision_string()
    }
    #[inline] pub fn get_hid_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_hid_control_point()
    }
    #[inline] pub fn get_hid_information() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_hid_information()
    }
    #[inline] pub fn get_ieee1107320601_regulatory_certification_data_list() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ieee1107320601_regulatory_certification_data_list()
    }
    #[inline] pub fn get_ln_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ln_control_point()
    }
    #[inline] pub fn get_ln_feature() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ln_feature()
    }
    #[inline] pub fn get_local_time_information() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_local_time_information()
    }
    #[inline] pub fn get_location_and_speed() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_location_and_speed()
    }
    #[inline] pub fn get_manufacturer_name_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_manufacturer_name_string()
    }
    #[inline] pub fn get_model_number_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_model_number_string()
    }
    #[inline] pub fn get_navigation() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_navigation()
    }
    #[inline] pub fn get_new_alert() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_new_alert()
    }
    #[inline] pub fn get_gap_peripheral_preferred_connection_parameters() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_peripheral_preferred_connection_parameters()
    }
    #[inline] pub fn get_gap_peripheral_privacy_flag() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_peripheral_privacy_flag()
    }
    #[inline] pub fn get_pnp_id() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_pnp_id()
    }
    #[inline] pub fn get_position_quality() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_position_quality()
    }
    #[inline] pub fn get_protocol_mode() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_protocol_mode()
    }
    #[inline] pub fn get_gap_reconnection_address() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gap_reconnection_address()
    }
    #[inline] pub fn get_reference_time_information() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_reference_time_information()
    }
    #[inline] pub fn get_report() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_report()
    }
    #[inline] pub fn get_report_map() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_report_map()
    }
    #[inline] pub fn get_ringer_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ringer_control_point()
    }
    #[inline] pub fn get_ringer_setting() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_ringer_setting()
    }
    #[inline] pub fn get_scan_interval_window() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_scan_interval_window()
    }
    #[inline] pub fn get_scan_refresh() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_scan_refresh()
    }
    #[inline] pub fn get_serial_number_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_serial_number_string()
    }
    #[inline] pub fn get_gatt_service_changed() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_gatt_service_changed()
    }
    #[inline] pub fn get_software_revision_string() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_software_revision_string()
    }
    #[inline] pub fn get_supported_new_alert_category() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_supported_new_alert_category()
    }
    #[inline] pub fn get_support_unread_alert_category() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_support_unread_alert_category()
    }
    #[inline] pub fn get_system_id() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_system_id()
    }
    #[inline] pub fn get_time_accuracy() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_accuracy()
    }
    #[inline] pub fn get_time_source() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_source()
    }
    #[inline] pub fn get_time_update_control_point() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_update_control_point()
    }
    #[inline] pub fn get_time_update_state() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_update_state()
    }
    #[inline] pub fn get_time_with_dst() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_with_dst()
    }
    #[inline] pub fn get_time_zone() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_time_zone()
    }
    #[inline] pub fn get_tx_power_level() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_tx_power_level()
    }
    #[inline] pub fn get_unread_alert_status() -> Result<Guid> {
        <Self as RtActivatable<IGattCharacteristicUuidsStatics2>>::get_activation_factory().get_unread_alert_status()
    }
}
DEFINE_CLSID!(GattCharacteristicUuids(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,67,104,97,114,97,99,116,101,114,105,115,116,105,99,85,117,105,100,115,0]) [CLSID_GattCharacteristicUuids]);
DEFINE_IID!(IID_IGattCharacteristicUuidsStatics, 1492796806, 45534, 18188, 183, 222, 13, 17, 255, 68, 244, 183);
RT_INTERFACE!{static interface IGattCharacteristicUuidsStatics(IGattCharacteristicUuidsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicUuidsStatics] {
    fn get_BatteryLevel(&self, out: *mut Guid) -> HRESULT,
    fn get_BloodPressureFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_BloodPressureMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_BodySensorLocation(&self, out: *mut Guid) -> HRESULT,
    fn get_CscFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_CscMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_GlucoseFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_GlucoseMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_GlucoseMeasurementContext(&self, out: *mut Guid) -> HRESULT,
    fn get_HeartRateControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_HeartRateMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_IntermediateCuffPressure(&self, out: *mut Guid) -> HRESULT,
    fn get_IntermediateTemperature(&self, out: *mut Guid) -> HRESULT,
    fn get_MeasurementInterval(&self, out: *mut Guid) -> HRESULT,
    fn get_RecordAccessControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_RscFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_RscMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_SCControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_SensorLocation(&self, out: *mut Guid) -> HRESULT,
    fn get_TemperatureMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_TemperatureType(&self, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattCharacteristicUuidsStatics> {
    #[inline] pub fn get_battery_level(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BatteryLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BloodPressureFeature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BloodPressureMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_body_sensor_location(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BodySensorLocation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_csc_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CscFeature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_csc_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CscMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GlucoseFeature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GlucoseMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose_measurement_context(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GlucoseMeasurementContext)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeartRateControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeartRateMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_cuff_pressure(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IntermediateCuffPressure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_temperature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IntermediateTemperature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_measurement_interval(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MeasurementInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_record_access_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RecordAccessControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rsc_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RscFeature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rsc_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RscMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sc_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SCControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sensor_location(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SensorLocation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_temperature_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TemperatureMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_temperature_type(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TemperatureType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattCharacteristicUuidsStatics2, 408269861, 54382, 18988, 156, 63, 237, 109, 234, 41, 231, 190);
RT_INTERFACE!{static interface IGattCharacteristicUuidsStatics2(IGattCharacteristicUuidsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicUuidsStatics2] {
    fn get_AlertCategoryId(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertCategoryIdBitMask(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertLevel(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertNotificationControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_AlertStatus(&self, out: *mut Guid) -> HRESULT,
    fn get_GapAppearance(&self, out: *mut Guid) -> HRESULT,
    fn get_BootKeyboardInputReport(&self, out: *mut Guid) -> HRESULT,
    fn get_BootKeyboardOutputReport(&self, out: *mut Guid) -> HRESULT,
    fn get_BootMouseInputReport(&self, out: *mut Guid) -> HRESULT,
    fn get_CurrentTime(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerMeasurement(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPowerVector(&self, out: *mut Guid) -> HRESULT,
    fn get_DateTime(&self, out: *mut Guid) -> HRESULT,
    fn get_DayDateTime(&self, out: *mut Guid) -> HRESULT,
    fn get_DayOfWeek(&self, out: *mut Guid) -> HRESULT,
    fn get_GapDeviceName(&self, out: *mut Guid) -> HRESULT,
    fn get_DstOffset(&self, out: *mut Guid) -> HRESULT,
    fn get_ExactTime256(&self, out: *mut Guid) -> HRESULT,
    fn get_FirmwareRevisionString(&self, out: *mut Guid) -> HRESULT,
    fn get_HardwareRevisionString(&self, out: *mut Guid) -> HRESULT,
    fn get_HidControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_HidInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_Ieee1107320601RegulatoryCertificationDataList(&self, out: *mut Guid) -> HRESULT,
    fn get_LnControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_LnFeature(&self, out: *mut Guid) -> HRESULT,
    fn get_LocalTimeInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_LocationAndSpeed(&self, out: *mut Guid) -> HRESULT,
    fn get_ManufacturerNameString(&self, out: *mut Guid) -> HRESULT,
    fn get_ModelNumberString(&self, out: *mut Guid) -> HRESULT,
    fn get_Navigation(&self, out: *mut Guid) -> HRESULT,
    fn get_NewAlert(&self, out: *mut Guid) -> HRESULT,
    fn get_GapPeripheralPreferredConnectionParameters(&self, out: *mut Guid) -> HRESULT,
    fn get_GapPeripheralPrivacyFlag(&self, out: *mut Guid) -> HRESULT,
    fn get_PnpId(&self, out: *mut Guid) -> HRESULT,
    fn get_PositionQuality(&self, out: *mut Guid) -> HRESULT,
    fn get_ProtocolMode(&self, out: *mut Guid) -> HRESULT,
    fn get_GapReconnectionAddress(&self, out: *mut Guid) -> HRESULT,
    fn get_ReferenceTimeInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_Report(&self, out: *mut Guid) -> HRESULT,
    fn get_ReportMap(&self, out: *mut Guid) -> HRESULT,
    fn get_RingerControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_RingerSetting(&self, out: *mut Guid) -> HRESULT,
    fn get_ScanIntervalWindow(&self, out: *mut Guid) -> HRESULT,
    fn get_ScanRefresh(&self, out: *mut Guid) -> HRESULT,
    fn get_SerialNumberString(&self, out: *mut Guid) -> HRESULT,
    fn get_GattServiceChanged(&self, out: *mut Guid) -> HRESULT,
    fn get_SoftwareRevisionString(&self, out: *mut Guid) -> HRESULT,
    fn get_SupportedNewAlertCategory(&self, out: *mut Guid) -> HRESULT,
    fn get_SupportUnreadAlertCategory(&self, out: *mut Guid) -> HRESULT,
    fn get_SystemId(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeAccuracy(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeSource(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeUpdateControlPoint(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeUpdateState(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeWithDst(&self, out: *mut Guid) -> HRESULT,
    fn get_TimeZone(&self, out: *mut Guid) -> HRESULT,
    fn get_TxPowerLevel(&self, out: *mut Guid) -> HRESULT,
    fn get_UnreadAlertStatus(&self, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattCharacteristicUuidsStatics2> {
    #[inline] pub fn get_alert_category_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlertCategoryId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_category_id_bit_mask(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlertCategoryIdBitMask)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_level(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlertLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_notification_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlertNotificationControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alert_status(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlertStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_appearance(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GapAppearance)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_boot_keyboard_input_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BootKeyboardInputReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_boot_keyboard_output_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BootKeyboardOutputReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_boot_mouse_input_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BootMouseInputReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CurrentTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingPowerControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingPowerFeature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_measurement(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingPowerMeasurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power_vector(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingPowerVector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_date_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DateTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_day_date_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DayDateTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_day_of_week(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DayOfWeek)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_device_name(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GapDeviceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dst_offset(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DstOffset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_exact_time_256(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExactTime256)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_firmware_revision_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_FirmwareRevisionString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_revision_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HardwareRevisionString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hid_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HidControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hid_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HidInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ieee1107320601_regulatory_certification_data_list(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ieee1107320601RegulatoryCertificationDataList)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ln_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LnControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ln_feature(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LnFeature)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_local_time_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocalTimeInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_and_speed(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationAndSpeed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_name_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ManufacturerNameString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_model_number_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ModelNumberString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_navigation(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Navigation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_alert(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NewAlert)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_peripheral_preferred_connection_parameters(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GapPeripheralPreferredConnectionParameters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_peripheral_privacy_flag(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GapPeripheralPrivacyFlag)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pnp_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PnpId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position_quality(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PositionQuality)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_mode(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtocolMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gap_reconnection_address(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GapReconnectionAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reference_time_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReferenceTimeInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Report)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_map(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportMap)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ringer_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RingerControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ringer_setting(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RingerSetting)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_interval_window(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScanIntervalWindow)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_refresh(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScanRefresh)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_serial_number_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SerialNumberString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gatt_service_changed(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GattServiceChanged)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_software_revision_string(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SoftwareRevisionString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_new_alert_category(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SupportedNewAlertCategory)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_support_unread_alert_category(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SupportUnreadAlertCategory)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_system_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SystemId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_accuracy(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TimeAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_source(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TimeSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_update_control_point(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TimeUpdateControlPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_update_state(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TimeUpdateState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_with_dst(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TimeWithDst)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_time_zone(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TimeZone)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tx_power_level(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TxPowerLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unread_alert_status(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UnreadAlertStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattClientCharacteristicConfigurationDescriptorValue: i32 {
    None = 0, Notify = 1, Indicate = 2,
}}
DEFINE_IID!(IID_IGattClientNotificationResult, 1349342617, 274, 16794, 142, 59, 174, 33, 175, 171, 210, 194);
RT_INTERFACE!{interface IGattClientNotificationResult(IGattClientNotificationResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattClientNotificationResult] {
    fn get_SubscribedClient(&self, out: *mut *mut GattSubscribedClient) -> HRESULT,
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT
}}
impl ComPtr<IGattClientNotificationResult> {
    #[inline] pub fn get_subscribed_client(&self) -> Result<Option<ComPtr<GattSubscribedClient>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SubscribedClient)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattClientNotificationResult: IGattClientNotificationResult}
DEFINE_IID!(IID_IGattClientNotificationResult2, 2410595479, 17888, 18814, 149, 130, 41, 161, 254, 40, 26, 213);
RT_INTERFACE!{interface IGattClientNotificationResult2(IGattClientNotificationResult2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattClientNotificationResult2] {
    fn get_BytesSent(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IGattClientNotificationResult2> {
    #[inline] pub fn get_bytes_sent(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BytesSent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattCommunicationStatus: i32 {
    Success = 0, Unreachable = 1, ProtocolError = 2, AccessDenied = 3,
}}
DEFINE_IID!(IID_IGattDescriptor, 2449825579, 32900, 17220, 180, 194, 40, 77, 225, 154, 133, 6);
RT_INTERFACE!{interface IGattDescriptor(IGattDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptor] {
    fn get_ProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_ProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn get_AttributeHandle(&self, out: *mut u16) -> HRESULT,
    fn ReadValueAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattReadResult>) -> HRESULT,
    fn ReadValueWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattReadResult>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn WriteValueAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<GattCommunicationStatus>) -> HRESULT
}}
impl ComPtr<IGattDescriptor> {
    #[inline] pub fn get_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ProtectionLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_handle(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttributeHandle)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read_value_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattReadResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadValueAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_value_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattReadResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadValueWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<GattCommunicationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteValueAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDescriptor: IGattDescriptor}
impl RtActivatable<IGattDescriptorStatics> for GattDescriptor {}
impl GattDescriptor {
    #[inline] pub fn convert_short_id_to_uuid(shortId: u16) -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorStatics>>::get_activation_factory().convert_short_id_to_uuid(shortId)
    }
}
DEFINE_CLSID!(GattDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_GattDescriptor]);
DEFINE_IID!(IID_IGattDescriptor2, 2404793657, 54832, 16492, 186, 17, 16, 205, 209, 107, 14, 94);
RT_INTERFACE!{interface IGattDescriptor2(IGattDescriptor2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptor2] {
    #[cfg(feature="windows-storage")] fn WriteValueWithResultAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<GattWriteResult>) -> HRESULT
}}
impl ComPtr<IGattDescriptor2> {
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value_with_result_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<GattWriteResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WriteValueWithResultAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDescriptorsResult, 2613088755, 38375, 17545, 141, 37, 255, 129, 149, 90, 87, 185);
RT_INTERFACE!{interface IGattDescriptorsResult(IGattDescriptorsResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptorsResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT,
    fn get_Descriptors(&self, out: *mut *mut foundation::collections::IVectorView<GattDescriptor>) -> HRESULT
}}
impl ComPtr<IGattDescriptorsResult> {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDescriptorsResult: IGattDescriptorsResult}
DEFINE_IID!(IID_IGattDescriptorStatics, 2449825581, 32900, 17220, 180, 194, 40, 77, 225, 154, 133, 6);
RT_INTERFACE!{static interface IGattDescriptorStatics(IGattDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptorStatics] {
    fn ConvertShortIdToUuid(&self, shortId: u16, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattDescriptorStatics> {
    #[inline] pub fn convert_short_id_to_uuid(&self, shortId: u16) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ConvertShortIdToUuid)(self.deref() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattDescriptorUuids}
impl RtActivatable<IGattDescriptorUuidsStatics> for GattDescriptorUuids {}
impl GattDescriptorUuids {
    #[inline] pub fn get_characteristic_aggregate_format() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_aggregate_format()
    }
    #[inline] pub fn get_characteristic_extended_properties() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_extended_properties()
    }
    #[inline] pub fn get_characteristic_presentation_format() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_presentation_format()
    }
    #[inline] pub fn get_characteristic_user_description() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_characteristic_user_description()
    }
    #[inline] pub fn get_client_characteristic_configuration() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_client_characteristic_configuration()
    }
    #[inline] pub fn get_server_characteristic_configuration() -> Result<Guid> {
        <Self as RtActivatable<IGattDescriptorUuidsStatics>>::get_activation_factory().get_server_characteristic_configuration()
    }
}
DEFINE_CLSID!(GattDescriptorUuids(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,115,99,114,105,112,116,111,114,85,117,105,100,115,0]) [CLSID_GattDescriptorUuids]);
DEFINE_IID!(IID_IGattDescriptorUuidsStatics, 2801296078, 40188, 17137, 145, 133, 255, 55, 183, 81, 129, 211);
RT_INTERFACE!{static interface IGattDescriptorUuidsStatics(IGattDescriptorUuidsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattDescriptorUuidsStatics] {
    fn get_CharacteristicAggregateFormat(&self, out: *mut Guid) -> HRESULT,
    fn get_CharacteristicExtendedProperties(&self, out: *mut Guid) -> HRESULT,
    fn get_CharacteristicPresentationFormat(&self, out: *mut Guid) -> HRESULT,
    fn get_CharacteristicUserDescription(&self, out: *mut Guid) -> HRESULT,
    fn get_ClientCharacteristicConfiguration(&self, out: *mut Guid) -> HRESULT,
    fn get_ServerCharacteristicConfiguration(&self, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattDescriptorUuidsStatics> {
    #[inline] pub fn get_characteristic_aggregate_format(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicAggregateFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_extended_properties(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicExtendedProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_presentation_format(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicPresentationFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_user_description(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicUserDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_client_characteristic_configuration(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClientCharacteristicConfiguration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_server_characteristic_configuration(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServerCharacteristicConfiguration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceService, 2893773829, 45884, 18383, 153, 15, 107, 143, 85, 119, 223, 113);
RT_INTERFACE!{interface IGattDeviceService(IGattDeviceServiceVtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceService] {
    fn GetCharacteristics(&self, characteristicUuid: Guid, out: *mut *mut foundation::collections::IVectorView<GattCharacteristic>) -> HRESULT,
    fn GetIncludedServices(&self, serviceUuid: Guid, out: *mut *mut foundation::collections::IVectorView<GattDeviceService>) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn get_AttributeHandle(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IGattDeviceService> {
    #[inline] pub fn get_characteristics(&self, characteristicUuid: Guid) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattCharacteristic>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCharacteristics)(self.deref() as *const _ as *mut _, characteristicUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services(&self, serviceUuid: Guid) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIncludedServices)(self.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_handle(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttributeHandle)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDeviceService: IGattDeviceService}
impl RtActivatable<IGattDeviceServiceStatics> for GattDeviceService {}
impl RtActivatable<IGattDeviceServiceStatics2> for GattDeviceService {}
impl GattDeviceService {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceService>>> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector_from_uuid(serviceUuid: Guid) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().get_device_selector_from_uuid(serviceUuid)
    }
    #[inline] pub fn get_device_selector_from_short_id(serviceShortId: u16) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().get_device_selector_from_short_id(serviceShortId)
    }
    #[inline] pub fn convert_short_id_to_uuid(shortId: u16) -> Result<Guid> {
        <Self as RtActivatable<IGattDeviceServiceStatics>>::get_activation_factory().convert_short_id_to_uuid(shortId)
    }
    #[inline] pub fn from_id_with_sharing_mode_async(deviceId: &HStringArg, sharingMode: GattSharingMode) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceService>>> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().from_id_with_sharing_mode_async(deviceId, sharingMode)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id(bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id(bluetoothDeviceId)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_with_cache_mode(bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id_with_cache_mode(bluetoothDeviceId, cacheMode)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid(bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>, serviceUuid: Guid) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id_and_uuid(bluetoothDeviceId, serviceUuid)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid_with_cache_mode(bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IGattDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_id_and_uuid_with_cache_mode(bluetoothDeviceId, serviceUuid, cacheMode)
    }
}
DEFINE_CLSID!(GattDeviceService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,68,101,118,105,99,101,83,101,114,118,105,99,101,0]) [CLSID_GattDeviceService]);
DEFINE_IID!(IID_IGattDeviceService2, 4233384459, 2829, 18184, 186, 224, 159, 253, 148, 137, 188, 89);
RT_INTERFACE!{interface IGattDeviceService2(IGattDeviceService2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceService2] {
    fn get_Device(&self, out: *mut *mut super::BluetoothLEDevice) -> HRESULT,
    fn get_ParentServices(&self, out: *mut *mut foundation::collections::IVectorView<GattDeviceService>) -> HRESULT,
    fn GetAllCharacteristics(&self, out: *mut *mut foundation::collections::IVectorView<GattCharacteristic>) -> HRESULT,
    fn GetAllIncludedServices(&self, out: *mut *mut foundation::collections::IVectorView<GattDeviceService>) -> HRESULT
}}
impl ComPtr<IGattDeviceService2> {
    #[inline] pub fn get_device(&self) -> Result<Option<ComPtr<super::BluetoothLEDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Device)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_services(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ParentServices)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_characteristics(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattCharacteristic>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllCharacteristics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_included_services(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllIncludedServices)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceService3, 2996021584, 3155, 17276, 169, 179, 92, 50, 16, 198, 229, 105);
RT_INTERFACE!{interface IGattDeviceService3(IGattDeviceService3Vtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceService3] {
    fn get_DeviceAccessInformation(&self, out: *mut *mut super::super::enumeration::DeviceAccessInformation) -> HRESULT,
    fn get_Session(&self, out: *mut *mut GattSession) -> HRESULT,
    fn get_SharingMode(&self, out: *mut GattSharingMode) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>) -> HRESULT,
    fn OpenAsync(&self, sharingMode: GattSharingMode, out: *mut *mut foundation::IAsyncOperation<GattOpenStatus>) -> HRESULT,
    fn GetCharacteristicsAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattCharacteristicsResult>) -> HRESULT,
    fn GetCharacteristicsWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattCharacteristicsResult>) -> HRESULT,
    fn GetCharacteristicsForUuidAsync(&self, characteristicUuid: Guid, out: *mut *mut foundation::IAsyncOperation<GattCharacteristicsResult>) -> HRESULT,
    fn GetCharacteristicsForUuidWithCacheModeAsync(&self, characteristicUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattCharacteristicsResult>) -> HRESULT,
    fn GetIncludedServicesAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattDeviceServicesResult>) -> HRESULT,
    fn GetIncludedServicesWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattDeviceServicesResult>) -> HRESULT,
    fn GetIncludedServicesForUuidAsync(&self, serviceUuid: Guid, out: *mut *mut foundation::IAsyncOperation<GattDeviceServicesResult>) -> HRESULT,
    fn GetIncludedServicesForUuidWithCacheModeAsync(&self, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<GattDeviceServicesResult>) -> HRESULT
}}
impl ComPtr<IGattDeviceService3> {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<ComPtr<super::super::enumeration::DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceAccessInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<GattSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<GattSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_async(&self, sharingMode: GattSharingMode) -> Result<ComPtr<foundation::IAsyncOperation<GattOpenStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenAsync)(self.deref() as *const _ as *mut _, sharingMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCharacteristicsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCharacteristicsWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_for_uuid_async(&self, characteristicUuid: Guid) -> Result<ComPtr<foundation::IAsyncOperation<GattCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCharacteristicsForUuidAsync)(self.deref() as *const _ as *mut _, characteristicUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics_for_uuid_with_cache_mode_async(&self, characteristicUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCharacteristicsForUuidWithCacheModeAsync)(self.deref() as *const _ as *mut _, characteristicUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIncludedServicesAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIncludedServicesWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_for_uuid_async(&self, serviceUuid: Guid) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIncludedServicesForUuidAsync)(self.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_included_services_for_uuid_with_cache_mode_async(&self, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceServicesResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIncludedServicesForUuidWithCacheModeAsync)(self.deref() as *const _ as *mut _, serviceUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceServicesResult, 387830766, 365, 16797, 131, 138, 87, 108, 244, 117, 163, 216);
RT_INTERFACE!{interface IGattDeviceServicesResult(IGattDeviceServicesResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceServicesResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT,
    fn get_Services(&self, out: *mut *mut foundation::collections::IVectorView<GattDeviceService>) -> HRESULT
}}
impl ComPtr<IGattDeviceServicesResult> {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_services(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Services)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattDeviceServicesResult: IGattDeviceServicesResult}
DEFINE_IID!(IID_IGattDeviceServiceStatics, 426573858, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
RT_INTERFACE!{static interface IGattDeviceServiceStatics(IGattDeviceServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceServiceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<GattDeviceService>) -> HRESULT,
    fn GetDeviceSelectorFromUuid(&self, serviceUuid: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromShortId(&self, serviceShortId: u16, out: *mut HSTRING) -> HRESULT,
    fn ConvertShortIdToUuid(&self, shortId: u16, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattDeviceServiceStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_uuid(&self, serviceUuid: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromUuid)(self.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_short_id(&self, serviceShortId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromShortId)(self.deref() as *const _ as *mut _, serviceShortId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn convert_short_id_to_uuid(&self, shortId: u16) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ConvertShortIdToUuid)(self.deref() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattDeviceServiceStatics2, 100931694, 9382, 19213, 162, 242, 48, 204, 1, 84, 93, 37);
RT_INTERFACE!{static interface IGattDeviceServiceStatics2(IGattDeviceServiceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattDeviceServiceStatics2] {
    fn FromIdWithSharingModeAsync(&self, deviceId: HSTRING, sharingMode: GattSharingMode, out: *mut *mut foundation::IAsyncOperation<GattDeviceService>) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceId(&self, bluetoothDeviceId: *mut super::BluetoothDeviceId, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceIdWithCacheMode(&self, bluetoothDeviceId: *mut super::BluetoothDeviceId, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceIdAndUuid(&self, bluetoothDeviceId: *mut super::BluetoothDeviceId, serviceUuid: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceIdAndUuidWithCacheMode(&self, bluetoothDeviceId: *mut super::BluetoothDeviceId, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IGattDeviceServiceStatics2> {
    #[inline] pub fn from_id_with_sharing_mode_async(&self, deviceId: &HStringArg, sharingMode: GattSharingMode) -> Result<ComPtr<foundation::IAsyncOperation<GattDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdWithSharingModeAsync)(self.deref() as *const _ as *mut _, deviceId.get(), sharingMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id(&self, bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceId)(self.deref() as *const _ as *mut _, bluetoothDeviceId.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_with_cache_mode(&self, bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceIdWithCacheMode)(self.deref() as *const _ as *mut _, bluetoothDeviceId.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid(&self, bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>, serviceUuid: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceIdAndUuid)(self.deref() as *const _ as *mut _, bluetoothDeviceId.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_id_and_uuid_with_cache_mode(&self, bluetoothDeviceId: &ComPtr<super::BluetoothDeviceId>, serviceUuid: Guid, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceIdAndUuidWithCacheMode)(self.deref() as *const _ as *mut _, bluetoothDeviceId.deref() as *const _ as *mut _, serviceUuid, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattLocalCharacteristic, 2933798765, 21522, 19828, 146, 168, 141, 235, 133, 38, 130, 156);
RT_INTERFACE!{interface IGattLocalCharacteristic(IGattLocalCharacteristicVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalCharacteristic] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_CharacteristicProperties(&self, out: *mut GattCharacteristicProperties) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn CreateDescriptorAsync(&self, descriptorUuid: Guid, parameters: *mut GattLocalDescriptorParameters, out: *mut *mut foundation::IAsyncOperation<GattLocalDescriptorResult>) -> HRESULT,
    fn get_Descriptors(&self, out: *mut *mut foundation::collections::IVectorView<GattLocalDescriptor>) -> HRESULT,
    fn get_UserDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PresentationFormats(&self, out: *mut *mut foundation::collections::IVectorView<GattPresentationFormat>) -> HRESULT,
    fn get_SubscribedClients(&self, out: *mut *mut foundation::collections::IVectorView<GattSubscribedClient>) -> HRESULT,
    fn add_SubscribedClientsChanged(&self, handler: *mut foundation::TypedEventHandler<GattLocalCharacteristic, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SubscribedClientsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReadRequested(&self, handler: *mut foundation::TypedEventHandler<GattLocalCharacteristic, GattReadRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WriteRequested(&self, handler: *mut foundation::TypedEventHandler<GattLocalCharacteristic, GattWriteRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WriteRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn NotifyValueAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<GattClientNotificationResult>>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn NotifyValueForSubscribedClientAsync(&self, value: *mut crate::windows::storage::streams::IBuffer, subscribedClient: *mut GattSubscribedClient, out: *mut *mut foundation::IAsyncOperation<GattClientNotificationResult>) -> HRESULT
}}
impl ComPtr<IGattLocalCharacteristic> {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StaticValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_properties(&self) -> Result<GattCharacteristicProperties> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_descriptor_async(&self, descriptorUuid: Guid, parameters: &ComPtr<GattLocalDescriptorParameters>) -> Result<ComPtr<foundation::IAsyncOperation<GattLocalDescriptorResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateDescriptorAsync)(self.deref() as *const _ as *mut _, descriptorUuid, parameters.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattLocalDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_user_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UserDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_formats(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattPresentationFormat>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PresentationFormats)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subscribed_clients(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattSubscribedClient>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SubscribedClients)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_subscribed_clients_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattLocalCharacteristic, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SubscribedClientsChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_subscribed_clients_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SubscribedClientsChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_read_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<GattLocalCharacteristic, GattReadRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_read_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_write_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<GattLocalCharacteristic, GattWriteRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_WriteRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_write_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_WriteRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn notify_value_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<GattClientNotificationResult>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).NotifyValueAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn notify_value_for_subscribed_client_async(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>, subscribedClient: &ComPtr<GattSubscribedClient>) -> Result<ComPtr<foundation::IAsyncOperation<GattClientNotificationResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).NotifyValueForSubscribedClientAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, subscribedClient.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalCharacteristic: IGattLocalCharacteristic}
DEFINE_IID!(IID_IGattLocalCharacteristicParameters, 4210507188, 19711, 17607, 132, 69, 4, 14, 110, 173, 0, 99);
RT_INTERFACE!{interface IGattLocalCharacteristicParameters(IGattLocalCharacteristicParametersVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalCharacteristicParameters] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_StaticValue(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn put_CharacteristicProperties(&self, value: GattCharacteristicProperties) -> HRESULT,
    fn get_CharacteristicProperties(&self, out: *mut GattCharacteristicProperties) -> HRESULT,
    fn put_ReadProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_WriteProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_UserDescription(&self, value: HSTRING) -> HRESULT,
    fn get_UserDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PresentationFormats(&self, out: *mut *mut foundation::collections::IVector<GattPresentationFormat>) -> HRESULT
}}
impl ComPtr<IGattLocalCharacteristicParameters> {
    #[cfg(feature="windows-storage")] #[inline] pub fn set_static_value(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StaticValue)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StaticValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_characteristic_properties(&self, value: GattCharacteristicProperties) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CharacteristicProperties)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristic_properties(&self) -> Result<GattCharacteristicProperties> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_read_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadProtectionLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_write_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_WriteProtectionLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_user_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_UserDescription)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_user_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UserDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_formats(&self) -> Result<Option<ComPtr<foundation::collections::IVector<GattPresentationFormat>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PresentationFormats)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalCharacteristicParameters: IGattLocalCharacteristicParameters}
impl RtActivatable<IActivationFactory> for GattLocalCharacteristicParameters {}
DEFINE_CLSID!(GattLocalCharacteristicParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,76,111,99,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_GattLocalCharacteristicParameters]);
DEFINE_IID!(IID_IGattLocalCharacteristicResult, 2037767835, 368, 17303, 150, 102, 146, 248, 99, 241, 46, 230);
RT_INTERFACE!{interface IGattLocalCharacteristicResult(IGattLocalCharacteristicResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalCharacteristicResult] {
    fn get_Characteristic(&self, out: *mut *mut GattLocalCharacteristic) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl ComPtr<IGattLocalCharacteristicResult> {
    #[inline] pub fn get_characteristic(&self) -> Result<Option<ComPtr<GattLocalCharacteristic>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristic)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalCharacteristicResult: IGattLocalCharacteristicResult}
DEFINE_IID!(IID_IGattLocalDescriptor, 4102995462, 30877, 19019, 134, 82, 189, 1, 123, 93, 47, 198);
RT_INTERFACE!{interface IGattLocalDescriptor(IGattLocalDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalDescriptor] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn add_ReadRequested(&self, handler: *mut foundation::TypedEventHandler<GattLocalDescriptor, GattReadRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_WriteRequested(&self, handler: *mut foundation::TypedEventHandler<GattLocalDescriptor, GattWriteRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_WriteRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGattLocalDescriptor> {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StaticValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_read_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<GattLocalDescriptor, GattReadRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_read_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_write_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<GattLocalDescriptor, GattWriteRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_WriteRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_write_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_WriteRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalDescriptor: IGattLocalDescriptor}
DEFINE_IID!(IID_IGattLocalDescriptorParameters, 1608441450, 62401, 19302, 140, 75, 227, 210, 41, 59, 64, 233);
RT_INTERFACE!{interface IGattLocalDescriptorParameters(IGattLocalDescriptorParametersVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalDescriptorParameters] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_StaticValue(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_StaticValue(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn put_ReadProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_ReadProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT,
    fn put_WriteProtectionLevel(&self, value: GattProtectionLevel) -> HRESULT,
    fn get_WriteProtectionLevel(&self, out: *mut GattProtectionLevel) -> HRESULT
}}
impl ComPtr<IGattLocalDescriptorParameters> {
    #[cfg(feature="windows-storage")] #[inline] pub fn set_static_value(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StaticValue)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_static_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StaticValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_read_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadProtectionLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_write_protection_level(&self, value: GattProtectionLevel) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_WriteProtectionLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_protection_level(&self) -> Result<GattProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalDescriptorParameters: IGattLocalDescriptorParameters}
impl RtActivatable<IActivationFactory> for GattLocalDescriptorParameters {}
DEFINE_CLSID!(GattLocalDescriptorParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,76,111,99,97,108,68,101,115,99,114,105,112,116,111,114,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_GattLocalDescriptorParameters]);
DEFINE_IID!(IID_IGattLocalDescriptorResult, 928485822, 12831, 17254, 191, 193, 59, 198, 184, 44, 121, 248);
RT_INTERFACE!{interface IGattLocalDescriptorResult(IGattLocalDescriptorResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalDescriptorResult] {
    fn get_Descriptor(&self, out: *mut *mut GattLocalDescriptor) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl ComPtr<IGattLocalDescriptorResult> {
    #[inline] pub fn get_descriptor(&self) -> Result<Option<ComPtr<GattLocalDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalDescriptorResult: IGattLocalDescriptorResult}
DEFINE_IID!(IID_IGattLocalService, 4111721048, 63479, 18690, 184, 3, 87, 252, 199, 214, 254, 131);
RT_INTERFACE!{interface IGattLocalService(IGattLocalServiceVtbl): IInspectable(IInspectableVtbl) [IID_IGattLocalService] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn CreateCharacteristicAsync(&self, characteristicUuid: Guid, parameters: *mut GattLocalCharacteristicParameters, out: *mut *mut foundation::IAsyncOperation<GattLocalCharacteristicResult>) -> HRESULT,
    fn get_Characteristics(&self, out: *mut *mut foundation::collections::IVectorView<GattLocalCharacteristic>) -> HRESULT
}}
impl ComPtr<IGattLocalService> {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_characteristic_async(&self, characteristicUuid: Guid, parameters: &ComPtr<GattLocalCharacteristicParameters>) -> Result<ComPtr<foundation::IAsyncOperation<GattLocalCharacteristicResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateCharacteristicAsync)(self.deref() as *const _ as *mut _, characteristicUuid, parameters.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GattLocalCharacteristic>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattLocalService: IGattLocalService}
RT_ENUM! { enum GattOpenStatus: i32 {
    Unspecified = 0, Success = 1, AlreadyOpened = 2, NotFound = 3, SharingViolation = 4, AccessDenied = 5,
}}
DEFINE_IID!(IID_IGattPresentationFormat, 426573857, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
RT_INTERFACE!{interface IGattPresentationFormat(IGattPresentationFormatVtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormat] {
    fn get_FormatType(&self, out: *mut u8) -> HRESULT,
    fn get_Exponent(&self, out: *mut i32) -> HRESULT,
    fn get_Unit(&self, out: *mut u16) -> HRESULT,
    fn get_Namespace(&self, out: *mut u8) -> HRESULT,
    fn get_Description(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IGattPresentationFormat> {
    #[inline] pub fn get_format_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_FormatType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_exponent(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Exponent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unit(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Unit)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_namespace(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Namespace)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Description)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattPresentationFormat: IGattPresentationFormat}
impl RtActivatable<IGattPresentationFormatStatics> for GattPresentationFormat {}
impl RtActivatable<IGattPresentationFormatStatics2> for GattPresentationFormat {}
impl GattPresentationFormat {
    #[inline] pub fn get_bluetooth_sig_assigned_numbers() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatStatics>>::get_activation_factory().get_bluetooth_sig_assigned_numbers()
    }
    #[inline] pub fn from_parts(formatType: u8, exponent: i32, unit: u16, namespaceId: u8, description: u16) -> Result<Option<ComPtr<GattPresentationFormat>>> {
        <Self as RtActivatable<IGattPresentationFormatStatics2>>::get_activation_factory().from_parts(formatType, exponent, unit, namespaceId, description)
    }
}
DEFINE_CLSID!(GattPresentationFormat(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,101,115,101,110,116,97,116,105,111,110,70,111,114,109,97,116,0]) [CLSID_GattPresentationFormat]);
DEFINE_IID!(IID_IGattPresentationFormatStatics, 426573856, 64173, 17884, 174, 91, 42, 195, 24, 78, 132, 219);
RT_INTERFACE!{static interface IGattPresentationFormatStatics(IGattPresentationFormatStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatStatics] {
    fn get_BluetoothSigAssignedNumbers(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IGattPresentationFormatStatics> {
    #[inline] pub fn get_bluetooth_sig_assigned_numbers(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluetoothSigAssignedNumbers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattPresentationFormatStatics2, 2848069395, 47151, 17246, 182, 52, 33, 253, 133, 164, 60, 7);
RT_INTERFACE!{static interface IGattPresentationFormatStatics2(IGattPresentationFormatStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatStatics2] {
    fn FromParts(&self, formatType: u8, exponent: i32, unit: u16, namespaceId: u8, description: u16, out: *mut *mut GattPresentationFormat) -> HRESULT
}}
impl ComPtr<IGattPresentationFormatStatics2> {
    #[inline] pub fn from_parts(&self, formatType: u8, exponent: i32, unit: u16, namespaceId: u8, description: u16) -> Result<Option<ComPtr<GattPresentationFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromParts)(self.deref() as *const _ as *mut _, formatType, exponent, unit, namespaceId, description, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattPresentationFormatTypes}
impl RtActivatable<IGattPresentationFormatTypesStatics> for GattPresentationFormatTypes {}
impl GattPresentationFormatTypes {
    #[inline] pub fn get_boolean() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_boolean()
    }
    #[inline] pub fn get_bit2() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_bit2()
    }
    #[inline] pub fn get_nibble() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_nibble()
    }
    #[inline] pub fn get_uint8() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint8()
    }
    #[inline] pub fn get_uint12() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint12()
    }
    #[inline] pub fn get_uint16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint16()
    }
    #[inline] pub fn get_uint24() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint24()
    }
    #[inline] pub fn get_uint32() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint32()
    }
    #[inline] pub fn get_uint48() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint48()
    }
    #[inline] pub fn get_uint64() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint64()
    }
    #[inline] pub fn get_uint128() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_uint128()
    }
    #[inline] pub fn get_sint8() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint8()
    }
    #[inline] pub fn get_sint12() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint12()
    }
    #[inline] pub fn get_sint16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint16()
    }
    #[inline] pub fn get_sint24() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint24()
    }
    #[inline] pub fn get_sint32() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint32()
    }
    #[inline] pub fn get_sint48() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint48()
    }
    #[inline] pub fn get_sint64() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint64()
    }
    #[inline] pub fn get_sint128() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sint128()
    }
    #[inline] pub fn get_float32() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_float32()
    }
    #[inline] pub fn get_float64() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_float64()
    }
    #[inline] pub fn get_sfloat() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_sfloat()
    }
    #[inline] pub fn get_float() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_float()
    }
    #[inline] pub fn get_duint16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_duint16()
    }
    #[inline] pub fn get_utf8() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_utf8()
    }
    #[inline] pub fn get_utf16() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_utf16()
    }
    #[inline] pub fn get_struct() -> Result<u8> {
        <Self as RtActivatable<IGattPresentationFormatTypesStatics>>::get_activation_factory().get_struct()
    }
}
DEFINE_CLSID!(GattPresentationFormatTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,101,115,101,110,116,97,116,105,111,110,70,111,114,109,97,116,84,121,112,101,115,0]) [CLSID_GattPresentationFormatTypes]);
DEFINE_IID!(IID_IGattPresentationFormatTypesStatics, 4210145802, 12474, 16540, 190, 247, 207, 251, 109, 3, 184, 251);
RT_INTERFACE!{static interface IGattPresentationFormatTypesStatics(IGattPresentationFormatTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattPresentationFormatTypesStatics] {
    fn get_Boolean(&self, out: *mut u8) -> HRESULT,
    fn get_Bit2(&self, out: *mut u8) -> HRESULT,
    fn get_Nibble(&self, out: *mut u8) -> HRESULT,
    fn get_UInt8(&self, out: *mut u8) -> HRESULT,
    fn get_UInt12(&self, out: *mut u8) -> HRESULT,
    fn get_UInt16(&self, out: *mut u8) -> HRESULT,
    fn get_UInt24(&self, out: *mut u8) -> HRESULT,
    fn get_UInt32(&self, out: *mut u8) -> HRESULT,
    fn get_UInt48(&self, out: *mut u8) -> HRESULT,
    fn get_UInt64(&self, out: *mut u8) -> HRESULT,
    fn get_UInt128(&self, out: *mut u8) -> HRESULT,
    fn get_SInt8(&self, out: *mut u8) -> HRESULT,
    fn get_SInt12(&self, out: *mut u8) -> HRESULT,
    fn get_SInt16(&self, out: *mut u8) -> HRESULT,
    fn get_SInt24(&self, out: *mut u8) -> HRESULT,
    fn get_SInt32(&self, out: *mut u8) -> HRESULT,
    fn get_SInt48(&self, out: *mut u8) -> HRESULT,
    fn get_SInt64(&self, out: *mut u8) -> HRESULT,
    fn get_SInt128(&self, out: *mut u8) -> HRESULT,
    fn get_Float32(&self, out: *mut u8) -> HRESULT,
    fn get_Float64(&self, out: *mut u8) -> HRESULT,
    fn get_SFloat(&self, out: *mut u8) -> HRESULT,
    fn get_Float(&self, out: *mut u8) -> HRESULT,
    fn get_DUInt16(&self, out: *mut u8) -> HRESULT,
    fn get_Utf8(&self, out: *mut u8) -> HRESULT,
    fn get_Utf16(&self, out: *mut u8) -> HRESULT,
    fn get_Struct(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IGattPresentationFormatTypesStatics> {
    #[inline] pub fn get_boolean(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Boolean)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bit2(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Bit2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_nibble(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Nibble)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint8(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt8)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint12(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt12)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt16)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint24(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt24)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint32(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt32)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint48(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt48)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint64(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt64)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uint128(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UInt128)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint8(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt8)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint12(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt12)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt16)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint24(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt24)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint32(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt32)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint48(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt48)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint64(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt64)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sint128(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SInt128)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_float32(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Float32)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_float64(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Float64)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sfloat(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SFloat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_float(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Float)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duint16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DUInt16)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_utf8(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Utf8)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_utf16(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Utf16)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_struct(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Struct)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattProtectionLevel: i32 {
    Plain = 0, AuthenticationRequired = 1, EncryptionRequired = 2, EncryptionAndAuthenticationRequired = 3,
}}
RT_CLASS!{static class GattProtocolError}
impl RtActivatable<IGattProtocolErrorStatics> for GattProtocolError {}
impl GattProtocolError {
    #[inline] pub fn get_invalid_handle() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_handle()
    }
    #[inline] pub fn get_read_not_permitted() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_read_not_permitted()
    }
    #[inline] pub fn get_write_not_permitted() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_write_not_permitted()
    }
    #[inline] pub fn get_invalid_pdu() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_pdu()
    }
    #[inline] pub fn get_insufficient_authentication() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_authentication()
    }
    #[inline] pub fn get_request_not_supported() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_request_not_supported()
    }
    #[inline] pub fn get_invalid_offset() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_offset()
    }
    #[inline] pub fn get_insufficient_authorization() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_authorization()
    }
    #[inline] pub fn get_prepare_queue_full() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_prepare_queue_full()
    }
    #[inline] pub fn get_attribute_not_found() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_attribute_not_found()
    }
    #[inline] pub fn get_attribute_not_long() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_attribute_not_long()
    }
    #[inline] pub fn get_insufficient_encryption_key_size() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_encryption_key_size()
    }
    #[inline] pub fn get_invalid_attribute_value_length() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_invalid_attribute_value_length()
    }
    #[inline] pub fn get_unlikely_error() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_unlikely_error()
    }
    #[inline] pub fn get_insufficient_encryption() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_encryption()
    }
    #[inline] pub fn get_unsupported_group_type() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_unsupported_group_type()
    }
    #[inline] pub fn get_insufficient_resources() -> Result<u8> {
        <Self as RtActivatable<IGattProtocolErrorStatics>>::get_activation_factory().get_insufficient_resources()
    }
}
DEFINE_CLSID!(GattProtocolError(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,80,114,111,116,111,99,111,108,69,114,114,111,114,0]) [CLSID_GattProtocolError]);
DEFINE_IID!(IID_IGattProtocolErrorStatics, 3393635781, 3788, 18441, 190, 163, 207, 121, 188, 153, 30, 55);
RT_INTERFACE!{static interface IGattProtocolErrorStatics(IGattProtocolErrorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattProtocolErrorStatics] {
    fn get_InvalidHandle(&self, out: *mut u8) -> HRESULT,
    fn get_ReadNotPermitted(&self, out: *mut u8) -> HRESULT,
    fn get_WriteNotPermitted(&self, out: *mut u8) -> HRESULT,
    fn get_InvalidPdu(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientAuthentication(&self, out: *mut u8) -> HRESULT,
    fn get_RequestNotSupported(&self, out: *mut u8) -> HRESULT,
    fn get_InvalidOffset(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientAuthorization(&self, out: *mut u8) -> HRESULT,
    fn get_PrepareQueueFull(&self, out: *mut u8) -> HRESULT,
    fn get_AttributeNotFound(&self, out: *mut u8) -> HRESULT,
    fn get_AttributeNotLong(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientEncryptionKeySize(&self, out: *mut u8) -> HRESULT,
    fn get_InvalidAttributeValueLength(&self, out: *mut u8) -> HRESULT,
    fn get_UnlikelyError(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientEncryption(&self, out: *mut u8) -> HRESULT,
    fn get_UnsupportedGroupType(&self, out: *mut u8) -> HRESULT,
    fn get_InsufficientResources(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IGattProtocolErrorStatics> {
    #[inline] pub fn get_invalid_handle(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidHandle)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_read_not_permitted(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadNotPermitted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_not_permitted(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteNotPermitted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_pdu(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidPdu)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_authentication(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InsufficientAuthentication)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_request_not_supported(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RequestNotSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_offset(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidOffset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_authorization(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InsufficientAuthorization)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_prepare_queue_full(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PrepareQueueFull)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_not_found(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttributeNotFound)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attribute_not_long(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttributeNotLong)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_encryption_key_size(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InsufficientEncryptionKeySize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_invalid_attribute_value_length(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InvalidAttributeValueLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unlikely_error(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UnlikelyError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_encryption(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InsufficientEncryption)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unsupported_group_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UnsupportedGroupType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_insufficient_resources(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InsufficientResources)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattReadClientCharacteristicConfigurationDescriptorResult, 1671851785, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
RT_INTERFACE!{interface IGattReadClientCharacteristicConfigurationDescriptorResult(IGattReadClientCharacteristicConfigurationDescriptorResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattReadClientCharacteristicConfigurationDescriptorResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ClientCharacteristicConfigurationDescriptor(&self, out: *mut GattClientCharacteristicConfigurationDescriptorValue) -> HRESULT
}}
impl ComPtr<IGattReadClientCharacteristicConfigurationDescriptorResult> {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_client_characteristic_configuration_descriptor(&self) -> Result<GattClientCharacteristicConfigurationDescriptorValue> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClientCharacteristicConfigurationDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadClientCharacteristicConfigurationDescriptorResult: IGattReadClientCharacteristicConfigurationDescriptorResult}
DEFINE_IID!(IID_IGattReadClientCharacteristicConfigurationDescriptorResult2, 468821405, 47693, 17954, 134, 81, 244, 238, 21, 13, 10, 93);
RT_INTERFACE!{interface IGattReadClientCharacteristicConfigurationDescriptorResult2(IGattReadClientCharacteristicConfigurationDescriptorResult2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattReadClientCharacteristicConfigurationDescriptorResult2] {
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT
}}
impl ComPtr<IGattReadClientCharacteristicConfigurationDescriptorResult2> {
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattReadRequest, 4057818421, 27341, 17062, 164, 187, 215, 137, 218, 224, 4, 62);
RT_INTERFACE!{interface IGattReadRequest(IGattReadRequestVtbl): IInspectable(IInspectableVtbl) [IID_IGattReadRequest] {
    fn get_Offset(&self, out: *mut u32) -> HRESULT,
    fn get_Length(&self, out: *mut u32) -> HRESULT,
    fn get_State(&self, out: *mut GattRequestState) -> HRESULT,
    fn add_StateChanged(&self, handler: *mut foundation::TypedEventHandler<GattReadRequest, GattRequestStateChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn RespondWithValue(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn RespondWithProtocolError(&self, protocolError: u8) -> HRESULT
}}
impl ComPtr<IGattReadRequest> {
    #[inline] pub fn get_offset(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Offset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Length)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<GattRequestState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattReadRequest, GattRequestStateChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StateChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StateChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn respond_with_value(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RespondWithValue)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn respond_with_protocol_error(&self, protocolError: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RespondWithProtocolError)(self.deref() as *const _ as *mut _, protocolError);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadRequest: IGattReadRequest}
DEFINE_IID!(IID_IGattReadRequestedEventArgs, 2471064131, 62364, 18507, 138, 182, 153, 107, 164, 134, 207, 163);
RT_INTERFACE!{interface IGattReadRequestedEventArgs(IGattReadRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattReadRequestedEventArgs] {
    fn get_Session(&self, out: *mut *mut GattSession) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT,
    fn GetRequestAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattReadRequest>) -> HRESULT
}}
impl ComPtr<IGattReadRequestedEventArgs> {
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<GattSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_request_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattReadRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRequestAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadRequestedEventArgs: IGattReadRequestedEventArgs}
DEFINE_IID!(IID_IGattReadResult, 1671851784, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
RT_INTERFACE!{interface IGattReadResult(IGattReadResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattReadResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IGattReadResult> {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReadResult: IGattReadResult}
DEFINE_IID!(IID_IGattReadResult2, 2702135456, 64323, 18607, 186, 170, 99, 138, 92, 99, 41, 254);
RT_INTERFACE!{interface IGattReadResult2(IGattReadResult2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattReadResult2] {
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT
}}
impl ComPtr<IGattReadResult2> {
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattReliableWriteTransaction, 1671851783, 6890, 19532, 165, 15, 151, 186, 228, 116, 179, 72);
RT_INTERFACE!{interface IGattReliableWriteTransaction(IGattReliableWriteTransactionVtbl): IInspectable(IInspectableVtbl) [IID_IGattReliableWriteTransaction] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn WriteValue(&self, characteristic: *mut GattCharacteristic, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn CommitAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattCommunicationStatus>) -> HRESULT
}}
impl ComPtr<IGattReliableWriteTransaction> {
    #[cfg(feature="windows-storage")] #[inline] pub fn write_value(&self, characteristic: &ComPtr<GattCharacteristic>, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).WriteValue)(self.deref() as *const _ as *mut _, characteristic.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn commit_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattCommunicationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CommitAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattReliableWriteTransaction: IGattReliableWriteTransaction}
impl RtActivatable<IActivationFactory> for GattReliableWriteTransaction {}
DEFINE_CLSID!(GattReliableWriteTransaction(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,82,101,108,105,97,98,108,101,87,114,105,116,101,84,114,97,110,115,97,99,116,105,111,110,0]) [CLSID_GattReliableWriteTransaction]);
DEFINE_IID!(IID_IGattReliableWriteTransaction2, 1360083335, 61202, 17967, 159, 178, 161, 164, 58, 103, 148, 22);
RT_INTERFACE!{interface IGattReliableWriteTransaction2(IGattReliableWriteTransaction2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattReliableWriteTransaction2] {
    fn CommitWithResultAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattWriteResult>) -> HRESULT
}}
impl ComPtr<IGattReliableWriteTransaction2> {
    #[inline] pub fn commit_with_result_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattWriteResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CommitWithResultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattRequestState: i32 {
    Pending = 0, Completed = 1, Canceled = 2,
}}
DEFINE_IID!(IID_IGattRequestStateChangedEventArgs, 3895777580, 10174, 17587, 157, 13, 79, 198, 232, 8, 221, 63);
RT_INTERFACE!{interface IGattRequestStateChangedEventArgs(IGattRequestStateChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattRequestStateChangedEventArgs] {
    fn get_State(&self, out: *mut GattRequestState) -> HRESULT,
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT
}}
impl ComPtr<IGattRequestStateChangedEventArgs> {
    #[inline] pub fn get_state(&self) -> Result<GattRequestState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattRequestStateChangedEventArgs: IGattRequestStateChangedEventArgs}
DEFINE_IID!(IID_IGattServiceProvider, 2015540173, 10377, 20358, 160, 81, 63, 10, 237, 28, 39, 96);
RT_INTERFACE!{interface IGattServiceProvider(IGattServiceProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProvider] {
    fn get_Service(&self, out: *mut *mut GattLocalService) -> HRESULT,
    fn get_AdvertisementStatus(&self, out: *mut GattServiceProviderAdvertisementStatus) -> HRESULT,
    fn add_AdvertisementStatusChanged(&self, handler: *mut foundation::TypedEventHandler<GattServiceProvider, GattServiceProviderAdvertisementStatusChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AdvertisementStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn StartAdvertising(&self) -> HRESULT,
    fn StartAdvertisingWithParameters(&self, parameters: *mut GattServiceProviderAdvertisingParameters) -> HRESULT,
    fn StopAdvertising(&self) -> HRESULT
}}
impl ComPtr<IGattServiceProvider> {
    #[inline] pub fn get_service(&self) -> Result<Option<ComPtr<GattLocalService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Service)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_status(&self) -> Result<GattServiceProviderAdvertisementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdvertisementStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_advertisement_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattServiceProvider, GattServiceProviderAdvertisementStatusChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AdvertisementStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_advertisement_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AdvertisementStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_advertising(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StartAdvertising)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_advertising_with_parameters(&self, parameters: &ComPtr<GattServiceProviderAdvertisingParameters>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StartAdvertisingWithParameters)(self.deref() as *const _ as *mut _, parameters.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_advertising(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StopAdvertising)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProvider: IGattServiceProvider}
impl RtActivatable<IGattServiceProviderStatics> for GattServiceProvider {}
impl GattServiceProvider {
    #[inline] pub fn create_async(serviceUuid: Guid) -> Result<ComPtr<foundation::IAsyncOperation<GattServiceProviderResult>>> {
        <Self as RtActivatable<IGattServiceProviderStatics>>::get_activation_factory().create_async(serviceUuid)
    }
}
DEFINE_CLSID!(GattServiceProvider(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,0]) [CLSID_GattServiceProvider]);
RT_ENUM! { enum GattServiceProviderAdvertisementStatus: i32 {
    Created = 0, Stopped = 1, Started = 2, Aborted = 3,
}}
DEFINE_IID!(IID_IGattServiceProviderAdvertisementStatusChangedEventArgs, 1504029285, 64033, 20476, 177, 85, 4, 217, 40, 1, 38, 134);
RT_INTERFACE!{interface IGattServiceProviderAdvertisementStatusChangedEventArgs(IGattServiceProviderAdvertisementStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderAdvertisementStatusChangedEventArgs] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Status(&self, out: *mut GattServiceProviderAdvertisementStatus) -> HRESULT
}}
impl ComPtr<IGattServiceProviderAdvertisementStatusChangedEventArgs> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<GattServiceProviderAdvertisementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderAdvertisementStatusChangedEventArgs: IGattServiceProviderAdvertisementStatusChangedEventArgs}
DEFINE_IID!(IID_IGattServiceProviderAdvertisingParameters, 3805163947, 25365, 19490, 155, 215, 120, 29, 188, 61, 141, 130);
RT_INTERFACE!{interface IGattServiceProviderAdvertisingParameters(IGattServiceProviderAdvertisingParametersVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderAdvertisingParameters] {
    fn put_IsConnectable(&self, value: bool) -> HRESULT,
    fn get_IsConnectable(&self, out: *mut bool) -> HRESULT,
    fn put_IsDiscoverable(&self, value: bool) -> HRESULT,
    fn get_IsDiscoverable(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IGattServiceProviderAdvertisingParameters> {
    #[inline] pub fn set_is_connectable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsConnectable)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_connectable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsConnectable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_discoverable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDiscoverable)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_discoverable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDiscoverable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderAdvertisingParameters: IGattServiceProviderAdvertisingParameters}
impl RtActivatable<IActivationFactory> for GattServiceProviderAdvertisingParameters {}
DEFINE_CLSID!(GattServiceProviderAdvertisingParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,65,100,118,101,114,116,105,115,105,110,103,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_GattServiceProviderAdvertisingParameters]);
DEFINE_IID!(IID_IGattServiceProviderResult, 1984337624, 50494, 17036, 138, 72, 103, 175, 224, 44, 58, 230);
RT_INTERFACE!{interface IGattServiceProviderResult(IGattServiceProviderResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderResult] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_ServiceProvider(&self, out: *mut *mut GattServiceProvider) -> HRESULT
}}
impl ComPtr<IGattServiceProviderResult> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_provider(&self) -> Result<Option<ComPtr<GattServiceProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceProvider)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattServiceProviderResult: IGattServiceProviderResult}
DEFINE_IID!(IID_IGattServiceProviderStatics, 830029923, 21078, 16468, 164, 244, 123, 190, 119, 85, 165, 126);
RT_INTERFACE!{static interface IGattServiceProviderStatics(IGattServiceProviderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderStatics] {
    fn CreateAsync(&self, serviceUuid: Guid, out: *mut *mut foundation::IAsyncOperation<GattServiceProviderResult>) -> HRESULT
}}
impl ComPtr<IGattServiceProviderStatics> {
    #[inline] pub fn create_async(&self, serviceUuid: Guid) -> Result<ComPtr<foundation::IAsyncOperation<GattServiceProviderResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateAsync)(self.deref() as *const _ as *mut _, serviceUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class GattServiceUuids}
impl RtActivatable<IGattServiceUuidsStatics> for GattServiceUuids {}
impl RtActivatable<IGattServiceUuidsStatics2> for GattServiceUuids {}
impl GattServiceUuids {
    #[inline] pub fn get_battery() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_battery()
    }
    #[inline] pub fn get_blood_pressure() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_blood_pressure()
    }
    #[inline] pub fn get_cycling_speed_and_cadence() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_cycling_speed_and_cadence()
    }
    #[inline] pub fn get_generic_access() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_generic_access()
    }
    #[inline] pub fn get_generic_attribute() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_generic_attribute()
    }
    #[inline] pub fn get_glucose() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_glucose()
    }
    #[inline] pub fn get_health_thermometer() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_health_thermometer()
    }
    #[inline] pub fn get_heart_rate() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_heart_rate()
    }
    #[inline] pub fn get_running_speed_and_cadence() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics>>::get_activation_factory().get_running_speed_and_cadence()
    }
    #[inline] pub fn get_alert_notification() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_alert_notification()
    }
    #[inline] pub fn get_current_time() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_current_time()
    }
    #[inline] pub fn get_cycling_power() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_cycling_power()
    }
    #[inline] pub fn get_device_information() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_device_information()
    }
    #[inline] pub fn get_human_interface_device() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_human_interface_device()
    }
    #[inline] pub fn get_immediate_alert() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_immediate_alert()
    }
    #[inline] pub fn get_link_loss() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_link_loss()
    }
    #[inline] pub fn get_location_and_navigation() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_location_and_navigation()
    }
    #[inline] pub fn get_next_dst_change() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_next_dst_change()
    }
    #[inline] pub fn get_phone_alert_status() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_phone_alert_status()
    }
    #[inline] pub fn get_reference_time_update() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_reference_time_update()
    }
    #[inline] pub fn get_scan_parameters() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_scan_parameters()
    }
    #[inline] pub fn get_tx_power() -> Result<Guid> {
        <Self as RtActivatable<IGattServiceUuidsStatics2>>::get_activation_factory().get_tx_power()
    }
}
DEFINE_CLSID!(GattServiceUuids(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,114,118,105,99,101,85,117,105,100,115,0]) [CLSID_GattServiceUuids]);
DEFINE_IID!(IID_IGattServiceUuidsStatics, 1841655896, 39610, 17431, 184, 242, 220, 224, 22, 211, 78, 226);
RT_INTERFACE!{static interface IGattServiceUuidsStatics(IGattServiceUuidsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceUuidsStatics] {
    fn get_Battery(&self, out: *mut Guid) -> HRESULT,
    fn get_BloodPressure(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingSpeedAndCadence(&self, out: *mut Guid) -> HRESULT,
    fn get_GenericAccess(&self, out: *mut Guid) -> HRESULT,
    fn get_GenericAttribute(&self, out: *mut Guid) -> HRESULT,
    fn get_Glucose(&self, out: *mut Guid) -> HRESULT,
    fn get_HealthThermometer(&self, out: *mut Guid) -> HRESULT,
    fn get_HeartRate(&self, out: *mut Guid) -> HRESULT,
    fn get_RunningSpeedAndCadence(&self, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattServiceUuidsStatics> {
    #[inline] pub fn get_battery(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Battery)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blood_pressure(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BloodPressure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_speed_and_cadence(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingSpeedAndCadence)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_generic_access(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GenericAccess)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_generic_attribute(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GenericAttribute)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_glucose(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Glucose)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_health_thermometer(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HealthThermometer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heart_rate(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeartRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_running_speed_and_cadence(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RunningSpeedAndCadence)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattServiceUuidsStatics2, 3534656757, 15637, 20345, 156, 12, 234, 175, 166, 117, 21, 92);
RT_INTERFACE!{static interface IGattServiceUuidsStatics2(IGattServiceUuidsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceUuidsStatics2] {
    fn get_AlertNotification(&self, out: *mut Guid) -> HRESULT,
    fn get_CurrentTime(&self, out: *mut Guid) -> HRESULT,
    fn get_CyclingPower(&self, out: *mut Guid) -> HRESULT,
    fn get_DeviceInformation(&self, out: *mut Guid) -> HRESULT,
    fn get_HumanInterfaceDevice(&self, out: *mut Guid) -> HRESULT,
    fn get_ImmediateAlert(&self, out: *mut Guid) -> HRESULT,
    fn get_LinkLoss(&self, out: *mut Guid) -> HRESULT,
    fn get_LocationAndNavigation(&self, out: *mut Guid) -> HRESULT,
    fn get_NextDstChange(&self, out: *mut Guid) -> HRESULT,
    fn get_PhoneAlertStatus(&self, out: *mut Guid) -> HRESULT,
    fn get_ReferenceTimeUpdate(&self, out: *mut Guid) -> HRESULT,
    fn get_ScanParameters(&self, out: *mut Guid) -> HRESULT,
    fn get_TxPower(&self, out: *mut Guid) -> HRESULT
}}
impl ComPtr<IGattServiceUuidsStatics2> {
    #[inline] pub fn get_alert_notification(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlertNotification)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_current_time(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CurrentTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cycling_power(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CyclingPower)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_information(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_human_interface_device(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HumanInterfaceDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_immediate_alert(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ImmediateAlert)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_link_loss(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LinkLoss)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_location_and_navigation(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationAndNavigation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_next_dst_change(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NextDstChange)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_alert_status(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PhoneAlertStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reference_time_update(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReferenceTimeUpdate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_parameters(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScanParameters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tx_power(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TxPower)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGattSession, 3527102787, 57422, 19492, 153, 156, 156, 37, 111, 152, 86, 177);
RT_INTERFACE!{interface IGattSession(IGattSessionVtbl): IInspectable(IInspectableVtbl) [IID_IGattSession] {
    fn get_DeviceId(&self, out: *mut *mut super::BluetoothDeviceId) -> HRESULT,
    fn get_CanMaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn put_MaintainConnection(&self, value: bool) -> HRESULT,
    fn get_MaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn get_MaxPduSize(&self, out: *mut u16) -> HRESULT,
    fn get_SessionStatus(&self, out: *mut GattSessionStatus) -> HRESULT,
    fn add_MaxPduSizeChanged(&self, handler: *mut foundation::TypedEventHandler<GattSession, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MaxPduSizeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SessionStatusChanged(&self, handler: *mut foundation::TypedEventHandler<GattSession, GattSessionStatusChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGattSession> {
    #[inline] pub fn get_device_id(&self) -> Result<Option<ComPtr<super::BluetoothDeviceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_can_maintain_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanMaintainConnection)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_maintain_connection(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_MaintainConnection)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_maintain_connection(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaintainConnection)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_pdu_size(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPduSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_session_status(&self) -> Result<GattSessionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SessionStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_max_pdu_size_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattSession, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MaxPduSizeChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_max_pdu_size_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MaxPduSizeChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_session_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattSession, GattSessionStatusChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SessionStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SessionStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattSession: IGattSession}
impl RtActivatable<IGattSessionStatics> for GattSession {}
impl GattSession {
    #[inline] pub fn from_device_id_async(deviceId: &ComPtr<super::BluetoothDeviceId>) -> Result<ComPtr<foundation::IAsyncOperation<GattSession>>> {
        <Self as RtActivatable<IGattSessionStatics>>::get_activation_factory().from_device_id_async(deviceId)
    }
}
DEFINE_CLSID!(GattSession(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,71,101,110,101,114,105,99,65,116,116,114,105,98,117,116,101,80,114,111,102,105,108,101,46,71,97,116,116,83,101,115,115,105,111,110,0]) [CLSID_GattSession]);
DEFINE_IID!(IID_IGattSessionStatics, 778418524, 21407, 19895, 130, 168, 115, 189, 187, 247, 62, 191);
RT_INTERFACE!{static interface IGattSessionStatics(IGattSessionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattSessionStatics] {
    fn FromDeviceIdAsync(&self, deviceId: *mut super::BluetoothDeviceId, out: *mut *mut foundation::IAsyncOperation<GattSession>) -> HRESULT
}}
impl ComPtr<IGattSessionStatics> {
    #[inline] pub fn from_device_id_async(&self, deviceId: &ComPtr<super::BluetoothDeviceId>) -> Result<ComPtr<foundation::IAsyncOperation<GattSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromDeviceIdAsync)(self.deref() as *const _ as *mut _, deviceId.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GattSessionStatus: i32 {
    Closed = 0, Active = 1,
}}
DEFINE_IID!(IID_IGattSessionStatusChangedEventArgs, 1980086062, 33663, 16460, 171, 52, 49, 99, 243, 157, 223, 50);
RT_INTERFACE!{interface IGattSessionStatusChangedEventArgs(IGattSessionStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattSessionStatusChangedEventArgs] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Status(&self, out: *mut GattSessionStatus) -> HRESULT
}}
impl ComPtr<IGattSessionStatusChangedEventArgs> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<GattSessionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattSessionStatusChangedEventArgs: IGattSessionStatusChangedEventArgs}
RT_ENUM! { enum GattSharingMode: i32 {
    Unspecified = 0, Exclusive = 1, SharedReadOnly = 2, SharedReadAndWrite = 3,
}}
DEFINE_IID!(IID_IGattSubscribedClient, 1936625665, 5540, 20162, 146, 72, 227, 242, 13, 70, 59, 233);
RT_INTERFACE!{interface IGattSubscribedClient(IGattSubscribedClientVtbl): IInspectable(IInspectableVtbl) [IID_IGattSubscribedClient] {
    fn get_Session(&self, out: *mut *mut GattSession) -> HRESULT,
    fn get_MaxNotificationSize(&self, out: *mut u16) -> HRESULT,
    fn add_MaxNotificationSizeChanged(&self, handler: *mut foundation::TypedEventHandler<GattSubscribedClient, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MaxNotificationSizeChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGattSubscribedClient> {
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<GattSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_notification_size(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxNotificationSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_max_notification_size_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattSubscribedClient, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MaxNotificationSizeChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_max_notification_size_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MaxNotificationSizeChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattSubscribedClient: IGattSubscribedClient}
DEFINE_IID!(IID_IGattValueChangedEventArgs, 3525040980, 1763, 20184, 162, 99, 172, 250, 200, 186, 115, 19);
RT_INTERFACE!{interface IGattValueChangedEventArgs(IGattValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattValueChangedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_CharacteristicValue(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<IGattValueChangedEventArgs> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_characteristic_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CharacteristicValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GattValueChangedEventArgs: IGattValueChangedEventArgs}
RT_ENUM! { enum GattWriteOption: i32 {
    WriteWithResponse = 0, WriteWithoutResponse = 1,
}}
DEFINE_IID!(IID_IGattWriteRequest, 2931206637, 56879, 20418, 169, 168, 148, 234, 120, 68, 241, 61);
RT_INTERFACE!{interface IGattWriteRequest(IGattWriteRequestVtbl): IInspectable(IInspectableVtbl) [IID_IGattWriteRequest] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_Offset(&self, out: *mut u32) -> HRESULT,
    fn get_Option(&self, out: *mut GattWriteOption) -> HRESULT,
    fn get_State(&self, out: *mut GattRequestState) -> HRESULT,
    fn add_StateChanged(&self, handler: *mut foundation::TypedEventHandler<GattWriteRequest, GattRequestStateChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Respond(&self) -> HRESULT,
    fn RespondWithProtocolError(&self, protocolError: u8) -> HRESULT
}}
impl ComPtr<IGattWriteRequest> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_offset(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Offset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_option(&self) -> Result<GattWriteOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Option)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<GattRequestState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GattWriteRequest, GattRequestStateChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StateChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StateChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn respond(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Respond)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn respond_with_protocol_error(&self, protocolError: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RespondWithProtocolError)(self.deref() as *const _ as *mut _, protocolError);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GattWriteRequest: IGattWriteRequest}
DEFINE_IID!(IID_IGattWriteRequestedEventArgs, 770476990, 42810, 18202, 148, 213, 3, 125, 234, 221, 8, 6);
RT_INTERFACE!{interface IGattWriteRequestedEventArgs(IGattWriteRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGattWriteRequestedEventArgs] {
    fn get_Session(&self, out: *mut *mut GattSession) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT,
    fn GetRequestAsync(&self, out: *mut *mut foundation::IAsyncOperation<GattWriteRequest>) -> HRESULT
}}
impl ComPtr<IGattWriteRequestedEventArgs> {
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<GattSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_request_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GattWriteRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRequestAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattWriteRequestedEventArgs: IGattWriteRequestedEventArgs}
DEFINE_IID!(IID_IGattWriteResult, 1234296241, 52011, 17655, 153, 252, 210, 154, 40, 113, 220, 155);
RT_INTERFACE!{interface IGattWriteResult(IGattWriteResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattWriteResult] {
    fn get_Status(&self, out: *mut GattCommunicationStatus) -> HRESULT,
    fn get_ProtocolError(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT
}}
impl ComPtr<IGattWriteResult> {
    #[inline] pub fn get_status(&self) -> Result<GattCommunicationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_error(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GattWriteResult: IGattWriteResult}
} // Windows.Devices.Bluetooth.GenericAttributeProfile
pub mod rfcomm { // Windows.Devices.Bluetooth.Rfcomm
use crate::prelude::*;
DEFINE_IID!(IID_IRfcommDeviceService, 2927755039, 50593, 19520, 140, 40, 243, 239, 214, 144, 98, 243);
RT_INTERFACE!{interface IRfcommDeviceService(IRfcommDeviceServiceVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_ConnectionHostName(&self, out: *mut *mut crate::windows::networking::HostName) -> HRESULT,
    fn get_ConnectionServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceId(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_ProtectionLevel(&self, out: *mut crate::windows::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_MaxProtectionLevel(&self, out: *mut crate::windows::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetSdpRawAttributesAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetSdpRawAttributesWithCacheModeAsync(&self, cacheMode: super::BluetoothCacheMode, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>>) -> HRESULT
}}
impl ComPtr<IRfcommDeviceService> {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_connection_host_name(&self) -> Result<Option<ComPtr<crate::windows::networking::HostName>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionHostName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionServiceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_id(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_protection_level(&self) -> Result<crate::windows::networking::sockets::SocketProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_max_protection_level(&self) -> Result<crate::windows::networking::sockets::SocketProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_raw_attributes_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSdpRawAttributesAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_raw_attributes_with_cache_mode_async(&self, cacheMode: super::BluetoothCacheMode) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IMapView<u32, crate::windows::storage::streams::IBuffer>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSdpRawAttributesWithCacheModeAsync)(self.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommDeviceService: IRfcommDeviceService}
impl RtActivatable<IRfcommDeviceServiceStatics> for RfcommDeviceService {}
impl RtActivatable<IRfcommDeviceServiceStatics2> for RfcommDeviceService {}
impl RfcommDeviceService {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<RfcommDeviceService>>> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector(serviceId: &ComPtr<RfcommServiceId>) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics>>::get_activation_factory().get_device_selector(serviceId)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device(bluetoothDevice: &ComPtr<super::BluetoothDevice>) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device(bluetoothDevice)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_with_cache_mode(bluetoothDevice: &ComPtr<super::BluetoothDevice>, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_with_cache_mode(bluetoothDevice, cacheMode)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id(bluetoothDevice: &ComPtr<super::BluetoothDevice>, serviceId: &ComPtr<RfcommServiceId>) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_and_service_id(bluetoothDevice, serviceId)
    }
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(bluetoothDevice: &ComPtr<super::BluetoothDevice>, serviceId: &ComPtr<RfcommServiceId>, cacheMode: super::BluetoothCacheMode) -> Result<HString> {
        <Self as RtActivatable<IRfcommDeviceServiceStatics2>>::get_activation_factory().get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(bluetoothDevice, serviceId, cacheMode)
    }
}
DEFINE_CLSID!(RfcommDeviceService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,68,101,118,105,99,101,83,101,114,118,105,99,101,0]) [CLSID_RfcommDeviceService]);
DEFINE_IID!(IID_IRfcommDeviceService2, 1399647508, 60365, 18942, 191, 159, 64, 239, 198, 137, 178, 13);
RT_INTERFACE!{interface IRfcommDeviceService2(IRfcommDeviceService2Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService2] {
    fn get_Device(&self, out: *mut *mut super::BluetoothDevice) -> HRESULT
}}
impl ComPtr<IRfcommDeviceService2> {
    #[inline] pub fn get_device(&self) -> Result<Option<ComPtr<super::BluetoothDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Device)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommDeviceService3, 472034534, 56644, 19747, 134, 109, 143, 52, 134, 238, 100, 144);
RT_INTERFACE!{interface IRfcommDeviceService3(IRfcommDeviceService3Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceService3] {
    fn get_DeviceAccessInformation(&self, out: *mut *mut super::super::enumeration::DeviceAccessInformation) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>) -> HRESULT
}}
impl ComPtr<IRfcommDeviceService3> {
    #[inline] pub fn get_device_access_information(&self) -> Result<Option<ComPtr<super::super::enumeration::DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceAccessInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::super::enumeration::DeviceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommDeviceServicesResult, 994588812, 31951, 18574, 150, 37, 210, 89, 165, 115, 45, 85);
RT_INTERFACE!{interface IRfcommDeviceServicesResult(IRfcommDeviceServicesResultVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServicesResult] {
    fn get_Error(&self, out: *mut super::BluetoothError) -> HRESULT,
    fn get_Services(&self, out: *mut *mut foundation::collections::IVectorView<RfcommDeviceService>) -> HRESULT
}}
impl ComPtr<IRfcommDeviceServicesResult> {
    #[inline] pub fn get_error(&self) -> Result<super::BluetoothError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_services(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<RfcommDeviceService>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Services)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommDeviceServicesResult: IRfcommDeviceServicesResult}
DEFINE_IID!(IID_IRfcommDeviceServiceStatics, 2762033647, 25197, 16812, 178, 83, 135, 172, 92, 39, 226, 138);
RT_INTERFACE!{static interface IRfcommDeviceServiceStatics(IRfcommDeviceServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServiceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<RfcommDeviceService>) -> HRESULT,
    fn GetDeviceSelector(&self, serviceId: *mut RfcommServiceId, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IRfcommDeviceServiceStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<RfcommDeviceService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self, serviceId: &ComPtr<RfcommServiceId>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, serviceId.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommDeviceServiceStatics2, 2861347273, 59277, 19428, 128, 118, 10, 61, 135, 160, 160, 95);
RT_INTERFACE!{static interface IRfcommDeviceServiceStatics2(IRfcommDeviceServiceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommDeviceServiceStatics2] {
    fn GetDeviceSelectorForBluetoothDevice(&self, bluetoothDevice: *mut super::BluetoothDevice, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceWithCacheMode(&self, bluetoothDevice: *mut super::BluetoothDevice, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceAndServiceId(&self, bluetoothDevice: *mut super::BluetoothDevice, serviceId: *mut RfcommServiceId, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorForBluetoothDeviceAndServiceIdWithCacheMode(&self, bluetoothDevice: *mut super::BluetoothDevice, serviceId: *mut RfcommServiceId, cacheMode: super::BluetoothCacheMode, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IRfcommDeviceServiceStatics2> {
    #[inline] pub fn get_device_selector_for_bluetooth_device(&self, bluetoothDevice: &ComPtr<super::BluetoothDevice>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDevice)(self.deref() as *const _ as *mut _, bluetoothDevice.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_with_cache_mode(&self, bluetoothDevice: &ComPtr<super::BluetoothDevice>, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceWithCacheMode)(self.deref() as *const _ as *mut _, bluetoothDevice.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id(&self, bluetoothDevice: &ComPtr<super::BluetoothDevice>, serviceId: &ComPtr<RfcommServiceId>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceAndServiceId)(self.deref() as *const _ as *mut _, bluetoothDevice.deref() as *const _ as *mut _, serviceId.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_for_bluetooth_device_and_service_id_with_cache_mode(&self, bluetoothDevice: &ComPtr<super::BluetoothDevice>, serviceId: &ComPtr<RfcommServiceId>, cacheMode: super::BluetoothCacheMode) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorForBluetoothDeviceAndServiceIdWithCacheMode)(self.deref() as *const _ as *mut _, bluetoothDevice.deref() as *const _ as *mut _, serviceId.deref() as *const _ as *mut _, cacheMode, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommServiceId, 576885252, 32258, 16407, 129, 54, 218, 27, 106, 27, 155, 191);
RT_INTERFACE!{interface IRfcommServiceId(IRfcommServiceIdVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceId] {
    fn get_Uuid(&self, out: *mut Guid) -> HRESULT,
    fn AsShortId(&self, out: *mut u32) -> HRESULT,
    fn AsString(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IRfcommServiceId> {
    #[inline] pub fn get_uuid(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uuid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn as_short_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).AsShortId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn as_string(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AsString)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommServiceId: IRfcommServiceId}
impl RtActivatable<IRfcommServiceIdStatics> for RfcommServiceId {}
impl RfcommServiceId {
    #[inline] pub fn from_uuid(uuid: Guid) -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().from_uuid(uuid)
    }
    #[inline] pub fn from_short_id(shortId: u32) -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().from_short_id(shortId)
    }
    #[inline] pub fn get_serial_port() -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_serial_port()
    }
    #[inline] pub fn get_obex_object_push() -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_obex_object_push()
    }
    #[inline] pub fn get_obex_file_transfer() -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_obex_file_transfer()
    }
    #[inline] pub fn get_phone_book_access_pce() -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_phone_book_access_pce()
    }
    #[inline] pub fn get_phone_book_access_pse() -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_phone_book_access_pse()
    }
    #[inline] pub fn get_generic_file_transfer() -> Result<Option<ComPtr<RfcommServiceId>>> {
        <Self as RtActivatable<IRfcommServiceIdStatics>>::get_activation_factory().get_generic_file_transfer()
    }
}
DEFINE_CLSID!(RfcommServiceId(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,83,101,114,118,105,99,101,73,100,0]) [CLSID_RfcommServiceId]);
DEFINE_IID!(IID_IRfcommServiceIdStatics, 706191034, 43381, 18147, 181, 107, 8, 255, 215, 131, 165, 254);
RT_INTERFACE!{static interface IRfcommServiceIdStatics(IRfcommServiceIdStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceIdStatics] {
    fn FromUuid(&self, uuid: Guid, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn FromShortId(&self, shortId: u32, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn get_SerialPort(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn get_ObexObjectPush(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn get_ObexFileTransfer(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn get_PhoneBookAccessPce(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn get_PhoneBookAccessPse(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    fn get_GenericFileTransfer(&self, out: *mut *mut RfcommServiceId) -> HRESULT
}}
impl ComPtr<IRfcommServiceIdStatics> {
    #[inline] pub fn from_uuid(&self, uuid: Guid) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromUuid)(self.deref() as *const _ as *mut _, uuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_short_id(&self, shortId: u32) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromShortId)(self.deref() as *const _ as *mut _, shortId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_serial_port(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SerialPort)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_obex_object_push(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ObexObjectPush)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_obex_file_transfer(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ObexFileTransfer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_book_access_pce(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhoneBookAccessPce)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_phone_book_access_pse(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhoneBookAccessPse)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_generic_file_transfer(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_GenericFileTransfer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommServiceProvider, 3940285892, 45558, 17663, 159, 124, 231, 168, 42, 184, 104, 33);
RT_INTERFACE!{interface IRfcommServiceProvider(IRfcommServiceProviderVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProvider] {
    fn get_ServiceId(&self, out: *mut *mut RfcommServiceId) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SdpRawAttributes(&self, out: *mut *mut foundation::collections::IMap<u32, crate::windows::storage::streams::IBuffer>) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-networking")] fn StartAdvertising(&self, listener: *mut crate::windows::networking::sockets::StreamSocketListener) -> HRESULT,
    fn StopAdvertising(&self) -> HRESULT
}}
impl ComPtr<IRfcommServiceProvider> {
    #[inline] pub fn get_service_id(&self) -> Result<Option<ComPtr<RfcommServiceId>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_sdp_raw_attributes(&self) -> Result<Option<ComPtr<foundation::collections::IMap<u32, crate::windows::storage::streams::IBuffer>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SdpRawAttributes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn start_advertising(&self, listener: &ComPtr<crate::windows::networking::sockets::StreamSocketListener>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StartAdvertising)(self.deref() as *const _ as *mut _, listener.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_advertising(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StopAdvertising)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class RfcommServiceProvider: IRfcommServiceProvider}
impl RtActivatable<IRfcommServiceProviderStatics> for RfcommServiceProvider {}
impl RfcommServiceProvider {
    #[inline] pub fn create_async(serviceId: &ComPtr<RfcommServiceId>) -> Result<ComPtr<foundation::IAsyncOperation<RfcommServiceProvider>>> {
        <Self as RtActivatable<IRfcommServiceProviderStatics>>::get_activation_factory().create_async(serviceId)
    }
}
DEFINE_CLSID!(RfcommServiceProvider(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,66,108,117,101,116,111,111,116,104,46,82,102,99,111,109,109,46,82,102,99,111,109,109,83,101,114,118,105,99,101,80,114,111,118,105,100,101,114,0]) [CLSID_RfcommServiceProvider]);
DEFINE_IID!(IID_IRfcommServiceProvider2, 1936449478, 15489, 19742, 186, 242, 221, 187, 129, 40, 69, 18);
RT_INTERFACE!{interface IRfcommServiceProvider2(IRfcommServiceProvider2Vtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProvider2] {
    #[cfg(feature="windows-networking")] fn StartAdvertisingWithRadioDiscoverability(&self, listener: *mut crate::windows::networking::sockets::StreamSocketListener, radioDiscoverable: bool) -> HRESULT
}}
impl ComPtr<IRfcommServiceProvider2> {
    #[cfg(feature="windows-networking")] #[inline] pub fn start_advertising_with_radio_discoverability(&self, listener: &ComPtr<crate::windows::networking::sockets::StreamSocketListener>, radioDiscoverable: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StartAdvertisingWithRadioDiscoverability)(self.deref() as *const _ as *mut _, listener.deref() as *const _ as *mut _, radioDiscoverable);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IRfcommServiceProviderStatics, 2559083267, 27082, 16698, 132, 247, 67, 68, 199, 41, 41, 151);
RT_INTERFACE!{static interface IRfcommServiceProviderStatics(IRfcommServiceProviderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommServiceProviderStatics] {
    fn CreateAsync(&self, serviceId: *mut RfcommServiceId, out: *mut *mut foundation::IAsyncOperation<RfcommServiceProvider>) -> HRESULT
}}
impl ComPtr<IRfcommServiceProviderStatics> {
    #[inline] pub fn create_async(&self, serviceId: &ComPtr<RfcommServiceId>) -> Result<ComPtr<foundation::IAsyncOperation<RfcommServiceProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateAsync)(self.deref() as *const _ as *mut _, serviceId.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Bluetooth.Rfcomm
} // Windows.Devices.Bluetooth
pub mod custom { // Windows.Devices.Custom
use crate::prelude::*;
DEFINE_IID!(IID_ICustomDevice, 3710919967, 50315, 17341, 188, 177, 222, 200, 143, 21, 20, 62);
RT_INTERFACE!{interface ICustomDevice(ICustomDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ICustomDevice] {
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut *mut super::super::storage::streams::IInputStream) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut *mut super::super::storage::streams::IOutputStream) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SendIOControlAsync(&self, ioControlCode: *mut IIOControlCode, inputBuffer: *mut super::super::storage::streams::IBuffer, outputBuffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<u32>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TrySendIOControlAsync(&self, ioControlCode: *mut IIOControlCode, inputBuffer: *mut super::super::storage::streams::IBuffer, outputBuffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ICustomDevice> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IInputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IOutputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_io_control_async(&self, ioControlCode: &ComPtr<IIOControlCode>, inputBuffer: &ComPtr<super::super::storage::streams::IBuffer>, outputBuffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendIOControlAsync)(self.deref() as *const _ as *mut _, ioControlCode.deref() as *const _ as *mut _, inputBuffer.deref() as *const _ as *mut _, outputBuffer.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_send_io_control_async(&self, ioControlCode: &ComPtr<IIOControlCode>, inputBuffer: &ComPtr<super::super::storage::streams::IBuffer>, outputBuffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TrySendIOControlAsync)(self.deref() as *const _ as *mut _, ioControlCode.deref() as *const _ as *mut _, inputBuffer.deref() as *const _ as *mut _, outputBuffer.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomDevice: ICustomDevice}
impl RtActivatable<ICustomDeviceStatics> for CustomDevice {}
impl CustomDevice {
    #[inline] pub fn get_device_selector(classGuid: Guid) -> Result<HString> {
        <Self as RtActivatable<ICustomDeviceStatics>>::get_activation_factory().get_device_selector(classGuid)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode) -> Result<ComPtr<foundation::IAsyncOperation<CustomDevice>>> {
        <Self as RtActivatable<ICustomDeviceStatics>>::get_activation_factory().from_id_async(deviceId, desiredAccess, sharingMode)
    }
}
DEFINE_CLSID!(CustomDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,67,117,115,116,111,109,68,101,118,105,99,101,0]) [CLSID_CustomDevice]);
DEFINE_IID!(IID_ICustomDeviceStatics, 3357672210, 61260, 18097, 165, 142, 238, 179, 8, 220, 137, 23);
RT_INTERFACE!{static interface ICustomDeviceStatics(ICustomDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomDeviceStatics] {
    fn GetDeviceSelector(&self, classGuid: Guid, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode, out: *mut *mut foundation::IAsyncOperation<CustomDevice>) -> HRESULT
}}
impl ComPtr<ICustomDeviceStatics> {
    #[inline] pub fn get_device_selector(&self, classGuid: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, classGuid, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, desiredAccess: DeviceAccessMode, sharingMode: DeviceSharingMode) -> Result<ComPtr<foundation::IAsyncOperation<CustomDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), desiredAccess, sharingMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DeviceAccessMode: i32 {
    Read = 0, Write = 1, ReadWrite = 2,
}}
RT_ENUM! { enum DeviceSharingMode: i32 {
    Shared = 0, Exclusive = 1,
}}
DEFINE_IID!(IID_IIOControlCode, 244668903, 24776, 17269, 167, 97, 127, 136, 8, 6, 108, 96);
RT_INTERFACE!{interface IIOControlCode(IIOControlCodeVtbl): IInspectable(IInspectableVtbl) [IID_IIOControlCode] {
    fn get_AccessMode(&self, out: *mut IOControlAccessMode) -> HRESULT,
    fn get_BufferingMethod(&self, out: *mut IOControlBufferingMethod) -> HRESULT,
    fn get_Function(&self, out: *mut u16) -> HRESULT,
    fn get_DeviceType(&self, out: *mut u16) -> HRESULT,
    fn get_ControlCode(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IIOControlCode> {
    #[inline] pub fn get_access_mode(&self) -> Result<IOControlAccessMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AccessMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buffering_method(&self) -> Result<IOControlBufferingMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BufferingMethod)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_function(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Function)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_type(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DeviceType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ControlCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IIOControlCodeFactory, 2238348528, 19473, 17582, 175, 198, 184, 212, 162, 18, 120, 143);
RT_INTERFACE!{static interface IIOControlCodeFactory(IIOControlCodeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IIOControlCodeFactory] {
    fn CreateIOControlCode(&self, deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod, out: *mut *mut IOControlCode) -> HRESULT
}}
impl ComPtr<IIOControlCodeFactory> {
    #[inline] pub fn create_io_control_code(&self, deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod) -> Result<ComPtr<IOControlCode>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateIOControlCode)(self.deref() as *const _ as *mut _, deviceType, function, accessMode, bufferingMethod, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownDeviceTypes}
impl RtActivatable<IKnownDeviceTypesStatics> for KnownDeviceTypes {}
impl KnownDeviceTypes {
    #[inline] pub fn get_unknown() -> Result<u16> {
        <Self as RtActivatable<IKnownDeviceTypesStatics>>::get_activation_factory().get_unknown()
    }
}
DEFINE_CLSID!(KnownDeviceTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,75,110,111,119,110,68,101,118,105,99,101,84,121,112,101,115,0]) [CLSID_KnownDeviceTypes]);
DEFINE_IID!(IID_IKnownDeviceTypesStatics, 3998513602, 21576, 17882, 173, 27, 36, 148, 140, 35, 144, 148);
RT_INTERFACE!{static interface IKnownDeviceTypesStatics(IKnownDeviceTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownDeviceTypesStatics] {
    fn get_Unknown(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IKnownDeviceTypesStatics> {
    #[inline] pub fn get_unknown(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Unknown)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum IOControlAccessMode: i32 {
    Any = 0, Read = 1, Write = 2, ReadWrite = 3,
}}
RT_ENUM! { enum IOControlBufferingMethod: i32 {
    Buffered = 0, DirectInput = 1, DirectOutput = 2, Neither = 3,
}}
RT_CLASS!{class IOControlCode: IIOControlCode}
impl RtActivatable<IIOControlCodeFactory> for IOControlCode {}
impl IOControlCode {
    #[inline] pub fn create_io_control_code(deviceType: u16, function: u16, accessMode: IOControlAccessMode, bufferingMethod: IOControlBufferingMethod) -> Result<ComPtr<IOControlCode>> {
        <Self as RtActivatable<IIOControlCodeFactory>>::get_activation_factory().create_io_control_code(deviceType, function, accessMode, bufferingMethod)
    }
}
DEFINE_CLSID!(IOControlCode(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,67,117,115,116,111,109,46,73,79,67,111,110,116,114,111,108,67,111,100,101,0]) [CLSID_IOControlCode]);
} // Windows.Devices.Custom
pub mod display { // Windows.Devices.Display
use crate::prelude::*;
DEFINE_IID!(IID_IDisplayMonitor, 527111636, 7425, 19537, 135, 226, 111, 149, 74, 119, 43, 89);
RT_INTERFACE!{interface IDisplayMonitor(IDisplayMonitorVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayMonitor] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionKind(&self, out: *mut DisplayMonitorConnectionKind) -> HRESULT,
    fn get_PhysicalConnector(&self, out: *mut DisplayMonitorPhysicalConnectorKind) -> HRESULT,
    fn get_DisplayAdapterDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_DisplayAdapterId(&self, out: *mut super::super::graphics::DisplayAdapterId) -> HRESULT,
    fn get_DisplayAdapterTargetId(&self, out: *mut u32) -> HRESULT,
    fn get_UsageKind(&self, out: *mut DisplayMonitorUsageKind) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_NativeResolutionInRawPixels(&self, out: *mut super::super::graphics::SizeInt32) -> HRESULT,
    fn get_PhysicalSizeInInches(&self, out: *mut *mut foundation::IReference<foundation::Size>) -> HRESULT,
    fn get_RawDpiX(&self, out: *mut f32) -> HRESULT,
    fn get_RawDpiY(&self, out: *mut f32) -> HRESULT,
    fn get_RedPrimary(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_GreenPrimary(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_BluePrimary(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_WhitePoint(&self, out: *mut foundation::Point) -> HRESULT,
    fn get_MaxLuminanceInNits(&self, out: *mut f32) -> HRESULT,
    fn get_MinLuminanceInNits(&self, out: *mut f32) -> HRESULT,
    fn get_MaxAverageFullFrameLuminanceInNits(&self, out: *mut f32) -> HRESULT,
    fn GetDescriptor(&self, descriptorKind: DisplayMonitorDescriptorKind, outSize: *mut u32, out: *mut *mut u8) -> HRESULT
}}
impl ComPtr<IDisplayMonitor> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_kind(&self) -> Result<DisplayMonitorConnectionKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConnectionKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_connector(&self) -> Result<DisplayMonitorPhysicalConnectorKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PhysicalConnector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display_adapter_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayAdapterDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_display_adapter_id(&self) -> Result<super::super::graphics::DisplayAdapterId> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DisplayAdapterId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_display_adapter_target_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DisplayAdapterTargetId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_kind(&self) -> Result<DisplayMonitorUsageKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_native_resolution_in_raw_pixels(&self) -> Result<super::super::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NativeResolutionInRawPixels)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_size_in_inches(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::Size>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhysicalSizeInInches)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_dpi_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RawDpiX)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_raw_dpi_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RawDpiY)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red_primary(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RedPrimary)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_green_primary(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GreenPrimary)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blue_primary(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BluePrimary)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_white_point(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WhitePoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_luminance_in_nits(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxLuminanceInNits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_luminance_in_nits(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinLuminanceInNits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_average_full_frame_luminance_in_nits(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxAverageFullFrameLuminanceInNits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptor(&self, descriptorKind: DisplayMonitorDescriptorKind) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDescriptor)(self.deref() as *const _ as *mut _, descriptorKind, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayMonitor: IDisplayMonitor}
impl RtActivatable<IDisplayMonitorStatics> for DisplayMonitor {}
impl DisplayMonitor {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IDisplayMonitorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DisplayMonitor>>> {
        <Self as RtActivatable<IDisplayMonitorStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn from_interface_id_async(deviceInterfaceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DisplayMonitor>>> {
        <Self as RtActivatable<IDisplayMonitorStatics>>::get_activation_factory().from_interface_id_async(deviceInterfaceId)
    }
}
DEFINE_CLSID!(DisplayMonitor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,68,105,115,112,108,97,121,77,111,110,105,116,111,114,0]) [CLSID_DisplayMonitor]);
RT_ENUM! { enum DisplayMonitorConnectionKind: i32 {
    Internal = 0, Wired = 1, Wireless = 2, Virtual = 3,
}}
RT_ENUM! { enum DisplayMonitorDescriptorKind: i32 {
    Edid = 0, DisplayId = 1,
}}
RT_ENUM! { enum DisplayMonitorPhysicalConnectorKind: i32 {
    Unknown = 0, HD15 = 1, AnalogTV = 2, Dvi = 3, Hdmi = 4, Lvds = 5, Sdi = 6, DisplayPort = 7,
}}
DEFINE_IID!(IID_IDisplayMonitorStatics, 1856924047, 41512, 19461, 130, 29, 182, 149, 214, 103, 222, 142);
RT_INTERFACE!{static interface IDisplayMonitorStatics(IDisplayMonitorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayMonitorStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<DisplayMonitor>) -> HRESULT,
    fn FromInterfaceIdAsync(&self, deviceInterfaceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<DisplayMonitor>) -> HRESULT
}}
impl ComPtr<IDisplayMonitorStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DisplayMonitor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_interface_id_async(&self, deviceInterfaceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DisplayMonitor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromInterfaceIdAsync)(self.deref() as *const _ as *mut _, deviceInterfaceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayMonitorUsageKind: i32 {
    Standard = 0, HeadMounted = 1, SpecialPurpose = 2,
}}
pub mod core { // Windows.Devices.Display.Core
use crate::prelude::*;
DEFINE_IID!(IID_IDisplayAdapter, 2775536263, 61440, 24366, 181, 172, 55, 131, 162, 182, 154, 245);
RT_INTERFACE!{interface IDisplayAdapter(IDisplayAdapterVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayAdapter] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Id(&self, out: *mut crate::windows::graphics::DisplayAdapterId) -> HRESULT,
    fn get_DeviceInterfacePath(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SourceCount(&self, out: *mut u32) -> HRESULT,
    fn get_PciVendorId(&self, out: *mut u32) -> HRESULT,
    fn get_PciDeviceId(&self, out: *mut u32) -> HRESULT,
    fn get_PciSubSystemId(&self, out: *mut u32) -> HRESULT,
    fn get_PciRevision(&self, out: *mut u32) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<Guid, IInspectable>) -> HRESULT
}}
impl ComPtr<IDisplayAdapter> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_id(&self) -> Result<crate::windows::graphics::DisplayAdapterId> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_interface_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInterfacePath)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_source_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SourceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_vendor_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PciVendorId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_device_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PciDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_sub_system_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PciSubSystemId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pci_revision(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PciRevision)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayAdapter: IDisplayAdapter}
impl RtActivatable<IDisplayAdapterStatics> for DisplayAdapter {}
impl DisplayAdapter {
    #[cfg(feature="windows-graphics")] #[inline] pub fn from_id(id: crate::windows::graphics::DisplayAdapterId) -> Result<Option<ComPtr<DisplayAdapter>>> {
        <Self as RtActivatable<IDisplayAdapterStatics>>::get_activation_factory().from_id(id)
    }
}
DEFINE_CLSID!(DisplayAdapter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,65,100,97,112,116,101,114,0]) [CLSID_DisplayAdapter]);
DEFINE_IID!(IID_IDisplayAdapterStatics, 497827034, 18463, 21609, 132, 112, 130, 196, 186, 104, 10, 40);
RT_INTERFACE!{static interface IDisplayAdapterStatics(IDisplayAdapterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayAdapterStatics] {
    #[cfg(feature="windows-graphics")] fn FromId(&self, id: crate::windows::graphics::DisplayAdapterId, out: *mut *mut DisplayAdapter) -> HRESULT
}}
impl ComPtr<IDisplayAdapterStatics> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn from_id(&self, id: crate::windows::graphics::DisplayAdapterId) -> Result<Option<ComPtr<DisplayAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromId)(self.deref() as *const _ as *mut _, id, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayBitsPerChannel: u32 {
    None = 0, Bpc6 = 1, Bpc8 = 2, Bpc10 = 4, Bpc12 = 8, Bpc14 = 16, Bpc16 = 32,
}}
DEFINE_IID!(IID_IDisplayDevice, 2764682796, 13151, 22321, 140, 180, 193, 204, 212, 115, 16, 112);
RT_INTERFACE!{interface IDisplayDevice(IDisplayDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayDevice] {
    fn CreateScanoutSource(&self, target: *mut DisplayTarget, out: *mut *mut DisplaySource) -> HRESULT,
    fn CreatePrimary(&self, target: *mut DisplayTarget, desc: *mut DisplayPrimaryDescription, out: *mut *mut DisplaySurface) -> HRESULT,
    fn CreateTaskPool(&self, out: *mut *mut DisplayTaskPool) -> HRESULT,
    fn CreatePeriodicFence(&self, target: *mut DisplayTarget, offsetFromVBlank: foundation::TimeSpan, out: *mut *mut DisplayFence) -> HRESULT,
    fn WaitForVBlank(&self, source: *mut DisplaySource) -> HRESULT,
    fn CreateSimpleScanout(&self, pSource: *mut DisplaySource, pSurface: *mut DisplaySurface, subResourceIndex: u32, syncInterval: u32, out: *mut *mut DisplayScanout) -> HRESULT,
    fn IsCapabilitySupported(&self, capability: DisplayDeviceCapability, out: *mut bool) -> HRESULT
}}
impl ComPtr<IDisplayDevice> {
    #[inline] pub fn create_scanout_source(&self, target: &ComPtr<DisplayTarget>) -> Result<Option<ComPtr<DisplaySource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateScanoutSource)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_primary(&self, target: &ComPtr<DisplayTarget>, desc: &ComPtr<DisplayPrimaryDescription>) -> Result<Option<ComPtr<DisplaySurface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreatePrimary)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, desc.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_task_pool(&self) -> Result<Option<ComPtr<DisplayTaskPool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateTaskPool)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_periodic_fence(&self, target: &ComPtr<DisplayTarget>, offsetFromVBlank: foundation::TimeSpan) -> Result<Option<ComPtr<DisplayFence>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreatePeriodicFence)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, offsetFromVBlank, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn wait_for_v_blank(&self, source: &ComPtr<DisplaySource>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).WaitForVBlank)(self.deref() as *const _ as *mut _, source.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_simple_scanout(&self, pSource: &ComPtr<DisplaySource>, pSurface: &ComPtr<DisplaySurface>, subResourceIndex: u32, syncInterval: u32) -> Result<Option<ComPtr<DisplayScanout>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateSimpleScanout)(self.deref() as *const _ as *mut _, pSource.deref() as *const _ as *mut _, pSurface.deref() as *const _ as *mut _, subResourceIndex, syncInterval, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_capability_supported(&self, capability: DisplayDeviceCapability) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsCapabilitySupported)(self.deref() as *const _ as *mut _, capability, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayDevice: IDisplayDevice}
RT_ENUM! { enum DisplayDeviceCapability: i32 {
    FlipOverride = 0,
}}
DEFINE_IID!(IID_IDisplayFence, 81590767, 13318, 22272, 143, 236, 119, 235, 164, 197, 167, 75);
RT_INTERFACE!{interface IDisplayFence(IDisplayFenceVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayFence] {
    
}}
RT_CLASS!{class DisplayFence: IDisplayFence}
DEFINE_IID!(IID_IDisplayManager, 1322853467, 5612, 22242, 144, 114, 127, 229, 8, 74, 49, 167);
RT_INTERFACE!{interface IDisplayManager(IDisplayManagerVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManager] {
    fn GetCurrentTargets(&self, out: *mut *mut foundation::collections::IVectorView<DisplayTarget>) -> HRESULT,
    fn GetCurrentAdapters(&self, out: *mut *mut foundation::collections::IVectorView<DisplayAdapter>) -> HRESULT,
    fn TryAcquireTarget(&self, target: *mut DisplayTarget, out: *mut DisplayManagerResult) -> HRESULT,
    fn ReleaseTarget(&self, target: *mut DisplayTarget) -> HRESULT,
    fn TryReadCurrentStateForAllTargets(&self, out: *mut *mut DisplayManagerResultWithState) -> HRESULT,
    fn TryAcquireTargetsAndReadCurrentState(&self, targets: *mut foundation::collections::IIterable<DisplayTarget>, out: *mut *mut DisplayManagerResultWithState) -> HRESULT,
    fn TryAcquireTargetsAndCreateEmptyState(&self, targets: *mut foundation::collections::IIterable<DisplayTarget>, out: *mut *mut DisplayManagerResultWithState) -> HRESULT,
    fn TryAcquireTargetsAndCreateSubstate(&self, existingState: *mut DisplayState, targets: *mut foundation::collections::IIterable<DisplayTarget>, out: *mut *mut DisplayManagerResultWithState) -> HRESULT,
    fn CreateDisplayDevice(&self, adapter: *mut DisplayAdapter, out: *mut *mut DisplayDevice) -> HRESULT,
    fn add_Enabled(&self, handler: *mut foundation::TypedEventHandler<DisplayManager, DisplayManagerEnabledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Enabled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Disabled(&self, handler: *mut foundation::TypedEventHandler<DisplayManager, DisplayManagerDisabledEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Disabled(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Changed(&self, handler: *mut foundation::TypedEventHandler<DisplayManager, DisplayManagerChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Changed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PathsFailedOrInvalidated(&self, handler: *mut foundation::TypedEventHandler<DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PathsFailedOrInvalidated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IDisplayManager> {
    #[inline] pub fn get_current_targets(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<DisplayTarget>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentTargets)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_adapters(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<DisplayAdapter>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentAdapters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_target(&self, target: &ComPtr<DisplayTarget>) -> Result<DisplayManagerResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryAcquireTarget)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn release_target(&self, target: &ComPtr<DisplayTarget>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ReleaseTarget)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_current_state_for_all_targets(&self) -> Result<Option<ComPtr<DisplayManagerResultWithState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryReadCurrentStateForAllTargets)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_targets_and_read_current_state(&self, targets: &ComPtr<foundation::collections::IIterable<DisplayTarget>>) -> Result<Option<ComPtr<DisplayManagerResultWithState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryAcquireTargetsAndReadCurrentState)(self.deref() as *const _ as *mut _, targets.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_targets_and_create_empty_state(&self, targets: &ComPtr<foundation::collections::IIterable<DisplayTarget>>) -> Result<Option<ComPtr<DisplayManagerResultWithState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryAcquireTargetsAndCreateEmptyState)(self.deref() as *const _ as *mut _, targets.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_targets_and_create_substate(&self, existingState: &ComPtr<DisplayState>, targets: &ComPtr<foundation::collections::IIterable<DisplayTarget>>) -> Result<Option<ComPtr<DisplayManagerResultWithState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryAcquireTargetsAndCreateSubstate)(self.deref() as *const _ as *mut _, existingState.deref() as *const _ as *mut _, targets.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_display_device(&self, adapter: &ComPtr<DisplayAdapter>) -> Result<Option<ComPtr<DisplayDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateDisplayDevice)(self.deref() as *const _ as *mut _, adapter.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_enabled(&self, handler: &ComPtr<foundation::TypedEventHandler<DisplayManager, DisplayManagerEnabledEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Enabled)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enabled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Enabled)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disabled(&self, handler: &ComPtr<foundation::TypedEventHandler<DisplayManager, DisplayManagerDisabledEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Disabled)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disabled(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Disabled)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<DisplayManager, DisplayManagerChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Changed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Changed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_paths_failed_or_invalidated(&self, handler: &ComPtr<foundation::TypedEventHandler<DisplayManager, DisplayManagerPathsFailedOrInvalidatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PathsFailedOrInvalidated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_paths_failed_or_invalidated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PathsFailedOrInvalidated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManager: IDisplayManager}
impl RtActivatable<IDisplayManagerStatics> for DisplayManager {}
impl DisplayManager {
    #[inline] pub fn create(options: DisplayManagerOptions) -> Result<Option<ComPtr<DisplayManager>>> {
        <Self as RtActivatable<IDisplayManagerStatics>>::get_activation_factory().create(options)
    }
}
DEFINE_CLSID!(DisplayManager(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,77,97,110,97,103,101,114,0]) [CLSID_DisplayManager]);
DEFINE_IID!(IID_IDisplayManagerChangedEventArgs, 1790943877, 27850, 22321, 188, 220, 66, 229, 210, 245, 197, 15);
RT_INTERFACE!{interface IDisplayManagerChangedEventArgs(IDisplayManagerChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManagerChangedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IDisplayManagerChangedEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerChangedEventArgs: IDisplayManagerChangedEventArgs}
DEFINE_IID!(IID_IDisplayManagerDisabledEventArgs, 2267471332, 26515, 22899, 161, 31, 95, 251, 201, 63, 219, 144);
RT_INTERFACE!{interface IDisplayManagerDisabledEventArgs(IDisplayManagerDisabledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManagerDisabledEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IDisplayManagerDisabledEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerDisabledEventArgs: IDisplayManagerDisabledEventArgs}
DEFINE_IID!(IID_IDisplayManagerEnabledEventArgs, 4040114031, 17146, 22946, 178, 151, 38, 225, 113, 61, 232, 72);
RT_INTERFACE!{interface IDisplayManagerEnabledEventArgs(IDisplayManagerEnabledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManagerEnabledEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IDisplayManagerEnabledEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerEnabledEventArgs: IDisplayManagerEnabledEventArgs}
RT_ENUM! { enum DisplayManagerOptions: u32 {
    None = 0, EnforceSourceOwnership = 1,
}}
DEFINE_IID!(IID_IDisplayManagerPathsFailedOrInvalidatedEventArgs, 61232729, 7660, 23573, 178, 162, 143, 233, 18, 152, 105, 254);
RT_INTERFACE!{interface IDisplayManagerPathsFailedOrInvalidatedEventArgs(IDisplayManagerPathsFailedOrInvalidatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManagerPathsFailedOrInvalidatedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IDisplayManagerPathsFailedOrInvalidatedEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerPathsFailedOrInvalidatedEventArgs: IDisplayManagerPathsFailedOrInvalidatedEventArgs}
RT_ENUM! { enum DisplayManagerResult: i32 {
    Success = 0, UnknownFailure = 1, TargetAccessDenied = 2, TargetStale = 3, RemoteSessionNotSupported = 4,
}}
DEFINE_IID!(IID_IDisplayManagerResultWithState, 2389011110, 26132, 21694, 191, 239, 73, 148, 84, 127, 123, 225);
RT_INTERFACE!{interface IDisplayManagerResultWithState(IDisplayManagerResultWithStateVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManagerResultWithState] {
    fn get_ErrorCode(&self, out: *mut DisplayManagerResult) -> HRESULT,
    fn get_ExtendedErrorCode(&self, out: *mut foundation::HResult) -> HRESULT,
    fn get_State(&self, out: *mut *mut DisplayState) -> HRESULT
}}
impl ComPtr<IDisplayManagerResultWithState> {
    #[inline] pub fn get_error_code(&self) -> Result<DisplayManagerResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ErrorCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedErrorCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<Option<ComPtr<DisplayState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayManagerResultWithState: IDisplayManagerResultWithState}
DEFINE_IID!(IID_IDisplayManagerStatics, 728470598, 47513, 21813, 157, 105, 83, 240, 146, 199, 128, 161);
RT_INTERFACE!{static interface IDisplayManagerStatics(IDisplayManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayManagerStatics] {
    fn Create(&self, options: DisplayManagerOptions, out: *mut *mut DisplayManager) -> HRESULT
}}
impl ComPtr<IDisplayManagerStatics> {
    #[inline] pub fn create(&self, options: DisplayManagerOptions) -> Result<Option<ComPtr<DisplayManager>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDisplayModeInfo, 1221923744, 63387, 23156, 160, 94, 218, 130, 31, 71, 8, 104);
RT_INTERFACE!{interface IDisplayModeInfo(IDisplayModeInfoVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayModeInfo] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourceResolution(&self, out: *mut crate::windows::graphics::SizeInt32) -> HRESULT,
    fn get_IsStereo(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourcePixelFormat(&self, out: *mut crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_TargetResolution(&self, out: *mut crate::windows::graphics::SizeInt32) -> HRESULT,
    fn get_PresentationRate(&self, out: *mut DisplayPresentationRate) -> HRESULT,
    fn get_IsInterlaced(&self, out: *mut bool) -> HRESULT,
    fn GetWireFormatSupportedBitsPerChannel(&self, encoding: DisplayWireFormatPixelEncoding, out: *mut DisplayBitsPerChannel) -> HRESULT,
    fn IsWireFormatSupported(&self, wireFormat: *mut DisplayWireFormat, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<Guid, IInspectable>) -> HRESULT
}}
impl ComPtr<IDisplayModeInfo> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_resolution(&self) -> Result<crate::windows::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SourceResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stereo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStereo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_pixel_format(&self) -> Result<crate::windows::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SourcePixelFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_target_resolution(&self) -> Result<crate::windows::graphics::SizeInt32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TargetResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_rate(&self) -> Result<DisplayPresentationRate> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PresentationRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_interlaced(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsInterlaced)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_wire_format_supported_bits_per_channel(&self, encoding: DisplayWireFormatPixelEncoding) -> Result<DisplayBitsPerChannel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetWireFormatSupportedBitsPerChannel)(self.deref() as *const _ as *mut _, encoding, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_wire_format_supported(&self, wireFormat: &ComPtr<DisplayWireFormat>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsWireFormatSupported)(self.deref() as *const _ as *mut _, wireFormat.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayModeInfo: IDisplayModeInfo}
RT_ENUM! { enum DisplayModeQueryOptions: u32 {
    None = 0, OnlyPreferredResolution = 1,
}}
DEFINE_IID!(IID_IDisplayPath, 3017791050, 29792, 23774, 129, 27, 213, 174, 159, 61, 159, 132);
RT_INTERFACE!{interface IDisplayPath(IDisplayPathVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayPath] {
    fn get_View(&self, out: *mut *mut DisplayView) -> HRESULT,
    fn get_Target(&self, out: *mut *mut DisplayTarget) -> HRESULT,
    fn get_Status(&self, out: *mut DisplayPathStatus) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourceResolution(&self, out: *mut *mut foundation::IReference<crate::windows::graphics::SizeInt32>) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_SourceResolution(&self, value: *mut foundation::IReference<crate::windows::graphics::SizeInt32>) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_SourcePixelFormat(&self, out: *mut crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_SourcePixelFormat(&self, value: crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    fn get_IsStereo(&self, out: *mut bool) -> HRESULT,
    fn put_IsStereo(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_TargetResolution(&self, out: *mut *mut foundation::IReference<crate::windows::graphics::SizeInt32>) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_TargetResolution(&self, value: *mut foundation::IReference<crate::windows::graphics::SizeInt32>) -> HRESULT,
    fn get_PresentationRate(&self, out: *mut *mut foundation::IReference<DisplayPresentationRate>) -> HRESULT,
    fn put_PresentationRate(&self, value: *mut foundation::IReference<DisplayPresentationRate>) -> HRESULT,
    fn get_IsInterlaced(&self, out: *mut *mut foundation::IReference<bool>) -> HRESULT,
    fn put_IsInterlaced(&self, value: *mut foundation::IReference<bool>) -> HRESULT,
    fn get_WireFormat(&self, out: *mut *mut DisplayWireFormat) -> HRESULT,
    fn put_WireFormat(&self, value: *mut DisplayWireFormat) -> HRESULT,
    fn get_Rotation(&self, out: *mut DisplayRotation) -> HRESULT,
    fn put_Rotation(&self, value: DisplayRotation) -> HRESULT,
    fn get_Scaling(&self, out: *mut DisplayPathScaling) -> HRESULT,
    fn put_Scaling(&self, value: DisplayPathScaling) -> HRESULT,
    fn FindModes(&self, flags: DisplayModeQueryOptions, out: *mut *mut foundation::collections::IVectorView<DisplayModeInfo>) -> HRESULT,
    fn ApplyPropertiesFromMode(&self, modeResult: *mut DisplayModeInfo) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMap<Guid, IInspectable>) -> HRESULT
}}
impl ComPtr<IDisplayPath> {
    #[inline] pub fn get_view(&self) -> Result<Option<ComPtr<DisplayView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_View)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_target(&self) -> Result<Option<ComPtr<DisplayTarget>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Target)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<DisplayPathStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_resolution(&self) -> Result<Option<ComPtr<foundation::IReference<crate::windows::graphics::SizeInt32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SourceResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_source_resolution(&self, value: &ComPtr<foundation::IReference<crate::windows::graphics::SizeInt32>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SourceResolution)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_source_pixel_format(&self) -> Result<crate::windows::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SourcePixelFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_source_pixel_format(&self, value: crate::windows::graphics::directx::DirectXPixelFormat) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SourcePixelFormat)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stereo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStereo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_stereo(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsStereo)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_target_resolution(&self) -> Result<Option<ComPtr<foundation::IReference<crate::windows::graphics::SizeInt32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TargetResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_target_resolution(&self, value: &ComPtr<foundation::IReference<crate::windows::graphics::SizeInt32>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_TargetResolution)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_presentation_rate(&self) -> Result<Option<ComPtr<foundation::IReference<DisplayPresentationRate>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PresentationRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_presentation_rate(&self, value: &ComPtr<foundation::IReference<DisplayPresentationRate>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PresentationRate)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_interlaced(&self) -> Result<Option<ComPtr<foundation::IReference<bool>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_IsInterlaced)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_is_interlaced(&self, value: &ComPtr<foundation::IReference<bool>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsInterlaced)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_wire_format(&self) -> Result<Option<ComPtr<DisplayWireFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_WireFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_wire_format(&self, value: &ComPtr<DisplayWireFormat>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_WireFormat)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation(&self) -> Result<DisplayRotation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Rotation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_rotation(&self, value: DisplayRotation) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Rotation)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scaling(&self) -> Result<DisplayPathScaling> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Scaling)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scaling(&self, value: DisplayPathScaling) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Scaling)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn find_modes(&self, flags: DisplayModeQueryOptions) -> Result<Option<ComPtr<foundation::collections::IVectorView<DisplayModeInfo>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindModes)(self.deref() as *const _ as *mut _, flags, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn apply_properties_from_mode(&self, modeResult: &ComPtr<DisplayModeInfo>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ApplyPropertiesFromMode)(self.deref() as *const _ as *mut _, modeResult.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMap<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayPath: IDisplayPath}
RT_ENUM! { enum DisplayPathScaling: i32 {
    Identity = 0, Centered = 1, Stretched = 2, AspectRatioStretched = 3, Custom = 4, DriverPreferred = 5,
}}
RT_ENUM! { enum DisplayPathStatus: i32 {
    Unknown = 0, Succeeded = 1, Pending = 2, Failed = 3, FailedAsync = 4, InvalidatedAsync = 5,
}}
RT_STRUCT! { struct DisplayPresentationRate {
    VerticalSyncRate: foundation::numerics::Rational, VerticalSyncsPerPresentation: i32,
}}
DEFINE_IID!(IID_IDisplayPrimaryDescription, 2267386322, 54579, 20735, 168, 94, 6, 105, 97, 148, 183, 124);
RT_INTERFACE!{interface IDisplayPrimaryDescription(IDisplayPrimaryDescriptionVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayPrimaryDescription] {
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Format(&self, out: *mut crate::windows::graphics::directx::DirectXPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ColorSpace(&self, out: *mut crate::windows::graphics::directx::DirectXColorSpace) -> HRESULT,
    fn get_IsStereo(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_MultisampleDescription(&self, out: *mut crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<Guid, IInspectable>) -> HRESULT
}}
impl ComPtr<IDisplayPrimaryDescription> {
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Width)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Height)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_format(&self) -> Result<crate::windows::graphics::directx::DirectXPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Format)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_color_space(&self) -> Result<crate::windows::graphics::directx::DirectXColorSpace> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ColorSpace)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stereo(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStereo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_multisample_description(&self) -> Result<crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MultisampleDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayPrimaryDescription: IDisplayPrimaryDescription}
impl RtActivatable<IDisplayPrimaryDescriptionFactory> for DisplayPrimaryDescription {}
impl RtActivatable<IDisplayPrimaryDescriptionStatics> for DisplayPrimaryDescription {}
impl DisplayPrimaryDescription {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_instance(width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<ComPtr<DisplayPrimaryDescription>> {
        <Self as RtActivatable<IDisplayPrimaryDescriptionFactory>>::get_activation_factory().create_instance(width, height, pixelFormat, colorSpace, isStereo, multisampleDescription)
    }
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_properties(extraProperties: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>>, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<Option<ComPtr<DisplayPrimaryDescription>>> {
        <Self as RtActivatable<IDisplayPrimaryDescriptionStatics>>::get_activation_factory().create_with_properties(extraProperties, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription)
    }
}
DEFINE_CLSID!(DisplayPrimaryDescription(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,80,114,105,109,97,114,121,68,101,115,99,114,105,112,116,105,111,110,0]) [CLSID_DisplayPrimaryDescription]);
DEFINE_IID!(IID_IDisplayPrimaryDescriptionFactory, 443219835, 13879, 23622, 180, 121, 118, 213, 118, 33, 110, 101);
RT_INTERFACE!{static interface IDisplayPrimaryDescriptionFactory(IDisplayPrimaryDescriptionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayPrimaryDescriptionFactory] {
    #[cfg(feature="windows-graphics")] fn CreateInstance(&self, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription, out: *mut *mut DisplayPrimaryDescription) -> HRESULT
}}
impl ComPtr<IDisplayPrimaryDescriptionFactory> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_instance(&self, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<ComPtr<DisplayPrimaryDescription>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDisplayPrimaryDescriptionStatics, 3859696891, 14025, 22237, 143, 161, 111, 248, 196, 224, 255, 7);
RT_INTERFACE!{static interface IDisplayPrimaryDescriptionStatics(IDisplayPrimaryDescriptionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayPrimaryDescriptionStatics] {
    #[cfg(feature="windows-graphics")] fn CreateWithProperties(&self, extraProperties: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription, out: *mut *mut DisplayPrimaryDescription) -> HRESULT
}}
impl ComPtr<IDisplayPrimaryDescriptionStatics> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_with_properties(&self, extraProperties: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>>, width: u32, height: u32, pixelFormat: crate::windows::graphics::directx::DirectXPixelFormat, colorSpace: crate::windows::graphics::directx::DirectXColorSpace, isStereo: bool, multisampleDescription: crate::windows::graphics::directx::direct3d11::Direct3DMultisampleDescription) -> Result<Option<ComPtr<DisplayPrimaryDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithProperties)(self.deref() as *const _ as *mut _, extraProperties.deref() as *const _ as *mut _, width, height, pixelFormat, colorSpace, isStereo, multisampleDescription, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayRotation: i32 {
    None = 0, Clockwise90Degrees = 1, Clockwise180Degrees = 2, Clockwise270Degrees = 3,
}}
DEFINE_IID!(IID_IDisplayScanout, 3808761896, 7077, 20711, 138, 57, 187, 31, 210, 244, 248, 185);
RT_INTERFACE!{interface IDisplayScanout(IDisplayScanoutVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayScanout] {
    
}}
RT_CLASS!{class DisplayScanout: IDisplayScanout}
DEFINE_IID!(IID_IDisplaySource, 3973144513, 60124, 20924, 151, 29, 59, 198, 40, 219, 45, 212);
RT_INTERFACE!{interface IDisplaySource(IDisplaySourceVtbl): IInspectable(IInspectableVtbl) [IID_IDisplaySource] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_AdapterId(&self, out: *mut crate::windows::graphics::DisplayAdapterId) -> HRESULT,
    fn get_SourceId(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetMetadata(&self, key: Guid, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IDisplaySource> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_adapter_id(&self) -> Result<crate::windows::graphics::DisplayAdapterId> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdapterId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SourceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_metadata(&self, key: Guid) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetMetadata)(self.deref() as *const _ as *mut _, key, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplaySource: IDisplaySource}
DEFINE_IID!(IID_IDisplayState, 135435041, 4533, 23730, 153, 248, 233, 11, 71, 154, 138, 29);
RT_INTERFACE!{interface IDisplayState(IDisplayStateVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayState] {
    fn get_IsReadOnly(&self, out: *mut bool) -> HRESULT,
    fn get_IsStale(&self, out: *mut bool) -> HRESULT,
    fn get_Targets(&self, out: *mut *mut foundation::collections::IVectorView<DisplayTarget>) -> HRESULT,
    fn get_Views(&self, out: *mut *mut foundation::collections::IVectorView<DisplayView>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMap<Guid, IInspectable>) -> HRESULT,
    fn ConnectTarget(&self, target: *mut DisplayTarget, out: *mut *mut DisplayPath) -> HRESULT,
    fn ConnectTargetToView(&self, target: *mut DisplayTarget, view: *mut DisplayView, out: *mut *mut DisplayPath) -> HRESULT,
    fn CanConnectTargetToView(&self, target: *mut DisplayTarget, view: *mut DisplayView, out: *mut bool) -> HRESULT,
    fn GetViewForTarget(&self, target: *mut DisplayTarget, out: *mut *mut DisplayView) -> HRESULT,
    fn GetPathForTarget(&self, target: *mut DisplayTarget, out: *mut *mut DisplayPath) -> HRESULT,
    fn DisconnectTarget(&self, target: *mut DisplayTarget) -> HRESULT,
    fn TryFunctionalize(&self, options: DisplayStateFunctionalizeOptions, out: *mut *mut DisplayStateOperationResult) -> HRESULT,
    fn TryApply(&self, options: DisplayStateApplyOptions, out: *mut *mut DisplayStateOperationResult) -> HRESULT,
    fn Clone(&self, out: *mut *mut DisplayState) -> HRESULT
}}
impl ComPtr<IDisplayState> {
    #[inline] pub fn get_is_read_only(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsReadOnly)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stale(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStale)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_targets(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<DisplayTarget>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Targets)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_views(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<DisplayView>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Views)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMap<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_target(&self, target: &ComPtr<DisplayTarget>) -> Result<Option<ComPtr<DisplayPath>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectTarget)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_target_to_view(&self, target: &ComPtr<DisplayTarget>, view: &ComPtr<DisplayView>) -> Result<Option<ComPtr<DisplayPath>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectTargetToView)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, view.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_connect_target_to_view(&self, target: &ComPtr<DisplayTarget>, view: &ComPtr<DisplayView>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).CanConnectTargetToView)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, view.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_view_for_target(&self, target: &ComPtr<DisplayTarget>) -> Result<Option<ComPtr<DisplayView>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetViewForTarget)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_path_for_target(&self, target: &ComPtr<DisplayTarget>) -> Result<Option<ComPtr<DisplayPath>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetPathForTarget)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn disconnect_target(&self, target: &ComPtr<DisplayTarget>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).DisconnectTarget)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_functionalize(&self, options: DisplayStateFunctionalizeOptions) -> Result<Option<ComPtr<DisplayStateOperationResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryFunctionalize)(self.deref() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_apply(&self, options: DisplayStateApplyOptions) -> Result<Option<ComPtr<DisplayStateOperationResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryApply)(self.deref() as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clone(&self) -> Result<Option<ComPtr<DisplayState>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Clone)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayState: IDisplayState}
RT_ENUM! { enum DisplayStateApplyOptions: u32 {
    None = 0, FailIfStateChanged = 1, ForceReapply = 2, ForceModeEnumeration = 4,
}}
RT_ENUM! { enum DisplayStateFunctionalizeOptions: u32 {
    None = 0, FailIfStateChanged = 1, ValidateTopologyOnly = 2,
}}
DEFINE_IID!(IID_IDisplayStateOperationResult, 4239245279, 56359, 22072, 183, 242, 235, 223, 164, 247, 234, 147);
RT_INTERFACE!{interface IDisplayStateOperationResult(IDisplayStateOperationResultVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayStateOperationResult] {
    fn get_Status(&self, out: *mut DisplayStateOperationStatus) -> HRESULT,
    fn get_ExtendedErrorCode(&self, out: *mut foundation::HResult) -> HRESULT
}}
impl ComPtr<IDisplayStateOperationResult> {
    #[inline] pub fn get_status(&self) -> Result<DisplayStateOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_error_code(&self) -> Result<foundation::HResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedErrorCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayStateOperationResult: IDisplayStateOperationResult}
RT_ENUM! { enum DisplayStateOperationStatus: i32 {
    Success = 0, PartialFailure = 1, UnknownFailure = 2, TargetOwnershipLost = 3, SystemStateChanged = 4, TooManyPathsForAdapter = 5, ModesNotSupported = 6, RemoteSessionNotSupported = 7,
}}
DEFINE_IID!(IID_IDisplaySurface, 1498377414, 5018, 22230, 164, 177, 21, 254, 44, 183, 106, 219);
RT_INTERFACE!{interface IDisplaySurface(IDisplaySurfaceVtbl): IInspectable(IInspectableVtbl) [IID_IDisplaySurface] {
    
}}
RT_CLASS!{class DisplaySurface: IDisplaySurface}
DEFINE_IID!(IID_IDisplayTarget, 2932178031, 18356, 21611, 152, 124, 231, 63, 167, 145, 254, 58);
RT_INTERFACE!{interface IDisplayTarget(IDisplayTargetVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayTarget] {
    fn get_Adapter(&self, out: *mut *mut DisplayAdapter) -> HRESULT,
    fn get_DeviceInterfacePath(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AdapterRelativeId(&self, out: *mut u32) -> HRESULT,
    fn get_IsConnected(&self, out: *mut bool) -> HRESULT,
    fn get_IsVirtualModeEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsVirtualTopologyEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_UsageKind(&self, out: *mut super::DisplayMonitorUsageKind) -> HRESULT,
    fn get_MonitorPersistence(&self, out: *mut DisplayTargetPersistence) -> HRESULT,
    fn get_StableMonitorId(&self, out: *mut HSTRING) -> HRESULT,
    fn TryGetMonitor(&self, out: *mut *mut super::DisplayMonitor) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<Guid, IInspectable>) -> HRESULT,
    fn get_IsStale(&self, out: *mut bool) -> HRESULT,
    fn IsSame(&self, otherTarget: *mut DisplayTarget, out: *mut bool) -> HRESULT,
    fn IsEqual(&self, otherTarget: *mut DisplayTarget, out: *mut bool) -> HRESULT
}}
impl ComPtr<IDisplayTarget> {
    #[inline] pub fn get_adapter(&self) -> Result<Option<ComPtr<DisplayAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Adapter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_interface_path(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInterfacePath)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_adapter_relative_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdapterRelativeId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_connected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsConnected)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_virtual_mode_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsVirtualModeEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_virtual_topology_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsVirtualTopologyEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_kind(&self) -> Result<super::DisplayMonitorUsageKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_monitor_persistence(&self) -> Result<DisplayTargetPersistence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MonitorPersistence)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_stable_monitor_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StableMonitorId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_monitor(&self) -> Result<Option<ComPtr<super::DisplayMonitor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetMonitor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stale(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStale)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_same(&self, otherTarget: &ComPtr<DisplayTarget>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsSame)(self.deref() as *const _ as *mut _, otherTarget.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, otherTarget: &ComPtr<DisplayTarget>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsEqual)(self.deref() as *const _ as *mut _, otherTarget.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayTarget: IDisplayTarget}
RT_ENUM! { enum DisplayTargetPersistence: i32 {
    None = 0, BootPersisted = 1, TemporaryPersisted = 2, PathPersisted = 3,
}}
DEFINE_IID!(IID_IDisplayTask, 1577612360, 4955, 23472, 191, 99, 99, 127, 132, 34, 124, 122);
RT_INTERFACE!{interface IDisplayTask(IDisplayTaskVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayTask] {
    fn SetScanout(&self, scanout: *mut DisplayScanout) -> HRESULT,
    fn SetWait(&self, readyFence: *mut DisplayFence, readyFenceValue: u64) -> HRESULT
}}
impl ComPtr<IDisplayTask> {
    #[inline] pub fn set_scanout(&self, scanout: &ComPtr<DisplayScanout>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetScanout)(self.deref() as *const _ as *mut _, scanout.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_wait(&self, readyFence: &ComPtr<DisplayFence>, readyFenceValue: u64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetWait)(self.deref() as *const _ as *mut _, readyFence.deref() as *const _ as *mut _, readyFenceValue);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayTask: IDisplayTask}
DEFINE_IID!(IID_IDisplayTaskPool, 3329631549, 9085, 21832, 170, 250, 62, 81, 127, 239, 239, 28);
RT_INTERFACE!{interface IDisplayTaskPool(IDisplayTaskPoolVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayTaskPool] {
    fn CreateTask(&self, out: *mut *mut DisplayTask) -> HRESULT,
    fn ExecuteTask(&self, task: *mut DisplayTask) -> HRESULT
}}
impl ComPtr<IDisplayTaskPool> {
    #[inline] pub fn create_task(&self) -> Result<Option<ComPtr<DisplayTask>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateTask)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn execute_task(&self, task: &ComPtr<DisplayTask>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ExecuteTask)(self.deref() as *const _ as *mut _, task.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayTaskPool: IDisplayTaskPool}
RT_ENUM! { enum DisplayTaskSignalKind: i32 {
    OnPresentFlipAway = 0,
}}
DEFINE_IID!(IID_IDisplayView, 2965998753, 46937, 23385, 177, 173, 240, 120, 106, 169, 229, 61);
RT_INTERFACE!{interface IDisplayView(IDisplayViewVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayView] {
    fn get_Paths(&self, out: *mut *mut foundation::collections::IVectorView<DisplayPath>) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ContentResolution(&self, out: *mut *mut foundation::IReference<crate::windows::graphics::SizeInt32>) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_ContentResolution(&self, value: *mut foundation::IReference<crate::windows::graphics::SizeInt32>) -> HRESULT,
    fn SetPrimaryPath(&self, path: *mut DisplayPath) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMap<Guid, IInspectable>) -> HRESULT
}}
impl ComPtr<IDisplayView> {
    #[inline] pub fn get_paths(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<DisplayPath>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Paths)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_content_resolution(&self) -> Result<Option<ComPtr<foundation::IReference<crate::windows::graphics::SizeInt32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ContentResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_content_resolution(&self, value: &ComPtr<foundation::IReference<crate::windows::graphics::SizeInt32>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ContentResolution)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_primary_path(&self, path: &ComPtr<DisplayPath>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetPrimaryPath)(self.deref() as *const _ as *mut _, path.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMap<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayView: IDisplayView}
DEFINE_IID!(IID_IDisplayWireFormat, 449615485, 34604, 23096, 187, 185, 29, 72, 114, 183, 98, 85);
RT_INTERFACE!{interface IDisplayWireFormat(IDisplayWireFormatVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayWireFormat] {
    fn get_PixelEncoding(&self, out: *mut DisplayWireFormatPixelEncoding) -> HRESULT,
    fn get_BitsPerChannel(&self, out: *mut i32) -> HRESULT,
    fn get_ColorSpace(&self, out: *mut DisplayWireFormatColorSpace) -> HRESULT,
    fn get_Eotf(&self, out: *mut DisplayWireFormatEotf) -> HRESULT,
    fn get_HdrMetadata(&self, out: *mut DisplayWireFormatHdrMetadata) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<Guid, IInspectable>) -> HRESULT
}}
impl ComPtr<IDisplayWireFormat> {
    #[inline] pub fn get_pixel_encoding(&self) -> Result<DisplayWireFormatPixelEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PixelEncoding)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bits_per_channel(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BitsPerChannel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_color_space(&self) -> Result<DisplayWireFormatColorSpace> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ColorSpace)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eotf(&self) -> Result<DisplayWireFormatEotf> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Eotf)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hdr_metadata(&self) -> Result<DisplayWireFormatHdrMetadata> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HdrMetadata)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<Guid, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DisplayWireFormat: IDisplayWireFormat}
impl RtActivatable<IDisplayWireFormatFactory> for DisplayWireFormat {}
impl RtActivatable<IDisplayWireFormatStatics> for DisplayWireFormat {}
impl DisplayWireFormat {
    #[inline] pub fn create_instance(pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<ComPtr<DisplayWireFormat>> {
        <Self as RtActivatable<IDisplayWireFormatFactory>>::get_activation_factory().create_instance(pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata)
    }
    #[inline] pub fn create_with_properties(extraProperties: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>>, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<Option<ComPtr<DisplayWireFormat>>> {
        <Self as RtActivatable<IDisplayWireFormatStatics>>::get_activation_factory().create_with_properties(extraProperties, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata)
    }
}
DEFINE_CLSID!(DisplayWireFormat(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,68,105,115,112,108,97,121,46,67,111,114,101,46,68,105,115,112,108,97,121,87,105,114,101,70,111,114,109,97,116,0]) [CLSID_DisplayWireFormat]);
RT_ENUM! { enum DisplayWireFormatColorSpace: i32 {
    BT709 = 0, BT2020 = 1, ProfileDefinedWideColorGamut = 2,
}}
RT_ENUM! { enum DisplayWireFormatEotf: i32 {
    Sdr = 0, HdrSmpte2084 = 1,
}}
DEFINE_IID!(IID_IDisplayWireFormatFactory, 3002058965, 2518, 21990, 173, 34, 144, 20, 179, 210, 82, 41);
RT_INTERFACE!{static interface IDisplayWireFormatFactory(IDisplayWireFormatFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayWireFormatFactory] {
    fn CreateInstance(&self, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata, out: *mut *mut DisplayWireFormat) -> HRESULT
}}
impl ComPtr<IDisplayWireFormatFactory> {
    #[inline] pub fn create_instance(&self, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<ComPtr<DisplayWireFormat>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DisplayWireFormatHdrMetadata: i32 {
    None = 0, Hdr10 = 1, Hdr10Plus = 2, DolbyVisionLowLatency = 3,
}}
RT_ENUM! { enum DisplayWireFormatPixelEncoding: i32 {
    Rgb444 = 0, Ycc444 = 1, Ycc422 = 2, Ycc420 = 3, Intensity = 4,
}}
DEFINE_IID!(IID_IDisplayWireFormatStatics, 3312820781, 50150, 24442, 189, 251, 135, 198, 171, 134, 97, 213);
RT_INTERFACE!{static interface IDisplayWireFormatStatics(IDisplayWireFormatStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDisplayWireFormatStatics] {
    fn CreateWithProperties(&self, extraProperties: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata, out: *mut *mut DisplayWireFormat) -> HRESULT
}}
impl ComPtr<IDisplayWireFormatStatics> {
    #[inline] pub fn create_with_properties(&self, extraProperties: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<Guid, IInspectable>>>, pixelEncoding: DisplayWireFormatPixelEncoding, bitsPerChannel: i32, colorSpace: DisplayWireFormatColorSpace, eotf: DisplayWireFormatEotf, hdrMetadata: DisplayWireFormatHdrMetadata) -> Result<Option<ComPtr<DisplayWireFormat>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithProperties)(self.deref() as *const _ as *mut _, extraProperties.deref() as *const _ as *mut _, pixelEncoding, bitsPerChannel, colorSpace, eotf, hdrMetadata, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Display.Core
} // Windows.Devices.Display
pub mod enumeration { // Windows.Devices.Enumeration
use crate::prelude::*;
DEFINE_IID!(IID_IDeviceAccessChangedEventArgs, 3738831820, 20381, 20312, 157, 186, 169, 188, 128, 4, 8, 213);
RT_INTERFACE!{interface IDeviceAccessChangedEventArgs(IDeviceAccessChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessChangedEventArgs] {
    fn get_Status(&self, out: *mut DeviceAccessStatus) -> HRESULT
}}
impl ComPtr<IDeviceAccessChangedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<DeviceAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceAccessChangedEventArgs: IDeviceAccessChangedEventArgs}
DEFINE_IID!(IID_IDeviceAccessChangedEventArgs2, 2186424930, 37707, 19248, 161, 120, 173, 195, 159, 47, 43, 227);
RT_INTERFACE!{interface IDeviceAccessChangedEventArgs2(IDeviceAccessChangedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessChangedEventArgs2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IDeviceAccessChangedEventArgs2> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceAccessInformation, 195730035, 28133, 18709, 141, 221, 154, 5, 84, 166, 245, 69);
RT_INTERFACE!{interface IDeviceAccessInformation(IDeviceAccessInformationVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessInformation] {
    fn add_AccessChanged(&self, handler: *mut foundation::TypedEventHandler<DeviceAccessInformation, DeviceAccessChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AccessChanged(&self, cookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_CurrentStatus(&self, out: *mut DeviceAccessStatus) -> HRESULT
}}
impl ComPtr<IDeviceAccessInformation> {
    #[inline] pub fn add_access_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceAccessInformation, DeviceAccessChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AccessChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_access_changed(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AccessChanged)(self.deref() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_status(&self) -> Result<DeviceAccessStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CurrentStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceAccessInformation: IDeviceAccessInformation}
impl RtActivatable<IDeviceAccessInformationStatics> for DeviceAccessInformation {}
impl DeviceAccessInformation {
    #[inline] pub fn create_from_id(deviceId: &HStringArg) -> Result<Option<ComPtr<DeviceAccessInformation>>> {
        <Self as RtActivatable<IDeviceAccessInformationStatics>>::get_activation_factory().create_from_id(deviceId)
    }
    #[inline] pub fn create_from_device_class_id(deviceClassId: Guid) -> Result<Option<ComPtr<DeviceAccessInformation>>> {
        <Self as RtActivatable<IDeviceAccessInformationStatics>>::get_activation_factory().create_from_device_class_id(deviceClassId)
    }
    #[inline] pub fn create_from_device_class(deviceClass: DeviceClass) -> Result<Option<ComPtr<DeviceAccessInformation>>> {
        <Self as RtActivatable<IDeviceAccessInformationStatics>>::get_activation_factory().create_from_device_class(deviceClass)
    }
}
DEFINE_CLSID!(DeviceAccessInformation(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,65,99,99,101,115,115,73,110,102,111,114,109,97,116,105,111,110,0]) [CLSID_DeviceAccessInformation]);
DEFINE_IID!(IID_IDeviceAccessInformationStatics, 1464587219, 24368, 17869, 138, 148, 114, 79, 229, 151, 48, 132);
RT_INTERFACE!{static interface IDeviceAccessInformationStatics(IDeviceAccessInformationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccessInformationStatics] {
    fn CreateFromId(&self, deviceId: HSTRING, out: *mut *mut DeviceAccessInformation) -> HRESULT,
    fn CreateFromDeviceClassId(&self, deviceClassId: Guid, out: *mut *mut DeviceAccessInformation) -> HRESULT,
    fn CreateFromDeviceClass(&self, deviceClass: DeviceClass, out: *mut *mut DeviceAccessInformation) -> HRESULT
}}
impl ComPtr<IDeviceAccessInformationStatics> {
    #[inline] pub fn create_from_id(&self, deviceId: &HStringArg) -> Result<Option<ComPtr<DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromId)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_device_class_id(&self, deviceClassId: Guid) -> Result<Option<ComPtr<DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromDeviceClassId)(self.deref() as *const _ as *mut _, deviceClassId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_device_class(&self, deviceClass: DeviceClass) -> Result<Option<ComPtr<DeviceAccessInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromDeviceClass)(self.deref() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum DeviceAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
RT_ENUM! { enum DeviceClass: i32 {
    All = 0, AudioCapture = 1, AudioRender = 2, PortableStorageDevice = 3, VideoCapture = 4, ImageScanner = 5, Location = 6,
}}
DEFINE_IID!(IID_IDeviceConnectionChangeTriggerDetails, 3092745228, 48065, 18507, 191, 250, 123, 49, 220, 194, 0, 178);
RT_INTERFACE!{interface IDeviceConnectionChangeTriggerDetails(IDeviceConnectionChangeTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceConnectionChangeTriggerDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IDeviceConnectionChangeTriggerDetails> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceConnectionChangeTriggerDetails: IDeviceConnectionChangeTriggerDetails}
DEFINE_IID!(IID_IDeviceDisconnectButtonClickedEventArgs, 2386867565, 63746, 18944, 181, 54, 243, 121, 146, 230, 162, 167);
RT_INTERFACE!{interface IDeviceDisconnectButtonClickedEventArgs(IDeviceDisconnectButtonClickedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceDisconnectButtonClickedEventArgs] {
    fn get_Device(&self, out: *mut *mut DeviceInformation) -> HRESULT
}}
impl ComPtr<IDeviceDisconnectButtonClickedEventArgs> {
    #[inline] pub fn get_device(&self) -> Result<Option<ComPtr<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Device)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceDisconnectButtonClickedEventArgs: IDeviceDisconnectButtonClickedEventArgs}
DEFINE_IID!(IID_IDeviceInformation, 2879454101, 17304, 18589, 142, 68, 230, 19, 9, 39, 1, 31);
RT_INTERFACE!{interface IDeviceInformation(IDeviceInformationVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformation] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_EnclosureLocation(&self, out: *mut *mut EnclosureLocation) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn Update(&self, updateInfo: *mut DeviceInformationUpdate) -> HRESULT,
    fn GetThumbnailAsync(&self, out: *mut *mut foundation::IAsyncOperation<DeviceThumbnail>) -> HRESULT,
    fn GetGlyphThumbnailAsync(&self, out: *mut *mut foundation::IAsyncOperation<DeviceThumbnail>) -> HRESULT
}}
impl ComPtr<IDeviceInformation> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_default(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_enclosure_location(&self) -> Result<Option<ComPtr<EnclosureLocation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EnclosureLocation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn update(&self, updateInfo: &ComPtr<DeviceInformationUpdate>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Update)(self.deref() as *const _ as *mut _, updateInfo.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_thumbnail_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<DeviceThumbnail>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetThumbnailAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_glyph_thumbnail_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<DeviceThumbnail>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGlyphThumbnailAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformation: IDeviceInformation}
impl RtActivatable<IDeviceInformationStatics> for DeviceInformation {}
impl RtActivatable<IDeviceInformationStatics2> for DeviceInformation {}
impl DeviceInformation {
    #[inline] pub fn create_from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_from_id_async(deviceId)
    }
    #[inline] pub fn create_from_id_async_additional_properties(deviceId: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_from_id_async_additional_properties(deviceId, additionalProperties)
    }
    #[inline] pub fn find_all_async() -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn find_all_async_device_class(deviceClass: DeviceClass) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async_device_class(deviceClass)
    }
    #[inline] pub fn find_all_async_aqs_filter(aqsFilter: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async_aqs_filter(aqsFilter)
    }
    #[inline] pub fn find_all_async_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().find_all_async_aqs_filter_and_additional_properties(aqsFilter, additionalProperties)
    }
    #[inline] pub fn create_watcher() -> Result<Option<ComPtr<DeviceWatcher>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn create_watcher_device_class(deviceClass: DeviceClass) -> Result<Option<ComPtr<DeviceWatcher>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher_device_class(deviceClass)
    }
    #[inline] pub fn create_watcher_aqs_filter(aqsFilter: &HStringArg) -> Result<Option<ComPtr<DeviceWatcher>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher_aqs_filter(aqsFilter)
    }
    #[inline] pub fn create_watcher_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<Option<ComPtr<DeviceWatcher>>> {
        <Self as RtActivatable<IDeviceInformationStatics>>::get_activation_factory().create_watcher_aqs_filter_and_additional_properties(aqsFilter, additionalProperties)
    }
    #[inline] pub fn get_aqs_filter_from_device_class(deviceClass: DeviceClass) -> Result<HString> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().get_aqs_filter_from_device_class(deviceClass)
    }
    #[inline] pub fn create_from_id_async_with_kind_and_additional_properties(deviceId: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>, kind: DeviceInformationKind) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().create_from_id_async_with_kind_and_additional_properties(deviceId, additionalProperties, kind)
    }
    #[inline] pub fn find_all_async_with_kind_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>, kind: DeviceInformationKind) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().find_all_async_with_kind_aqs_filter_and_additional_properties(aqsFilter, additionalProperties, kind)
    }
    #[inline] pub fn create_watcher_with_kind_aqs_filter_and_additional_properties(aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>, kind: DeviceInformationKind) -> Result<Option<ComPtr<DeviceWatcher>>> {
        <Self as RtActivatable<IDeviceInformationStatics2>>::get_activation_factory().create_watcher_with_kind_aqs_filter_and_additional_properties(aqsFilter, additionalProperties, kind)
    }
}
DEFINE_CLSID!(DeviceInformation(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,73,110,102,111,114,109,97,116,105,111,110,0]) [CLSID_DeviceInformation]);
DEFINE_IID!(IID_IDeviceInformation2, 4048987704, 31127, 18649, 161, 12, 38, 157, 70, 83, 63, 72);
RT_INTERFACE!{interface IDeviceInformation2(IDeviceInformation2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformation2] {
    fn get_Kind(&self, out: *mut DeviceInformationKind) -> HRESULT,
    fn get_Pairing(&self, out: *mut *mut DeviceInformationPairing) -> HRESULT
}}
impl ComPtr<IDeviceInformation2> {
    #[inline] pub fn get_kind(&self) -> Result<DeviceInformationKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Kind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pairing(&self) -> Result<Option<ComPtr<DeviceInformationPairing>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Pairing)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationCollection: foundation::collections::IVectorView<DeviceInformation>}
DEFINE_IID!(IID_IDeviceInformationCustomPairing, 2232650754, 20198, 18708, 131, 112, 16, 122, 57, 20, 76, 14);
RT_INTERFACE!{interface IDeviceInformationCustomPairing(IDeviceInformationCustomPairingVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationCustomPairing] {
    fn PairAsync(&self, pairingKindsSupported: DevicePairingKinds, out: *mut *mut foundation::IAsyncOperation<DevicePairingResult>) -> HRESULT,
    fn PairWithProtectionLevelAsync(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, out: *mut *mut foundation::IAsyncOperation<DevicePairingResult>) -> HRESULT,
    fn PairWithProtectionLevelAndSettingsAsync(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: *mut IDevicePairingSettings, out: *mut *mut foundation::IAsyncOperation<DevicePairingResult>) -> HRESULT,
    fn add_PairingRequested(&self, handler: *mut foundation::TypedEventHandler<DeviceInformationCustomPairing, DevicePairingRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PairingRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IDeviceInformationCustomPairing> {
    #[inline] pub fn pair_async(&self, pairingKindsSupported: DevicePairingKinds) -> Result<ComPtr<foundation::IAsyncOperation<DevicePairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PairAsync)(self.deref() as *const _ as *mut _, pairingKindsSupported, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_async(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> Result<ComPtr<foundation::IAsyncOperation<DevicePairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PairWithProtectionLevelAsync)(self.deref() as *const _ as *mut _, pairingKindsSupported, minProtectionLevel, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_and_settings_async(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: &ComPtr<IDevicePairingSettings>) -> Result<ComPtr<foundation::IAsyncOperation<DevicePairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PairWithProtectionLevelAndSettingsAsync)(self.deref() as *const _ as *mut _, pairingKindsSupported, minProtectionLevel, devicePairingSettings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_pairing_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceInformationCustomPairing, DevicePairingRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PairingRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pairing_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PairingRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationCustomPairing: IDeviceInformationCustomPairing}
RT_ENUM! { enum DeviceInformationKind: i32 {
    Unknown = 0, DeviceInterface = 1, DeviceContainer = 2, Device = 3, DeviceInterfaceClass = 4, AssociationEndpoint = 5, AssociationEndpointContainer = 6, AssociationEndpointService = 7, DevicePanel = 8,
}}
DEFINE_IID!(IID_IDeviceInformationPairing, 742877685, 63108, 16597, 132, 105, 232, 219, 170, 183, 4, 133);
RT_INTERFACE!{interface IDeviceInformationPairing(IDeviceInformationPairingVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairing] {
    fn get_IsPaired(&self, out: *mut bool) -> HRESULT,
    fn get_CanPair(&self, out: *mut bool) -> HRESULT,
    fn PairAsync(&self, out: *mut *mut foundation::IAsyncOperation<DevicePairingResult>) -> HRESULT,
    fn PairWithProtectionLevelAsync(&self, minProtectionLevel: DevicePairingProtectionLevel, out: *mut *mut foundation::IAsyncOperation<DevicePairingResult>) -> HRESULT
}}
impl ComPtr<IDeviceInformationPairing> {
    #[inline] pub fn get_is_paired(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaired)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_pair(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanPair)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn pair_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<DevicePairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PairAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_async(&self, minProtectionLevel: DevicePairingProtectionLevel) -> Result<ComPtr<foundation::IAsyncOperation<DevicePairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PairWithProtectionLevelAsync)(self.deref() as *const _ as *mut _, minProtectionLevel, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationPairing: IDeviceInformationPairing}
impl RtActivatable<IDeviceInformationPairingStatics> for DeviceInformationPairing {}
impl RtActivatable<IDeviceInformationPairingStatics2> for DeviceInformationPairing {}
impl DeviceInformationPairing {
    #[inline] pub fn try_register_for_all_inbound_pairing_requests(pairingKindsSupported: DevicePairingKinds) -> Result<bool> {
        <Self as RtActivatable<IDeviceInformationPairingStatics>>::get_activation_factory().try_register_for_all_inbound_pairing_requests(pairingKindsSupported)
    }
    #[inline] pub fn try_register_for_all_inbound_pairing_requests_with_protection_level(pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> Result<bool> {
        <Self as RtActivatable<IDeviceInformationPairingStatics2>>::get_activation_factory().try_register_for_all_inbound_pairing_requests_with_protection_level(pairingKindsSupported, minProtectionLevel)
    }
}
DEFINE_CLSID!(DeviceInformationPairing(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,73,110,102,111,114,109,97,116,105,111,110,80,97,105,114,105,110,103,0]) [CLSID_DeviceInformationPairing]);
DEFINE_IID!(IID_IDeviceInformationPairing2, 4135981821, 2798, 17192, 133, 204, 28, 116, 43, 177, 121, 13);
RT_INTERFACE!{interface IDeviceInformationPairing2(IDeviceInformationPairing2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairing2] {
    fn get_ProtectionLevel(&self, out: *mut DevicePairingProtectionLevel) -> HRESULT,
    fn get_Custom(&self, out: *mut *mut DeviceInformationCustomPairing) -> HRESULT,
    fn PairWithProtectionLevelAndSettingsAsync(&self, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: *mut IDevicePairingSettings, out: *mut *mut foundation::IAsyncOperation<DevicePairingResult>) -> HRESULT,
    fn UnpairAsync(&self, out: *mut *mut foundation::IAsyncOperation<DeviceUnpairingResult>) -> HRESULT
}}
impl ComPtr<IDeviceInformationPairing2> {
    #[inline] pub fn get_protection_level(&self) -> Result<DevicePairingProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_custom(&self) -> Result<Option<ComPtr<DeviceInformationCustomPairing>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Custom)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn pair_with_protection_level_and_settings_async(&self, minProtectionLevel: DevicePairingProtectionLevel, devicePairingSettings: &ComPtr<IDevicePairingSettings>) -> Result<ComPtr<foundation::IAsyncOperation<DevicePairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PairWithProtectionLevelAndSettingsAsync)(self.deref() as *const _ as *mut _, minProtectionLevel, devicePairingSettings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn unpair_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<DeviceUnpairingResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UnpairAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationPairingStatics, 3910517768, 14036, 18849, 191, 19, 81, 65, 115, 121, 155, 107);
RT_INTERFACE!{static interface IDeviceInformationPairingStatics(IDeviceInformationPairingStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairingStatics] {
    fn TryRegisterForAllInboundPairingRequests(&self, pairingKindsSupported: DevicePairingKinds, out: *mut bool) -> HRESULT
}}
impl ComPtr<IDeviceInformationPairingStatics> {
    #[inline] pub fn try_register_for_all_inbound_pairing_requests(&self, pairingKindsSupported: DevicePairingKinds) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryRegisterForAllInboundPairingRequests)(self.deref() as *const _ as *mut _, pairingKindsSupported, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationPairingStatics2, 81679218, 47031, 18283, 167, 79, 197, 131, 106, 112, 77, 152);
RT_INTERFACE!{static interface IDeviceInformationPairingStatics2(IDeviceInformationPairingStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationPairingStatics2] {
    fn TryRegisterForAllInboundPairingRequestsWithProtectionLevel(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel, out: *mut bool) -> HRESULT
}}
impl ComPtr<IDeviceInformationPairingStatics2> {
    #[inline] pub fn try_register_for_all_inbound_pairing_requests_with_protection_level(&self, pairingKindsSupported: DevicePairingKinds, minProtectionLevel: DevicePairingProtectionLevel) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryRegisterForAllInboundPairingRequestsWithProtectionLevel)(self.deref() as *const _ as *mut _, pairingKindsSupported, minProtectionLevel, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationStatics, 3246329870, 14918, 19064, 128, 19, 118, 157, 201, 185, 115, 144);
RT_INTERFACE!{static interface IDeviceInformationStatics(IDeviceInformationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationStatics] {
    fn CreateFromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<DeviceInformation>) -> HRESULT,
    fn CreateFromIdAsyncAdditionalProperties(&self, deviceId: HSTRING, additionalProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<DeviceInformation>) -> HRESULT,
    fn FindAllAsync(&self, out: *mut *mut foundation::IAsyncOperation<DeviceInformationCollection>) -> HRESULT,
    fn FindAllAsyncDeviceClass(&self, deviceClass: DeviceClass, out: *mut *mut foundation::IAsyncOperation<DeviceInformationCollection>) -> HRESULT,
    fn FindAllAsyncAqsFilter(&self, aqsFilter: HSTRING, out: *mut *mut foundation::IAsyncOperation<DeviceInformationCollection>) -> HRESULT,
    fn FindAllAsyncAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<DeviceInformationCollection>) -> HRESULT,
    fn CreateWatcher(&self, out: *mut *mut DeviceWatcher) -> HRESULT,
    fn CreateWatcherDeviceClass(&self, deviceClass: DeviceClass, out: *mut *mut DeviceWatcher) -> HRESULT,
    fn CreateWatcherAqsFilter(&self, aqsFilter: HSTRING, out: *mut *mut DeviceWatcher) -> HRESULT,
    fn CreateWatcherAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut DeviceWatcher) -> HRESULT
}}
impl ComPtr<IDeviceInformationStatics> {
    #[inline] pub fn create_from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_id_async_additional_properties(&self, deviceId: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromIdAsyncAdditionalProperties)(self.deref() as *const _ as *mut _, deviceId.get(), additionalProperties.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_device_class(&self, deviceClass: DeviceClass) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsyncDeviceClass)(self.deref() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_aqs_filter(&self, aqsFilter: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsyncAqsFilter)(self.deref() as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsyncAqsFilterAndAdditionalProperties)(self.deref() as *const _ as *mut _, aqsFilter.get(), additionalProperties.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher(&self) -> Result<Option<ComPtr<DeviceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcher)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_device_class(&self, deviceClass: DeviceClass) -> Result<Option<ComPtr<DeviceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcherDeviceClass)(self.deref() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_aqs_filter(&self, aqsFilter: &HStringArg) -> Result<Option<ComPtr<DeviceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcherAqsFilter)(self.deref() as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<Option<ComPtr<DeviceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcherAqsFilterAndAdditionalProperties)(self.deref() as *const _ as *mut _, aqsFilter.get(), additionalProperties.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationStatics2, 1228623668, 43087, 17917, 145, 103, 21, 209, 203, 27, 209, 249);
RT_INTERFACE!{static interface IDeviceInformationStatics2(IDeviceInformationStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationStatics2] {
    fn GetAqsFilterFromDeviceClass(&self, deviceClass: DeviceClass, out: *mut HSTRING) -> HRESULT,
    fn CreateFromIdAsyncWithKindAndAdditionalProperties(&self, deviceId: HSTRING, additionalProperties: *mut foundation::collections::IIterable<HString>, kind: DeviceInformationKind, out: *mut *mut foundation::IAsyncOperation<DeviceInformation>) -> HRESULT,
    fn FindAllAsyncWithKindAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: *mut foundation::collections::IIterable<HString>, kind: DeviceInformationKind, out: *mut *mut foundation::IAsyncOperation<DeviceInformationCollection>) -> HRESULT,
    fn CreateWatcherWithKindAqsFilterAndAdditionalProperties(&self, aqsFilter: HSTRING, additionalProperties: *mut foundation::collections::IIterable<HString>, kind: DeviceInformationKind, out: *mut *mut DeviceWatcher) -> HRESULT
}}
impl ComPtr<IDeviceInformationStatics2> {
    #[inline] pub fn get_aqs_filter_from_device_class(&self, deviceClass: DeviceClass) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAqsFilterFromDeviceClass)(self.deref() as *const _ as *mut _, deviceClass, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_id_async_with_kind_and_additional_properties(&self, deviceId: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>, kind: DeviceInformationKind) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromIdAsyncWithKindAndAdditionalProperties)(self.deref() as *const _ as *mut _, deviceId.get(), additionalProperties.deref() as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_with_kind_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>, kind: DeviceInformationKind) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformationCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsyncWithKindAqsFilterAndAdditionalProperties)(self.deref() as *const _ as *mut _, aqsFilter.get(), additionalProperties.deref() as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_with_kind_aqs_filter_and_additional_properties(&self, aqsFilter: &HStringArg, additionalProperties: &ComPtr<foundation::collections::IIterable<HString>>, kind: DeviceInformationKind) -> Result<Option<ComPtr<DeviceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcherWithKindAqsFilterAndAdditionalProperties)(self.deref() as *const _ as *mut _, aqsFilter.get(), additionalProperties.deref() as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceInformationUpdate, 2402374405, 55666, 17591, 163, 126, 158, 130, 44, 120, 33, 59);
RT_INTERFACE!{interface IDeviceInformationUpdate(IDeviceInformationUpdateVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationUpdate] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IDeviceInformationUpdate> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceInformationUpdate: IDeviceInformationUpdate}
DEFINE_IID!(IID_IDeviceInformationUpdate2, 1570575500, 43123, 18526, 186, 166, 170, 98, 7, 136, 227, 204);
RT_INTERFACE!{interface IDeviceInformationUpdate2(IDeviceInformationUpdate2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceInformationUpdate2] {
    fn get_Kind(&self, out: *mut DeviceInformationKind) -> HRESULT
}}
impl ComPtr<IDeviceInformationUpdate2> {
    #[inline] pub fn get_kind(&self) -> Result<DeviceInformationKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Kind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum DevicePairingKinds: u32 {
    None = 0, ConfirmOnly = 1, DisplayPin = 2, ProvidePin = 4, ConfirmPinMatch = 8,
}}
RT_ENUM! { enum DevicePairingProtectionLevel: i32 {
    Default = 0, None = 1, Encryption = 2, EncryptionAndAuthentication = 3,
}}
DEFINE_IID!(IID_IDevicePairingRequestedEventArgs, 4145544278, 56939, 18559, 131, 118, 1, 128, 172, 166, 153, 99);
RT_INTERFACE!{interface IDevicePairingRequestedEventArgs(IDevicePairingRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingRequestedEventArgs] {
    fn get_DeviceInformation(&self, out: *mut *mut DeviceInformation) -> HRESULT,
    fn get_PairingKind(&self, out: *mut DevicePairingKinds) -> HRESULT,
    fn get_Pin(&self, out: *mut HSTRING) -> HRESULT,
    fn Accept(&self) -> HRESULT,
    fn AcceptWithPin(&self, pin: HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IDevicePairingRequestedEventArgs> {
    #[inline] pub fn get_device_information(&self) -> Result<Option<ComPtr<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pairing_kind(&self) -> Result<DevicePairingKinds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PairingKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pin(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Pin)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Accept)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept_with_pin(&self, pin: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).AcceptWithPin)(self.deref() as *const _ as *mut _, pin.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePairingRequestedEventArgs: IDevicePairingRequestedEventArgs}
DEFINE_IID!(IID_IDevicePairingResult, 120259263, 56725, 16421, 155, 55, 222, 81, 173, 186, 55, 183);
RT_INTERFACE!{interface IDevicePairingResult(IDevicePairingResultVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingResult] {
    fn get_Status(&self, out: *mut DevicePairingResultStatus) -> HRESULT,
    fn get_ProtectionLevelUsed(&self, out: *mut DevicePairingProtectionLevel) -> HRESULT
}}
impl ComPtr<IDevicePairingResult> {
    #[inline] pub fn get_status(&self) -> Result<DevicePairingResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_level_used(&self) -> Result<DevicePairingProtectionLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionLevelUsed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePairingResult: IDevicePairingResult}
RT_ENUM! { enum DevicePairingResultStatus: i32 {
    Paired = 0, NotReadyToPair = 1, NotPaired = 2, AlreadyPaired = 3, ConnectionRejected = 4, TooManyConnections = 5, HardwareFailure = 6, AuthenticationTimeout = 7, AuthenticationNotAllowed = 8, AuthenticationFailure = 9, NoSupportedProfiles = 10, ProtectionLevelCouldNotBeMet = 11, AccessDenied = 12, InvalidCeremonyData = 13, PairingCanceled = 14, OperationAlreadyInProgress = 15, RequiredHandlerNotRegistered = 16, RejectedByHandler = 17, RemoteDeviceHasAssociation = 18, Failed = 19,
}}
DEFINE_IID!(IID_IDevicePairingSettings, 1210888828, 33723, 16910, 190, 81, 102, 2, 178, 34, 222, 84);
RT_INTERFACE!{interface IDevicePairingSettings(IDevicePairingSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingSettings] {
    
}}
DEFINE_IID!(IID_IDevicePicker, 2224650914, 842, 17472, 136, 19, 125, 11, 212, 121, 191, 90);
RT_INTERFACE!{interface IDevicePicker(IDevicePickerVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePicker] {
    fn get_Filter(&self, out: *mut *mut DevicePickerFilter) -> HRESULT,
    fn get_Appearance(&self, out: *mut *mut DevicePickerAppearance) -> HRESULT,
    fn get_RequestedProperties(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn add_DeviceSelected(&self, handler: *mut foundation::TypedEventHandler<DevicePicker, DeviceSelectedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeviceSelected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DisconnectButtonClicked(&self, handler: *mut foundation::TypedEventHandler<DevicePicker, DeviceDisconnectButtonClickedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DisconnectButtonClicked(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DevicePickerDismissed(&self, handler: *mut foundation::TypedEventHandler<DevicePicker, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DevicePickerDismissed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Show(&self, selection: foundation::Rect) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowWithPlacement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement) -> HRESULT,
    fn PickSingleDeviceAsync(&self, selection: foundation::Rect, out: *mut *mut foundation::IAsyncOperation<DeviceInformation>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-ui")] fn PickSingleDeviceAsyncWithPlacement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement, out: *mut *mut foundation::IAsyncOperation<DeviceInformation>) -> HRESULT,
    fn Hide(&self) -> HRESULT,
    fn SetDisplayStatus(&self, device: *mut DeviceInformation, status: HSTRING, options: DevicePickerDisplayStatusOptions) -> HRESULT
}}
impl ComPtr<IDevicePicker> {
    #[inline] pub fn get_filter(&self) -> Result<Option<ComPtr<DevicePickerFilter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Filter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_appearance(&self) -> Result<Option<ComPtr<DevicePickerAppearance>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Appearance)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_requested_properties(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RequestedProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_device_selected(&self, handler: &ComPtr<foundation::TypedEventHandler<DevicePicker, DeviceSelectedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DeviceSelected)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_device_selected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DeviceSelected)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disconnect_button_clicked(&self, handler: &ComPtr<foundation::TypedEventHandler<DevicePicker, DeviceDisconnectButtonClickedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DisconnectButtonClicked)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disconnect_button_clicked(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DisconnectButtonClicked)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_device_picker_dismissed(&self, handler: &ComPtr<foundation::TypedEventHandler<DevicePicker, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DevicePickerDismissed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_device_picker_dismissed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DevicePickerDismissed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn show(&self, selection: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Show)(self.deref() as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_with_placement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ShowWithPlacement)(self.deref() as *const _ as *mut _, selection, placement);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pick_single_device_async(&self, selection: foundation::Rect) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PickSingleDeviceAsync)(self.deref() as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn pick_single_device_async_with_placement(&self, selection: foundation::Rect, placement: super::super::ui::popups::Placement) -> Result<ComPtr<foundation::IAsyncOperation<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).PickSingleDeviceAsyncWithPlacement)(self.deref() as *const _ as *mut _, selection, placement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn hide(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Hide)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_display_status(&self, device: &ComPtr<DeviceInformation>, status: &HStringArg, options: DevicePickerDisplayStatusOptions) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetDisplayStatus)(self.deref() as *const _ as *mut _, device.deref() as *const _ as *mut _, status.get(), options);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePicker: IDevicePicker}
impl RtActivatable<IActivationFactory> for DevicePicker {}
DEFINE_CLSID!(DevicePicker(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,68,101,118,105,99,101,80,105,99,107,101,114,0]) [CLSID_DevicePicker]);
DEFINE_IID!(IID_IDevicePickerAppearance, 3868857030, 58919, 20184, 155, 108, 70, 10, 244, 69, 229, 109);
RT_INTERFACE!{interface IDevicePickerAppearance(IDevicePickerAppearanceVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePickerAppearance] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_ForegroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_ForegroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_BackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_BackgroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_AccentColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_AccentColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_SelectedForegroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_SelectedForegroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_SelectedBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_SelectedBackgroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_SelectedAccentColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_SelectedAccentColor(&self, value: super::super::ui::Color) -> HRESULT
}}
impl ComPtr<IDevicePickerAppearance> {
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Title)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_title(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Title)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_foreground_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ForegroundColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_foreground_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ForegroundColor)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BackgroundColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_background_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BackgroundColor)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_accent_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AccentColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_accent_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AccentColor)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_selected_foreground_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SelectedForegroundColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_selected_foreground_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SelectedForegroundColor)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_selected_background_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SelectedBackgroundColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_selected_background_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SelectedBackgroundColor)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_selected_accent_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SelectedAccentColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_selected_accent_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SelectedAccentColor)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePickerAppearance: IDevicePickerAppearance}
RT_ENUM! { enum DevicePickerDisplayStatusOptions: u32 {
    None = 0, ShowProgress = 1, ShowDisconnectButton = 2, ShowRetryButton = 4,
}}
DEFINE_IID!(IID_IDevicePickerFilter, 2447086242, 22475, 18673, 155, 89, 165, 155, 122, 31, 2, 162);
RT_INTERFACE!{interface IDevicePickerFilter(IDevicePickerFilterVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePickerFilter] {
    fn get_SupportedDeviceClasses(&self, out: *mut *mut foundation::collections::IVector<DeviceClass>) -> HRESULT,
    fn get_SupportedDeviceSelectors(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT
}}
impl ComPtr<IDevicePickerFilter> {
    #[inline] pub fn get_supported_device_classes(&self) -> Result<Option<ComPtr<foundation::collections::IVector<DeviceClass>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedDeviceClasses)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_device_selectors(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedDeviceSelectors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DevicePickerFilter: IDevicePickerFilter}
DEFINE_IID!(IID_IDeviceSelectedEventArgs, 647944926, 7471, 18752, 132, 2, 65, 86, 184, 29, 60, 119);
RT_INTERFACE!{interface IDeviceSelectedEventArgs(IDeviceSelectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceSelectedEventArgs] {
    fn get_SelectedDevice(&self, out: *mut *mut DeviceInformation) -> HRESULT
}}
impl ComPtr<IDeviceSelectedEventArgs> {
    #[inline] pub fn get_selected_device(&self) -> Result<Option<ComPtr<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SelectedDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceSelectedEventArgs: IDeviceSelectedEventArgs}
#[cfg(feature="windows-storage")] RT_CLASS!{class DeviceThumbnail: super::super::storage::streams::IRandomAccessStreamWithContentType}
#[cfg(not(feature="windows-storage"))] RT_CLASS!{class DeviceThumbnail: IInspectable}
DEFINE_IID!(IID_IDeviceUnpairingResult, 1727285971, 31193, 17483, 146, 207, 169, 46, 247, 37, 113, 199);
RT_INTERFACE!{interface IDeviceUnpairingResult(IDeviceUnpairingResultVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceUnpairingResult] {
    fn get_Status(&self, out: *mut DeviceUnpairingResultStatus) -> HRESULT
}}
impl ComPtr<IDeviceUnpairingResult> {
    #[inline] pub fn get_status(&self) -> Result<DeviceUnpairingResultStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceUnpairingResult: IDeviceUnpairingResult}
RT_ENUM! { enum DeviceUnpairingResultStatus: i32 {
    Unpaired = 0, AlreadyUnpaired = 1, OperationAlreadyInProgress = 2, AccessDenied = 3, Failed = 4,
}}
DEFINE_IID!(IID_IDeviceWatcher, 3387603325, 36715, 20374, 169, 244, 171, 200, 20, 226, 34, 113);
RT_INTERFACE!{interface IDeviceWatcher(IDeviceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcher] {
    fn add_Added(&self, handler: *mut foundation::TypedEventHandler<DeviceWatcher, DeviceInformation>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Added(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: *mut foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Removed(&self, handler: *mut foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Removed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: *mut foundation::TypedEventHandler<DeviceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<DeviceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IDeviceWatcher> {
    #[inline] pub fn add_added(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceWatcher, DeviceInformation>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Added)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Added)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Updated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Updated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceWatcher, DeviceInformationUpdate>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Removed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Removed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnumerationCompleted)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnumerationCompleted)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<DeviceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceWatcher: IDeviceWatcher}
DEFINE_IID!(IID_IDeviceWatcher2, 4278732142, 60692, 18921, 154, 105, 129, 23, 197, 74, 233, 113);
RT_INTERFACE!{interface IDeviceWatcher2(IDeviceWatcher2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcher2] {
    #[cfg(feature="windows-applicationmodel")] fn GetBackgroundTrigger(&self, requestedEventKinds: *mut foundation::collections::IIterable<DeviceWatcherEventKind>, out: *mut *mut super::super::applicationmodel::background::DeviceWatcherTrigger) -> HRESULT
}}
impl ComPtr<IDeviceWatcher2> {
    #[cfg(feature="windows-applicationmodel")] #[inline] pub fn get_background_trigger(&self, requestedEventKinds: &ComPtr<foundation::collections::IIterable<DeviceWatcherEventKind>>) -> Result<Option<ComPtr<super::super::applicationmodel::background::DeviceWatcherTrigger>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBackgroundTrigger)(self.deref() as *const _ as *mut _, requestedEventKinds.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IDeviceWatcherEvent, 1957338123, 7613, 18429, 182, 53, 60, 197, 86, 208, 255, 139);
RT_INTERFACE!{interface IDeviceWatcherEvent(IDeviceWatcherEventVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherEvent] {
    fn get_Kind(&self, out: *mut DeviceWatcherEventKind) -> HRESULT,
    fn get_DeviceInformation(&self, out: *mut *mut DeviceInformation) -> HRESULT,
    fn get_DeviceInformationUpdate(&self, out: *mut *mut DeviceInformationUpdate) -> HRESULT
}}
impl ComPtr<IDeviceWatcherEvent> {
    #[inline] pub fn get_kind(&self) -> Result<DeviceWatcherEventKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Kind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_information(&self) -> Result<Option<ComPtr<DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_information_update(&self) -> Result<Option<ComPtr<DeviceInformationUpdate>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformationUpdate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceWatcherEvent: IDeviceWatcherEvent}
RT_ENUM! { enum DeviceWatcherEventKind: i32 {
    Add = 0, Update = 1, Remove = 2,
}}
RT_ENUM! { enum DeviceWatcherStatus: i32 {
    Created = 0, Started = 1, EnumerationCompleted = 2, Stopping = 3, Stopped = 4, Aborted = 5,
}}
DEFINE_IID!(IID_IDeviceWatcherTriggerDetails, 947945753, 19639, 20055, 165, 109, 119, 109, 7, 203, 254, 249);
RT_INTERFACE!{interface IDeviceWatcherTriggerDetails(IDeviceWatcherTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherTriggerDetails] {
    fn get_DeviceWatcherEvents(&self, out: *mut *mut foundation::collections::IVectorView<DeviceWatcherEvent>) -> HRESULT
}}
impl ComPtr<IDeviceWatcherTriggerDetails> {
    #[inline] pub fn get_device_watcher_events(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<DeviceWatcherEvent>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceWatcherEvents)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class DeviceWatcherTriggerDetails: IDeviceWatcherTriggerDetails}
DEFINE_IID!(IID_IEnclosureLocation, 1110706727, 22544, 17820, 170, 187, 198, 94, 31, 129, 62, 207);
RT_INTERFACE!{interface IEnclosureLocation(IEnclosureLocationVtbl): IInspectable(IInspectableVtbl) [IID_IEnclosureLocation] {
    fn get_InDock(&self, out: *mut bool) -> HRESULT,
    fn get_InLid(&self, out: *mut bool) -> HRESULT,
    fn get_Panel(&self, out: *mut Panel) -> HRESULT
}}
impl ComPtr<IEnclosureLocation> {
    #[inline] pub fn get_in_dock(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InDock)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_in_lid(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InLid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_panel(&self) -> Result<Panel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Panel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class EnclosureLocation: IEnclosureLocation}
DEFINE_IID!(IID_IEnclosureLocation2, 679844187, 57469, 18525, 138, 158, 189, 242, 154, 239, 79, 102);
RT_INTERFACE!{interface IEnclosureLocation2(IEnclosureLocation2Vtbl): IInspectable(IInspectableVtbl) [IID_IEnclosureLocation2] {
    fn get_RotationAngleInDegreesClockwise(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IEnclosureLocation2> {
    #[inline] pub fn get_rotation_angle_in_degrees_clockwise(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RotationAngleInDegreesClockwise)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum Panel: i32 {
    Unknown = 0, Front = 1, Back = 2, Top = 3, Bottom = 4, Left = 5, Right = 6,
}}
pub mod pnp { // Windows.Devices.Enumeration.Pnp
use crate::prelude::*;
DEFINE_IID!(IID_IPnpObject, 2512806488, 29499, 19087, 147, 163, 219, 7, 138, 200, 112, 193);
RT_INTERFACE!{interface IPnpObject(IPnpObjectVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObject] {
    fn get_Type(&self, out: *mut PnpObjectType) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn Update(&self, updateInfo: *mut PnpObjectUpdate) -> HRESULT
}}
impl ComPtr<IPnpObject> {
    #[inline] pub fn get_type(&self) -> Result<PnpObjectType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Type)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn update(&self, updateInfo: &ComPtr<PnpObjectUpdate>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Update)(self.deref() as *const _ as *mut _, updateInfo.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PnpObject: IPnpObject}
impl RtActivatable<IPnpObjectStatics> for PnpObject {}
impl PnpObject {
    #[inline] pub fn create_from_id_async(type_: PnpObjectType, id: &HStringArg, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<PnpObject>>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().create_from_id_async(type_, id, requestedProperties)
    }
    #[inline] pub fn find_all_async(type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<PnpObjectCollection>>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().find_all_async(type_, requestedProperties)
    }
    #[inline] pub fn find_all_async_aqs_filter(type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>, aqsFilter: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PnpObjectCollection>>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().find_all_async_aqs_filter(type_, requestedProperties, aqsFilter)
    }
    #[inline] pub fn create_watcher(type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<Option<ComPtr<PnpObjectWatcher>>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().create_watcher(type_, requestedProperties)
    }
    #[inline] pub fn create_watcher_aqs_filter(type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>, aqsFilter: &HStringArg) -> Result<Option<ComPtr<PnpObjectWatcher>>> {
        <Self as RtActivatable<IPnpObjectStatics>>::get_activation_factory().create_watcher_aqs_filter(type_, requestedProperties, aqsFilter)
    }
}
DEFINE_CLSID!(PnpObject(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,69,110,117,109,101,114,97,116,105,111,110,46,80,110,112,46,80,110,112,79,98,106,101,99,116,0]) [CLSID_PnpObject]);
RT_CLASS!{class PnpObjectCollection: foundation::collections::IVectorView<PnpObject>}
DEFINE_IID!(IID_IPnpObjectStatics, 3015911997, 53608, 18016, 187, 243, 167, 51, 177, 75, 110, 1);
RT_INTERFACE!{static interface IPnpObjectStatics(IPnpObjectStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObjectStatics] {
    fn CreateFromIdAsync(&self, type_: PnpObjectType, id: HSTRING, requestedProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<PnpObject>) -> HRESULT,
    fn FindAllAsync(&self, type_: PnpObjectType, requestedProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<PnpObjectCollection>) -> HRESULT,
    fn FindAllAsyncAqsFilter(&self, type_: PnpObjectType, requestedProperties: *mut foundation::collections::IIterable<HString>, aqsFilter: HSTRING, out: *mut *mut foundation::IAsyncOperation<PnpObjectCollection>) -> HRESULT,
    fn CreateWatcher(&self, type_: PnpObjectType, requestedProperties: *mut foundation::collections::IIterable<HString>, out: *mut *mut PnpObjectWatcher) -> HRESULT,
    fn CreateWatcherAqsFilter(&self, type_: PnpObjectType, requestedProperties: *mut foundation::collections::IIterable<HString>, aqsFilter: HSTRING, out: *mut *mut PnpObjectWatcher) -> HRESULT
}}
impl ComPtr<IPnpObjectStatics> {
    #[inline] pub fn create_from_id_async(&self, type_: PnpObjectType, id: &HStringArg, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<PnpObject>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromIdAsync)(self.deref() as *const _ as *mut _, type_, id.get(), requestedProperties.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self, type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<PnpObjectCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsync)(self.deref() as *const _ as *mut _, type_, requestedProperties.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async_aqs_filter(&self, type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>, aqsFilter: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PnpObjectCollection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsyncAqsFilter)(self.deref() as *const _ as *mut _, type_, requestedProperties.deref() as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher(&self, type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<Option<ComPtr<PnpObjectWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcher)(self.deref() as *const _ as *mut _, type_, requestedProperties.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher_aqs_filter(&self, type_: PnpObjectType, requestedProperties: &ComPtr<foundation::collections::IIterable<HString>>, aqsFilter: &HStringArg) -> Result<Option<ComPtr<PnpObjectWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcherAqsFilter)(self.deref() as *const _ as *mut _, type_, requestedProperties.deref() as *const _ as *mut _, aqsFilter.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PnpObjectType: i32 {
    Unknown = 0, DeviceInterface = 1, DeviceContainer = 2, Device = 3, DeviceInterfaceClass = 4, AssociationEndpoint = 5, AssociationEndpointContainer = 6, AssociationEndpointService = 7, DevicePanel = 8,
}}
DEFINE_IID!(IID_IPnpObjectUpdate, 1868163090, 30, 18500, 188, 198, 67, 40, 134, 133, 106, 23);
RT_INTERFACE!{interface IPnpObjectUpdate(IPnpObjectUpdateVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObjectUpdate] {
    fn get_Type(&self, out: *mut PnpObjectType) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IPnpObjectUpdate> {
    #[inline] pub fn get_type(&self) -> Result<PnpObjectType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Type)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PnpObjectUpdate: IPnpObjectUpdate}
DEFINE_IID!(IID_IPnpObjectWatcher, 2211011752, 18290, 19066, 172, 168, 228, 140, 66, 168, 156, 68);
RT_INTERFACE!{interface IPnpObjectWatcher(IPnpObjectWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPnpObjectWatcher] {
    fn add_Added(&self, handler: *mut foundation::TypedEventHandler<PnpObjectWatcher, PnpObject>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Added(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: *mut foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Removed(&self, handler: *mut foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Removed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: *mut foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IPnpObjectWatcher> {
    #[inline] pub fn add_added(&self, handler: &ComPtr<foundation::TypedEventHandler<PnpObjectWatcher, PnpObject>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Added)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Added)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Updated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Updated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<PnpObjectWatcher, PnpObjectUpdate>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Removed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Removed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &ComPtr<foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnumerationCompleted)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnumerationCompleted)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<PnpObjectWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PnpObjectWatcher: IPnpObjectWatcher}
} // Windows.Devices.Enumeration.Pnp
} // Windows.Devices.Enumeration
pub mod geolocation { // Windows.Devices.Geolocation
use crate::prelude::*;
RT_ENUM! { enum AltitudeReferenceSystem: i32 {
    Unspecified = 0, Terrain = 1, Ellipsoid = 2, Geoid = 3, Surface = 4,
}}
RT_STRUCT! { struct BasicGeoposition {
    Latitude: f64, Longitude: f64, Altitude: f64,
}}
DEFINE_IID!(IID_ICivicAddress, 2824239642, 25844, 19784, 188, 234, 246, 176, 8, 236, 163, 76);
RT_INTERFACE!{interface ICivicAddress(ICivicAddressVtbl): IInspectable(IInspectableVtbl) [IID_ICivicAddress] {
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<ICivicAddress> {
    #[inline] pub fn get_country(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Country)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_city(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_City)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PostalCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CivicAddress: ICivicAddress}
DEFINE_IID!(IID_IGeoboundingBox, 144099339, 10063, 17370, 154, 6, 203, 252, 218, 235, 78, 194);
RT_INTERFACE!{interface IGeoboundingBox(IGeoboundingBoxVtbl): IInspectable(IInspectableVtbl) [IID_IGeoboundingBox] {
    fn get_NorthwestCorner(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_SoutheastCorner(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_Center(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_MinAltitude(&self, out: *mut f64) -> HRESULT,
    fn get_MaxAltitude(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IGeoboundingBox> {
    #[inline] pub fn get_northwest_corner(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NorthwestCorner)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_southeast_corner(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SoutheastCorner)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_center(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Center)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_altitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinAltitude)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_altitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxAltitude)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GeoboundingBox: IGeoboundingBox}
impl RtActivatable<IGeoboundingBoxFactory> for GeoboundingBox {}
impl RtActivatable<IGeoboundingBoxStatics> for GeoboundingBox {}
impl GeoboundingBox {
    #[inline] pub fn create(northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition) -> Result<ComPtr<GeoboundingBox>> {
        <Self as RtActivatable<IGeoboundingBoxFactory>>::get_activation_factory().create(northwestCorner, southeastCorner)
    }
    #[inline] pub fn create_with_altitude_reference(northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<GeoboundingBox>> {
        <Self as RtActivatable<IGeoboundingBoxFactory>>::get_activation_factory().create_with_altitude_reference(northwestCorner, southeastCorner, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<GeoboundingBox>> {
        <Self as RtActivatable<IGeoboundingBoxFactory>>::get_activation_factory().create_with_altitude_reference_and_spatial_reference(northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId)
    }
    #[inline] pub fn try_compute(positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>) -> Result<Option<ComPtr<GeoboundingBox>>> {
        <Self as RtActivatable<IGeoboundingBoxStatics>>::get_activation_factory().try_compute(positions)
    }
    #[inline] pub fn try_compute_with_altitude_reference(positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeRefSystem: AltitudeReferenceSystem) -> Result<Option<ComPtr<GeoboundingBox>>> {
        <Self as RtActivatable<IGeoboundingBoxStatics>>::get_activation_factory().try_compute_with_altitude_reference(positions, altitudeRefSystem)
    }
    #[inline] pub fn try_compute_with_altitude_reference_and_spatial_reference(positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Option<ComPtr<GeoboundingBox>>> {
        <Self as RtActivatable<IGeoboundingBoxStatics>>::get_activation_factory().try_compute_with_altitude_reference_and_spatial_reference(positions, altitudeRefSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(GeoboundingBox(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,98,111,117,110,100,105,110,103,66,111,120,0]) [CLSID_GeoboundingBox]);
DEFINE_IID!(IID_IGeoboundingBoxFactory, 1308337545, 1041, 19132, 179, 181, 91, 188, 203, 87, 217, 140);
RT_INTERFACE!{static interface IGeoboundingBoxFactory(IGeoboundingBoxFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeoboundingBoxFactory] {
    fn Create(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, out: *mut *mut GeoboundingBox) -> HRESULT,
    fn CreateWithAltitudeReference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut GeoboundingBox) -> HRESULT,
    fn CreateWithAltitudeReferenceAndSpatialReference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut GeoboundingBox) -> HRESULT
}}
impl ComPtr<IGeoboundingBoxFactory> {
    #[inline] pub fn create(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition) -> Result<ComPtr<GeoboundingBox>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, northwestCorner, southeastCorner, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<GeoboundingBox>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReference)(self.deref() as *const _ as *mut _, northwestCorner, southeastCorner, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(&self, northwestCorner: BasicGeoposition, southeastCorner: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<GeoboundingBox>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReferenceAndSpatialReference)(self.deref() as *const _ as *mut _, northwestCorner, southeastCorner, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeoboundingBoxStatics, 1740113672, 58906, 19664, 132, 27, 147, 35, 55, 146, 181, 202);
RT_INTERFACE!{static interface IGeoboundingBoxStatics(IGeoboundingBoxStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeoboundingBoxStatics] {
    fn TryCompute(&self, positions: *mut foundation::collections::IIterable<BasicGeoposition>, out: *mut *mut GeoboundingBox) -> HRESULT,
    fn TryComputeWithAltitudeReference(&self, positions: *mut foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, out: *mut *mut GeoboundingBox) -> HRESULT,
    fn TryComputeWithAltitudeReferenceAndSpatialReference(&self, positions: *mut foundation::collections::IIterable<BasicGeoposition>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut GeoboundingBox) -> HRESULT
}}
impl ComPtr<IGeoboundingBoxStatics> {
    #[inline] pub fn try_compute(&self, positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>) -> Result<Option<ComPtr<GeoboundingBox>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryCompute)(self.deref() as *const _ as *mut _, positions.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_compute_with_altitude_reference(&self, positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeRefSystem: AltitudeReferenceSystem) -> Result<Option<ComPtr<GeoboundingBox>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryComputeWithAltitudeReference)(self.deref() as *const _ as *mut _, positions.deref() as *const _ as *mut _, altitudeRefSystem, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_compute_with_altitude_reference_and_spatial_reference(&self, positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeRefSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<Option<ComPtr<GeoboundingBox>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryComputeWithAltitudeReferenceAndSpatialReference)(self.deref() as *const _ as *mut _, positions.deref() as *const _ as *mut _, altitudeRefSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocircle, 971266115, 43001, 20067, 146, 167, 186, 12, 40, 209, 36, 177);
RT_INTERFACE!{interface IGeocircle(IGeocircleVtbl): IInspectable(IInspectableVtbl) [IID_IGeocircle] {
    fn get_Center(&self, out: *mut BasicGeoposition) -> HRESULT,
    fn get_Radius(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IGeocircle> {
    #[inline] pub fn get_center(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Center)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_radius(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Radius)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geocircle: IGeocircle}
impl RtActivatable<IGeocircleFactory> for Geocircle {}
impl Geocircle {
    #[inline] pub fn create(position: BasicGeoposition, radius: f64) -> Result<ComPtr<Geocircle>> {
        <Self as RtActivatable<IGeocircleFactory>>::get_activation_factory().create(position, radius)
    }
    #[inline] pub fn create_with_altitude_reference_system(position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<Geocircle>> {
        <Self as RtActivatable<IGeocircleFactory>>::get_activation_factory().create_with_altitude_reference_system(position, radius, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<Geocircle>> {
        <Self as RtActivatable<IGeocircleFactory>>::get_activation_factory().create_with_altitude_reference_system_and_spatial_reference_id(position, radius, altitudeReferenceSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(Geocircle(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,99,105,114,99,108,101,0]) [CLSID_Geocircle]);
DEFINE_IID!(IID_IGeocircleFactory, 2950058783, 29361, 20349, 135, 204, 78, 212, 201, 132, 156, 5);
RT_INTERFACE!{static interface IGeocircleFactory(IGeocircleFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeocircleFactory] {
    fn Create(&self, position: BasicGeoposition, radius: f64, out: *mut *mut Geocircle) -> HRESULT,
    fn CreateWithAltitudeReferenceSystem(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut Geocircle) -> HRESULT,
    fn CreateWithAltitudeReferenceSystemAndSpatialReferenceId(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut Geocircle) -> HRESULT
}}
impl ComPtr<IGeocircleFactory> {
    #[inline] pub fn create(&self, position: BasicGeoposition, radius: f64) -> Result<ComPtr<Geocircle>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, position, radius, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<Geocircle>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReferenceSystem)(self.deref() as *const _ as *mut _, position, radius, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(&self, position: BasicGeoposition, radius: f64, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<Geocircle>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReferenceSystemAndSpatialReferenceId)(self.deref() as *const _ as *mut _, position, radius, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocoordinate, 3995181994, 38762, 19568, 128, 61, 8, 62, 165, 91, 203, 196);
RT_INTERFACE!{interface IGeocoordinate(IGeocoordinateVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinate] {
    fn get_Latitude(&self, out: *mut f64) -> HRESULT,
    fn get_Longitude(&self, out: *mut f64) -> HRESULT,
    fn get_Altitude(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT,
    fn get_Accuracy(&self, out: *mut f64) -> HRESULT,
    fn get_AltitudeAccuracy(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT,
    fn get_Heading(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT,
    fn get_Speed(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<IGeocoordinate> {
    #[inline] pub fn get_latitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Latitude)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_longitude(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Longitude)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Altitude)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_accuracy(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Accuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude_accuracy(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AltitudeAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_heading(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Heading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_speed(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Speed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geocoordinate: IGeocoordinate}
DEFINE_IID!(IID_IGeocoordinateSatelliteData, 3274339545, 9736, 18252, 145, 44, 6, 221, 73, 15, 74, 247);
RT_INTERFACE!{interface IGeocoordinateSatelliteData(IGeocoordinateSatelliteDataVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateSatelliteData] {
    fn get_PositionDilutionOfPrecision(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT,
    fn get_HorizontalDilutionOfPrecision(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT,
    fn get_VerticalDilutionOfPrecision(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT
}}
impl ComPtr<IGeocoordinateSatelliteData> {
    #[inline] pub fn get_position_dilution_of_precision(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PositionDilutionOfPrecision)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_dilution_of_precision(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HorizontalDilutionOfPrecision)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_dilution_of_precision(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VerticalDilutionOfPrecision)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GeocoordinateSatelliteData: IGeocoordinateSatelliteData}
DEFINE_IID!(IID_IGeocoordinateWithPoint, 4276749605, 53804, 19782, 181, 39, 11, 150, 6, 111, 199, 219);
RT_INTERFACE!{interface IGeocoordinateWithPoint(IGeocoordinateWithPointVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPoint] {
    fn get_Point(&self, out: *mut *mut Geopoint) -> HRESULT
}}
impl ComPtr<IGeocoordinateWithPoint> {
    #[inline] pub fn get_point(&self) -> Result<Option<ComPtr<Geopoint>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Point)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocoordinateWithPositionData, 2514891966, 56278, 16556, 184, 242, 166, 92, 3, 64, 217, 166);
RT_INTERFACE!{interface IGeocoordinateWithPositionData(IGeocoordinateWithPositionDataVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPositionData] {
    fn get_PositionSource(&self, out: *mut PositionSource) -> HRESULT,
    fn get_SatelliteData(&self, out: *mut *mut GeocoordinateSatelliteData) -> HRESULT
}}
impl ComPtr<IGeocoordinateWithPositionData> {
    #[inline] pub fn get_position_source(&self) -> Result<PositionSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PositionSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_satellite_data(&self) -> Result<Option<ComPtr<GeocoordinateSatelliteData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SatelliteData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeocoordinateWithPositionSourceTimestamp, 2235825154, 51697, 17936, 175, 224, 139, 195, 166, 168, 112, 54);
RT_INTERFACE!{interface IGeocoordinateWithPositionSourceTimestamp(IGeocoordinateWithPositionSourceTimestampVtbl): IInspectable(IInspectableVtbl) [IID_IGeocoordinateWithPositionSourceTimestamp] {
    fn get_PositionSourceTimestamp(&self, out: *mut *mut foundation::IReference<foundation::DateTime>) -> HRESULT
}}
impl ComPtr<IGeocoordinateWithPositionSourceTimestamp> {
    #[inline] pub fn get_position_source_timestamp(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::DateTime>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PositionSourceTimestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GeolocationAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, Denied = 2,
}}
DEFINE_IID!(IID_IGeolocator, 2848178018, 17700, 18825, 138, 169, 222, 1, 157, 46, 85, 31);
RT_INTERFACE!{interface IGeolocator(IGeolocatorVtbl): IInspectable(IInspectableVtbl) [IID_IGeolocator] {
    fn get_DesiredAccuracy(&self, out: *mut PositionAccuracy) -> HRESULT,
    fn put_DesiredAccuracy(&self, value: PositionAccuracy) -> HRESULT,
    fn get_MovementThreshold(&self, out: *mut f64) -> HRESULT,
    fn put_MovementThreshold(&self, value: f64) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_LocationStatus(&self, out: *mut PositionStatus) -> HRESULT,
    fn GetGeopositionAsync(&self, out: *mut *mut foundation::IAsyncOperation<Geoposition>) -> HRESULT,
    fn GetGeopositionAsyncWithAgeAndTimeout(&self, maximumAge: foundation::TimeSpan, timeout: foundation::TimeSpan, out: *mut *mut foundation::IAsyncOperation<Geoposition>) -> HRESULT,
    fn add_PositionChanged(&self, handler: *mut foundation::TypedEventHandler<Geolocator, PositionChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PositionChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StatusChanged(&self, handler: *mut foundation::TypedEventHandler<Geolocator, StatusChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGeolocator> {
    #[inline] pub fn get_desired_accuracy(&self) -> Result<PositionAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DesiredAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_accuracy(&self, value: PositionAccuracy) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DesiredAccuracy)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_movement_threshold(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MovementThreshold)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_movement_threshold(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_MovementThreshold)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_location_status(&self) -> Result<PositionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LocationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGeopositionAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_async_with_age_and_timeout(&self, maximumAge: foundation::TimeSpan, timeout: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGeopositionAsyncWithAgeAndTimeout)(self.deref() as *const _ as *mut _, maximumAge, timeout, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_position_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Geolocator, PositionChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PositionChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_position_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PositionChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Geolocator, StatusChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Geolocator: IGeolocator}
impl RtActivatable<IGeolocatorStatics> for Geolocator {}
impl RtActivatable<IGeolocatorStatics2> for Geolocator {}
impl RtActivatable<IActivationFactory> for Geolocator {}
impl Geolocator {
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<GeolocationAccessStatus>>> {
        <Self as RtActivatable<IGeolocatorStatics>>::get_activation_factory().request_access_async()
    }
    #[inline] pub fn get_geoposition_history_async(startTime: foundation::DateTime) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>>> {
        <Self as RtActivatable<IGeolocatorStatics>>::get_activation_factory().get_geoposition_history_async(startTime)
    }
    #[inline] pub fn get_geoposition_history_with_duration_async(startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>>> {
        <Self as RtActivatable<IGeolocatorStatics>>::get_activation_factory().get_geoposition_history_with_duration_async(startTime, duration)
    }
    #[inline] pub fn get_is_default_geoposition_recommended() -> Result<bool> {
        <Self as RtActivatable<IGeolocatorStatics2>>::get_activation_factory().get_is_default_geoposition_recommended()
    }
    #[inline] pub fn set_default_geoposition(value: &ComPtr<foundation::IReference<BasicGeoposition>>) -> Result<()> {
        <Self as RtActivatable<IGeolocatorStatics2>>::get_activation_factory().set_default_geoposition(value)
    }
    #[inline] pub fn get_default_geoposition() -> Result<Option<ComPtr<foundation::IReference<BasicGeoposition>>>> {
        <Self as RtActivatable<IGeolocatorStatics2>>::get_activation_factory().get_default_geoposition()
    }
}
DEFINE_CLSID!(Geolocator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,108,111,99,97,116,111,114,0]) [CLSID_Geolocator]);
DEFINE_IID!(IID_IGeolocator2, 3518246509, 34961, 17332, 173, 54, 39, 198, 254, 154, 151, 177);
RT_INTERFACE!{interface IGeolocator2(IGeolocator2Vtbl): IInspectable(IInspectableVtbl) [IID_IGeolocator2] {
    fn AllowFallbackToConsentlessPositions(&self) -> HRESULT
}}
impl ComPtr<IGeolocator2> {
    #[inline] pub fn allow_fallback_to_consentless_positions(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).AllowFallbackToConsentlessPositions)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeolocatorStatics, 2593027441, 11765, 17809, 159, 135, 235, 95, 216, 148, 233, 183);
RT_INTERFACE!{static interface IGeolocatorStatics(IGeolocatorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeolocatorStatics] {
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<GeolocationAccessStatus>) -> HRESULT,
    fn GetGeopositionHistoryAsync(&self, startTime: foundation::DateTime, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>) -> HRESULT,
    fn GetGeopositionHistoryWithDurationAsync(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>) -> HRESULT
}}
impl ComPtr<IGeolocatorStatics> {
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GeolocationAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_history_async(&self, startTime: foundation::DateTime) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGeopositionHistoryAsync)(self.deref() as *const _ as *mut _, startTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition_history_with_duration_async(&self, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<Geoposition>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetGeopositionHistoryWithDurationAsync)(self.deref() as *const _ as *mut _, startTime, duration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeolocatorStatics2, 2570064290, 64028, 17969, 167, 29, 13, 190, 177, 37, 13, 156);
RT_INTERFACE!{static interface IGeolocatorStatics2(IGeolocatorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGeolocatorStatics2] {
    fn get_IsDefaultGeopositionRecommended(&self, out: *mut bool) -> HRESULT,
    fn put_DefaultGeoposition(&self, value: *mut foundation::IReference<BasicGeoposition>) -> HRESULT,
    fn get_DefaultGeoposition(&self, out: *mut *mut foundation::IReference<BasicGeoposition>) -> HRESULT
}}
impl ComPtr<IGeolocatorStatics2> {
    #[inline] pub fn get_is_default_geoposition_recommended(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDefaultGeopositionRecommended)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_default_geoposition(&self, value: &ComPtr<foundation::IReference<BasicGeoposition>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DefaultGeoposition)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_default_geoposition(&self) -> Result<Option<ComPtr<foundation::IReference<BasicGeoposition>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultGeoposition)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeolocatorWithScalarAccuracy, 2532692929, 47119, 17930, 153, 77, 169, 108, 71, 165, 26, 164);
RT_INTERFACE!{interface IGeolocatorWithScalarAccuracy(IGeolocatorWithScalarAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_IGeolocatorWithScalarAccuracy] {
    fn get_DesiredAccuracyInMeters(&self, out: *mut *mut foundation::IReference<u32>) -> HRESULT,
    fn put_DesiredAccuracyInMeters(&self, value: *mut foundation::IReference<u32>) -> HRESULT
}}
impl ComPtr<IGeolocatorWithScalarAccuracy> {
    #[inline] pub fn get_desired_accuracy_in_meters(&self) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DesiredAccuracyInMeters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_accuracy_in_meters(&self, value: &ComPtr<foundation::IReference<u32>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DesiredAccuracyInMeters)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeopath, 3846166457, 11684, 18196, 166, 82, 222, 133, 147, 40, 152, 152);
RT_INTERFACE!{interface IGeopath(IGeopathVtbl): IInspectable(IInspectableVtbl) [IID_IGeopath] {
    fn get_Positions(&self, out: *mut *mut foundation::collections::IVectorView<BasicGeoposition>) -> HRESULT
}}
impl ComPtr<IGeopath> {
    #[inline] pub fn get_positions(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<BasicGeoposition>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Positions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Geopath: IGeopath}
impl RtActivatable<IGeopathFactory> for Geopath {}
impl Geopath {
    #[inline] pub fn create(positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>) -> Result<ComPtr<Geopath>> {
        <Self as RtActivatable<IGeopathFactory>>::get_activation_factory().create(positions)
    }
    #[inline] pub fn create_with_altitude_reference(positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<Geopath>> {
        <Self as RtActivatable<IGeopathFactory>>::get_activation_factory().create_with_altitude_reference(positions, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<Geopath>> {
        <Self as RtActivatable<IGeopathFactory>>::get_activation_factory().create_with_altitude_reference_and_spatial_reference(positions, altitudeReferenceSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(Geopath(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,112,97,116,104,0]) [CLSID_Geopath]);
DEFINE_IID!(IID_IGeopathFactory, 666806728, 51175, 17241, 155, 155, 252, 163, 224, 94, 245, 147);
RT_INTERFACE!{static interface IGeopathFactory(IGeopathFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeopathFactory] {
    fn Create(&self, positions: *mut foundation::collections::IIterable<BasicGeoposition>, out: *mut *mut Geopath) -> HRESULT,
    fn CreateWithAltitudeReference(&self, positions: *mut foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut Geopath) -> HRESULT,
    fn CreateWithAltitudeReferenceAndSpatialReference(&self, positions: *mut foundation::collections::IIterable<BasicGeoposition>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut Geopath) -> HRESULT
}}
impl ComPtr<IGeopathFactory> {
    #[inline] pub fn create(&self, positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>) -> Result<ComPtr<Geopath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, positions.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference(&self, positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<Geopath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReference)(self.deref() as *const _ as *mut _, positions.deref() as *const _ as *mut _, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_and_spatial_reference(&self, positions: &ComPtr<foundation::collections::IIterable<BasicGeoposition>>, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<Geopath>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReferenceAndSpatialReference)(self.deref() as *const _ as *mut _, positions.deref() as *const _ as *mut _, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeopoint, 1811546347, 58734, 18875, 156, 175, 203, 170, 120, 168, 188, 239);
RT_INTERFACE!{interface IGeopoint(IGeopointVtbl): IInspectable(IInspectableVtbl) [IID_IGeopoint] {
    fn get_Position(&self, out: *mut BasicGeoposition) -> HRESULT
}}
impl ComPtr<IGeopoint> {
    #[inline] pub fn get_position(&self) -> Result<BasicGeoposition> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Position)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geopoint: IGeopoint}
impl RtActivatable<IGeopointFactory> for Geopoint {}
impl Geopoint {
    #[inline] pub fn create(position: BasicGeoposition) -> Result<ComPtr<Geopoint>> {
        <Self as RtActivatable<IGeopointFactory>>::get_activation_factory().create(position)
    }
    #[inline] pub fn create_with_altitude_reference_system(position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<Geopoint>> {
        <Self as RtActivatable<IGeopointFactory>>::get_activation_factory().create_with_altitude_reference_system(position, altitudeReferenceSystem)
    }
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<Geopoint>> {
        <Self as RtActivatable<IGeopointFactory>>::get_activation_factory().create_with_altitude_reference_system_and_spatial_reference_id(position, altitudeReferenceSystem, spatialReferenceId)
    }
}
DEFINE_CLSID!(Geopoint(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,112,111,105,110,116,0]) [CLSID_Geopoint]);
DEFINE_IID!(IID_IGeopointFactory, 3681258803, 30397, 20016, 138, 247, 168, 68, 220, 55, 183, 160);
RT_INTERFACE!{static interface IGeopointFactory(IGeopointFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeopointFactory] {
    fn Create(&self, position: BasicGeoposition, out: *mut *mut Geopoint) -> HRESULT,
    fn CreateWithAltitudeReferenceSystem(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, out: *mut *mut Geopoint) -> HRESULT,
    fn CreateWithAltitudeReferenceSystemAndSpatialReferenceId(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32, out: *mut *mut Geopoint) -> HRESULT
}}
impl ComPtr<IGeopointFactory> {
    #[inline] pub fn create(&self, position: BasicGeoposition) -> Result<ComPtr<Geopoint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, position, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem) -> Result<ComPtr<Geopoint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReferenceSystem)(self.deref() as *const _ as *mut _, position, altitudeReferenceSystem, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_altitude_reference_system_and_spatial_reference_id(&self, position: BasicGeoposition, altitudeReferenceSystem: AltitudeReferenceSystem, spatialReferenceId: u32) -> Result<ComPtr<Geopoint>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithAltitudeReferenceSystemAndSpatialReferenceId)(self.deref() as *const _ as *mut _, position, altitudeReferenceSystem, spatialReferenceId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeoposition, 3247244372, 32065, 20471, 169, 87, 157, 255, 180, 239, 127, 91);
RT_INTERFACE!{interface IGeoposition(IGeopositionVtbl): IInspectable(IInspectableVtbl) [IID_IGeoposition] {
    fn get_Coordinate(&self, out: *mut *mut Geocoordinate) -> HRESULT,
    fn get_CivicAddress(&self, out: *mut *mut CivicAddress) -> HRESULT
}}
impl ComPtr<IGeoposition> {
    #[inline] pub fn get_coordinate(&self) -> Result<Option<ComPtr<Geocoordinate>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Coordinate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_civic_address(&self) -> Result<Option<ComPtr<CivicAddress>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CivicAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Geoposition: IGeoposition}
DEFINE_IID!(IID_IGeoposition2, 2137192087, 34417, 19213, 134, 248, 71, 74, 132, 150, 24, 124);
RT_INTERFACE!{interface IGeoposition2(IGeoposition2Vtbl): IInspectable(IInspectableVtbl) [IID_IGeoposition2] {
    fn get_VenueData(&self, out: *mut *mut VenueData) -> HRESULT
}}
impl ComPtr<IGeoposition2> {
    #[inline] pub fn get_venue_data(&self) -> Result<Option<ComPtr<VenueData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VenueData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeoshape, 3382485679, 50985, 17345, 143, 171, 214, 222, 201, 20, 223, 126);
RT_INTERFACE!{interface IGeoshape(IGeoshapeVtbl): IInspectable(IInspectableVtbl) [IID_IGeoshape] {
    fn get_GeoshapeType(&self, out: *mut GeoshapeType) -> HRESULT,
    fn get_SpatialReferenceId(&self, out: *mut u32) -> HRESULT,
    fn get_AltitudeReferenceSystem(&self, out: *mut AltitudeReferenceSystem) -> HRESULT
}}
impl ComPtr<IGeoshape> {
    #[inline] pub fn get_geoshape_type(&self) -> Result<GeoshapeType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GeoshapeType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_spatial_reference_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SpatialReferenceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude_reference_system(&self) -> Result<AltitudeReferenceSystem> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AltitudeReferenceSystem)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum GeoshapeType: i32 {
    Geopoint = 0, Geocircle = 1, Geopath = 2, GeoboundingBox = 3,
}}
DEFINE_IID!(IID_IGeovisit, 2978445942, 40694, 16811, 160, 221, 121, 62, 206, 118, 226, 222);
RT_INTERFACE!{interface IGeovisit(IGeovisitVtbl): IInspectable(IInspectableVtbl) [IID_IGeovisit] {
    fn get_Position(&self, out: *mut *mut Geoposition) -> HRESULT,
    fn get_StateChange(&self, out: *mut VisitStateChange) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<IGeovisit> {
    #[inline] pub fn get_position(&self) -> Result<Option<ComPtr<Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Position)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state_change(&self) -> Result<VisitStateChange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StateChange)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geovisit: IGeovisit}
DEFINE_IID!(IID_IGeovisitMonitor, 2148633263, 22852, 17809, 131, 193, 57, 102, 71, 245, 79, 44);
RT_INTERFACE!{interface IGeovisitMonitor(IGeovisitMonitorVtbl): IInspectable(IInspectableVtbl) [IID_IGeovisitMonitor] {
    fn get_MonitoringScope(&self, out: *mut VisitMonitoringScope) -> HRESULT,
    fn Start(&self, value: VisitMonitoringScope) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn add_VisitStateChanged(&self, handler: *mut foundation::TypedEventHandler<GeovisitMonitor, GeovisitStateChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisitStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGeovisitMonitor> {
    #[inline] pub fn get_monitoring_scope(&self) -> Result<VisitMonitoringScope> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MonitoringScope)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self, value: VisitMonitoringScope) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_visit_state_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GeovisitMonitor, GeovisitStateChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_VisitStateChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_visit_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_VisitStateChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitMonitor: IGeovisitMonitor}
impl RtActivatable<IGeovisitMonitorStatics> for GeovisitMonitor {}
impl RtActivatable<IActivationFactory> for GeovisitMonitor {}
impl GeovisitMonitor {
    #[inline] pub fn get_last_report_async() -> Result<ComPtr<foundation::IAsyncOperation<Geovisit>>> {
        <Self as RtActivatable<IGeovisitMonitorStatics>>::get_activation_factory().get_last_report_async()
    }
}
DEFINE_CLSID!(GeovisitMonitor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,118,105,115,105,116,77,111,110,105,116,111,114,0]) [CLSID_GeovisitMonitor]);
DEFINE_IID!(IID_IGeovisitMonitorStatics, 3170465447, 48114, 19677, 149, 207, 85, 76, 130, 237, 251, 135);
RT_INTERFACE!{static interface IGeovisitMonitorStatics(IGeovisitMonitorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeovisitMonitorStatics] {
    fn GetLastReportAsync(&self, out: *mut *mut foundation::IAsyncOperation<Geovisit>) -> HRESULT
}}
impl ComPtr<IGeovisitMonitorStatics> {
    #[inline] pub fn get_last_report_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<Geovisit>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetLastReportAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeovisitStateChangedEventArgs, 3467956735, 35667, 18792, 190, 237, 76, 236, 208, 41, 206, 21);
RT_INTERFACE!{interface IGeovisitStateChangedEventArgs(IGeovisitStateChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGeovisitStateChangedEventArgs] {
    fn get_Visit(&self, out: *mut *mut Geovisit) -> HRESULT
}}
impl ComPtr<IGeovisitStateChangedEventArgs> {
    #[inline] pub fn get_visit(&self) -> Result<Option<ComPtr<Geovisit>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Visit)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitStateChangedEventArgs: IGeovisitStateChangedEventArgs}
DEFINE_IID!(IID_IGeovisitTriggerDetails, 3933670814, 53705, 17739, 153, 183, 178, 248, 205, 210, 72, 47);
RT_INTERFACE!{interface IGeovisitTriggerDetails(IGeovisitTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IGeovisitTriggerDetails] {
    fn ReadReports(&self, out: *mut *mut foundation::collections::IVectorView<Geovisit>) -> HRESULT
}}
impl ComPtr<IGeovisitTriggerDetails> {
    #[inline] pub fn read_reports(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<Geovisit>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadReports)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GeovisitTriggerDetails: IGeovisitTriggerDetails}
RT_ENUM! { enum PositionAccuracy: i32 {
    Default = 0, High = 1,
}}
DEFINE_IID!(IID_IPositionChangedEventArgs, 931503333, 40222, 18117, 191, 59, 106, 216, 202, 193, 160, 147);
RT_INTERFACE!{interface IPositionChangedEventArgs(IPositionChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPositionChangedEventArgs] {
    fn get_Position(&self, out: *mut *mut Geoposition) -> HRESULT
}}
impl ComPtr<IPositionChangedEventArgs> {
    #[inline] pub fn get_position(&self) -> Result<Option<ComPtr<Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Position)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PositionChangedEventArgs: IPositionChangedEventArgs}
RT_ENUM! { enum PositionSource: i32 {
    Cellular = 0, Satellite = 1, WiFi = 2, IPAddress = 3, Unknown = 4, Default = 5, Obfuscated = 6,
}}
RT_ENUM! { enum PositionStatus: i32 {
    Ready = 0, Initializing = 1, NoData = 2, Disabled = 3, NotInitialized = 4, NotAvailable = 5,
}}
DEFINE_IID!(IID_IStatusChangedEventArgs, 877908698, 35987, 16657, 162, 5, 154, 236, 252, 155, 229, 192);
RT_INTERFACE!{interface IStatusChangedEventArgs(IStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IStatusChangedEventArgs] {
    fn get_Status(&self, out: *mut PositionStatus) -> HRESULT
}}
impl ComPtr<IStatusChangedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<PositionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class StatusChangedEventArgs: IStatusChangedEventArgs}
DEFINE_IID!(IID_IVenueData, 1727238535, 24803, 19247, 181, 39, 79, 83, 241, 195, 198, 119);
RT_INTERFACE!{interface IVenueData(IVenueDataVtbl): IInspectable(IInspectableVtbl) [IID_IVenueData] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Level(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IVenueData> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_level(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Level)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VenueData: IVenueData}
RT_ENUM! { enum VisitMonitoringScope: i32 {
    Venue = 0, City = 1,
}}
RT_ENUM! { enum VisitStateChange: i32 {
    TrackingLost = 0, Arrived = 1, Departed = 2, OtherMovement = 3,
}}
pub mod geofencing { // Windows.Devices.Geolocation.Geofencing
use crate::prelude::*;
DEFINE_IID!(IID_IGeofence, 2617837603, 60856, 18400, 130, 69, 91, 246, 29, 50, 31, 45);
RT_INTERFACE!{interface IGeofence(IGeofenceVtbl): IInspectable(IInspectableVtbl) [IID_IGeofence] {
    fn get_StartTime(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_DwellTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MonitoredStates(&self, out: *mut MonitoredGeofenceStates) -> HRESULT,
    fn get_Geoshape(&self, out: *mut *mut super::IGeoshape) -> HRESULT,
    fn get_SingleUse(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IGeofence> {
    #[inline] pub fn get_start_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StartTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Duration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dwell_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DwellTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_monitored_states(&self) -> Result<MonitoredGeofenceStates> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MonitoredStates)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geoshape(&self) -> Result<Option<ComPtr<super::IGeoshape>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Geoshape)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_single_use(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SingleUse)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Geofence: IGeofence}
impl RtActivatable<IGeofenceFactory> for Geofence {}
impl Geofence {
    #[inline] pub fn create(id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>) -> Result<ComPtr<Geofence>> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create(id, geoshape)
    }
    #[inline] pub fn create_with_monitor_states(id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>, monitoredStates: MonitoredGeofenceStates, singleUse: bool) -> Result<ComPtr<Geofence>> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create_with_monitor_states(id, geoshape, monitoredStates, singleUse)
    }
    #[inline] pub fn create_with_monitor_states_and_dwell_time(id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan) -> Result<ComPtr<Geofence>> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create_with_monitor_states_and_dwell_time(id, geoshape, monitoredStates, singleUse, dwellTime)
    }
    #[inline] pub fn create_with_monitor_states_dwell_time_start_time_and_duration(id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<Geofence>> {
        <Self as RtActivatable<IGeofenceFactory>>::get_activation_factory().create_with_monitor_states_dwell_time_start_time_and_duration(id, geoshape, monitoredStates, singleUse, dwellTime, startTime, duration)
    }
}
DEFINE_CLSID!(Geofence(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,102,101,110,99,105,110,103,46,71,101,111,102,101,110,99,101,0]) [CLSID_Geofence]);
DEFINE_IID!(IID_IGeofenceFactory, 2216649291, 12895, 19344, 188, 167, 43, 128, 34, 169, 55, 150);
RT_INTERFACE!{static interface IGeofenceFactory(IGeofenceFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceFactory] {
    fn Create(&self, id: HSTRING, geoshape: *mut super::IGeoshape, out: *mut *mut Geofence) -> HRESULT,
    fn CreateWithMonitorStates(&self, id: HSTRING, geoshape: *mut super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, out: *mut *mut Geofence) -> HRESULT,
    fn CreateWithMonitorStatesAndDwellTime(&self, id: HSTRING, geoshape: *mut super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, out: *mut *mut Geofence) -> HRESULT,
    fn CreateWithMonitorStatesDwellTimeStartTimeAndDuration(&self, id: HSTRING, geoshape: *mut super::IGeoshape, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, startTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut *mut Geofence) -> HRESULT
}}
impl ComPtr<IGeofenceFactory> {
    #[inline] pub fn create(&self, id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>) -> Result<ComPtr<Geofence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, id.get(), geoshape.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_monitor_states(&self, id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>, monitoredStates: MonitoredGeofenceStates, singleUse: bool) -> Result<ComPtr<Geofence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithMonitorStates)(self.deref() as *const _ as *mut _, id.get(), geoshape.deref() as *const _ as *mut _, monitoredStates, singleUse, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_monitor_states_and_dwell_time(&self, id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan) -> Result<ComPtr<Geofence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithMonitorStatesAndDwellTime)(self.deref() as *const _ as *mut _, id.get(), geoshape.deref() as *const _ as *mut _, monitoredStates, singleUse, dwellTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_monitor_states_dwell_time_start_time_and_duration(&self, id: &HStringArg, geoshape: &ComPtr<super::IGeoshape>, monitoredStates: MonitoredGeofenceStates, singleUse: bool, dwellTime: foundation::TimeSpan, startTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<Geofence>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithMonitorStatesDwellTimeStartTimeAndDuration)(self.deref() as *const _ as *mut _, id.get(), geoshape.deref() as *const _ as *mut _, monitoredStates, singleUse, dwellTime, startTime, duration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGeofenceMonitor, 1276075896, 7199, 17953, 187, 189, 131, 59, 146, 36, 114, 38);
RT_INTERFACE!{interface IGeofenceMonitor(IGeofenceMonitorVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceMonitor] {
    fn get_Status(&self, out: *mut GeofenceMonitorStatus) -> HRESULT,
    fn get_Geofences(&self, out: *mut *mut foundation::collections::IVector<Geofence>) -> HRESULT,
    fn get_LastKnownGeoposition(&self, out: *mut *mut super::Geoposition) -> HRESULT,
    fn add_GeofenceStateChanged(&self, eventHandler: *mut foundation::TypedEventHandler<GeofenceMonitor, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GeofenceStateChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn ReadReports(&self, out: *mut *mut foundation::collections::IVectorView<GeofenceStateChangeReport>) -> HRESULT,
    fn add_StatusChanged(&self, eventHandler: *mut foundation::TypedEventHandler<GeofenceMonitor, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGeofenceMonitor> {
    #[inline] pub fn get_status(&self) -> Result<GeofenceMonitorStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geofences(&self) -> Result<Option<ComPtr<foundation::collections::IVector<Geofence>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Geofences)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_last_known_geoposition(&self) -> Result<Option<ComPtr<super::Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_LastKnownGeoposition)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_geofence_state_changed(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<GeofenceMonitor, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_GeofenceStateChanged)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_geofence_state_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_GeofenceStateChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_reports(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<GeofenceStateChangeReport>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadReports)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<GeofenceMonitor, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusChanged)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GeofenceMonitor: IGeofenceMonitor}
impl RtActivatable<IGeofenceMonitorStatics> for GeofenceMonitor {}
impl GeofenceMonitor {
    #[inline] pub fn get_current() -> Result<Option<ComPtr<GeofenceMonitor>>> {
        <Self as RtActivatable<IGeofenceMonitorStatics>>::get_activation_factory().get_current()
    }
}
DEFINE_CLSID!(GeofenceMonitor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,101,111,108,111,99,97,116,105,111,110,46,71,101,111,102,101,110,99,105,110,103,46,71,101,111,102,101,110,99,101,77,111,110,105,116,111,114,0]) [CLSID_GeofenceMonitor]);
DEFINE_IID!(IID_IGeofenceMonitorStatics, 768815055, 32373, 18585, 172, 227, 43, 208, 166, 92, 206, 6);
RT_INTERFACE!{static interface IGeofenceMonitorStatics(IGeofenceMonitorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceMonitorStatics] {
    fn get_Current(&self, out: *mut *mut GeofenceMonitor) -> HRESULT
}}
impl ComPtr<IGeofenceMonitorStatics> {
    #[inline] pub fn get_current(&self) -> Result<Option<ComPtr<GeofenceMonitor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Current)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GeofenceMonitorStatus: i32 {
    Ready = 0, Initializing = 1, NoData = 2, Disabled = 3, NotInitialized = 4, NotAvailable = 5,
}}
RT_ENUM! { enum GeofenceRemovalReason: i32 {
    Used = 0, Expired = 1,
}}
RT_ENUM! { enum GeofenceState: u32 {
    None = 0, Entered = 1, Exited = 2, Removed = 4,
}}
DEFINE_IID!(IID_IGeofenceStateChangeReport, 2586065944, 9316, 19593, 190, 5, 179, 255, 255, 91, 171, 197);
RT_INTERFACE!{interface IGeofenceStateChangeReport(IGeofenceStateChangeReportVtbl): IInspectable(IInspectableVtbl) [IID_IGeofenceStateChangeReport] {
    fn get_NewState(&self, out: *mut GeofenceState) -> HRESULT,
    fn get_Geofence(&self, out: *mut *mut Geofence) -> HRESULT,
    fn get_Geoposition(&self, out: *mut *mut super::Geoposition) -> HRESULT,
    fn get_RemovalReason(&self, out: *mut GeofenceRemovalReason) -> HRESULT
}}
impl ComPtr<IGeofenceStateChangeReport> {
    #[inline] pub fn get_new_state(&self) -> Result<GeofenceState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NewState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geofence(&self) -> Result<Option<ComPtr<Geofence>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Geofence)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_geoposition(&self) -> Result<Option<ComPtr<super::Geoposition>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Geoposition)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_removal_reason(&self) -> Result<GeofenceRemovalReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RemovalReason)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GeofenceStateChangeReport: IGeofenceStateChangeReport}
RT_ENUM! { enum MonitoredGeofenceStates: u32 {
    None = 0, Entered = 1, Exited = 2, Removed = 4,
}}
} // Windows.Devices.Geolocation.Geofencing
} // Windows.Devices.Geolocation
pub mod gpio { // Windows.Devices.Gpio
use crate::prelude::*;
RT_STRUCT! { struct GpioChangeCount {
    Count: u64, RelativeTime: foundation::TimeSpan,
}}
DEFINE_IID!(IID_IGpioChangeCounter, 3411984606, 26625, 17407, 128, 61, 69, 118, 98, 138, 139, 38);
RT_INTERFACE!{interface IGpioChangeCounter(IGpioChangeCounterVtbl): IInspectable(IInspectableVtbl) [IID_IGpioChangeCounter] {
    fn put_Polarity(&self, value: GpioChangePolarity) -> HRESULT,
    fn get_Polarity(&self, out: *mut GpioChangePolarity) -> HRESULT,
    fn get_IsStarted(&self, out: *mut bool) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Read(&self, out: *mut GpioChangeCount) -> HRESULT,
    fn Reset(&self, out: *mut GpioChangeCount) -> HRESULT
}}
impl ComPtr<IGpioChangeCounter> {
    #[inline] pub fn set_polarity(&self, value: GpioChangePolarity) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Polarity)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_polarity(&self) -> Result<GpioChangePolarity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Polarity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_started(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStarted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self) -> Result<GpioChangeCount> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn reset(&self) -> Result<GpioChangeCount> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).Reset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioChangeCounter: IGpioChangeCounter}
impl RtActivatable<IGpioChangeCounterFactory> for GpioChangeCounter {}
impl GpioChangeCounter {
    #[inline] pub fn create(pin: &ComPtr<GpioPin>) -> Result<ComPtr<GpioChangeCounter>> {
        <Self as RtActivatable<IGpioChangeCounterFactory>>::get_activation_factory().create(pin)
    }
}
DEFINE_CLSID!(GpioChangeCounter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,104,97,110,103,101,67,111,117,110,116,101,114,0]) [CLSID_GpioChangeCounter]);
DEFINE_IID!(IID_IGpioChangeCounterFactory, 343774390, 2718, 16652, 180, 250, 248, 159, 64, 82, 8, 77);
RT_INTERFACE!{static interface IGpioChangeCounterFactory(IGpioChangeCounterFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGpioChangeCounterFactory] {
    fn Create(&self, pin: *mut GpioPin, out: *mut *mut GpioChangeCounter) -> HRESULT
}}
impl ComPtr<IGpioChangeCounterFactory> {
    #[inline] pub fn create(&self, pin: &ComPtr<GpioPin>) -> Result<ComPtr<GpioChangeCounter>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, pin.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GpioChangePolarity: i32 {
    Falling = 0, Rising = 1, Both = 2,
}}
DEFINE_IID!(IID_IGpioChangeReader, 180127839, 57393, 18664, 133, 144, 112, 222, 120, 54, 60, 109);
RT_INTERFACE!{interface IGpioChangeReader(IGpioChangeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioChangeReader] {
    fn get_Capacity(&self, out: *mut i32) -> HRESULT,
    fn get_Length(&self, out: *mut i32) -> HRESULT,
    fn get_IsEmpty(&self, out: *mut bool) -> HRESULT,
    fn get_IsOverflowed(&self, out: *mut bool) -> HRESULT,
    fn put_Polarity(&self, value: GpioChangePolarity) -> HRESULT,
    fn get_Polarity(&self, out: *mut GpioChangePolarity) -> HRESULT,
    fn get_IsStarted(&self, out: *mut bool) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn GetNextItem(&self, out: *mut GpioChangeRecord) -> HRESULT,
    fn PeekNextItem(&self, out: *mut GpioChangeRecord) -> HRESULT,
    fn GetAllItems(&self, out: *mut *mut foundation::collections::IVector<GpioChangeRecord>) -> HRESULT,
    fn WaitForItemsAsync(&self, count: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IGpioChangeReader> {
    #[inline] pub fn get_capacity(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Capacity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Length)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEmpty)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_overflowed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsOverflowed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_polarity(&self, value: GpioChangePolarity) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Polarity)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_polarity(&self) -> Result<GpioChangePolarity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Polarity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_started(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStarted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn clear(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Clear)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_next_item(&self) -> Result<GpioChangeRecord> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetNextItem)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn peek_next_item(&self) -> Result<GpioChangeRecord> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).PeekNextItem)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_all_items(&self) -> Result<Option<ComPtr<foundation::collections::IVector<GpioChangeRecord>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllItems)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn wait_for_items_async(&self, count: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).WaitForItemsAsync)(self.deref() as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioChangeReader: IGpioChangeReader}
impl RtActivatable<IGpioChangeReaderFactory> for GpioChangeReader {}
impl GpioChangeReader {
    #[inline] pub fn create(pin: &ComPtr<GpioPin>) -> Result<ComPtr<GpioChangeReader>> {
        <Self as RtActivatable<IGpioChangeReaderFactory>>::get_activation_factory().create(pin)
    }
    #[inline] pub fn create_with_capacity(pin: &ComPtr<GpioPin>, minCapacity: i32) -> Result<ComPtr<GpioChangeReader>> {
        <Self as RtActivatable<IGpioChangeReaderFactory>>::get_activation_factory().create_with_capacity(pin, minCapacity)
    }
}
DEFINE_CLSID!(GpioChangeReader(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,104,97,110,103,101,82,101,97,100,101,114,0]) [CLSID_GpioChangeReader]);
DEFINE_IID!(IID_IGpioChangeReaderFactory, 2841218803, 14606, 17434, 157, 28, 232, 222, 11, 45, 240, 223);
RT_INTERFACE!{static interface IGpioChangeReaderFactory(IGpioChangeReaderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGpioChangeReaderFactory] {
    fn Create(&self, pin: *mut GpioPin, out: *mut *mut GpioChangeReader) -> HRESULT,
    fn CreateWithCapacity(&self, pin: *mut GpioPin, minCapacity: i32, out: *mut *mut GpioChangeReader) -> HRESULT
}}
impl ComPtr<IGpioChangeReaderFactory> {
    #[inline] pub fn create(&self, pin: &ComPtr<GpioPin>) -> Result<ComPtr<GpioChangeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, pin.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_with_capacity(&self, pin: &ComPtr<GpioPin>, minCapacity: i32) -> Result<ComPtr<GpioChangeReader>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithCapacity)(self.deref() as *const _ as *mut _, pin.deref() as *const _ as *mut _, minCapacity, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_STRUCT! { struct GpioChangeRecord {
    RelativeTime: foundation::TimeSpan, Edge: GpioPinEdge,
}}
DEFINE_IID!(IID_IGpioController, 675287779, 29793, 18076, 168, 188, 97, 214, 157, 8, 165, 60);
RT_INTERFACE!{interface IGpioController(IGpioControllerVtbl): IInspectable(IInspectableVtbl) [IID_IGpioController] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn OpenPin(&self, pinNumber: i32, out: *mut *mut GpioPin) -> HRESULT,
    fn OpenPinWithSharingMode(&self, pinNumber: i32, sharingMode: GpioSharingMode, out: *mut *mut GpioPin) -> HRESULT,
    fn TryOpenPin(&self, pinNumber: i32, sharingMode: GpioSharingMode, pin: *mut *mut GpioPin, openStatus: *mut GpioOpenStatus, out: *mut bool) -> HRESULT
}}
impl ComPtr<IGpioController> {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_pin(&self, pinNumber: i32) -> Result<Option<ComPtr<GpioPin>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenPin)(self.deref() as *const _ as *mut _, pinNumber, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_pin_with_sharing_mode(&self, pinNumber: i32, sharingMode: GpioSharingMode) -> Result<Option<ComPtr<GpioPin>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenPinWithSharingMode)(self.deref() as *const _ as *mut _, pinNumber, sharingMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_open_pin(&self, pinNumber: i32, sharingMode: GpioSharingMode) -> Result<(Option<ComPtr<GpioPin>>, GpioOpenStatus, bool)> { unsafe { 
        let mut pin = null_mut(); let mut openStatus = zeroed(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryOpenPin)(self.deref() as *const _ as *mut _, pinNumber, sharingMode, &mut pin, &mut openStatus, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap_optional(pin), openStatus, out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioController: IGpioController}
impl RtActivatable<IGpioControllerStatics> for GpioController {}
impl RtActivatable<IGpioControllerStatics2> for GpioController {}
impl GpioController {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<GpioController>>> {
        <Self as RtActivatable<IGpioControllerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_controllers_async(provider: &ComPtr<provider::IGpioProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<GpioController>>>> {
        <Self as RtActivatable<IGpioControllerStatics2>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<GpioController>>> {
        <Self as RtActivatable<IGpioControllerStatics2>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(GpioController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,71,112,105,111,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_GpioController]);
DEFINE_IID!(IID_IGpioControllerStatics, 785839150, 31479, 16662, 149, 51, 196, 61, 153, 161, 251, 100);
RT_INTERFACE!{static interface IGpioControllerStatics(IGpioControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGpioControllerStatics] {
    fn GetDefault(&self, out: *mut *mut GpioController) -> HRESULT
}}
impl ComPtr<IGpioControllerStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<GpioController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioControllerStatics2, 2435546400, 27812, 16646, 163, 115, 255, 253, 52, 107, 14, 91);
RT_INTERFACE!{static interface IGpioControllerStatics2(IGpioControllerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGpioControllerStatics2] {
    fn GetControllersAsync(&self, provider: *mut provider::IGpioProvider, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<GpioController>>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<GpioController>) -> HRESULT
}}
impl ComPtr<IGpioControllerStatics2> {
    #[inline] pub fn get_controllers_async(&self, provider: &ComPtr<provider::IGpioProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<GpioController>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<GpioController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum GpioOpenStatus: i32 {
    PinOpened = 0, PinUnavailable = 1, SharingViolation = 2, MuxingConflict = 3, UnknownError = 4,
}}
DEFINE_IID!(IID_IGpioPin, 299479175, 44974, 18320, 158, 233, 224, 234, 201, 66, 210, 1);
RT_INTERFACE!{interface IGpioPin(IGpioPinVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPin] {
    fn add_ValueChanged(&self, handler: *mut foundation::TypedEventHandler<GpioPin, GpioPinValueChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DebounceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DebounceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_PinNumber(&self, out: *mut i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut GpioSharingMode) -> HRESULT,
    fn IsDriveModeSupported(&self, driveMode: GpioPinDriveMode, out: *mut bool) -> HRESULT,
    fn GetDriveMode(&self, out: *mut GpioPinDriveMode) -> HRESULT,
    fn SetDriveMode(&self, value: GpioPinDriveMode) -> HRESULT,
    fn Write(&self, value: GpioPinValue) -> HRESULT,
    fn Read(&self, out: *mut GpioPinValue) -> HRESULT
}}
impl ComPtr<IGpioPin> {
    #[inline] pub fn add_value_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<GpioPin, GpioPinValueChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ValueChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_value_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ValueChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_debounce_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DebounceTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_debounce_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DebounceTimeout)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<GpioSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_drive_mode_supported(&self, driveMode: GpioPinDriveMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsDriveModeSupported)(self.deref() as *const _ as *mut _, driveMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_drive_mode(&self) -> Result<GpioPinDriveMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetDriveMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_drive_mode(&self, value: GpioPinDriveMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetDriveMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, value: GpioPinValue) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Write)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self) -> Result<GpioPinValue> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioPin: IGpioPin}
RT_ENUM! { enum GpioPinDriveMode: i32 {
    Input = 0, Output = 1, InputPullUp = 2, InputPullDown = 3, OutputOpenDrain = 4, OutputOpenDrainPullUp = 5, OutputOpenSource = 6, OutputOpenSourcePullDown = 7,
}}
RT_ENUM! { enum GpioPinEdge: i32 {
    FallingEdge = 0, RisingEdge = 1,
}}
RT_ENUM! { enum GpioPinValue: i32 {
    Low = 0, High = 1,
}}
DEFINE_IID!(IID_IGpioPinValueChangedEventArgs, 825731809, 28733, 16473, 189, 36, 181, 178, 93, 255, 184, 78);
RT_INTERFACE!{interface IGpioPinValueChangedEventArgs(IGpioPinValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinValueChangedEventArgs] {
    fn get_Edge(&self, out: *mut GpioPinEdge) -> HRESULT
}}
impl ComPtr<IGpioPinValueChangedEventArgs> {
    #[inline] pub fn get_edge(&self) -> Result<GpioPinEdge> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Edge)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioPinValueChangedEventArgs: IGpioPinValueChangedEventArgs}
RT_ENUM! { enum GpioSharingMode: i32 {
    Exclusive = 0, SharedReadOnly = 1,
}}
pub mod provider { // Windows.Devices.Gpio.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IGpioControllerProvider, 2903625415, 6634, 19233, 135, 79, 185, 26, 237, 74, 37, 219);
RT_INTERFACE!{interface IGpioControllerProvider(IGpioControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioControllerProvider] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn OpenPinProvider(&self, pin: i32, sharingMode: ProviderGpioSharingMode, out: *mut *mut IGpioPinProvider) -> HRESULT
}}
impl ComPtr<IGpioControllerProvider> {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_pin_provider(&self, pin: i32, sharingMode: ProviderGpioSharingMode) -> Result<Option<ComPtr<IGpioPinProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenPinProvider)(self.deref() as *const _ as *mut _, pin, sharingMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioPinProvider, 1110723767, 27324, 16639, 156, 231, 115, 184, 83, 1, 185, 0);
RT_INTERFACE!{interface IGpioPinProvider(IGpioPinProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinProvider] {
    fn add_ValueChanged(&self, handler: *mut foundation::TypedEventHandler<IGpioPinProvider, GpioPinProviderValueChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValueChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DebounceTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DebounceTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_PinNumber(&self, out: *mut i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut ProviderGpioSharingMode) -> HRESULT,
    fn IsDriveModeSupported(&self, driveMode: ProviderGpioPinDriveMode, out: *mut bool) -> HRESULT,
    fn GetDriveMode(&self, out: *mut ProviderGpioPinDriveMode) -> HRESULT,
    fn SetDriveMode(&self, value: ProviderGpioPinDriveMode) -> HRESULT,
    fn Write(&self, value: ProviderGpioPinValue) -> HRESULT,
    fn Read(&self, out: *mut ProviderGpioPinValue) -> HRESULT
}}
impl ComPtr<IGpioPinProvider> {
    #[inline] pub fn add_value_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<IGpioPinProvider, GpioPinProviderValueChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ValueChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_value_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ValueChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_debounce_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DebounceTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_debounce_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DebounceTimeout)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_pin_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<ProviderGpioSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_drive_mode_supported(&self, driveMode: ProviderGpioPinDriveMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsDriveModeSupported)(self.deref() as *const _ as *mut _, driveMode, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_drive_mode(&self) -> Result<ProviderGpioPinDriveMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetDriveMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_drive_mode(&self, value: ProviderGpioPinDriveMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetDriveMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, value: ProviderGpioPinValue) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Write)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self) -> Result<ProviderGpioPinValue> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioPinProviderValueChangedEventArgs, 849794802, 15707, 17613, 143, 190, 19, 166, 159, 46, 219, 36);
RT_INTERFACE!{interface IGpioPinProviderValueChangedEventArgs(IGpioPinProviderValueChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinProviderValueChangedEventArgs] {
    fn get_Edge(&self, out: *mut ProviderGpioPinEdge) -> HRESULT
}}
impl ComPtr<IGpioPinProviderValueChangedEventArgs> {
    #[inline] pub fn get_edge(&self) -> Result<ProviderGpioPinEdge> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Edge)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GpioPinProviderValueChangedEventArgs: IGpioPinProviderValueChangedEventArgs}
impl RtActivatable<IGpioPinProviderValueChangedEventArgsFactory> for GpioPinProviderValueChangedEventArgs {}
impl GpioPinProviderValueChangedEventArgs {
    #[inline] pub fn create(edge: ProviderGpioPinEdge) -> Result<ComPtr<GpioPinProviderValueChangedEventArgs>> {
        <Self as RtActivatable<IGpioPinProviderValueChangedEventArgsFactory>>::get_activation_factory().create(edge)
    }
}
DEFINE_CLSID!(GpioPinProviderValueChangedEventArgs(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,71,112,105,111,46,80,114,111,118,105,100,101,114,46,71,112,105,111,80,105,110,80,114,111,118,105,100,101,114,86,97,108,117,101,67,104,97,110,103,101,100,69,118,101,110,116,65,114,103,115,0]) [CLSID_GpioPinProviderValueChangedEventArgs]);
DEFINE_IID!(IID_IGpioPinProviderValueChangedEventArgsFactory, 1053494105, 22156, 17298, 178, 74, 138, 89, 169, 2, 177, 241);
RT_INTERFACE!{static interface IGpioPinProviderValueChangedEventArgsFactory(IGpioPinProviderValueChangedEventArgsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGpioPinProviderValueChangedEventArgsFactory] {
    fn Create(&self, edge: ProviderGpioPinEdge, out: *mut *mut GpioPinProviderValueChangedEventArgs) -> HRESULT
}}
impl ComPtr<IGpioPinProviderValueChangedEventArgsFactory> {
    #[inline] pub fn create(&self, edge: ProviderGpioPinEdge) -> Result<ComPtr<GpioPinProviderValueChangedEventArgs>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, edge, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGpioProvider, 1156065031, 2250, 17226, 175, 224, 214, 21, 128, 68, 111, 126);
RT_INTERFACE!{interface IGpioProvider(IGpioProviderVtbl): IInspectable(IInspectableVtbl) [IID_IGpioProvider] {
    fn GetControllers(&self, out: *mut *mut foundation::collections::IVectorView<IGpioControllerProvider>) -> HRESULT
}}
impl ComPtr<IGpioProvider> {
    #[inline] pub fn get_controllers(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<IGpioControllerProvider>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderGpioPinDriveMode: i32 {
    Input = 0, Output = 1, InputPullUp = 2, InputPullDown = 3, OutputOpenDrain = 4, OutputOpenDrainPullUp = 5, OutputOpenSource = 6, OutputOpenSourcePullDown = 7,
}}
RT_ENUM! { enum ProviderGpioPinEdge: i32 {
    FallingEdge = 0, RisingEdge = 1,
}}
RT_ENUM! { enum ProviderGpioPinValue: i32 {
    Low = 0, High = 1,
}}
RT_ENUM! { enum ProviderGpioSharingMode: i32 {
    Exclusive = 0, SharedReadOnly = 1,
}}
} // Windows.Devices.Gpio.Provider
} // Windows.Devices.Gpio
pub mod haptics { // Windows.Devices.Haptics
use crate::prelude::*;
RT_CLASS!{static class KnownSimpleHapticsControllerWaveforms}
impl RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics> for KnownSimpleHapticsControllerWaveforms {}
impl KnownSimpleHapticsControllerWaveforms {
    #[inline] pub fn get_click() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_click()
    }
    #[inline] pub fn get_buzz_continuous() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_buzz_continuous()
    }
    #[inline] pub fn get_rumble_continuous() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_rumble_continuous()
    }
    #[inline] pub fn get_press() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_press()
    }
    #[inline] pub fn get_release() -> Result<u16> {
        <Self as RtActivatable<IKnownSimpleHapticsControllerWaveformsStatics>>::get_activation_factory().get_release()
    }
}
DEFINE_CLSID!(KnownSimpleHapticsControllerWaveforms(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,97,112,116,105,99,115,46,75,110,111,119,110,83,105,109,112,108,101,72,97,112,116,105,99,115,67,111,110,116,114,111,108,108,101,114,87,97,118,101,102,111,114,109,115,0]) [CLSID_KnownSimpleHapticsControllerWaveforms]);
DEFINE_IID!(IID_IKnownSimpleHapticsControllerWaveformsStatics, 1029144311, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{static interface IKnownSimpleHapticsControllerWaveformsStatics(IKnownSimpleHapticsControllerWaveformsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownSimpleHapticsControllerWaveformsStatics] {
    fn get_Click(&self, out: *mut u16) -> HRESULT,
    fn get_BuzzContinuous(&self, out: *mut u16) -> HRESULT,
    fn get_RumbleContinuous(&self, out: *mut u16) -> HRESULT,
    fn get_Press(&self, out: *mut u16) -> HRESULT,
    fn get_Release(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IKnownSimpleHapticsControllerWaveformsStatics> {
    #[inline] pub fn get_click(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Click)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_buzz_continuous(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BuzzContinuous)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rumble_continuous(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RumbleContinuous)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_press(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Press)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_release(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Release)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleHapticsController, 1029144313, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface ISimpleHapticsController(ISimpleHapticsControllerVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleHapticsController] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedFeedback(&self, out: *mut *mut foundation::collections::IVectorView<SimpleHapticsControllerFeedback>) -> HRESULT,
    fn get_IsIntensitySupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlayCountSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPlayDurationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsReplayPauseIntervalSupported(&self, out: *mut bool) -> HRESULT,
    fn StopFeedback(&self) -> HRESULT,
    fn SendHapticFeedback(&self, feedback: *mut SimpleHapticsControllerFeedback) -> HRESULT,
    fn SendHapticFeedbackWithIntensity(&self, feedback: *mut SimpleHapticsControllerFeedback, intensity: f64) -> HRESULT,
    fn SendHapticFeedbackForDuration(&self, feedback: *mut SimpleHapticsControllerFeedback, intensity: f64, playDuration: foundation::TimeSpan) -> HRESULT,
    fn SendHapticFeedbackForPlayCount(&self, feedback: *mut SimpleHapticsControllerFeedback, intensity: f64, playCount: i32, replayPauseInterval: foundation::TimeSpan) -> HRESULT
}}
impl ComPtr<ISimpleHapticsController> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_feedback(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SimpleHapticsControllerFeedback>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedFeedback)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_intensity_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsIntensitySupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_play_count_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPlayCountSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_play_duration_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPlayDurationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_replay_pause_interval_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsReplayPauseIntervalSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn stop_feedback(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StopFeedback)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback(&self, feedback: &ComPtr<SimpleHapticsControllerFeedback>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SendHapticFeedback)(self.deref() as *const _ as *mut _, feedback.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback_with_intensity(&self, feedback: &ComPtr<SimpleHapticsControllerFeedback>, intensity: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SendHapticFeedbackWithIntensity)(self.deref() as *const _ as *mut _, feedback.deref() as *const _ as *mut _, intensity);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback_for_duration(&self, feedback: &ComPtr<SimpleHapticsControllerFeedback>, intensity: f64, playDuration: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SendHapticFeedbackForDuration)(self.deref() as *const _ as *mut _, feedback.deref() as *const _ as *mut _, intensity, playDuration);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn send_haptic_feedback_for_play_count(&self, feedback: &ComPtr<SimpleHapticsControllerFeedback>, intensity: f64, playCount: i32, replayPauseInterval: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SendHapticFeedbackForPlayCount)(self.deref() as *const _ as *mut _, feedback.deref() as *const _ as *mut _, intensity, playCount, replayPauseInterval);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleHapticsController: ISimpleHapticsController}
DEFINE_IID!(IID_ISimpleHapticsControllerFeedback, 1029144312, 19694, 4582, 181, 53, 0, 27, 220, 6, 171, 59);
RT_INTERFACE!{interface ISimpleHapticsControllerFeedback(ISimpleHapticsControllerFeedbackVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleHapticsControllerFeedback] {
    fn get_Waveform(&self, out: *mut u16) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ComPtr<ISimpleHapticsControllerFeedback> {
    #[inline] pub fn get_waveform(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Waveform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Duration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleHapticsControllerFeedback: ISimpleHapticsControllerFeedback}
RT_ENUM! { enum VibrationAccessStatus: i32 {
    Allowed = 0, DeniedByUser = 1, DeniedBySystem = 2, DeniedByEnergySaver = 3,
}}
DEFINE_IID!(IID_IVibrationDevice, 1089608254, 34884, 18431, 179, 18, 6, 24, 90, 56, 68, 218);
RT_INTERFACE!{interface IVibrationDevice(IVibrationDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IVibrationDevice] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SimpleHapticsController(&self, out: *mut *mut SimpleHapticsController) -> HRESULT
}}
impl ComPtr<IVibrationDevice> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_simple_haptics_controller(&self) -> Result<Option<ComPtr<SimpleHapticsController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SimpleHapticsController)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class VibrationDevice: IVibrationDevice}
impl RtActivatable<IVibrationDeviceStatics> for VibrationDevice {}
impl VibrationDevice {
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<VibrationAccessStatus>>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().request_access_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<VibrationDevice>>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<VibrationDevice>>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn find_all_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<VibrationDevice>>>> {
        <Self as RtActivatable<IVibrationDeviceStatics>>::get_activation_factory().find_all_async()
    }
}
DEFINE_CLSID!(VibrationDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,97,112,116,105,99,115,46,86,105,98,114,97,116,105,111,110,68,101,118,105,99,101,0]) [CLSID_VibrationDevice]);
DEFINE_IID!(IID_IVibrationDeviceStatics, 1407380973, 8848, 19145, 142, 179, 26, 132, 18, 46, 183, 28);
RT_INTERFACE!{static interface IVibrationDeviceStatics(IVibrationDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVibrationDeviceStatics] {
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<VibrationAccessStatus>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<VibrationDevice>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<VibrationDevice>) -> HRESULT,
    fn FindAllAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<VibrationDevice>>) -> HRESULT
}}
impl ComPtr<IVibrationDeviceStatics> {
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<VibrationAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<VibrationDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<VibrationDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<VibrationDevice>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Haptics
pub mod humaninterfacedevice { // Windows.Devices.HumanInterfaceDevice
use crate::prelude::*;
DEFINE_IID!(IID_IHidBooleanControl, 1380840586, 13973, 16524, 187, 162, 226, 235, 90, 191, 188, 32);
RT_INTERFACE!{interface IHidBooleanControl(IHidBooleanControlVtbl): IInspectable(IInspectableVtbl) [IID_IHidBooleanControl] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn put_IsActive(&self, value: bool) -> HRESULT,
    fn get_ControlDescription(&self, out: *mut *mut HidBooleanControlDescription) -> HRESULT
}}
impl ComPtr<IHidBooleanControl> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsagePage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsActive)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_active(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsActive)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_description(&self) -> Result<Option<ComPtr<HidBooleanControlDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ControlDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidBooleanControl: IHidBooleanControl}
DEFINE_IID!(IID_IHidBooleanControlDescription, 1637279043, 10712, 18986, 134, 131, 132, 158, 32, 123, 190, 49);
RT_INTERFACE!{interface IHidBooleanControlDescription(IHidBooleanControlDescriptionVtbl): IInspectable(IInspectableVtbl) [IID_IHidBooleanControlDescription] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_ReportId(&self, out: *mut u16) -> HRESULT,
    fn get_ReportType(&self, out: *mut HidReportType) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_ParentCollections(&self, out: *mut *mut foundation::collections::IVectorView<HidCollection>) -> HRESULT
}}
impl ComPtr<IHidBooleanControlDescription> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_type(&self) -> Result<HidReportType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsagePage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_collections(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HidCollection>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ParentCollections)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidBooleanControlDescription: IHidBooleanControlDescription}
DEFINE_IID!(IID_IHidBooleanControlDescription2, 3371094762, 35447, 19510, 170, 0, 95, 240, 68, 157, 62, 115);
RT_INTERFACE!{interface IHidBooleanControlDescription2(IHidBooleanControlDescription2Vtbl): IInspectable(IInspectableVtbl) [IID_IHidBooleanControlDescription2] {
    fn get_IsAbsolute(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IHidBooleanControlDescription2> {
    #[inline] pub fn get_is_absolute(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsAbsolute)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHidCollection, 1904866723, 13041, 18147, 190, 253, 68, 210, 102, 59, 126, 106);
RT_INTERFACE!{interface IHidCollection(IHidCollectionVtbl): IInspectable(IInspectableVtbl) [IID_IHidCollection] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_Type(&self, out: *mut HidCollectionType) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u32) -> HRESULT,
    fn get_UsageId(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IHidCollection> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<HidCollectionType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Type)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsagePage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class HidCollection: IHidCollection}
RT_ENUM! { enum HidCollectionType: i32 {
    Physical = 0, Application = 1, Logical = 2, Report = 3, NamedArray = 4, UsageSwitch = 5, UsageModifier = 6, Other = 7,
}}
DEFINE_IID!(IID_IHidDevice, 1602884839, 8704, 17198, 149, 218, 208, 155, 135, 213, 116, 168);
RT_INTERFACE!{interface IHidDevice(IHidDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IHidDevice] {
    fn get_VendorId(&self, out: *mut u16) -> HRESULT,
    fn get_ProductId(&self, out: *mut u16) -> HRESULT,
    fn get_Version(&self, out: *mut u16) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn GetInputReportAsync(&self, out: *mut *mut foundation::IAsyncOperation<HidInputReport>) -> HRESULT,
    fn GetInputReportByIdAsync(&self, reportId: u16, out: *mut *mut foundation::IAsyncOperation<HidInputReport>) -> HRESULT,
    fn GetFeatureReportAsync(&self, out: *mut *mut foundation::IAsyncOperation<HidFeatureReport>) -> HRESULT,
    fn GetFeatureReportByIdAsync(&self, reportId: u16, out: *mut *mut foundation::IAsyncOperation<HidFeatureReport>) -> HRESULT,
    fn CreateOutputReport(&self, out: *mut *mut HidOutputReport) -> HRESULT,
    fn CreateOutputReportById(&self, reportId: u16, out: *mut *mut HidOutputReport) -> HRESULT,
    fn CreateFeatureReport(&self, out: *mut *mut HidFeatureReport) -> HRESULT,
    fn CreateFeatureReportById(&self, reportId: u16, out: *mut *mut HidFeatureReport) -> HRESULT,
    fn SendOutputReportAsync(&self, outputReport: *mut HidOutputReport, out: *mut *mut foundation::IAsyncOperation<u32>) -> HRESULT,
    fn SendFeatureReportAsync(&self, featureReport: *mut HidFeatureReport, out: *mut *mut foundation::IAsyncOperation<u32>) -> HRESULT,
    fn GetBooleanControlDescriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16, out: *mut *mut foundation::collections::IVectorView<HidBooleanControlDescription>) -> HRESULT,
    fn GetNumericControlDescriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16, out: *mut *mut foundation::collections::IVectorView<HidNumericControlDescription>) -> HRESULT,
    fn add_InputReportReceived(&self, reportHandler: *mut foundation::TypedEventHandler<HidDevice, HidInputReportReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_InputReportReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IHidDevice> {
    #[inline] pub fn get_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_VendorId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProductId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_version(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Version)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsagePage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_input_report_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<HidInputReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetInputReportAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_input_report_by_id_async(&self, reportId: u16) -> Result<ComPtr<foundation::IAsyncOperation<HidInputReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetInputReportByIdAsync)(self.deref() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_feature_report_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<HidFeatureReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetFeatureReportAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_feature_report_by_id_async(&self, reportId: u16) -> Result<ComPtr<foundation::IAsyncOperation<HidFeatureReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetFeatureReportByIdAsync)(self.deref() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_output_report(&self) -> Result<Option<ComPtr<HidOutputReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateOutputReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_output_report_by_id(&self, reportId: u16) -> Result<Option<ComPtr<HidOutputReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateOutputReportById)(self.deref() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_feature_report(&self) -> Result<Option<ComPtr<HidFeatureReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFeatureReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_feature_report_by_id(&self, reportId: u16) -> Result<Option<ComPtr<HidFeatureReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFeatureReportById)(self.deref() as *const _ as *mut _, reportId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_output_report_async(&self, outputReport: &ComPtr<HidOutputReport>) -> Result<ComPtr<foundation::IAsyncOperation<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendOutputReportAsync)(self.deref() as *const _ as *mut _, outputReport.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_feature_report_async(&self, featureReport: &ComPtr<HidFeatureReport>) -> Result<ComPtr<foundation::IAsyncOperation<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendFeatureReportAsync)(self.deref() as *const _ as *mut _, featureReport.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_descriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<foundation::collections::IVectorView<HidBooleanControlDescription>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControlDescriptions)(self.deref() as *const _ as *mut _, reportType, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_descriptions(&self, reportType: HidReportType, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<foundation::collections::IVectorView<HidNumericControlDescription>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControlDescriptions)(self.deref() as *const _ as *mut _, reportType, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_input_report_received(&self, reportHandler: &ComPtr<foundation::TypedEventHandler<HidDevice, HidInputReportReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_InputReportReceived)(self.deref() as *const _ as *mut _, reportHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_input_report_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_InputReportReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class HidDevice: IHidDevice}
impl RtActivatable<IHidDeviceStatics> for HidDevice {}
impl HidDevice {
    #[inline] pub fn get_device_selector(usagePage: u16, usageId: u16) -> Result<HString> {
        <Self as RtActivatable<IHidDeviceStatics>>::get_activation_factory().get_device_selector(usagePage, usageId)
    }
    #[inline] pub fn get_device_selector_vid_pid(usagePage: u16, usageId: u16, vendorId: u16, productId: u16) -> Result<HString> {
        <Self as RtActivatable<IHidDeviceStatics>>::get_activation_factory().get_device_selector_vid_pid(usagePage, usageId, vendorId, productId)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id_async(deviceId: &HStringArg, accessMode: super::super::storage::FileAccessMode) -> Result<ComPtr<foundation::IAsyncOperation<HidDevice>>> {
        <Self as RtActivatable<IHidDeviceStatics>>::get_activation_factory().from_id_async(deviceId, accessMode)
    }
}
DEFINE_CLSID!(HidDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,72,117,109,97,110,73,110,116,101,114,102,97,99,101,68,101,118,105,99,101,46,72,105,100,68,101,118,105,99,101,0]) [CLSID_HidDevice]);
DEFINE_IID!(IID_IHidDeviceStatics, 2656666084, 38998, 16780, 159, 115, 119, 222, 12, 216, 87, 84);
RT_INTERFACE!{static interface IHidDeviceStatics(IHidDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHidDeviceStatics] {
    fn GetDeviceSelector(&self, usagePage: u16, usageId: u16, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorVidPid(&self, usagePage: u16, usageId: u16, vendorId: u16, productId: u16, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn FromIdAsync(&self, deviceId: HSTRING, accessMode: super::super::storage::FileAccessMode, out: *mut *mut foundation::IAsyncOperation<HidDevice>) -> HRESULT
}}
impl ComPtr<IHidDeviceStatics> {
    #[inline] pub fn get_device_selector(&self, usagePage: u16, usageId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_vid_pid(&self, usagePage: u16, usageId: u16, vendorId: u16, productId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorVidPid)(self.deref() as *const _ as *mut _, usagePage, usageId, vendorId, productId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, accessMode: super::super::storage::FileAccessMode) -> Result<ComPtr<foundation::IAsyncOperation<HidDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), accessMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHidFeatureReport, 2216532857, 23269, 18147, 130, 239, 31, 236, 92, 137, 66, 244);
RT_INTERFACE!{interface IHidFeatureReport(IHidFeatureReportVtbl): IInspectable(IInspectableVtbl) [IID_IHidFeatureReport] {
    fn get_Id(&self, out: *mut u16) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn GetBooleanControl(&self, usagePage: u16, usageId: u16, out: *mut *mut HidBooleanControl) -> HRESULT,
    fn GetBooleanControlByDescription(&self, controlDescription: *mut HidBooleanControlDescription, out: *mut *mut HidBooleanControl) -> HRESULT,
    fn GetNumericControl(&self, usagePage: u16, usageId: u16, out: *mut *mut HidNumericControl) -> HRESULT,
    fn GetNumericControlByDescription(&self, controlDescription: *mut HidNumericControlDescription, out: *mut *mut HidNumericControl) -> HRESULT
}}
impl ComPtr<IHidFeatureReport> {
    #[inline] pub fn get_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Data)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControl)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_by_description(&self, controlDescription: &ComPtr<HidBooleanControlDescription>) -> Result<Option<ComPtr<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControlByDescription)(self.deref() as *const _ as *mut _, controlDescription.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<HidNumericControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControl)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_by_description(&self, controlDescription: &ComPtr<HidNumericControlDescription>) -> Result<Option<ComPtr<HidNumericControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControlByDescription)(self.deref() as *const _ as *mut _, controlDescription.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidFeatureReport: IHidFeatureReport}
DEFINE_IID!(IID_IHidInputReport, 3277655632, 63463, 20109, 178, 62, 202, 187, 229, 107, 144, 233);
RT_INTERFACE!{interface IHidInputReport(IHidInputReportVtbl): IInspectable(IInspectableVtbl) [IID_IHidInputReport] {
    fn get_Id(&self, out: *mut u16) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_ActivatedBooleanControls(&self, out: *mut *mut foundation::collections::IVectorView<HidBooleanControl>) -> HRESULT,
    fn get_TransitionedBooleanControls(&self, out: *mut *mut foundation::collections::IVectorView<HidBooleanControl>) -> HRESULT,
    fn GetBooleanControl(&self, usagePage: u16, usageId: u16, out: *mut *mut HidBooleanControl) -> HRESULT,
    fn GetBooleanControlByDescription(&self, controlDescription: *mut HidBooleanControlDescription, out: *mut *mut HidBooleanControl) -> HRESULT,
    fn GetNumericControl(&self, usagePage: u16, usageId: u16, out: *mut *mut HidNumericControl) -> HRESULT,
    fn GetNumericControlByDescription(&self, controlDescription: *mut HidNumericControlDescription, out: *mut *mut HidNumericControl) -> HRESULT
}}
impl ComPtr<IHidInputReport> {
    #[inline] pub fn get_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_activated_boolean_controls(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HidBooleanControl>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ActivatedBooleanControls)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_transitioned_boolean_controls(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HidBooleanControl>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TransitionedBooleanControls)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControl)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_by_description(&self, controlDescription: &ComPtr<HidBooleanControlDescription>) -> Result<Option<ComPtr<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControlByDescription)(self.deref() as *const _ as *mut _, controlDescription.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<HidNumericControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControl)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_by_description(&self, controlDescription: &ComPtr<HidNumericControlDescription>) -> Result<Option<ComPtr<HidNumericControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControlByDescription)(self.deref() as *const _ as *mut _, controlDescription.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidInputReport: IHidInputReport}
DEFINE_IID!(IID_IHidInputReportReceivedEventArgs, 1884931531, 22962, 19906, 152, 92, 10, 220, 97, 54, 250, 45);
RT_INTERFACE!{interface IHidInputReportReceivedEventArgs(IHidInputReportReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHidInputReportReceivedEventArgs] {
    fn get_Report(&self, out: *mut *mut HidInputReport) -> HRESULT
}}
impl ComPtr<IHidInputReportReceivedEventArgs> {
    #[inline] pub fn get_report(&self) -> Result<Option<ComPtr<HidInputReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Report)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidInputReportReceivedEventArgs: IHidInputReportReceivedEventArgs}
DEFINE_IID!(IID_IHidNumericControl, 3817476773, 13735, 19317, 137, 200, 251, 31, 40, 177, 8, 35);
RT_INTERFACE!{interface IHidNumericControl(IHidNumericControlVtbl): IInspectable(IInspectableVtbl) [IID_IHidNumericControl] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_IsGrouped(&self, out: *mut bool) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_Value(&self, out: *mut i64) -> HRESULT,
    fn put_Value(&self, value: i64) -> HRESULT,
    fn get_ScaledValue(&self, out: *mut i64) -> HRESULT,
    fn put_ScaledValue(&self, value: i64) -> HRESULT,
    fn get_ControlDescription(&self, out: *mut *mut HidNumericControlDescription) -> HRESULT
}}
impl ComPtr<IHidNumericControl> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_grouped(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsGrouped)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsagePage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<i64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: i64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Value)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scaled_value(&self) -> Result<i64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScaledValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scaled_value(&self, value: i64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ScaledValue)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_description(&self) -> Result<Option<ComPtr<HidNumericControlDescription>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ControlDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidNumericControl: IHidNumericControl}
DEFINE_IID!(IID_IHidNumericControlDescription, 1670209158, 7575, 19573, 146, 127, 95, 245, 139, 160, 94, 50);
RT_INTERFACE!{interface IHidNumericControlDescription(IHidNumericControlDescriptionVtbl): IInspectable(IInspectableVtbl) [IID_IHidNumericControlDescription] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_ReportId(&self, out: *mut u16) -> HRESULT,
    fn get_ReportType(&self, out: *mut HidReportType) -> HRESULT,
    fn get_ReportSize(&self, out: *mut u32) -> HRESULT,
    fn get_ReportCount(&self, out: *mut u32) -> HRESULT,
    fn get_UsagePage(&self, out: *mut u16) -> HRESULT,
    fn get_UsageId(&self, out: *mut u16) -> HRESULT,
    fn get_LogicalMinimum(&self, out: *mut i32) -> HRESULT,
    fn get_LogicalMaximum(&self, out: *mut i32) -> HRESULT,
    fn get_PhysicalMinimum(&self, out: *mut i32) -> HRESULT,
    fn get_PhysicalMaximum(&self, out: *mut i32) -> HRESULT,
    fn get_UnitExponent(&self, out: *mut u32) -> HRESULT,
    fn get_Unit(&self, out: *mut u32) -> HRESULT,
    fn get_IsAbsolute(&self, out: *mut bool) -> HRESULT,
    fn get_HasNull(&self, out: *mut bool) -> HRESULT,
    fn get_ParentCollections(&self, out: *mut *mut foundation::collections::IVectorView<HidCollection>) -> HRESULT
}}
impl ComPtr<IHidNumericControlDescription> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_type(&self) -> Result<HidReportType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_page(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsagePage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usage_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsageId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_logical_minimum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LogicalMinimum)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_logical_maximum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LogicalMaximum)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_minimum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PhysicalMinimum)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_maximum(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PhysicalMaximum)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unit_exponent(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UnitExponent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_unit(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Unit)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_absolute(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsAbsolute)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_null(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HasNull)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_collections(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HidCollection>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ParentCollections)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidNumericControlDescription: IHidNumericControlDescription}
DEFINE_IID!(IID_IHidOutputReport, 1657480516, 51350, 17507, 147, 193, 223, 157, 176, 83, 196, 80);
RT_INTERFACE!{interface IHidOutputReport(IHidOutputReportVtbl): IInspectable(IInspectableVtbl) [IID_IHidOutputReport] {
    fn get_Id(&self, out: *mut u16) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn GetBooleanControl(&self, usagePage: u16, usageId: u16, out: *mut *mut HidBooleanControl) -> HRESULT,
    fn GetBooleanControlByDescription(&self, controlDescription: *mut HidBooleanControlDescription, out: *mut *mut HidBooleanControl) -> HRESULT,
    fn GetNumericControl(&self, usagePage: u16, usageId: u16, out: *mut *mut HidNumericControl) -> HRESULT,
    fn GetNumericControlByDescription(&self, controlDescription: *mut HidNumericControlDescription, out: *mut *mut HidNumericControl) -> HRESULT
}}
impl ComPtr<IHidOutputReport> {
    #[inline] pub fn get_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_data(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Data)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControl)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_by_description(&self, controlDescription: &ComPtr<HidBooleanControlDescription>) -> Result<Option<ComPtr<HidBooleanControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControlByDescription)(self.deref() as *const _ as *mut _, controlDescription.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<HidNumericControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControl)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_by_description(&self, controlDescription: &ComPtr<HidNumericControlDescription>) -> Result<Option<ComPtr<HidNumericControl>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControlByDescription)(self.deref() as *const _ as *mut _, controlDescription.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HidOutputReport: IHidOutputReport}
RT_ENUM! { enum HidReportType: i32 {
    Input = 0, Output = 1, Feature = 2,
}}
} // Windows.Devices.HumanInterfaceDevice
pub mod i2c { // Windows.Devices.I2c
use crate::prelude::*;
RT_ENUM! { enum I2cBusSpeed: i32 {
    StandardMode = 0, FastMode = 1,
}}
DEFINE_IID!(IID_II2cConnectionSettings, 4074443527, 43887, 17977, 167, 103, 84, 83, 109, 195, 70, 15);
RT_INTERFACE!{interface II2cConnectionSettings(II2cConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_II2cConnectionSettings] {
    fn get_SlaveAddress(&self, out: *mut i32) -> HRESULT,
    fn put_SlaveAddress(&self, value: i32) -> HRESULT,
    fn get_BusSpeed(&self, out: *mut I2cBusSpeed) -> HRESULT,
    fn put_BusSpeed(&self, value: I2cBusSpeed) -> HRESULT,
    fn get_SharingMode(&self, out: *mut I2cSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: I2cSharingMode) -> HRESULT
}}
impl ComPtr<II2cConnectionSettings> {
    #[inline] pub fn get_slave_address(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SlaveAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_slave_address(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SlaveAddress)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_speed(&self) -> Result<I2cBusSpeed> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BusSpeed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bus_speed(&self, value: I2cBusSpeed) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BusSpeed)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<I2cSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: I2cSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SharingMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class I2cConnectionSettings: II2cConnectionSettings}
impl RtActivatable<II2cConnectionSettingsFactory> for I2cConnectionSettings {}
impl I2cConnectionSettings {
    #[inline] pub fn create(slaveAddress: i32) -> Result<ComPtr<I2cConnectionSettings>> {
        <Self as RtActivatable<II2cConnectionSettingsFactory>>::get_activation_factory().create(slaveAddress)
    }
}
DEFINE_CLSID!(I2cConnectionSettings(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_I2cConnectionSettings]);
DEFINE_IID!(IID_II2cConnectionSettingsFactory, 2176157363, 38547, 16817, 162, 67, 222, 212, 246, 230, 105, 38);
RT_INTERFACE!{static interface II2cConnectionSettingsFactory(II2cConnectionSettingsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_II2cConnectionSettingsFactory] {
    fn Create(&self, slaveAddress: i32, out: *mut *mut I2cConnectionSettings) -> HRESULT
}}
impl ComPtr<II2cConnectionSettingsFactory> {
    #[inline] pub fn create(&self, slaveAddress: i32) -> Result<ComPtr<I2cConnectionSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, slaveAddress, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cController, 3297423794, 34720, 16742, 142, 62, 180, 184, 249, 124, 215, 41);
RT_INTERFACE!{interface II2cController(II2cControllerVtbl): IInspectable(IInspectableVtbl) [IID_II2cController] {
    fn GetDevice(&self, settings: *mut I2cConnectionSettings, out: *mut *mut I2cDevice) -> HRESULT
}}
impl ComPtr<II2cController> {
    #[inline] pub fn get_device(&self, settings: &ComPtr<I2cConnectionSettings>) -> Result<Option<ComPtr<I2cDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDevice)(self.deref() as *const _ as *mut _, settings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class I2cController: II2cController}
impl RtActivatable<II2cControllerStatics> for I2cController {}
impl I2cController {
    #[inline] pub fn get_controllers_async(provider: &ComPtr<provider::II2cProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<I2cController>>>> {
        <Self as RtActivatable<II2cControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<I2cController>>> {
        <Self as RtActivatable<II2cControllerStatics>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(I2cController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_I2cController]);
DEFINE_IID!(IID_II2cControllerStatics, 1090257765, 24325, 20094, 132, 189, 16, 13, 184, 224, 174, 197);
RT_INTERFACE!{static interface II2cControllerStatics(II2cControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_II2cControllerStatics] {
    fn GetControllersAsync(&self, provider: *mut provider::II2cProvider, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<I2cController>>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<I2cController>) -> HRESULT
}}
impl ComPtr<II2cControllerStatics> {
    #[inline] pub fn get_controllers_async(&self, provider: &ComPtr<provider::II2cProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<I2cController>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<I2cController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cDevice, 2251735350, 47557, 20336, 148, 73, 204, 70, 220, 111, 87, 235);
RT_INTERFACE!{interface II2cDevice(II2cDeviceVtbl): IInspectable(IInspectableVtbl) [IID_II2cDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionSettings(&self, out: *mut *mut I2cConnectionSettings) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn WritePartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut I2cTransferResult) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn ReadPartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut I2cTransferResult) -> HRESULT,
    fn WriteRead(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn WriteReadPartial(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8, out: *mut I2cTransferResult) -> HRESULT
}}
impl ComPtr<II2cDevice> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_settings(&self) -> Result<Option<ComPtr<I2cConnectionSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionSettings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Write)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_partial(&self, buffer: &[u8]) -> Result<I2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).WritePartial)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_partial(&self, buffer: &mut [u8]) -> Result<I2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ReadPartial)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn write_read(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).WriteRead)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_read_partial(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<I2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).WriteReadPartial)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class I2cDevice: II2cDevice}
impl RtActivatable<II2cDeviceStatics> for I2cDevice {}
impl I2cDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<II2cDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_friendly_name(friendlyName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<II2cDeviceStatics>>::get_activation_factory().get_device_selector_from_friendly_name(friendlyName)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg, settings: &ComPtr<I2cConnectionSettings>) -> Result<ComPtr<foundation::IAsyncOperation<I2cDevice>>> {
        <Self as RtActivatable<II2cDeviceStatics>>::get_activation_factory().from_id_async(deviceId, settings)
    }
}
DEFINE_CLSID!(I2cDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,50,99,46,73,50,99,68,101,118,105,99,101,0]) [CLSID_I2cDevice]);
DEFINE_IID!(IID_II2cDeviceStatics, 2443394019, 29492, 17682, 150, 188, 251, 174, 148, 89, 245, 246);
RT_INTERFACE!{static interface II2cDeviceStatics(II2cDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_II2cDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromFriendlyName(&self, friendlyName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, settings: *mut I2cConnectionSettings, out: *mut *mut foundation::IAsyncOperation<I2cDevice>) -> HRESULT
}}
impl ComPtr<II2cDeviceStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_friendly_name(&self, friendlyName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromFriendlyName)(self.deref() as *const _ as *mut _, friendlyName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, settings: &ComPtr<I2cConnectionSettings>) -> Result<ComPtr<foundation::IAsyncOperation<I2cDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), settings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum I2cSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
RT_STRUCT! { struct I2cTransferResult {
    Status: I2cTransferStatus, BytesTransferred: u32,
}}
RT_ENUM! { enum I2cTransferStatus: i32 {
    FullTransfer = 0, PartialTransfer = 1, SlaveAddressNotAcknowledged = 2, ClockStretchTimeout = 3, UnknownError = 4,
}}
pub mod provider { // Windows.Devices.I2c.Provider
use crate::prelude::*;
DEFINE_IID!(IID_II2cControllerProvider, 1640151938, 17680, 16739, 168, 124, 78, 21, 169, 85, 137, 128);
RT_INTERFACE!{interface II2cControllerProvider(II2cControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_II2cControllerProvider] {
    fn GetDeviceProvider(&self, settings: *mut ProviderI2cConnectionSettings, out: *mut *mut II2cDeviceProvider) -> HRESULT
}}
impl ComPtr<II2cControllerProvider> {
    #[inline] pub fn get_device_provider(&self, settings: &ComPtr<ProviderI2cConnectionSettings>) -> Result<Option<ComPtr<II2cDeviceProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceProvider)(self.deref() as *const _ as *mut _, settings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cDeviceProvider, 2905876052, 22504, 17726, 131, 41, 209, 228, 71, 209, 3, 169);
RT_INTERFACE!{interface II2cDeviceProvider(II2cDeviceProviderVtbl): IInspectable(IInspectableVtbl) [IID_II2cDeviceProvider] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn WritePartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut ProviderI2cTransferResult) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn ReadPartial(&self, bufferSize: u32, buffer: *mut u8, out: *mut ProviderI2cTransferResult) -> HRESULT,
    fn WriteRead(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn WriteReadPartial(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8, out: *mut ProviderI2cTransferResult) -> HRESULT
}}
impl ComPtr<II2cDeviceProvider> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Write)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_partial(&self, buffer: &[u8]) -> Result<ProviderI2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).WritePartial)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read_partial(&self, buffer: &mut [u8]) -> Result<ProviderI2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ReadPartial)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn write_read(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).WriteRead)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn write_read_partial(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<ProviderI2cTransferResult> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).WriteReadPartial)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_II2cProvider, 1863518270, 48994, 20450, 169, 90, 240, 137, 153, 102, 152, 24);
RT_INTERFACE!{interface II2cProvider(II2cProviderVtbl): IInspectable(IInspectableVtbl) [IID_II2cProvider] {
    fn GetControllersAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<II2cControllerProvider>>) -> HRESULT
}}
impl ComPtr<II2cProvider> {
    #[inline] pub fn get_controllers_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<II2cControllerProvider>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderI2cBusSpeed: i32 {
    StandardMode = 0, FastMode = 1,
}}
DEFINE_IID!(IID_IProviderI2cConnectionSettings, 3923463732, 58640, 17591, 128, 157, 242, 248, 91, 85, 83, 57);
RT_INTERFACE!{interface IProviderI2cConnectionSettings(IProviderI2cConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IProviderI2cConnectionSettings] {
    fn get_SlaveAddress(&self, out: *mut i32) -> HRESULT,
    fn put_SlaveAddress(&self, value: i32) -> HRESULT,
    fn get_BusSpeed(&self, out: *mut ProviderI2cBusSpeed) -> HRESULT,
    fn put_BusSpeed(&self, value: ProviderI2cBusSpeed) -> HRESULT,
    fn get_SharingMode(&self, out: *mut ProviderI2cSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: ProviderI2cSharingMode) -> HRESULT
}}
impl ComPtr<IProviderI2cConnectionSettings> {
    #[inline] pub fn get_slave_address(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SlaveAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_slave_address(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SlaveAddress)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_speed(&self) -> Result<ProviderI2cBusSpeed> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BusSpeed)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_bus_speed(&self, value: ProviderI2cBusSpeed) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BusSpeed)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<ProviderI2cSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: ProviderI2cSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SharingMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ProviderI2cConnectionSettings: IProviderI2cConnectionSettings}
RT_ENUM! { enum ProviderI2cSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
RT_STRUCT! { struct ProviderI2cTransferResult {
    Status: ProviderI2cTransferStatus, BytesTransferred: u32,
}}
RT_ENUM! { enum ProviderI2cTransferStatus: i32 {
    FullTransfer = 0, PartialTransfer = 1, SlaveAddressNotAcknowledged = 2,
}}
} // Windows.Devices.I2c.Provider
} // Windows.Devices.I2c
pub mod input { // Windows.Devices.Input
use crate::prelude::*;
DEFINE_IID!(IID_IKeyboardCapabilities, 977247062, 26520, 19388, 131, 62, 15, 52, 177, 124, 101, 255);
RT_INTERFACE!{interface IKeyboardCapabilities(IKeyboardCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IKeyboardCapabilities] {
    fn get_KeyboardPresent(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<IKeyboardCapabilities> {
    #[inline] pub fn get_keyboard_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_KeyboardPresent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class KeyboardCapabilities: IKeyboardCapabilities}
impl RtActivatable<IActivationFactory> for KeyboardCapabilities {}
DEFINE_CLSID!(KeyboardCapabilities(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,75,101,121,98,111,97,114,100,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_KeyboardCapabilities]);
DEFINE_IID!(IID_IMouseCapabilities, 3164987427, 32217, 19307, 154, 146, 85, 212, 60, 179, 143, 115);
RT_INTERFACE!{interface IMouseCapabilities(IMouseCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IMouseCapabilities] {
    fn get_MousePresent(&self, out: *mut i32) -> HRESULT,
    fn get_VerticalWheelPresent(&self, out: *mut i32) -> HRESULT,
    fn get_HorizontalWheelPresent(&self, out: *mut i32) -> HRESULT,
    fn get_SwapButtons(&self, out: *mut i32) -> HRESULT,
    fn get_NumberOfButtons(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IMouseCapabilities> {
    #[inline] pub fn get_mouse_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MousePresent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_vertical_wheel_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_VerticalWheelPresent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_horizontal_wheel_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HorizontalWheelPresent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_swap_buttons(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SwapButtons)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_number_of_buttons(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NumberOfButtons)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseCapabilities: IMouseCapabilities}
impl RtActivatable<IActivationFactory> for MouseCapabilities {}
DEFINE_CLSID!(MouseCapabilities(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,77,111,117,115,101,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_MouseCapabilities]);
RT_STRUCT! { struct MouseDelta {
    X: i32, Y: i32,
}}
DEFINE_IID!(IID_IMouseDevice, 2297295960, 62152, 18932, 190, 31, 194, 86, 179, 136, 188, 17);
RT_INTERFACE!{interface IMouseDevice(IMouseDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IMouseDevice] {
    fn add_MouseMoved(&self, handler: *mut foundation::TypedEventHandler<MouseDevice, MouseEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MouseMoved(&self, cookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IMouseDevice> {
    #[inline] pub fn add_mouse_moved(&self, handler: &ComPtr<foundation::TypedEventHandler<MouseDevice, MouseEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MouseMoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_mouse_moved(&self, cookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MouseMoved)(self.deref() as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseDevice: IMouseDevice}
impl RtActivatable<IMouseDeviceStatics> for MouseDevice {}
impl MouseDevice {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<MouseDevice>>> {
        <Self as RtActivatable<IMouseDeviceStatics>>::get_activation_factory().get_for_current_view()
    }
}
DEFINE_CLSID!(MouseDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,77,111,117,115,101,68,101,118,105,99,101,0]) [CLSID_MouseDevice]);
DEFINE_IID!(IID_IMouseDeviceStatics, 1212846149, 28016, 18907, 142, 104, 70, 255, 189, 23, 211, 141);
RT_INTERFACE!{static interface IMouseDeviceStatics(IMouseDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMouseDeviceStatics] {
    fn GetForCurrentView(&self, out: *mut *mut MouseDevice) -> HRESULT
}}
impl ComPtr<IMouseDeviceStatics> {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<MouseDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetForCurrentView)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMouseEventArgs, 4129663581, 9044, 19655, 146, 48, 150, 148, 28, 150, 159, 222);
RT_INTERFACE!{interface IMouseEventArgs(IMouseEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMouseEventArgs] {
    fn get_MouseDelta(&self, out: *mut MouseDelta) -> HRESULT
}}
impl ComPtr<IMouseEventArgs> {
    #[inline] pub fn get_mouse_delta(&self) -> Result<MouseDelta> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MouseDelta)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MouseEventArgs: IMouseEventArgs}
DEFINE_IID!(IID_IPointerDevice, 2479471356, 60363, 18046, 130, 198, 39, 111, 234, 227, 107, 90);
RT_INTERFACE!{interface IPointerDevice(IPointerDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IPointerDevice] {
    fn get_PointerDeviceType(&self, out: *mut PointerDeviceType) -> HRESULT,
    fn get_IsIntegrated(&self, out: *mut bool) -> HRESULT,
    fn get_MaxContacts(&self, out: *mut u32) -> HRESULT,
    fn get_PhysicalDeviceRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_ScreenRect(&self, out: *mut foundation::Rect) -> HRESULT,
    fn get_SupportedUsages(&self, out: *mut *mut foundation::collections::IVectorView<PointerDeviceUsage>) -> HRESULT
}}
impl ComPtr<IPointerDevice> {
    #[inline] pub fn get_pointer_device_type(&self) -> Result<PointerDeviceType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PointerDeviceType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_integrated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsIntegrated)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_contacts(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxContacts)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PhysicalDeviceRect)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_screen_rect(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScreenRect)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_usages(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PointerDeviceUsage>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedUsages)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PointerDevice: IPointerDevice}
impl RtActivatable<IPointerDeviceStatics> for PointerDevice {}
impl PointerDevice {
    #[inline] pub fn get_pointer_device(pointerId: u32) -> Result<Option<ComPtr<PointerDevice>>> {
        <Self as RtActivatable<IPointerDeviceStatics>>::get_activation_factory().get_pointer_device(pointerId)
    }
    #[inline] pub fn get_pointer_devices() -> Result<Option<ComPtr<foundation::collections::IVectorView<PointerDevice>>>> {
        <Self as RtActivatable<IPointerDeviceStatics>>::get_activation_factory().get_pointer_devices()
    }
}
DEFINE_CLSID!(PointerDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,80,111,105,110,116,101,114,68,101,118,105,99,101,0]) [CLSID_PointerDevice]);
DEFINE_IID!(IID_IPointerDevice2, 4171682464, 50308, 18591, 174, 62, 48, 210, 238, 31, 253, 62);
RT_INTERFACE!{interface IPointerDevice2(IPointerDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_IPointerDevice2] {
    fn get_MaxPointersWithZDistance(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IPointerDevice2> {
    #[inline] pub fn get_max_pointers_with_z_distance(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPointersWithZDistance)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPointerDeviceStatics, 3635976865, 53702, 16750, 189, 141, 87, 144, 145, 77, 197, 99);
RT_INTERFACE!{static interface IPointerDeviceStatics(IPointerDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPointerDeviceStatics] {
    fn GetPointerDevice(&self, pointerId: u32, out: *mut *mut PointerDevice) -> HRESULT,
    fn GetPointerDevices(&self, out: *mut *mut foundation::collections::IVectorView<PointerDevice>) -> HRESULT
}}
impl ComPtr<IPointerDeviceStatics> {
    #[inline] pub fn get_pointer_device(&self, pointerId: u32) -> Result<Option<ComPtr<PointerDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetPointerDevice)(self.deref() as *const _ as *mut _, pointerId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_pointer_devices(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PointerDevice>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetPointerDevices)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PointerDeviceType: i32 {
    Touch = 0, Pen = 1, Mouse = 2,
}}
RT_STRUCT! { struct PointerDeviceUsage {
    UsagePage: u32, Usage: u32, MinLogical: i32, MaxLogical: i32, MinPhysical: i32, MaxPhysical: i32, Unit: u32, PhysicalMultiplier: f32,
}}
DEFINE_IID!(IID_ITouchCapabilities, 551376377, 5105, 18120, 146, 133, 44, 5, 250, 62, 218, 111);
RT_INTERFACE!{interface ITouchCapabilities(ITouchCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ITouchCapabilities] {
    fn get_TouchPresent(&self, out: *mut i32) -> HRESULT,
    fn get_Contacts(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ITouchCapabilities> {
    #[inline] pub fn get_touch_present(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TouchPresent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contacts(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Contacts)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class TouchCapabilities: ITouchCapabilities}
impl RtActivatable<IActivationFactory> for TouchCapabilities {}
DEFINE_CLSID!(TouchCapabilities(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,84,111,117,99,104,67,97,112,97,98,105,108,105,116,105,101,115,0]) [CLSID_TouchCapabilities]);
pub mod preview { // Windows.Devices.Input.Preview
use crate::prelude::*;
RT_ENUM! { enum GazeDeviceConfigurationStatePreview: i32 {
    Unknown = 0, Ready = 1, Configuring = 2, ScreenSetupNeeded = 3, UserCalibrationNeeded = 4,
}}
DEFINE_IID!(IID_IGazeDevicePreview, 3885924073, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeDevicePreview(IGazeDevicePreviewVtbl): IInspectable(IInspectableVtbl) [IID_IGazeDevicePreview] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_CanTrackEyes(&self, out: *mut bool) -> HRESULT,
    fn get_CanTrackHead(&self, out: *mut bool) -> HRESULT,
    fn get_ConfigurationState(&self, out: *mut GazeDeviceConfigurationStatePreview) -> HRESULT,
    fn RequestCalibrationAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn GetNumericControlDescriptions(&self, usagePage: u16, usageId: u16, out: *mut *mut foundation::collections::IVectorView<super::super::humaninterfacedevice::HidNumericControlDescription>) -> HRESULT,
    fn GetBooleanControlDescriptions(&self, usagePage: u16, usageId: u16, out: *mut *mut foundation::collections::IVectorView<super::super::humaninterfacedevice::HidBooleanControlDescription>) -> HRESULT
}}
impl ComPtr<IGazeDevicePreview> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_track_eyes(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanTrackEyes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_track_head(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanTrackHead)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration_state(&self) -> Result<GazeDeviceConfigurationStatePreview> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConfigurationState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn request_calibration_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestCalibrationAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_numeric_control_descriptions(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::humaninterfacedevice::HidNumericControlDescription>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNumericControlDescriptions)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_boolean_control_descriptions(&self, usagePage: u16, usageId: u16) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::humaninterfacedevice::HidBooleanControlDescription>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBooleanControlDescriptions)(self.deref() as *const _ as *mut _, usagePage, usageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDevicePreview: IGazeDevicePreview}
DEFINE_IID!(IID_IGazeDeviceWatcherAddedPreviewEventArgs, 3885924077, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeDeviceWatcherAddedPreviewEventArgs(IGazeDeviceWatcherAddedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherAddedPreviewEventArgs] {
    fn get_Device(&self, out: *mut *mut GazeDevicePreview) -> HRESULT
}}
impl ComPtr<IGazeDeviceWatcherAddedPreviewEventArgs> {
    #[inline] pub fn get_device(&self) -> Result<Option<ComPtr<GazeDevicePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Device)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherAddedPreviewEventArgs: IGazeDeviceWatcherAddedPreviewEventArgs}
DEFINE_IID!(IID_IGazeDeviceWatcherPreview, 3885924071, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeDeviceWatcherPreview(IGazeDeviceWatcherPreviewVtbl): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherPreview] {
    fn add_Added(&self, handler: *mut foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherAddedPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Added(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Removed(&self, handler: *mut foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherRemovedPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Removed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Updated(&self, handler: *mut foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherUpdatedPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Updated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: *mut foundation::TypedEventHandler<GazeDeviceWatcherPreview, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IGazeDeviceWatcherPreview> {
    #[inline] pub fn add_added(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherAddedPreviewEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Added)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Added)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherRemovedPreviewEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Removed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Removed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeDeviceWatcherPreview, GazeDeviceWatcherUpdatedPreviewEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Updated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Updated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeDeviceWatcherPreview, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnumerationCompleted)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnumerationCompleted)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherPreview: IGazeDeviceWatcherPreview}
DEFINE_IID!(IID_IGazeDeviceWatcherRemovedPreviewEventArgs, 4066582280, 3647, 17183, 166, 6, 80, 179, 90, 249, 74, 28);
RT_INTERFACE!{interface IGazeDeviceWatcherRemovedPreviewEventArgs(IGazeDeviceWatcherRemovedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherRemovedPreviewEventArgs] {
    fn get_Device(&self, out: *mut *mut GazeDevicePreview) -> HRESULT
}}
impl ComPtr<IGazeDeviceWatcherRemovedPreviewEventArgs> {
    #[inline] pub fn get_device(&self) -> Result<Option<ComPtr<GazeDevicePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Device)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherRemovedPreviewEventArgs: IGazeDeviceWatcherRemovedPreviewEventArgs}
DEFINE_IID!(IID_IGazeDeviceWatcherUpdatedPreviewEventArgs, 2145923311, 32520, 18231, 136, 225, 74, 131, 174, 78, 72, 133);
RT_INTERFACE!{interface IGazeDeviceWatcherUpdatedPreviewEventArgs(IGazeDeviceWatcherUpdatedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeDeviceWatcherUpdatedPreviewEventArgs] {
    fn get_Device(&self, out: *mut *mut GazeDevicePreview) -> HRESULT
}}
impl ComPtr<IGazeDeviceWatcherUpdatedPreviewEventArgs> {
    #[inline] pub fn get_device(&self) -> Result<Option<ComPtr<GazeDevicePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Device)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeDeviceWatcherUpdatedPreviewEventArgs: IGazeDeviceWatcherUpdatedPreviewEventArgs}
DEFINE_IID!(IID_IGazeEnteredPreviewEventArgs, 627556163, 4645, 18591, 157, 209, 218, 167, 197, 15, 191, 75);
RT_INTERFACE!{interface IGazeEnteredPreviewEventArgs(IGazeEnteredPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeEnteredPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CurrentPoint(&self, out: *mut *mut GazePointPreview) -> HRESULT
}}
impl ComPtr<IGazeEnteredPreviewEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point(&self) -> Result<Option<ComPtr<GazePointPreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CurrentPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeEnteredPreviewEventArgs: IGazeEnteredPreviewEventArgs}
DEFINE_IID!(IID_IGazeExitedPreviewEventArgs, 1560998014, 32131, 16623, 159, 10, 251, 193, 187, 220, 197, 172);
RT_INTERFACE!{interface IGazeExitedPreviewEventArgs(IGazeExitedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeExitedPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CurrentPoint(&self, out: *mut *mut GazePointPreview) -> HRESULT
}}
impl ComPtr<IGazeExitedPreviewEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point(&self) -> Result<Option<ComPtr<GazePointPreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CurrentPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeExitedPreviewEventArgs: IGazeExitedPreviewEventArgs}
DEFINE_IID!(IID_IGazeInputSourcePreview, 3885924072, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeInputSourcePreview(IGazeInputSourcePreviewVtbl): IInspectable(IInspectableVtbl) [IID_IGazeInputSourcePreview] {
    fn add_GazeMoved(&self, handler: *mut foundation::TypedEventHandler<GazeInputSourcePreview, GazeMovedPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GazeMoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GazeEntered(&self, handler: *mut foundation::TypedEventHandler<GazeInputSourcePreview, GazeEnteredPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GazeEntered(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GazeExited(&self, handler: *mut foundation::TypedEventHandler<GazeInputSourcePreview, GazeExitedPreviewEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GazeExited(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGazeInputSourcePreview> {
    #[inline] pub fn add_gaze_moved(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeInputSourcePreview, GazeMovedPreviewEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_GazeMoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gaze_moved(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_GazeMoved)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_gaze_entered(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeInputSourcePreview, GazeEnteredPreviewEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_GazeEntered)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gaze_entered(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_GazeEntered)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_gaze_exited(&self, handler: &ComPtr<foundation::TypedEventHandler<GazeInputSourcePreview, GazeExitedPreviewEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_GazeExited)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_gaze_exited(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_GazeExited)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeInputSourcePreview: IGazeInputSourcePreview}
impl RtActivatable<IGazeInputSourcePreviewStatics> for GazeInputSourcePreview {}
impl GazeInputSourcePreview {
    #[inline] pub fn get_for_current_view() -> Result<Option<ComPtr<GazeInputSourcePreview>>> {
        <Self as RtActivatable<IGazeInputSourcePreviewStatics>>::get_activation_factory().get_for_current_view()
    }
    #[inline] pub fn create_watcher() -> Result<Option<ComPtr<GazeDeviceWatcherPreview>>> {
        <Self as RtActivatable<IGazeInputSourcePreviewStatics>>::get_activation_factory().create_watcher()
    }
}
DEFINE_CLSID!(GazeInputSourcePreview(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,73,110,112,117,116,46,80,114,101,118,105,101,119,46,71,97,122,101,73,110,112,117,116,83,111,117,114,99,101,80,114,101,118,105,101,119,0]) [CLSID_GazeInputSourcePreview]);
DEFINE_IID!(IID_IGazeInputSourcePreviewStatics, 3885924070, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{static interface IGazeInputSourcePreviewStatics(IGazeInputSourcePreviewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeInputSourcePreviewStatics] {
    fn GetForCurrentView(&self, out: *mut *mut GazeInputSourcePreview) -> HRESULT,
    fn CreateWatcher(&self, out: *mut *mut GazeDeviceWatcherPreview) -> HRESULT
}}
impl ComPtr<IGazeInputSourcePreviewStatics> {
    #[inline] pub fn get_for_current_view(&self) -> Result<Option<ComPtr<GazeInputSourcePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetForCurrentView)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_watcher(&self) -> Result<Option<ComPtr<GazeDeviceWatcherPreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcher)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGazeMovedPreviewEventArgs, 3885924075, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazeMovedPreviewEventArgs(IGazeMovedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGazeMovedPreviewEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT,
    fn get_CurrentPoint(&self, out: *mut *mut GazePointPreview) -> HRESULT,
    fn GetIntermediatePoints(&self, out: *mut *mut foundation::collections::IVector<GazePointPreview>) -> HRESULT
}}
impl ComPtr<IGazeMovedPreviewEventArgs> {
    #[inline] pub fn get_handled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_point(&self) -> Result<Option<ComPtr<GazePointPreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CurrentPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_intermediate_points(&self) -> Result<Option<ComPtr<foundation::collections::IVector<GazePointPreview>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIntermediatePoints)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazeMovedPreviewEventArgs: IGazeMovedPreviewEventArgs}
DEFINE_IID!(IID_IGazePointPreview, 3885924074, 45961, 4583, 178, 1, 200, 211, 255, 183, 87, 33);
RT_INTERFACE!{interface IGazePointPreview(IGazePointPreviewVtbl): IInspectable(IInspectableVtbl) [IID_IGazePointPreview] {
    fn get_SourceDevice(&self, out: *mut *mut GazeDevicePreview) -> HRESULT,
    fn get_EyeGazePosition(&self, out: *mut *mut foundation::IReference<foundation::Point>) -> HRESULT,
    fn get_HeadGazePosition(&self, out: *mut *mut foundation::IReference<foundation::Point>) -> HRESULT,
    fn get_Timestamp(&self, out: *mut u64) -> HRESULT,
    fn get_HidInputReport(&self, out: *mut *mut super::super::humaninterfacedevice::HidInputReport) -> HRESULT
}}
impl ComPtr<IGazePointPreview> {
    #[inline] pub fn get_source_device(&self) -> Result<Option<ComPtr<GazeDevicePreview>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SourceDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_eye_gaze_position(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::Point>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EyeGazePosition)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_head_gaze_position(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::Point>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HeadGazePosition)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<u64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hid_input_report(&self) -> Result<Option<ComPtr<super::super::humaninterfacedevice::HidInputReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HidInputReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GazePointPreview: IGazePointPreview}
} // Windows.Devices.Input.Preview
} // Windows.Devices.Input
pub mod lights { // Windows.Devices.Lights
use crate::prelude::*;
DEFINE_IID!(IID_ILamp, 75324314, 59973, 19243, 177, 162, 20, 223, 240, 11, 222, 123);
RT_INTERFACE!{interface ILamp(ILampVtbl): IInspectable(IInspectableVtbl) [IID_ILamp] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_BrightnessLevel(&self, out: *mut f32) -> HRESULT,
    fn put_BrightnessLevel(&self, value: f32) -> HRESULT,
    fn get_IsColorSettable(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: super::super::ui::Color) -> HRESULT,
    fn add_AvailabilityChanged(&self, handler: *mut foundation::TypedEventHandler<Lamp, LampAvailabilityChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailabilityChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ILamp> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness_level(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BrightnessLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness_level(&self, value: f32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BrightnessLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_color_settable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsColorSettable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Color)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Color)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_availability_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Lamp, LampAvailabilityChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AvailabilityChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_availability_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AvailabilityChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Lamp: ILamp}
impl RtActivatable<ILampStatics> for Lamp {}
impl Lamp {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILampStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Lamp>>> {
        <Self as RtActivatable<ILampStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<Lamp>>> {
        <Self as RtActivatable<ILampStatics>>::get_activation_factory().get_default_async()
    }
}
DEFINE_CLSID!(Lamp(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,76,97,109,112,0]) [CLSID_Lamp]);
DEFINE_IID!(IID_ILampArray, 2060359559, 51360, 20117, 161, 224, 213, 134, 118, 83, 134, 73);
RT_INTERFACE!{interface ILampArray(ILampArrayVtbl): IInspectable(IInspectableVtbl) [IID_ILampArray] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HardwareVendorId(&self, out: *mut u16) -> HRESULT,
    fn get_HardwareProductId(&self, out: *mut u16) -> HRESULT,
    fn get_HardwareVersion(&self, out: *mut u16) -> HRESULT,
    fn get_LampArrayKind(&self, out: *mut LampArrayKind) -> HRESULT,
    fn get_LampCount(&self, out: *mut i32) -> HRESULT,
    fn get_MinUpdateInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_BoundingBox(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_BrightnessLevel(&self, out: *mut f64) -> HRESULT,
    fn put_BrightnessLevel(&self, value: f64) -> HRESULT,
    fn get_IsConnected(&self, out: *mut bool) -> HRESULT,
    fn get_SupportsVirtualKeys(&self, out: *mut bool) -> HRESULT,
    fn GetLampInfo(&self, lampIndex: i32, out: *mut *mut LampInfo) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-system")] fn GetIndicesForKey(&self, key: super::super::system::VirtualKey, outSize: *mut u32, out: *mut *mut i32) -> HRESULT,
    fn GetIndicesForPurposes(&self, purposes: LampPurposes, outSize: *mut u32, out: *mut *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColor(&self, desiredColor: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColorForIndex(&self, lampIndex: i32, desiredColor: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetSingleColorForIndices(&self, desiredColor: super::super::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColorsForIndices(&self, desiredColorsSize: u32, desiredColors: *mut super::super::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT,
    #[cfg(not(all(feature="windows-system",feature="windows-ui")))] fn __Dummy21(&self) -> (),
    #[cfg(all(feature="windows-system",feature="windows-ui"))] fn SetColorsForKey(&self, desiredColor: super::super::ui::Color, key: super::super::system::VirtualKey) -> HRESULT,
    #[cfg(not(all(feature="windows-system",feature="windows-ui")))] fn __Dummy22(&self) -> (),
    #[cfg(all(feature="windows-system",feature="windows-ui"))] fn SetColorsForKeys(&self, desiredColorsSize: u32, desiredColors: *mut super::super::ui::Color, keysSize: u32, keys: *mut super::super::system::VirtualKey) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy23(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetColorsForPurposes(&self, desiredColor: super::super::ui::Color, purposes: LampPurposes) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SendMessageAsync(&self, messageId: i32, message: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    #[cfg(feature="windows-storage")] fn RequestMessageAsync(&self, messageId: i32, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT
}}
impl ComPtr<ILampArray> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HardwareVendorId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HardwareProductId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_hardware_version(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HardwareVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lamp_array_kind(&self) -> Result<LampArrayKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LampArrayKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lamp_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LampCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_update_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinUpdateInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bounding_box(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BoundingBox)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness_level(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BrightnessLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness_level(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BrightnessLevel)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_connected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsConnected)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supports_virtual_keys(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SupportsVirtualKeys)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lamp_info(&self, lampIndex: i32) -> Result<Option<ComPtr<LampInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetLampInfo)(self.deref() as *const _ as *mut _, lampIndex, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_indices_for_key(&self, key: super::super::system::VirtualKey) -> Result<ComArray<i32>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIndicesForKey)(self.deref() as *const _ as *mut _, key, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_indices_for_purposes(&self, purposes: LampPurposes) -> Result<ComArray<i32>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIndicesForPurposes)(self.deref() as *const _ as *mut _, purposes, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, desiredColor: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColor)(self.deref() as *const _ as *mut _, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color_for_index(&self, lampIndex: i32, desiredColor: super::super::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorForIndex)(self.deref() as *const _ as *mut _, lampIndex, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_single_color_for_indices(&self, desiredColor: super::super::ui::Color, lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetSingleColorForIndices)(self.deref() as *const _ as *mut _, desiredColor, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_colors_for_indices(&self, desiredColors: &[super::super::ui::Color], lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorsForIndices)(self.deref() as *const _ as *mut _, desiredColors.len() as u32, desiredColors.as_ptr() as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-system",feature="windows-ui"))] #[inline] pub fn set_colors_for_key(&self, desiredColor: super::super::ui::Color, key: super::super::system::VirtualKey) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorsForKey)(self.deref() as *const _ as *mut _, desiredColor, key);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(all(feature="windows-system",feature="windows-ui"))] #[inline] pub fn set_colors_for_keys(&self, desiredColors: &[super::super::ui::Color], keys: &[super::super::system::VirtualKey]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorsForKeys)(self.deref() as *const _ as *mut _, desiredColors.len() as u32, desiredColors.as_ptr() as *mut _, keys.len() as u32, keys.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_colors_for_purposes(&self, desiredColor: super::super::ui::Color, purposes: LampPurposes) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorsForPurposes)(self.deref() as *const _ as *mut _, desiredColor, purposes);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_message_async(&self, messageId: i32, message: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendMessageAsync)(self.deref() as *const _ as *mut _, messageId, message.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_message_async(&self, messageId: i32) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestMessageAsync)(self.deref() as *const _ as *mut _, messageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArray: ILampArray}
impl RtActivatable<ILampArrayStatics> for LampArray {}
impl LampArray {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILampArrayStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<LampArray>>> {
        <Self as RtActivatable<ILampArrayStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(LampArray(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,76,97,109,112,65,114,114,97,121,0]) [CLSID_LampArray]);
RT_ENUM! { enum LampArrayKind: i32 {
    Undefined = 0, Keyboard = 1, Mouse = 2, GameController = 3, Peripheral = 4, Scene = 5, Notification = 6, Chassis = 7, Wearable = 8, Furniture = 9, Art = 10,
}}
DEFINE_IID!(IID_ILampArrayStatics, 2075707789, 24513, 17709, 187, 31, 74, 212, 16, 211, 152, 255);
RT_INTERFACE!{static interface ILampArrayStatics(ILampArrayStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<LampArray>) -> HRESULT
}}
impl ComPtr<ILampArrayStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<LampArray>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampAvailabilityChangedEventArgs, 1332624877, 1954, 18845, 146, 96, 103, 227, 4, 83, 43, 164);
RT_INTERFACE!{interface ILampAvailabilityChangedEventArgs(ILampAvailabilityChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILampAvailabilityChangedEventArgs] {
    fn get_IsAvailable(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ILampAvailabilityChangedEventArgs> {
    #[inline] pub fn get_is_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsAvailable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LampAvailabilityChangedEventArgs: ILampAvailabilityChangedEventArgs}
DEFINE_IID!(IID_ILampInfo, 817582620, 2767, 18906, 140, 16, 21, 11, 156, 246, 39, 19);
RT_INTERFACE!{interface ILampInfo(ILampInfoVtbl): IInspectable(IInspectableVtbl) [IID_ILampInfo] {
    fn get_Index(&self, out: *mut i32) -> HRESULT,
    fn get_Purposes(&self, out: *mut LampPurposes) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_RedLevelCount(&self, out: *mut i32) -> HRESULT,
    fn get_GreenLevelCount(&self, out: *mut i32) -> HRESULT,
    fn get_BlueLevelCount(&self, out: *mut i32) -> HRESULT,
    fn get_GainLevelCount(&self, out: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_FixedColor(&self, out: *mut *mut foundation::IReference<super::super::ui::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn GetNearestSupportedColor(&self, desiredColor: super::super::ui::Color, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_UpdateLatency(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ComPtr<ILampInfo> {
    #[inline] pub fn get_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Index)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_purposes(&self) -> Result<LampPurposes> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Purposes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Position)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_red_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RedLevelCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_green_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GreenLevelCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_blue_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BlueLevelCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gain_level_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GainLevelCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_fixed_color(&self) -> Result<Option<ComPtr<foundation::IReference<super::super::ui::Color>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FixedColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn get_nearest_supported_color(&self, desiredColor: super::super::ui::Color) -> Result<super::super::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetNearestSupportedColor)(self.deref() as *const _ as *mut _, desiredColor, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_update_latency(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpdateLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LampInfo: ILampInfo}
RT_ENUM! { enum LampPurposes: u32 {
    Undefined = 0, Control = 1, Accent = 2, Branding = 4, Status = 8, Illumination = 16, Presentation = 32,
}}
DEFINE_IID!(IID_ILampStatics, 2820817260, 34949, 16414, 184, 33, 142, 139, 56, 168, 232, 236);
RT_INTERFACE!{static interface ILampStatics(ILampStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILampStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Lamp>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<Lamp>) -> HRESULT
}}
impl ComPtr<ILampStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Lamp>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<Lamp>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
pub mod effects { // Windows.Devices.Lights.Effects
use crate::prelude::*;
DEFINE_IID!(IID_ILampArrayBitmapEffect, 842588261, 55415, 17959, 137, 229, 42, 136, 247, 5, 47, 166);
RT_INTERFACE!{interface ILampArrayBitmapEffect(ILampArrayBitmapEffectVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayBitmapEffect] {
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_UpdateInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_UpdateInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_SuggestedBitmapSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn add_BitmapRequested(&self, handler: *mut foundation::TypedEventHandler<LampArrayBitmapEffect, LampArrayBitmapRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BitmapRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ILampArrayBitmapEffect> {
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Duration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Duration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StartDelay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StartDelay)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_update_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpdateInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_update_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_UpdateInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_suggested_bitmap_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SuggestedBitmapSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_bitmap_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<LampArrayBitmapEffect, LampArrayBitmapRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_BitmapRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_bitmap_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_BitmapRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayBitmapEffect: ILampArrayBitmapEffect}
impl RtActivatable<ILampArrayBitmapEffectFactory> for LampArrayBitmapEffect {}
impl LampArrayBitmapEffect {
    #[inline] pub fn create_instance(lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayBitmapEffect>> {
        <Self as RtActivatable<ILampArrayBitmapEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayBitmapEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,66,105,116,109,97,112,69,102,102,101,99,116,0]) [CLSID_LampArrayBitmapEffect]);
DEFINE_IID!(IID_ILampArrayBitmapEffectFactory, 325091472, 58166, 19599, 144, 83, 169, 36, 7, 202, 123, 29);
RT_INTERFACE!{static interface ILampArrayBitmapEffectFactory(ILampArrayBitmapEffectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayBitmapEffectFactory] {
    fn CreateInstance(&self, lampArray: *mut super::LampArray, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut *mut LampArrayBitmapEffect) -> HRESULT
}}
impl ComPtr<ILampArrayBitmapEffectFactory> {
    #[inline] pub fn create_instance(&self, lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayBitmapEffect>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, lampArray.deref() as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayBitmapRequestedEventArgs, 3367284638, 65123, 19793, 186, 189, 97, 157, 239, 180, 84, 186);
RT_INTERFACE!{interface ILampArrayBitmapRequestedEventArgs(ILampArrayBitmapRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayBitmapRequestedEventArgs] {
    fn get_SinceStarted(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn UpdateBitmap(&self, bitmap: *mut crate::windows::graphics::imaging::SoftwareBitmap) -> HRESULT
}}
impl ComPtr<ILampArrayBitmapRequestedEventArgs> {
    #[inline] pub fn get_since_started(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SinceStarted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn update_bitmap(&self, bitmap: &ComPtr<crate::windows::graphics::imaging::SoftwareBitmap>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UpdateBitmap)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayBitmapRequestedEventArgs: ILampArrayBitmapRequestedEventArgs}
DEFINE_IID!(IID_ILampArrayBlinkEffect, 3955176950, 12229, 19379, 179, 195, 98, 33, 167, 104, 13, 19);
RT_INTERFACE!{interface ILampArrayBlinkEffect(ILampArrayBlinkEffectVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayBlinkEffect] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut crate::windows::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: crate::windows::ui::Color) -> HRESULT,
    fn get_AttackDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_AttackDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_SustainDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_SustainDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_DecayDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_DecayDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_RepetitionDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RepetitionDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Occurrences(&self, out: *mut i32) -> HRESULT,
    fn put_Occurrences(&self, value: i32) -> HRESULT,
    fn get_RepetitionMode(&self, out: *mut LampArrayRepetitionMode) -> HRESULT,
    fn put_RepetitionMode(&self, value: LampArrayRepetitionMode) -> HRESULT
}}
impl ComPtr<ILampArrayBlinkEffect> {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<crate::windows::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Color)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Color)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_attack_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttackDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_attack_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AttackDuration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sustain_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SustainDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sustain_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SustainDuration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decay_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DecayDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decay_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DecayDuration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repetition_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RepetitionDelay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repetition_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RepetitionDelay)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StartDelay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StartDelay)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Occurrences)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Occurrences)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repetition_mode(&self) -> Result<LampArrayRepetitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RepetitionMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repetition_mode(&self, value: LampArrayRepetitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RepetitionMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayBlinkEffect: ILampArrayBlinkEffect}
impl RtActivatable<ILampArrayBlinkEffectFactory> for LampArrayBlinkEffect {}
impl LampArrayBlinkEffect {
    #[inline] pub fn create_instance(lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayBlinkEffect>> {
        <Self as RtActivatable<ILampArrayBlinkEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayBlinkEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,66,108,105,110,107,69,102,102,101,99,116,0]) [CLSID_LampArrayBlinkEffect]);
DEFINE_IID!(IID_ILampArrayBlinkEffectFactory, 2275351959, 40784, 18866, 165, 111, 1, 58, 160, 141, 85, 224);
RT_INTERFACE!{static interface ILampArrayBlinkEffectFactory(ILampArrayBlinkEffectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayBlinkEffectFactory] {
    fn CreateInstance(&self, lampArray: *mut super::LampArray, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut *mut LampArrayBlinkEffect) -> HRESULT
}}
impl ComPtr<ILampArrayBlinkEffectFactory> {
    #[inline] pub fn create_instance(&self, lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayBlinkEffect>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, lampArray.deref() as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayColorRampEffect, 721437751, 16551, 17198, 160, 185, 13, 87, 12, 33, 83, 255);
RT_INTERFACE!{interface ILampArrayColorRampEffect(ILampArrayColorRampEffectVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayColorRampEffect] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut crate::windows::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: crate::windows::ui::Color) -> HRESULT,
    fn get_RampDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RampDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_CompletionBehavior(&self, out: *mut LampArrayEffectCompletionBehavior) -> HRESULT,
    fn put_CompletionBehavior(&self, value: LampArrayEffectCompletionBehavior) -> HRESULT
}}
impl ComPtr<ILampArrayColorRampEffect> {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<crate::windows::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Color)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Color)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ramp_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RampDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_ramp_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RampDuration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StartDelay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StartDelay)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completion_behavior(&self) -> Result<LampArrayEffectCompletionBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompletionBehavior)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_completion_behavior(&self, value: LampArrayEffectCompletionBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CompletionBehavior)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayColorRampEffect: ILampArrayColorRampEffect}
impl RtActivatable<ILampArrayColorRampEffectFactory> for LampArrayColorRampEffect {}
impl LampArrayColorRampEffect {
    #[inline] pub fn create_instance(lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayColorRampEffect>> {
        <Self as RtActivatable<ILampArrayColorRampEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayColorRampEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,67,111,108,111,114,82,97,109,112,69,102,102,101,99,116,0]) [CLSID_LampArrayColorRampEffect]);
DEFINE_IID!(IID_ILampArrayColorRampEffectFactory, 1376506163, 3188, 19957, 190, 167, 72, 153, 224, 38, 107, 15);
RT_INTERFACE!{static interface ILampArrayColorRampEffectFactory(ILampArrayColorRampEffectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayColorRampEffectFactory] {
    fn CreateInstance(&self, lampArray: *mut super::LampArray, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut *mut LampArrayColorRampEffect) -> HRESULT
}}
impl ComPtr<ILampArrayColorRampEffectFactory> {
    #[inline] pub fn create_instance(&self, lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayColorRampEffect>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, lampArray.deref() as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayCustomEffect, 3965161840, 15412, 18550, 129, 139, 87, 101, 247, 139, 14, 228);
RT_INTERFACE!{interface ILampArrayCustomEffect(ILampArrayCustomEffectVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayCustomEffect] {
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_UpdateInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_UpdateInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn add_UpdateRequested(&self, handler: *mut foundation::TypedEventHandler<LampArrayCustomEffect, LampArrayUpdateRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ILampArrayCustomEffect> {
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Duration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Duration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_update_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpdateInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_update_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_UpdateInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_update_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<LampArrayCustomEffect, LampArrayUpdateRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_UpdateRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_update_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_UpdateRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayCustomEffect: ILampArrayCustomEffect}
impl RtActivatable<ILampArrayCustomEffectFactory> for LampArrayCustomEffect {}
impl LampArrayCustomEffect {
    #[inline] pub fn create_instance(lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayCustomEffect>> {
        <Self as RtActivatable<ILampArrayCustomEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArrayCustomEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,67,117,115,116,111,109,69,102,102,101,99,116,0]) [CLSID_LampArrayCustomEffect]);
DEFINE_IID!(IID_ILampArrayCustomEffectFactory, 1756657485, 25573, 19184, 165, 139, 62, 83, 91, 148, 232, 201);
RT_INTERFACE!{static interface ILampArrayCustomEffectFactory(ILampArrayCustomEffectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayCustomEffectFactory] {
    fn CreateInstance(&self, lampArray: *mut super::LampArray, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut *mut LampArrayCustomEffect) -> HRESULT
}}
impl ComPtr<ILampArrayCustomEffectFactory> {
    #[inline] pub fn create_instance(&self, lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArrayCustomEffect>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, lampArray.deref() as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayEffect, 299128208, 22523, 17734, 177, 206, 134, 49, 7, 247, 64, 223);
RT_INTERFACE!{interface ILampArrayEffect(ILampArrayEffectVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayEffect] {
    fn get_ZIndex(&self, out: *mut i32) -> HRESULT,
    fn put_ZIndex(&self, value: i32) -> HRESULT
}}
impl ComPtr<ILampArrayEffect> {
    #[inline] pub fn get_z_index(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ZIndex)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_z_index(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ZIndex)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum LampArrayEffectCompletionBehavior: i32 {
    ClearState = 0, KeepState = 1,
}}
DEFINE_IID!(IID_ILampArrayEffectPlaylist, 2112195582, 28513, 16643, 152, 199, 214, 99, 47, 123, 145, 105);
RT_INTERFACE!{interface ILampArrayEffectPlaylist(ILampArrayEffectPlaylistVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayEffectPlaylist] {
    fn Append(&self, effect: *mut ILampArrayEffect) -> HRESULT,
    fn OverrideZIndex(&self, zIndex: i32) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn get_EffectStartMode(&self, out: *mut LampArrayEffectStartMode) -> HRESULT,
    fn put_EffectStartMode(&self, value: LampArrayEffectStartMode) -> HRESULT,
    fn get_Occurrences(&self, out: *mut i32) -> HRESULT,
    fn put_Occurrences(&self, value: i32) -> HRESULT,
    fn get_RepetitionMode(&self, out: *mut LampArrayRepetitionMode) -> HRESULT,
    fn put_RepetitionMode(&self, value: LampArrayRepetitionMode) -> HRESULT
}}
impl ComPtr<ILampArrayEffectPlaylist> {
    #[inline] pub fn append(&self, effect: &ComPtr<ILampArrayEffect>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Append)(self.deref() as *const _ as *mut _, effect.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn override_z_index(&self, zIndex: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).OverrideZIndex)(self.deref() as *const _ as *mut _, zIndex);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Pause)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_effect_start_mode(&self) -> Result<LampArrayEffectStartMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EffectStartMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_effect_start_mode(&self, value: LampArrayEffectStartMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_EffectStartMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_occurrences(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Occurrences)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_occurrences(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Occurrences)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repetition_mode(&self) -> Result<LampArrayRepetitionMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RepetitionMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repetition_mode(&self, value: LampArrayRepetitionMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RepetitionMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayEffectPlaylist: ILampArrayEffectPlaylist}
impl RtActivatable<ILampArrayEffectPlaylistStatics> for LampArrayEffectPlaylist {}
impl RtActivatable<IActivationFactory> for LampArrayEffectPlaylist {}
impl LampArrayEffectPlaylist {
    #[inline] pub fn start_all(value: &ComPtr<foundation::collections::IIterable<LampArrayEffectPlaylist>>) -> Result<()> {
        <Self as RtActivatable<ILampArrayEffectPlaylistStatics>>::get_activation_factory().start_all(value)
    }
    #[inline] pub fn stop_all(value: &ComPtr<foundation::collections::IIterable<LampArrayEffectPlaylist>>) -> Result<()> {
        <Self as RtActivatable<ILampArrayEffectPlaylistStatics>>::get_activation_factory().stop_all(value)
    }
    #[inline] pub fn pause_all(value: &ComPtr<foundation::collections::IIterable<LampArrayEffectPlaylist>>) -> Result<()> {
        <Self as RtActivatable<ILampArrayEffectPlaylistStatics>>::get_activation_factory().pause_all(value)
    }
}
DEFINE_CLSID!(LampArrayEffectPlaylist(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,69,102,102,101,99,116,80,108,97,121,108,105,115,116,0]) [CLSID_LampArrayEffectPlaylist]);
DEFINE_IID!(IID_ILampArrayEffectPlaylistStatics, 4212466524, 59957, 19583, 160, 22, 243, 191, 198, 166, 196, 125);
RT_INTERFACE!{static interface ILampArrayEffectPlaylistStatics(ILampArrayEffectPlaylistStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayEffectPlaylistStatics] {
    fn StartAll(&self, value: *mut foundation::collections::IIterable<LampArrayEffectPlaylist>) -> HRESULT,
    fn StopAll(&self, value: *mut foundation::collections::IIterable<LampArrayEffectPlaylist>) -> HRESULT,
    fn PauseAll(&self, value: *mut foundation::collections::IIterable<LampArrayEffectPlaylist>) -> HRESULT
}}
impl ComPtr<ILampArrayEffectPlaylistStatics> {
    #[inline] pub fn start_all(&self, value: &ComPtr<foundation::collections::IIterable<LampArrayEffectPlaylist>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StartAll)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop_all(&self, value: &ComPtr<foundation::collections::IIterable<LampArrayEffectPlaylist>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).StopAll)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn pause_all(&self, value: &ComPtr<foundation::collections::IIterable<LampArrayEffectPlaylist>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PauseAll)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum LampArrayEffectStartMode: i32 {
    Sequential = 0, Simultaneous = 1,
}}
RT_ENUM! { enum LampArrayRepetitionMode: i32 {
    Occurrences = 0, Forever = 1,
}}
DEFINE_IID!(IID_ILampArraySolidEffect, 1142915603, 17356, 19251, 128, 235, 198, 221, 222, 125, 200, 237);
RT_INTERFACE!{interface ILampArraySolidEffect(ILampArraySolidEffectVtbl): IInspectable(IInspectableVtbl) [IID_ILampArraySolidEffect] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_Color(&self, out: *mut crate::windows::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_Color(&self, value: crate::windows::ui::Color) -> HRESULT,
    fn get_Duration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StartDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_StartDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_CompletionBehavior(&self, out: *mut LampArrayEffectCompletionBehavior) -> HRESULT,
    fn put_CompletionBehavior(&self, value: LampArrayEffectCompletionBehavior) -> HRESULT
}}
impl ComPtr<ILampArraySolidEffect> {
    #[cfg(feature="windows-ui")] #[inline] pub fn get_color(&self) -> Result<crate::windows::ui::Color> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Color)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, value: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Color)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Duration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Duration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_start_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StartDelay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_start_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StartDelay)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_completion_behavior(&self) -> Result<LampArrayEffectCompletionBehavior> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CompletionBehavior)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_completion_behavior(&self, value: LampArrayEffectCompletionBehavior) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CompletionBehavior)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArraySolidEffect: ILampArraySolidEffect}
impl RtActivatable<ILampArraySolidEffectFactory> for LampArraySolidEffect {}
impl LampArraySolidEffect {
    #[inline] pub fn create_instance(lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArraySolidEffect>> {
        <Self as RtActivatable<ILampArraySolidEffectFactory>>::get_activation_factory().create_instance(lampArray, lampIndexes)
    }
}
DEFINE_CLSID!(LampArraySolidEffect(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,76,105,103,104,116,115,46,69,102,102,101,99,116,115,46,76,97,109,112,65,114,114,97,121,83,111,108,105,100,69,102,102,101,99,116,0]) [CLSID_LampArraySolidEffect]);
DEFINE_IID!(IID_ILampArraySolidEffectFactory, 4167213868, 21878, 17217, 150, 27, 174, 225, 241, 60, 249, 221);
RT_INTERFACE!{static interface ILampArraySolidEffectFactory(ILampArraySolidEffectFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILampArraySolidEffectFactory] {
    fn CreateInstance(&self, lampArray: *mut super::LampArray, lampIndexesSize: u32, lampIndexes: *mut i32, out: *mut *mut LampArraySolidEffect) -> HRESULT
}}
impl ComPtr<ILampArraySolidEffectFactory> {
    #[inline] pub fn create_instance(&self, lampArray: &ComPtr<super::LampArray>, lampIndexes: &[i32]) -> Result<ComPtr<LampArraySolidEffect>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, lampArray.deref() as *const _ as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILampArrayUpdateRequestedEventArgs, 1935019370, 22378, 18607, 133, 57, 103, 255, 160, 171, 53, 22);
RT_INTERFACE!{interface ILampArrayUpdateRequestedEventArgs(ILampArrayUpdateRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILampArrayUpdateRequestedEventArgs] {
    fn get_SinceStarted(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetColor(&self, desiredColor: crate::windows::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetColorForIndex(&self, lampIndex: i32, desiredColor: crate::windows::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetSingleColorForIndices(&self, desiredColor: crate::windows::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT,
    #[cfg(feature="windows-ui")] fn SetColorsForIndices(&self, desiredColorsSize: u32, desiredColors: *mut crate::windows::ui::Color, lampIndexesSize: u32, lampIndexes: *mut i32) -> HRESULT
}}
impl ComPtr<ILampArrayUpdateRequestedEventArgs> {
    #[inline] pub fn get_since_started(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SinceStarted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color(&self, desiredColor: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColor)(self.deref() as *const _ as *mut _, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_color_for_index(&self, lampIndex: i32, desiredColor: crate::windows::ui::Color) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorForIndex)(self.deref() as *const _ as *mut _, lampIndex, desiredColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_single_color_for_indices(&self, desiredColor: crate::windows::ui::Color, lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetSingleColorForIndices)(self.deref() as *const _ as *mut _, desiredColor, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn set_colors_for_indices(&self, desiredColors: &[crate::windows::ui::Color], lampIndexes: &[i32]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetColorsForIndices)(self.deref() as *const _ as *mut _, desiredColors.len() as u32, desiredColors.as_ptr() as *mut _, lampIndexes.len() as u32, lampIndexes.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LampArrayUpdateRequestedEventArgs: ILampArrayUpdateRequestedEventArgs}
} // Windows.Devices.Lights.Effects
} // Windows.Devices.Lights
pub mod midi { // Windows.Devices.Midi
use crate::prelude::*;
RT_CLASS!{class MidiActiveSensingMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiActiveSensingMessage {}
DEFINE_CLSID!(MidiActiveSensingMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,65,99,116,105,118,101,83,101,110,115,105,110,103,77,101,115,115,97,103,101,0]) [CLSID_MidiActiveSensingMessage]);
DEFINE_IID!(IID_IMidiChannelPressureMessage, 3189745760, 25268, 19794, 163, 126, 146, 229, 77, 53, 185, 9);
RT_INTERFACE!{interface IMidiChannelPressureMessage(IMidiChannelPressureMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiChannelPressureMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Pressure(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiChannelPressureMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Pressure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiChannelPressureMessage: IMidiChannelPressureMessage}
impl RtActivatable<IMidiChannelPressureMessageFactory> for MidiChannelPressureMessage {}
impl MidiChannelPressureMessage {
    #[inline] pub fn create_midi_channel_pressure_message(channel: u8, pressure: u8) -> Result<ComPtr<MidiChannelPressureMessage>> {
        <Self as RtActivatable<IMidiChannelPressureMessageFactory>>::get_activation_factory().create_midi_channel_pressure_message(channel, pressure)
    }
}
DEFINE_CLSID!(MidiChannelPressureMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,104,97,110,110,101,108,80,114,101,115,115,117,114,101,77,101,115,115,97,103,101,0]) [CLSID_MidiChannelPressureMessage]);
DEFINE_IID!(IID_IMidiChannelPressureMessageFactory, 1645800751, 8836, 16682, 148, 207, 16, 251, 4, 132, 44, 108);
RT_INTERFACE!{static interface IMidiChannelPressureMessageFactory(IMidiChannelPressureMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiChannelPressureMessageFactory] {
    fn CreateMidiChannelPressureMessage(&self, channel: u8, pressure: u8, out: *mut *mut MidiChannelPressureMessage) -> HRESULT
}}
impl ComPtr<IMidiChannelPressureMessageFactory> {
    #[inline] pub fn create_midi_channel_pressure_message(&self, channel: u8, pressure: u8) -> Result<ComPtr<MidiChannelPressureMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiChannelPressureMessage)(self.deref() as *const _ as *mut _, channel, pressure, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiContinueMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiContinueMessage {}
DEFINE_CLSID!(MidiContinueMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,111,110,116,105,110,117,101,77,101,115,115,97,103,101,0]) [CLSID_MidiContinueMessage]);
DEFINE_IID!(IID_IMidiControlChangeMessage, 3085000579, 30733, 16479, 183, 129, 62, 21, 152, 201, 127, 64);
RT_INTERFACE!{interface IMidiControlChangeMessage(IMidiControlChangeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiControlChangeMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Controller(&self, out: *mut u8) -> HRESULT,
    fn get_ControlValue(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiControlChangeMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_controller(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Controller)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_control_value(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ControlValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiControlChangeMessage: IMidiControlChangeMessage}
impl RtActivatable<IMidiControlChangeMessageFactory> for MidiControlChangeMessage {}
impl MidiControlChangeMessage {
    #[inline] pub fn create_midi_control_change_message(channel: u8, controller: u8, controlValue: u8) -> Result<ComPtr<MidiControlChangeMessage>> {
        <Self as RtActivatable<IMidiControlChangeMessageFactory>>::get_activation_factory().create_midi_control_change_message(channel, controller, controlValue)
    }
}
DEFINE_CLSID!(MidiControlChangeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,67,111,110,116,114,111,108,67,104,97,110,103,101,77,101,115,115,97,103,101,0]) [CLSID_MidiControlChangeMessage]);
DEFINE_IID!(IID_IMidiControlChangeMessageFactory, 716260129, 38252, 18093, 151, 82, 248, 127, 85, 5, 47, 227);
RT_INTERFACE!{static interface IMidiControlChangeMessageFactory(IMidiControlChangeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiControlChangeMessageFactory] {
    fn CreateMidiControlChangeMessage(&self, channel: u8, controller: u8, controlValue: u8, out: *mut *mut MidiControlChangeMessage) -> HRESULT
}}
impl ComPtr<IMidiControlChangeMessageFactory> {
    #[inline] pub fn create_midi_control_change_message(&self, channel: u8, controller: u8, controlValue: u8) -> Result<ComPtr<MidiControlChangeMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiControlChangeMessage)(self.deref() as *const _ as *mut _, channel, controller, controlValue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiInPort, 3586251227, 38682, 20143, 162, 61, 234, 25, 254, 96, 127, 249);
RT_INTERFACE!{interface IMidiInPort(IMidiInPortVtbl): IInspectable(IInspectableVtbl) [IID_IMidiInPort] {
    fn add_MessageReceived(&self, handler: *mut foundation::TypedEventHandler<MidiInPort, MidiMessageReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMidiInPort> {
    #[inline] pub fn add_message_received(&self, handler: &ComPtr<foundation::TypedEventHandler<MidiInPort, MidiMessageReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MessageReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MessageReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiInPort: IMidiInPort}
impl RtActivatable<IMidiInPortStatics> for MidiInPort {}
impl MidiInPort {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<MidiInPort>>> {
        <Self as RtActivatable<IMidiInPortStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMidiInPortStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(MidiInPort(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,73,110,80,111,114,116,0]) [CLSID_MidiInPort]);
DEFINE_IID!(IID_IMidiInPortStatics, 1153710556, 26623, 19054, 139, 172, 253, 182, 97, 12, 242, 150);
RT_INTERFACE!{static interface IMidiInPortStatics(IMidiInPortStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiInPortStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<MidiInPort>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMidiInPortStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<MidiInPort>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiMessage, 2037807429, 4244, 17027, 155, 224, 40, 159, 192, 238, 131, 52);
RT_INTERFACE!{interface IMidiMessage(IMidiMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiMessage] {
    fn get_Timestamp(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_RawData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_Type(&self, out: *mut MidiMessageType) -> HRESULT
}}
impl ComPtr<IMidiMessage> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_raw_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RawData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_type(&self) -> Result<MidiMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Type)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiMessageReceivedEventArgs, 1985375830, 62248, 19281, 144, 125, 179, 168, 206, 150, 191, 128);
RT_INTERFACE!{interface IMidiMessageReceivedEventArgs(IMidiMessageReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiMessageReceivedEventArgs] {
    fn get_Message(&self, out: *mut *mut IMidiMessage) -> HRESULT
}}
impl ComPtr<IMidiMessageReceivedEventArgs> {
    #[inline] pub fn get_message(&self) -> Result<Option<ComPtr<IMidiMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Message)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiMessageReceivedEventArgs: IMidiMessageReceivedEventArgs}
RT_ENUM! { enum MidiMessageType: i32 {
    None = 0, NoteOff = 128, NoteOn = 144, PolyphonicKeyPressure = 160, ControlChange = 176, ProgramChange = 192, ChannelPressure = 208, PitchBendChange = 224, SystemExclusive = 240, MidiTimeCode = 241, SongPositionPointer = 242, SongSelect = 243, TuneRequest = 246, EndSystemExclusive = 247, TimingClock = 248, Start = 250, Continue = 251, Stop = 252, ActiveSensing = 254, SystemReset = 255,
}}
DEFINE_IID!(IID_IMidiNoteOffMessage, 385714932, 6542, 19855, 166, 84, 211, 5, 162, 147, 84, 143);
RT_INTERFACE!{interface IMidiNoteOffMessage(IMidiNoteOffMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOffMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Note(&self, out: *mut u8) -> HRESULT,
    fn get_Velocity(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiNoteOffMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_note(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Note)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocity(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Velocity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiNoteOffMessage: IMidiNoteOffMessage}
impl RtActivatable<IMidiNoteOffMessageFactory> for MidiNoteOffMessage {}
impl MidiNoteOffMessage {
    #[inline] pub fn create_midi_note_off_message(channel: u8, note: u8, velocity: u8) -> Result<ComPtr<MidiNoteOffMessage>> {
        <Self as RtActivatable<IMidiNoteOffMessageFactory>>::get_activation_factory().create_midi_note_off_message(channel, note, velocity)
    }
}
DEFINE_CLSID!(MidiNoteOffMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,78,111,116,101,79,102,102,77,101,115,115,97,103,101,0]) [CLSID_MidiNoteOffMessage]);
DEFINE_IID!(IID_IMidiNoteOffMessageFactory, 2796699872, 42825, 16991, 138, 244, 164, 217, 121, 204, 21, 181);
RT_INTERFACE!{static interface IMidiNoteOffMessageFactory(IMidiNoteOffMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOffMessageFactory] {
    fn CreateMidiNoteOffMessage(&self, channel: u8, note: u8, velocity: u8, out: *mut *mut MidiNoteOffMessage) -> HRESULT
}}
impl ComPtr<IMidiNoteOffMessageFactory> {
    #[inline] pub fn create_midi_note_off_message(&self, channel: u8, note: u8, velocity: u8) -> Result<ComPtr<MidiNoteOffMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiNoteOffMessage)(self.deref() as *const _ as *mut _, channel, note, velocity, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiNoteOnMessage, 3760343797, 24961, 18141, 175, 162, 65, 0, 4, 192, 87, 170);
RT_INTERFACE!{interface IMidiNoteOnMessage(IMidiNoteOnMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOnMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Note(&self, out: *mut u8) -> HRESULT,
    fn get_Velocity(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiNoteOnMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_note(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Note)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_velocity(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Velocity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiNoteOnMessage: IMidiNoteOnMessage}
impl RtActivatable<IMidiNoteOnMessageFactory> for MidiNoteOnMessage {}
impl MidiNoteOnMessage {
    #[inline] pub fn create_midi_note_on_message(channel: u8, note: u8, velocity: u8) -> Result<ComPtr<MidiNoteOnMessage>> {
        <Self as RtActivatable<IMidiNoteOnMessageFactory>>::get_activation_factory().create_midi_note_on_message(channel, note, velocity)
    }
}
DEFINE_CLSID!(MidiNoteOnMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,78,111,116,101,79,110,77,101,115,115,97,103,101,0]) [CLSID_MidiNoteOnMessage]);
DEFINE_IID!(IID_IMidiNoteOnMessageFactory, 2604826784, 22977, 16910, 181, 23, 21, 161, 10, 169, 96, 107);
RT_INTERFACE!{static interface IMidiNoteOnMessageFactory(IMidiNoteOnMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiNoteOnMessageFactory] {
    fn CreateMidiNoteOnMessage(&self, channel: u8, note: u8, velocity: u8, out: *mut *mut MidiNoteOnMessage) -> HRESULT
}}
impl ComPtr<IMidiNoteOnMessageFactory> {
    #[inline] pub fn create_midi_note_on_message(&self, channel: u8, note: u8, velocity: u8) -> Result<ComPtr<MidiNoteOnMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiNoteOnMessage)(self.deref() as *const _ as *mut _, channel, note, velocity, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiOutPort, 2468179359, 22434, 19002, 173, 184, 70, 64, 136, 111, 102, 147);
RT_INTERFACE!{interface IMidiOutPort(IMidiOutPortVtbl): IInspectable(IInspectableVtbl) [IID_IMidiOutPort] {
    fn SendMessage(&self, midiMessage: *mut IMidiMessage) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendBuffer(&self, midiData: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMidiOutPort> {
    #[inline] pub fn send_message(&self, midiMessage: &ComPtr<IMidiMessage>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SendMessage)(self.deref() as *const _ as *mut _, midiMessage.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_buffer(&self, midiData: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SendBuffer)(self.deref() as *const _ as *mut _, midiData.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiOutPort: IMidiOutPort}
impl RtActivatable<IMidiOutPortStatics> for MidiOutPort {}
impl MidiOutPort {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<IMidiOutPort>>> {
        <Self as RtActivatable<IMidiOutPortStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMidiOutPortStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(MidiOutPort(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,79,117,116,80,111,114,116,0]) [CLSID_MidiOutPort]);
DEFINE_IID!(IID_IMidiOutPortStatics, 106742761, 3976, 17547, 155, 100, 169, 88, 38, 198, 91, 143);
RT_INTERFACE!{static interface IMidiOutPortStatics(IMidiOutPortStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiOutPortStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<IMidiOutPort>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMidiOutPortStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<IMidiOutPort>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiPitchBendChangeMessage, 702500017, 11935, 20399, 140, 43, 156, 184, 42, 144, 121, 202);
RT_INTERFACE!{interface IMidiPitchBendChangeMessage(IMidiPitchBendChangeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPitchBendChangeMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Bend(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IMidiPitchBendChangeMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bend(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Bend)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiPitchBendChangeMessage: IMidiPitchBendChangeMessage}
impl RtActivatable<IMidiPitchBendChangeMessageFactory> for MidiPitchBendChangeMessage {}
impl MidiPitchBendChangeMessage {
    #[inline] pub fn create_midi_pitch_bend_change_message(channel: u8, bend: u16) -> Result<ComPtr<MidiPitchBendChangeMessage>> {
        <Self as RtActivatable<IMidiPitchBendChangeMessageFactory>>::get_activation_factory().create_midi_pitch_bend_change_message(channel, bend)
    }
}
DEFINE_CLSID!(MidiPitchBendChangeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,105,116,99,104,66,101,110,100,67,104,97,110,103,101,77,101,115,115,97,103,101,0]) [CLSID_MidiPitchBendChangeMessage]);
DEFINE_IID!(IID_IMidiPitchBendChangeMessageFactory, 4126072661, 53192, 18726, 179, 14, 163, 98, 35, 147, 48, 108);
RT_INTERFACE!{static interface IMidiPitchBendChangeMessageFactory(IMidiPitchBendChangeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPitchBendChangeMessageFactory] {
    fn CreateMidiPitchBendChangeMessage(&self, channel: u8, bend: u16, out: *mut *mut MidiPitchBendChangeMessage) -> HRESULT
}}
impl ComPtr<IMidiPitchBendChangeMessageFactory> {
    #[inline] pub fn create_midi_pitch_bend_change_message(&self, channel: u8, bend: u16) -> Result<ComPtr<MidiPitchBendChangeMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiPitchBendChangeMessage)(self.deref() as *const _ as *mut _, channel, bend, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiPolyphonicKeyPressureMessage, 527644670, 44264, 18592, 134, 142, 124, 219, 242, 15, 4, 214);
RT_INTERFACE!{interface IMidiPolyphonicKeyPressureMessage(IMidiPolyphonicKeyPressureMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPolyphonicKeyPressureMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Note(&self, out: *mut u8) -> HRESULT,
    fn get_Pressure(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiPolyphonicKeyPressureMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_note(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Note)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pressure(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Pressure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiPolyphonicKeyPressureMessage: IMidiPolyphonicKeyPressureMessage}
impl RtActivatable<IMidiPolyphonicKeyPressureMessageFactory> for MidiPolyphonicKeyPressureMessage {}
impl MidiPolyphonicKeyPressureMessage {
    #[inline] pub fn create_midi_polyphonic_key_pressure_message(channel: u8, note: u8, pressure: u8) -> Result<ComPtr<MidiPolyphonicKeyPressureMessage>> {
        <Self as RtActivatable<IMidiPolyphonicKeyPressureMessageFactory>>::get_activation_factory().create_midi_polyphonic_key_pressure_message(channel, note, pressure)
    }
}
DEFINE_CLSID!(MidiPolyphonicKeyPressureMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,111,108,121,112,104,111,110,105,99,75,101,121,80,114,101,115,115,117,114,101,77,101,115,115,97,103,101,0]) [CLSID_MidiPolyphonicKeyPressureMessage]);
DEFINE_IID!(IID_IMidiPolyphonicKeyPressureMessageFactory, 3918481470, 50355, 19922, 145, 124, 227, 73, 129, 90, 27, 59);
RT_INTERFACE!{static interface IMidiPolyphonicKeyPressureMessageFactory(IMidiPolyphonicKeyPressureMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiPolyphonicKeyPressureMessageFactory] {
    fn CreateMidiPolyphonicKeyPressureMessage(&self, channel: u8, note: u8, pressure: u8, out: *mut *mut MidiPolyphonicKeyPressureMessage) -> HRESULT
}}
impl ComPtr<IMidiPolyphonicKeyPressureMessageFactory> {
    #[inline] pub fn create_midi_polyphonic_key_pressure_message(&self, channel: u8, note: u8, pressure: u8) -> Result<ComPtr<MidiPolyphonicKeyPressureMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiPolyphonicKeyPressureMessage)(self.deref() as *const _ as *mut _, channel, note, pressure, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiProgramChangeMessage, 2629516408, 31294, 17191, 170, 152, 32, 184, 228, 72, 90, 248);
RT_INTERFACE!{interface IMidiProgramChangeMessage(IMidiProgramChangeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiProgramChangeMessage] {
    fn get_Channel(&self, out: *mut u8) -> HRESULT,
    fn get_Program(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiProgramChangeMessage> {
    #[inline] pub fn get_channel(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_program(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Program)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiProgramChangeMessage: IMidiProgramChangeMessage}
impl RtActivatable<IMidiProgramChangeMessageFactory> for MidiProgramChangeMessage {}
impl MidiProgramChangeMessage {
    #[inline] pub fn create_midi_program_change_message(channel: u8, program: u8) -> Result<ComPtr<MidiProgramChangeMessage>> {
        <Self as RtActivatable<IMidiProgramChangeMessageFactory>>::get_activation_factory().create_midi_program_change_message(channel, program)
    }
}
DEFINE_CLSID!(MidiProgramChangeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,80,114,111,103,114,97,109,67,104,97,110,103,101,77,101,115,115,97,103,101,0]) [CLSID_MidiProgramChangeMessage]);
DEFINE_IID!(IID_IMidiProgramChangeMessageFactory, 3601875847, 21067, 16644, 156, 153, 101, 114, 191, 210, 226, 97);
RT_INTERFACE!{static interface IMidiProgramChangeMessageFactory(IMidiProgramChangeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiProgramChangeMessageFactory] {
    fn CreateMidiProgramChangeMessage(&self, channel: u8, program: u8, out: *mut *mut MidiProgramChangeMessage) -> HRESULT
}}
impl ComPtr<IMidiProgramChangeMessageFactory> {
    #[inline] pub fn create_midi_program_change_message(&self, channel: u8, program: u8) -> Result<ComPtr<MidiProgramChangeMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiProgramChangeMessage)(self.deref() as *const _ as *mut _, channel, program, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiSongPositionPointerMessage, 1285885014, 60510, 19172, 161, 21, 136, 220, 87, 204, 43, 121);
RT_INTERFACE!{interface IMidiSongPositionPointerMessage(IMidiSongPositionPointerMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongPositionPointerMessage] {
    fn get_Beats(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<IMidiSongPositionPointerMessage> {
    #[inline] pub fn get_beats(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Beats)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSongPositionPointerMessage: IMidiSongPositionPointerMessage}
impl RtActivatable<IMidiSongPositionPointerMessageFactory> for MidiSongPositionPointerMessage {}
impl MidiSongPositionPointerMessage {
    #[inline] pub fn create_midi_song_position_pointer_message(beats: u16) -> Result<ComPtr<MidiSongPositionPointerMessage>> {
        <Self as RtActivatable<IMidiSongPositionPointerMessageFactory>>::get_activation_factory().create_midi_song_position_pointer_message(beats)
    }
}
DEFINE_CLSID!(MidiSongPositionPointerMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,111,110,103,80,111,115,105,116,105,111,110,80,111,105,110,116,101,114,77,101,115,115,97,103,101,0]) [CLSID_MidiSongPositionPointerMessage]);
DEFINE_IID!(IID_IMidiSongPositionPointerMessageFactory, 2617305494, 61707, 20458, 179, 149, 245, 214, 207, 128, 246, 78);
RT_INTERFACE!{static interface IMidiSongPositionPointerMessageFactory(IMidiSongPositionPointerMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongPositionPointerMessageFactory] {
    fn CreateMidiSongPositionPointerMessage(&self, beats: u16, out: *mut *mut MidiSongPositionPointerMessage) -> HRESULT
}}
impl ComPtr<IMidiSongPositionPointerMessageFactory> {
    #[inline] pub fn create_midi_song_position_pointer_message(&self, beats: u16) -> Result<ComPtr<MidiSongPositionPointerMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiSongPositionPointerMessage)(self.deref() as *const _ as *mut _, beats, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMidiSongSelectMessage, 1240527487, 28035, 18241, 165, 191, 70, 41, 246, 190, 151, 79);
RT_INTERFACE!{interface IMidiSongSelectMessage(IMidiSongSelectMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongSelectMessage] {
    fn get_Song(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiSongSelectMessage> {
    #[inline] pub fn get_song(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Song)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSongSelectMessage: IMidiSongSelectMessage}
impl RtActivatable<IMidiSongSelectMessageFactory> for MidiSongSelectMessage {}
impl MidiSongSelectMessage {
    #[inline] pub fn create_midi_song_select_message(song: u8) -> Result<ComPtr<MidiSongSelectMessage>> {
        <Self as RtActivatable<IMidiSongSelectMessageFactory>>::get_activation_factory().create_midi_song_select_message(song)
    }
}
DEFINE_CLSID!(MidiSongSelectMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,111,110,103,83,101,108,101,99,116,77,101,115,115,97,103,101,0]) [CLSID_MidiSongSelectMessage]);
DEFINE_IID!(IID_IMidiSongSelectMessageFactory, 2223536356, 34632, 16681, 166, 108, 160, 84, 147, 247, 93, 170);
RT_INTERFACE!{static interface IMidiSongSelectMessageFactory(IMidiSongSelectMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSongSelectMessageFactory] {
    fn CreateMidiSongSelectMessage(&self, song: u8, out: *mut *mut MidiSongSelectMessage) -> HRESULT
}}
impl ComPtr<IMidiSongSelectMessageFactory> {
    #[inline] pub fn create_midi_song_select_message(&self, song: u8) -> Result<ComPtr<MidiSongSelectMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiSongSelectMessage)(self.deref() as *const _ as *mut _, song, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiStartMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiStartMessage {}
DEFINE_CLSID!(MidiStartMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,116,97,114,116,77,101,115,115,97,103,101,0]) [CLSID_MidiStartMessage]);
RT_CLASS!{class MidiStopMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiStopMessage {}
DEFINE_CLSID!(MidiStopMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,116,111,112,77,101,115,115,97,103,101,0]) [CLSID_MidiStopMessage]);
DEFINE_IID!(IID_IMidiSynthesizer, 4040824158, 56208, 16479, 184, 174, 33, 210, 225, 127, 46, 69);
RT_INTERFACE!{interface IMidiSynthesizer(IMidiSynthesizerVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSynthesizer] {
    fn get_AudioDevice(&self, out: *mut *mut super::enumeration::DeviceInformation) -> HRESULT,
    fn get_Volume(&self, out: *mut f64) -> HRESULT,
    fn put_Volume(&self, value: f64) -> HRESULT
}}
impl ComPtr<IMidiSynthesizer> {
    #[inline] pub fn get_audio_device(&self) -> Result<Option<ComPtr<super::enumeration::DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AudioDevice)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_volume(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Volume)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_volume(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Volume)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSynthesizer: IMidiSynthesizer}
impl RtActivatable<IMidiSynthesizerStatics> for MidiSynthesizer {}
impl MidiSynthesizer {
    #[inline] pub fn create_async() -> Result<ComPtr<foundation::IAsyncOperation<MidiSynthesizer>>> {
        <Self as RtActivatable<IMidiSynthesizerStatics>>::get_activation_factory().create_async()
    }
    #[inline] pub fn create_from_audio_device_async(audioDevice: &ComPtr<super::enumeration::DeviceInformation>) -> Result<ComPtr<foundation::IAsyncOperation<MidiSynthesizer>>> {
        <Self as RtActivatable<IMidiSynthesizerStatics>>::get_activation_factory().create_from_audio_device_async(audioDevice)
    }
    #[inline] pub fn is_synthesizer(midiDevice: &ComPtr<super::enumeration::DeviceInformation>) -> Result<bool> {
        <Self as RtActivatable<IMidiSynthesizerStatics>>::get_activation_factory().is_synthesizer(midiDevice)
    }
}
DEFINE_CLSID!(MidiSynthesizer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,110,116,104,101,115,105,122,101,114,0]) [CLSID_MidiSynthesizer]);
DEFINE_IID!(IID_IMidiSynthesizerStatics, 1109715624, 26153, 19819, 170, 143, 212, 82, 26, 90, 49, 206);
RT_INTERFACE!{static interface IMidiSynthesizerStatics(IMidiSynthesizerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSynthesizerStatics] {
    fn CreateAsync(&self, out: *mut *mut foundation::IAsyncOperation<MidiSynthesizer>) -> HRESULT,
    fn CreateFromAudioDeviceAsync(&self, audioDevice: *mut super::enumeration::DeviceInformation, out: *mut *mut foundation::IAsyncOperation<MidiSynthesizer>) -> HRESULT,
    fn IsSynthesizer(&self, midiDevice: *mut super::enumeration::DeviceInformation, out: *mut bool) -> HRESULT
}}
impl ComPtr<IMidiSynthesizerStatics> {
    #[inline] pub fn create_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<MidiSynthesizer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_audio_device_async(&self, audioDevice: &ComPtr<super::enumeration::DeviceInformation>) -> Result<ComPtr<foundation::IAsyncOperation<MidiSynthesizer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromAudioDeviceAsync)(self.deref() as *const _ as *mut _, audioDevice.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_synthesizer(&self, midiDevice: &ComPtr<super::enumeration::DeviceInformation>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsSynthesizer)(self.deref() as *const _ as *mut _, midiDevice.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSystemExclusiveMessage: IMidiMessage}
impl RtActivatable<IMidiSystemExclusiveMessageFactory> for MidiSystemExclusiveMessage {}
impl MidiSystemExclusiveMessage {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_midi_system_exclusive_message(rawData: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<MidiSystemExclusiveMessage>> {
        <Self as RtActivatable<IMidiSystemExclusiveMessageFactory>>::get_activation_factory().create_midi_system_exclusive_message(rawData)
    }
}
DEFINE_CLSID!(MidiSystemExclusiveMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,115,116,101,109,69,120,99,108,117,115,105,118,101,77,101,115,115,97,103,101,0]) [CLSID_MidiSystemExclusiveMessage]);
DEFINE_IID!(IID_IMidiSystemExclusiveMessageFactory, 138273314, 15220, 17184, 155, 66, 12, 168, 84, 95, 138, 36);
RT_INTERFACE!{static interface IMidiSystemExclusiveMessageFactory(IMidiSystemExclusiveMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiSystemExclusiveMessageFactory] {
    #[cfg(feature="windows-storage")] fn CreateMidiSystemExclusiveMessage(&self, rawData: *mut super::super::storage::streams::IBuffer, out: *mut *mut MidiSystemExclusiveMessage) -> HRESULT
}}
impl ComPtr<IMidiSystemExclusiveMessageFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_midi_system_exclusive_message(&self, rawData: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<MidiSystemExclusiveMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiSystemExclusiveMessage)(self.deref() as *const _ as *mut _, rawData.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiSystemResetMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiSystemResetMessage {}
DEFINE_CLSID!(MidiSystemResetMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,83,121,115,116,101,109,82,101,115,101,116,77,101,115,115,97,103,101,0]) [CLSID_MidiSystemResetMessage]);
DEFINE_IID!(IID_IMidiTimeCodeMessage, 200738941, 64099, 18972, 141, 235, 192, 232, 119, 150, 166, 215);
RT_INTERFACE!{interface IMidiTimeCodeMessage(IMidiTimeCodeMessageVtbl): IInspectable(IInspectableVtbl) [IID_IMidiTimeCodeMessage] {
    fn get_FrameType(&self, out: *mut u8) -> HRESULT,
    fn get_Values(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IMidiTimeCodeMessage> {
    #[inline] pub fn get_frame_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_FrameType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_values(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Values)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiTimeCodeMessage: IMidiTimeCodeMessage}
impl RtActivatable<IMidiTimeCodeMessageFactory> for MidiTimeCodeMessage {}
impl MidiTimeCodeMessage {
    #[inline] pub fn create_midi_time_code_message(frameType: u8, values: u8) -> Result<ComPtr<MidiTimeCodeMessage>> {
        <Self as RtActivatable<IMidiTimeCodeMessageFactory>>::get_activation_factory().create_midi_time_code_message(frameType, values)
    }
}
DEFINE_CLSID!(MidiTimeCodeMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,105,109,101,67,111,100,101,77,101,115,115,97,103,101,0]) [CLSID_MidiTimeCodeMessage]);
DEFINE_IID!(IID_IMidiTimeCodeMessageFactory, 3945830853, 30492, 16606, 185, 97, 23, 90, 116, 137, 168, 94);
RT_INTERFACE!{static interface IMidiTimeCodeMessageFactory(IMidiTimeCodeMessageFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMidiTimeCodeMessageFactory] {
    fn CreateMidiTimeCodeMessage(&self, frameType: u8, values: u8, out: *mut *mut MidiTimeCodeMessage) -> HRESULT
}}
impl ComPtr<IMidiTimeCodeMessageFactory> {
    #[inline] pub fn create_midi_time_code_message(&self, frameType: u8, values: u8) -> Result<ComPtr<MidiTimeCodeMessage>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateMidiTimeCodeMessage)(self.deref() as *const _ as *mut _, frameType, values, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MidiTimingClockMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiTimingClockMessage {}
DEFINE_CLSID!(MidiTimingClockMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,105,109,105,110,103,67,108,111,99,107,77,101,115,115,97,103,101,0]) [CLSID_MidiTimingClockMessage]);
RT_CLASS!{class MidiTuneRequestMessage: IMidiMessage}
impl RtActivatable<IActivationFactory> for MidiTuneRequestMessage {}
DEFINE_CLSID!(MidiTuneRequestMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,77,105,100,105,46,77,105,100,105,84,117,110,101,82,101,113,117,101,115,116,77,101,115,115,97,103,101,0]) [CLSID_MidiTuneRequestMessage]);
} // Windows.Devices.Midi
pub mod perception { // Windows.Devices.Perception
use crate::prelude::*;
RT_CLASS!{static class KnownCameraIntrinsicsProperties}
impl RtActivatable<IKnownCameraIntrinsicsPropertiesStatics> for KnownCameraIntrinsicsProperties {}
impl KnownCameraIntrinsicsProperties {
    #[inline] pub fn get_focal_length() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_focal_length()
    }
    #[inline] pub fn get_principal_point() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_principal_point()
    }
    #[inline] pub fn get_radial_distortion() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_radial_distortion()
    }
    #[inline] pub fn get_tangential_distortion() -> Result<HString> {
        <Self as RtActivatable<IKnownCameraIntrinsicsPropertiesStatics>>::get_activation_factory().get_tangential_distortion()
    }
}
DEFINE_CLSID!(KnownCameraIntrinsicsProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,67,97,109,101,114,97,73,110,116,114,105,110,115,105,99,115,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownCameraIntrinsicsProperties]);
DEFINE_IID!(IID_IKnownCameraIntrinsicsPropertiesStatics, 146815352, 17274, 19863, 166, 99, 253, 49, 149, 96, 2, 73);
RT_INTERFACE!{static interface IKnownCameraIntrinsicsPropertiesStatics(IKnownCameraIntrinsicsPropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownCameraIntrinsicsPropertiesStatics] {
    fn get_FocalLength(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PrincipalPoint(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RadialDistortion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TangentialDistortion(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownCameraIntrinsicsPropertiesStatics> {
    #[inline] pub fn get_focal_length(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FocalLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_principal_point(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PrincipalPoint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_radial_distortion(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RadialDistortion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_tangential_distortion(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TangentialDistortion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionColorFrameSourceProperties}
impl RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics> for KnownPerceptionColorFrameSourceProperties {}
impl KnownPerceptionColorFrameSourceProperties {
    #[inline] pub fn get_exposure() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure()
    }
    #[inline] pub fn get_auto_exposure_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics>>::get_activation_factory().get_auto_exposure_enabled()
    }
    #[inline] pub fn get_exposure_compensation() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionColorFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure_compensation()
    }
}
DEFINE_CLSID!(KnownPerceptionColorFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,67,111,108,111,114,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionColorFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionColorFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 75);
RT_INTERFACE!{static interface IKnownPerceptionColorFrameSourcePropertiesStatics(IKnownPerceptionColorFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionColorFrameSourcePropertiesStatics] {
    fn get_Exposure(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AutoExposureEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExposureCompensation(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionColorFrameSourcePropertiesStatics> {
    #[inline] pub fn get_exposure(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Exposure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_exposure_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AutoExposureEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ExposureCompensation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionDepthFrameSourceProperties}
impl RtActivatable<IKnownPerceptionDepthFrameSourcePropertiesStatics> for KnownPerceptionDepthFrameSourceProperties {}
impl KnownPerceptionDepthFrameSourceProperties {
    #[inline] pub fn get_min_depth() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionDepthFrameSourcePropertiesStatics>>::get_activation_factory().get_min_depth()
    }
    #[inline] pub fn get_max_depth() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionDepthFrameSourcePropertiesStatics>>::get_activation_factory().get_max_depth()
    }
}
DEFINE_CLSID!(KnownPerceptionDepthFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,68,101,112,116,104,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionDepthFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionDepthFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 74);
RT_INTERFACE!{static interface IKnownPerceptionDepthFrameSourcePropertiesStatics(IKnownPerceptionDepthFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionDepthFrameSourcePropertiesStatics] {
    fn get_MinDepth(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MaxDepth(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionDepthFrameSourcePropertiesStatics> {
    #[inline] pub fn get_min_depth(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MinDepth)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_depth(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MaxDepth)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionFrameSourceProperties}
impl RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics> for KnownPerceptionFrameSourceProperties {}
impl RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics2> for KnownPerceptionFrameSourceProperties {}
impl KnownPerceptionFrameSourceProperties {
    #[inline] pub fn get_id() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_id()
    }
    #[inline] pub fn get_physical_device_ids() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_physical_device_ids()
    }
    #[inline] pub fn get_frame_kind() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_frame_kind()
    }
    #[inline] pub fn get_device_model_version() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_device_model_version()
    }
    #[inline] pub fn get_enclosure_location() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics>>::get_activation_factory().get_enclosure_location()
    }
    #[inline] pub fn get_device_id() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameSourcePropertiesStatics2>>::get_activation_factory().get_device_id()
    }
}
DEFINE_CLSID!(KnownPerceptionFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 71);
RT_INTERFACE!{static interface IKnownPerceptionFrameSourcePropertiesStatics(IKnownPerceptionFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameSourcePropertiesStatics] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhysicalDeviceIds(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FrameKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceModelVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EnclosureLocation(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionFrameSourcePropertiesStatics> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_ids(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhysicalDeviceIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_model_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceModelVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_enclosure_location(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EnclosureLocation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IKnownPerceptionFrameSourcePropertiesStatics2, 2848483441, 1500, 19021, 138, 92, 164, 236, 242, 107, 188, 70);
RT_INTERFACE!{static interface IKnownPerceptionFrameSourcePropertiesStatics2(IKnownPerceptionFrameSourcePropertiesStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameSourcePropertiesStatics2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionFrameSourcePropertiesStatics2> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionInfraredFrameSourceProperties}
impl RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics> for KnownPerceptionInfraredFrameSourceProperties {}
impl KnownPerceptionInfraredFrameSourceProperties {
    #[inline] pub fn get_exposure() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure()
    }
    #[inline] pub fn get_auto_exposure_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_auto_exposure_enabled()
    }
    #[inline] pub fn get_exposure_compensation() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_exposure_compensation()
    }
    #[inline] pub fn get_active_illumination_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_active_illumination_enabled()
    }
    #[inline] pub fn get_ambient_subtraction_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_ambient_subtraction_enabled()
    }
    #[inline] pub fn get_structure_light_pattern_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_structure_light_pattern_enabled()
    }
    #[inline] pub fn get_interleaved_illumination_enabled() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionInfraredFrameSourcePropertiesStatics>>::get_activation_factory().get_interleaved_illumination_enabled()
    }
}
DEFINE_CLSID!(KnownPerceptionInfraredFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,73,110,102,114,97,114,101,100,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionInfraredFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionInfraredFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 73);
RT_INTERFACE!{static interface IKnownPerceptionInfraredFrameSourcePropertiesStatics(IKnownPerceptionInfraredFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionInfraredFrameSourcePropertiesStatics] {
    fn get_Exposure(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AutoExposureEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExposureCompensation(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ActiveIlluminationEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AmbientSubtractionEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StructureLightPatternEnabled(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InterleavedIlluminationEnabled(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionInfraredFrameSourcePropertiesStatics> {
    #[inline] pub fn get_exposure(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Exposure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_exposure_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AutoExposureEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_exposure_compensation(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ExposureCompensation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_illumination_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ActiveIlluminationEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_ambient_subtraction_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AmbientSubtractionEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_structure_light_pattern_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StructureLightPatternEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interleaved_illumination_enabled(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterleavedIlluminationEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionVideoFrameSourceProperties}
impl RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics> for KnownPerceptionVideoFrameSourceProperties {}
impl KnownPerceptionVideoFrameSourceProperties {
    #[inline] pub fn get_video_profile() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_video_profile()
    }
    #[inline] pub fn get_supported_video_profiles() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_supported_video_profiles()
    }
    #[inline] pub fn get_available_video_profiles() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_available_video_profiles()
    }
    #[inline] pub fn get_is_mirrored() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_is_mirrored()
    }
    #[inline] pub fn get_camera_intrinsics() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoFrameSourcePropertiesStatics>>::get_activation_factory().get_camera_intrinsics()
    }
}
DEFINE_CLSID!(KnownPerceptionVideoFrameSourceProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,70,114,97,109,101,83,111,117,114,99,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionVideoFrameSourceProperties]);
DEFINE_IID!(IID_IKnownPerceptionVideoFrameSourcePropertiesStatics, 1576127650, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 72);
RT_INTERFACE!{static interface IKnownPerceptionVideoFrameSourcePropertiesStatics(IKnownPerceptionVideoFrameSourcePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionVideoFrameSourcePropertiesStatics] {
    fn get_VideoProfile(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsMirrored(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CameraIntrinsics(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionVideoFrameSourcePropertiesStatics> {
    #[inline] pub fn get_video_profile(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoProfile)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AvailableVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_mirrored(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_IsMirrored)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_camera_intrinsics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CameraIntrinsics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownPerceptionVideoProfileProperties}
impl RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics> for KnownPerceptionVideoProfileProperties {}
impl KnownPerceptionVideoProfileProperties {
    #[inline] pub fn get_bitmap_pixel_format() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_bitmap_pixel_format()
    }
    #[inline] pub fn get_bitmap_alpha_mode() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_bitmap_alpha_mode()
    }
    #[inline] pub fn get_width() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_width()
    }
    #[inline] pub fn get_height() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_height()
    }
    #[inline] pub fn get_frame_duration() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionVideoProfilePropertiesStatics>>::get_activation_factory().get_frame_duration()
    }
}
DEFINE_CLSID!(KnownPerceptionVideoProfileProperties(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,80,114,111,102,105,108,101,80,114,111,112,101,114,116,105,101,115,0]) [CLSID_KnownPerceptionVideoProfileProperties]);
DEFINE_IID!(IID_IKnownPerceptionVideoProfilePropertiesStatics, 2399724263, 23158, 17379, 161, 58, 218, 61, 145, 169, 239, 152);
RT_INTERFACE!{static interface IKnownPerceptionVideoProfilePropertiesStatics(IKnownPerceptionVideoProfilePropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionVideoProfilePropertiesStatics] {
    fn get_BitmapPixelFormat(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BitmapAlphaMode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Width(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Height(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FrameDuration(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionVideoProfilePropertiesStatics> {
    #[inline] pub fn get_bitmap_pixel_format(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BitmapPixelFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bitmap_alpha_mode(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BitmapAlphaMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Width)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Height)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_duration(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionColorFrame, 4267840841, 11455, 20372, 152, 97, 248, 23, 234, 49, 119, 71);
RT_INTERFACE!{interface IPerceptionColorFrame(IPerceptionColorFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrame] {
    #[cfg(feature="windows-media")] fn get_VideoFrame(&self, out: *mut *mut super::super::media::VideoFrame) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrame> {
    #[cfg(feature="windows-media")] #[inline] pub fn get_video_frame(&self) -> Result<Option<ComPtr<super::super::media::VideoFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrame: IPerceptionColorFrame}
DEFINE_IID!(IID_IPerceptionColorFrameArrivedEventArgs, 2410480341, 34551, 19853, 185, 102, 90, 55, 97, 186, 159, 89);
RT_INTERFACE!{interface IPerceptionColorFrameArrivedEventArgs(IPerceptionColorFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameArrivedEventArgs] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn TryOpenFrame(&self, out: *mut *mut PerceptionColorFrame) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameArrivedEventArgs> {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RelativeTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_open_frame(&self) -> Result<Option<ComPtr<PerceptionColorFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryOpenFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameArrivedEventArgs: IPerceptionColorFrameArrivedEventArgs}
DEFINE_IID!(IID_IPerceptionColorFrameReader, 1985017198, 47605, 17947, 131, 173, 242, 34, 175, 42, 170, 220);
RT_INTERFACE!{interface IPerceptionColorFrameReader(IPerceptionColorFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameReader] {
    fn add_FrameArrived(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameReader, PerceptionColorFrameArrivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut *mut PerceptionColorFrameSource) -> HRESULT,
    fn get_IsPaused(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaused(&self, value: bool) -> HRESULT,
    fn TryReadLatestFrame(&self, out: *mut *mut PerceptionColorFrame) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameReader> {
    #[inline] pub fn add_frame_arrived(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameReader, PerceptionColorFrameArrivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_FrameArrived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_FrameArrived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<PerceptionColorFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Source)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paused(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaused)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_paused(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsPaused)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_latest_frame(&self) -> Result<Option<ComPtr<PerceptionColorFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryReadLatestFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameReader: IPerceptionColorFrameReader}
DEFINE_IID!(IID_IPerceptionColorFrameSource, 3698178684, 2904, 18061, 156, 161, 109, 176, 76, 192, 71, 124);
RT_INTERFACE!{interface IPerceptionColorFrameSource(IPerceptionColorFrameSourceVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSource] {
    fn add_AvailableChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActiveChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertiesChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoProfileChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoProfileChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraIntrinsicsChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraIntrinsicsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Active(&self, out: *mut bool) -> HRESULT,
    fn get_IsControlled(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionVideoProfile>) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionVideoProfile>) -> HRESULT,
    fn get_VideoProfile(&self, out: *mut *mut PerceptionVideoProfile) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-media")] fn get_CameraIntrinsics(&self, out: *mut *mut super::super::media::devices::core::CameraIntrinsics) -> HRESULT,
    fn AcquireControlSession(&self, out: *mut *mut PerceptionControlSession) -> HRESULT,
    fn CanControlIndependentlyFrom(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn IsCorrelatedWith(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn TryGetTransformTo(&self, targetId: HSTRING, result: *mut foundation::numerics::Matrix4x4, out: *mut bool) -> HRESULT,
    fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&self, correlatedDepthFrameSource: *mut PerceptionDepthFrameSource, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>) -> HRESULT,
    fn TryGetDepthCorrelatedCoordinateMapperAsync(&self, targetSourceId: HSTRING, correlatedDepthFrameSource: *mut PerceptionDepthFrameSource, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>) -> HRESULT,
    fn TrySetVideoProfileAsync(&self, controlSession: *mut PerceptionControlSession, profile: *mut PerceptionVideoProfile, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> HRESULT,
    fn OpenReader(&self, out: *mut *mut PerceptionColorFrameReader) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameSource> {
    #[inline] pub fn add_available_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AvailableChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AvailableChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_active_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ActiveChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_active_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ActiveChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_properties_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PropertiesChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PropertiesChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_profile_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_VideoProfileChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_profile_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_VideoProfileChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_intrinsics_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CameraIntrinsicsChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_intrinsics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CameraIntrinsicsChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Available)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Active)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_controlled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsControlled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionVideoProfile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionVideoProfile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AvailableVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile(&self) -> Result<Option<ComPtr<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoProfile)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<ComPtr<super::super::media::devices::core::CameraIntrinsics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CameraIntrinsics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn acquire_control_session(&self) -> Result<Option<ComPtr<PerceptionControlSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AcquireControlSession)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_control_independently_from(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).CanControlIndependentlyFrom)(self.deref() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_correlated_with(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsCorrelatedWith)(self.deref() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_transform_to(&self, targetId: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, bool)> { unsafe { 
        let mut result = zeroed(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryGetTransformTo)(self.deref() as *const _ as *mut _, targetId.get(), &mut result, &mut out);
        if hr == S_OK { Ok((result, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_camera_intrinsics_async(&self, correlatedDepthFrameSource: &ComPtr<PerceptionDepthFrameSource>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self.deref() as *const _ as *mut _, correlatedDepthFrameSource.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_coordinate_mapper_async(&self, targetSourceId: &HStringArg, correlatedDepthFrameSource: &ComPtr<PerceptionDepthFrameSource>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self.deref() as *const _ as *mut _, targetSourceId.get(), correlatedDepthFrameSource.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_video_profile_async(&self, controlSession: &ComPtr<PerceptionControlSession>, profile: &ComPtr<PerceptionVideoProfile>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TrySetVideoProfileAsync)(self.deref() as *const _ as *mut _, controlSession.deref() as *const _ as *mut _, profile.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_reader(&self) -> Result<Option<ComPtr<PerceptionColorFrameReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenReader)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSource: IPerceptionColorFrameSource}
impl RtActivatable<IPerceptionColorFrameSourceStatics> for PerceptionColorFrameSource {}
impl PerceptionColorFrameSource {
    #[inline] pub fn create_watcher() -> Result<Option<ComPtr<PerceptionColorFrameSourceWatcher>>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn find_all_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionColorFrameSource>>>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionColorFrameSource>>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> {
        <Self as RtActivatable<IPerceptionColorFrameSourceStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(PerceptionColorFrameSource(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,67,111,108,111,114,70,114,97,109,101,83,111,117,114,99,101,0]) [CLSID_PerceptionColorFrameSource]);
DEFINE_IID!(IID_IPerceptionColorFrameSource2, 4169140453, 22065, 17901, 173, 152, 140, 106, 160, 76, 251, 145);
RT_INTERFACE!{interface IPerceptionColorFrameSource2(IPerceptionColorFrameSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSource2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameSource2> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionColorFrameSourceAddedEventArgs, 3513513190, 55844, 17452, 187, 213, 85, 84, 155, 91, 148, 243);
RT_INTERFACE!{interface IPerceptionColorFrameSourceAddedEventArgs(IPerceptionColorFrameSourceAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceAddedEventArgs] {
    fn get_FrameSource(&self, out: *mut *mut PerceptionColorFrameSource) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameSourceAddedEventArgs> {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<ComPtr<PerceptionColorFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSourceAddedEventArgs: IPerceptionColorFrameSourceAddedEventArgs}
DEFINE_IID!(IID_IPerceptionColorFrameSourceRemovedEventArgs, 3531078249, 60236, 17135, 186, 79, 40, 143, 97, 92, 147, 193);
RT_INTERFACE!{interface IPerceptionColorFrameSourceRemovedEventArgs(IPerceptionColorFrameSourceRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceRemovedEventArgs] {
    fn get_FrameSource(&self, out: *mut *mut PerceptionColorFrameSource) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameSourceRemovedEventArgs> {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<ComPtr<PerceptionColorFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSourceRemovedEventArgs: IPerceptionColorFrameSourceRemovedEventArgs}
DEFINE_IID!(IID_IPerceptionColorFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 73);
RT_INTERFACE!{static interface IPerceptionColorFrameSourceStatics(IPerceptionColorFrameSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceStatics] {
    fn CreateWatcher(&self, out: *mut *mut PerceptionColorFrameSourceWatcher) -> HRESULT,
    fn FindAllAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionColorFrameSource>>) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut *mut foundation::IAsyncOperation<PerceptionColorFrameSource>) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameSourceStatics> {
    #[inline] pub fn create_watcher(&self) -> Result<Option<ComPtr<PerceptionColorFrameSourceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcher)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionColorFrameSource>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionColorFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionColorFrameSourceWatcher, 2528973714, 58983, 16580, 137, 249, 20, 98, 222, 166, 169, 204);
RT_INTERFACE!{interface IPerceptionColorFrameSourceWatcher(IPerceptionColorFrameSourceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionColorFrameSourceWatcher] {
    fn add_SourceAdded(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceAddedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceRemoved(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceRemovedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: *mut foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::enumeration::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IPerceptionColorFrameSourceWatcher> {
    #[inline] pub fn add_source_added(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceAddedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SourceAdded)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SourceAdded)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, PerceptionColorFrameSourceRemovedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SourceRemoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SourceRemoved)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionColorFrameSourceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnumerationCompleted)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnumerationCompleted)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::enumeration::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionColorFrameSourceWatcher: IPerceptionColorFrameSourceWatcher}
DEFINE_IID!(IID_IPerceptionControlSession, 2576975443, 23101, 16767, 146, 57, 241, 136, 158, 84, 139, 72);
RT_INTERFACE!{interface IPerceptionControlSession(IPerceptionControlSessionVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionControlSession] {
    fn add_ControlLost(&self, handler: *mut foundation::TypedEventHandler<PerceptionControlSession, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ControlLost(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn TrySetPropertyAsync(&self, name: HSTRING, value: *mut IInspectable, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> HRESULT
}}
impl ComPtr<IPerceptionControlSession> {
    #[inline] pub fn add_control_lost(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionControlSession, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ControlLost)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_control_lost(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ControlLost)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_set_property_async(&self, name: &HStringArg, value: &ComPtr<IInspectable>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TrySetPropertyAsync)(self.deref() as *const _ as *mut _, name.get(), value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionControlSession: IPerceptionControlSession}
DEFINE_IID!(IID_IPerceptionDepthCorrelatedCameraIntrinsics, 1699269121, 34526, 23521, 101, 130, 128, 127, 207, 76, 149, 207);
RT_INTERFACE!{interface IPerceptionDepthCorrelatedCameraIntrinsics(IPerceptionDepthCorrelatedCameraIntrinsicsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthCorrelatedCameraIntrinsics] {
    fn UnprojectPixelAtCorrelatedDepth(&self, pixelCoordinate: foundation::Point, depthFrame: *mut PerceptionDepthFrame, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn UnprojectPixelsAtCorrelatedDepth(&self, sourceCoordinatesSize: u32, sourceCoordinates: *mut foundation::Point, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut foundation::numerics::Vector3) -> HRESULT,
    fn UnprojectRegionPixelsAtCorrelatedDepthAsync(&self, region: foundation::Rect, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut foundation::numerics::Vector3, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn UnprojectAllPixelsAtCorrelatedDepthAsync(&self, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut foundation::numerics::Vector3, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IPerceptionDepthCorrelatedCameraIntrinsics> {
    #[inline] pub fn unproject_pixel_at_correlated_depth(&self, pixelCoordinate: foundation::Point, depthFrame: &ComPtr<PerceptionDepthFrame>) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).UnprojectPixelAtCorrelatedDepth)(self.deref() as *const _ as *mut _, pixelCoordinate, depthFrame.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn unproject_pixels_at_correlated_depth(&self, sourceCoordinates: &[foundation::Point], depthFrame: &ComPtr<PerceptionDepthFrame>, results: &mut [foundation::numerics::Vector3]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UnprojectPixelsAtCorrelatedDepth)(self.deref() as *const _ as *mut _, sourceCoordinates.len() as u32, sourceCoordinates.as_ptr() as *mut _, depthFrame.deref() as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unproject_region_pixels_at_correlated_depth_async(&self, region: foundation::Rect, depthFrame: &ComPtr<PerceptionDepthFrame>, results: &mut [foundation::numerics::Vector3]) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UnprojectRegionPixelsAtCorrelatedDepthAsync)(self.deref() as *const _ as *mut _, region, depthFrame.deref() as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn unproject_all_pixels_at_correlated_depth_async(&self, depthFrame: &ComPtr<PerceptionDepthFrame>, results: &mut [foundation::numerics::Vector3]) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UnprojectAllPixelsAtCorrelatedDepthAsync)(self.deref() as *const _ as *mut _, depthFrame.deref() as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthCorrelatedCameraIntrinsics: IPerceptionDepthCorrelatedCameraIntrinsics}
DEFINE_IID!(IID_IPerceptionDepthCorrelatedCoordinateMapper, 1531813149, 46582, 18076, 184, 194, 185, 122, 69, 230, 134, 59);
RT_INTERFACE!{interface IPerceptionDepthCorrelatedCoordinateMapper(IPerceptionDepthCorrelatedCoordinateMapperVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthCorrelatedCoordinateMapper] {
    fn MapPixelToTarget(&self, sourcePixelCoordinate: foundation::Point, depthFrame: *mut PerceptionDepthFrame, out: *mut foundation::Point) -> HRESULT,
    fn MapPixelsToTarget(&self, sourceCoordinatesSize: u32, sourceCoordinates: *mut foundation::Point, depthFrame: *mut PerceptionDepthFrame, resultsSize: u32, results: *mut foundation::Point) -> HRESULT,
    fn MapRegionOfPixelsToTargetAsync(&self, region: foundation::Rect, depthFrame: *mut PerceptionDepthFrame, targetCoordinatesSize: u32, targetCoordinates: *mut foundation::Point, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn MapAllPixelsToTargetAsync(&self, depthFrame: *mut PerceptionDepthFrame, targetCoordinatesSize: u32, targetCoordinates: *mut foundation::Point, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IPerceptionDepthCorrelatedCoordinateMapper> {
    #[inline] pub fn map_pixel_to_target(&self, sourcePixelCoordinate: foundation::Point, depthFrame: &ComPtr<PerceptionDepthFrame>) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).MapPixelToTarget)(self.deref() as *const _ as *mut _, sourcePixelCoordinate, depthFrame.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn map_pixels_to_target(&self, sourceCoordinates: &[foundation::Point], depthFrame: &ComPtr<PerceptionDepthFrame>, results: &mut [foundation::Point]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).MapPixelsToTarget)(self.deref() as *const _ as *mut _, sourceCoordinates.len() as u32, sourceCoordinates.as_ptr() as *mut _, depthFrame.deref() as *const _ as *mut _, results.len() as u32, results.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn map_region_of_pixels_to_target_async(&self, region: foundation::Rect, depthFrame: &ComPtr<PerceptionDepthFrame>, targetCoordinates: &mut [foundation::Point]) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).MapRegionOfPixelsToTargetAsync)(self.deref() as *const _ as *mut _, region, depthFrame.deref() as *const _ as *mut _, targetCoordinates.len() as u32, targetCoordinates.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn map_all_pixels_to_target_async(&self, depthFrame: &ComPtr<PerceptionDepthFrame>, targetCoordinates: &mut [foundation::Point]) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).MapAllPixelsToTargetAsync)(self.deref() as *const _ as *mut _, depthFrame.deref() as *const _ as *mut _, targetCoordinates.len() as u32, targetCoordinates.as_mut_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthCorrelatedCoordinateMapper: IPerceptionDepthCorrelatedCoordinateMapper}
DEFINE_IID!(IID_IPerceptionDepthFrame, 2742780412, 39174, 20477, 145, 97, 0, 36, 179, 96, 182, 87);
RT_INTERFACE!{interface IPerceptionDepthFrame(IPerceptionDepthFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrame] {
    #[cfg(feature="windows-media")] fn get_VideoFrame(&self, out: *mut *mut super::super::media::VideoFrame) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrame> {
    #[cfg(feature="windows-media")] #[inline] pub fn get_video_frame(&self) -> Result<Option<ComPtr<super::super::media::VideoFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrame: IPerceptionDepthFrame}
DEFINE_IID!(IID_IPerceptionDepthFrameArrivedEventArgs, 1144858034, 45698, 17975, 145, 115, 172, 151, 132, 53, 201, 133);
RT_INTERFACE!{interface IPerceptionDepthFrameArrivedEventArgs(IPerceptionDepthFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameArrivedEventArgs] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn TryOpenFrame(&self, out: *mut *mut PerceptionDepthFrame) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameArrivedEventArgs> {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RelativeTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_open_frame(&self) -> Result<Option<ComPtr<PerceptionDepthFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryOpenFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameArrivedEventArgs: IPerceptionDepthFrameArrivedEventArgs}
DEFINE_IID!(IID_IPerceptionDepthFrameReader, 2980298911, 10651, 17938, 164, 247, 39, 15, 37, 160, 150, 236);
RT_INTERFACE!{interface IPerceptionDepthFrameReader(IPerceptionDepthFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameReader] {
    fn add_FrameArrived(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameReader, PerceptionDepthFrameArrivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut *mut PerceptionDepthFrameSource) -> HRESULT,
    fn get_IsPaused(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaused(&self, value: bool) -> HRESULT,
    fn TryReadLatestFrame(&self, out: *mut *mut PerceptionDepthFrame) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameReader> {
    #[inline] pub fn add_frame_arrived(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameReader, PerceptionDepthFrameArrivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_FrameArrived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_FrameArrived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<PerceptionDepthFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Source)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paused(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaused)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_paused(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsPaused)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_latest_frame(&self) -> Result<Option<ComPtr<PerceptionDepthFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryReadLatestFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameReader: IPerceptionDepthFrameReader}
DEFINE_IID!(IID_IPerceptionDepthFrameSource, 2043950038, 18427, 19953, 191, 201, 240, 29, 64, 189, 153, 66);
RT_INTERFACE!{interface IPerceptionDepthFrameSource(IPerceptionDepthFrameSourceVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSource] {
    fn add_AvailableChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActiveChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertiesChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoProfileChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoProfileChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraIntrinsicsChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraIntrinsicsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Active(&self, out: *mut bool) -> HRESULT,
    fn get_IsControlled(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionVideoProfile>) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionVideoProfile>) -> HRESULT,
    fn get_VideoProfile(&self, out: *mut *mut PerceptionVideoProfile) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-media")] fn get_CameraIntrinsics(&self, out: *mut *mut super::super::media::devices::core::CameraIntrinsics) -> HRESULT,
    fn AcquireControlSession(&self, out: *mut *mut PerceptionControlSession) -> HRESULT,
    fn CanControlIndependentlyFrom(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn IsCorrelatedWith(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn TryGetTransformTo(&self, targetId: HSTRING, result: *mut foundation::numerics::Matrix4x4, out: *mut bool) -> HRESULT,
    fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&self, target: *mut PerceptionDepthFrameSource, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>) -> HRESULT,
    fn TryGetDepthCorrelatedCoordinateMapperAsync(&self, targetId: HSTRING, depthFrameSourceToMapWith: *mut PerceptionDepthFrameSource, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>) -> HRESULT,
    fn TrySetVideoProfileAsync(&self, controlSession: *mut PerceptionControlSession, profile: *mut PerceptionVideoProfile, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> HRESULT,
    fn OpenReader(&self, out: *mut *mut PerceptionDepthFrameReader) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameSource> {
    #[inline] pub fn add_available_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AvailableChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AvailableChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_active_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ActiveChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_active_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ActiveChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_properties_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PropertiesChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PropertiesChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_profile_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_VideoProfileChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_profile_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_VideoProfileChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_intrinsics_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CameraIntrinsicsChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_intrinsics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CameraIntrinsicsChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Available)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Active)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_controlled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsControlled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionVideoProfile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionVideoProfile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AvailableVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile(&self) -> Result<Option<ComPtr<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoProfile)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<ComPtr<super::super::media::devices::core::CameraIntrinsics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CameraIntrinsics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn acquire_control_session(&self) -> Result<Option<ComPtr<PerceptionControlSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AcquireControlSession)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_control_independently_from(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).CanControlIndependentlyFrom)(self.deref() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_correlated_with(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsCorrelatedWith)(self.deref() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_transform_to(&self, targetId: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, bool)> { unsafe { 
        let mut result = zeroed(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryGetTransformTo)(self.deref() as *const _ as *mut _, targetId.get(), &mut result, &mut out);
        if hr == S_OK { Ok((result, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_camera_intrinsics_async(&self, target: &ComPtr<PerceptionDepthFrameSource>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_coordinate_mapper_async(&self, targetId: &HStringArg, depthFrameSourceToMapWith: &ComPtr<PerceptionDepthFrameSource>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self.deref() as *const _ as *mut _, targetId.get(), depthFrameSourceToMapWith.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_video_profile_async(&self, controlSession: &ComPtr<PerceptionControlSession>, profile: &ComPtr<PerceptionVideoProfile>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TrySetVideoProfileAsync)(self.deref() as *const _ as *mut _, controlSession.deref() as *const _ as *mut _, profile.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_reader(&self) -> Result<Option<ComPtr<PerceptionDepthFrameReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenReader)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSource: IPerceptionDepthFrameSource}
impl RtActivatable<IPerceptionDepthFrameSourceStatics> for PerceptionDepthFrameSource {}
impl PerceptionDepthFrameSource {
    #[inline] pub fn create_watcher() -> Result<Option<ComPtr<PerceptionDepthFrameSourceWatcher>>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn find_all_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionDepthFrameSource>>>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthFrameSource>>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> {
        <Self as RtActivatable<IPerceptionDepthFrameSourceStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(PerceptionDepthFrameSource(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,68,101,112,116,104,70,114,97,109,101,83,111,117,114,99,101,0]) [CLSID_PerceptionDepthFrameSource]);
DEFINE_IID!(IID_IPerceptionDepthFrameSource2, 3822206254, 28204, 20077, 145, 217, 112, 76, 216, 223, 247, 157);
RT_INTERFACE!{interface IPerceptionDepthFrameSource2(IPerceptionDepthFrameSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSource2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameSource2> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceAddedEventArgs, 2477031784, 35832, 17874, 162, 248, 74, 192, 147, 28, 199, 166);
RT_INTERFACE!{interface IPerceptionDepthFrameSourceAddedEventArgs(IPerceptionDepthFrameSourceAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceAddedEventArgs] {
    fn get_FrameSource(&self, out: *mut *mut PerceptionDepthFrameSource) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameSourceAddedEventArgs> {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<ComPtr<PerceptionDepthFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSourceAddedEventArgs: IPerceptionDepthFrameSourceAddedEventArgs}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceRemovedEventArgs, 2696989773, 59756, 19841, 134, 221, 56, 185, 94, 73, 198, 223);
RT_INTERFACE!{interface IPerceptionDepthFrameSourceRemovedEventArgs(IPerceptionDepthFrameSourceRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceRemovedEventArgs] {
    fn get_FrameSource(&self, out: *mut *mut PerceptionDepthFrameSource) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameSourceRemovedEventArgs> {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<ComPtr<PerceptionDepthFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSourceRemovedEventArgs: IPerceptionDepthFrameSourceRemovedEventArgs}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 72);
RT_INTERFACE!{static interface IPerceptionDepthFrameSourceStatics(IPerceptionDepthFrameSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceStatics] {
    fn CreateWatcher(&self, out: *mut *mut PerceptionDepthFrameSourceWatcher) -> HRESULT,
    fn FindAllAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionDepthFrameSource>>) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthFrameSource>) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameSourceStatics> {
    #[inline] pub fn create_watcher(&self) -> Result<Option<ComPtr<PerceptionDepthFrameSourceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcher)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionDepthFrameSource>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionDepthFrameSourceWatcher, 2014222033, 36098, 19755, 173, 164, 91, 166, 36, 160, 235, 16);
RT_INTERFACE!{interface IPerceptionDepthFrameSourceWatcher(IPerceptionDepthFrameSourceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionDepthFrameSourceWatcher] {
    fn add_SourceAdded(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceAddedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceRemoved(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceRemovedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: *mut foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::enumeration::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IPerceptionDepthFrameSourceWatcher> {
    #[inline] pub fn add_source_added(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceAddedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SourceAdded)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SourceAdded)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, PerceptionDepthFrameSourceRemovedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SourceRemoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SourceRemoved)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionDepthFrameSourceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnumerationCompleted)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnumerationCompleted)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::enumeration::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionDepthFrameSourceWatcher: IPerceptionDepthFrameSourceWatcher}
RT_ENUM! { enum PerceptionFrameSourceAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
DEFINE_IID!(IID_IPerceptionFrameSourcePropertiesChangedEventArgs, 1818812520, 48369, 20172, 184, 145, 118, 37, 209, 36, 75, 107);
RT_INTERFACE!{interface IPerceptionFrameSourcePropertiesChangedEventArgs(IPerceptionFrameSourcePropertiesChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameSourcePropertiesChangedEventArgs] {
    fn get_CollectionChange(&self, out: *mut foundation::collections::CollectionChange) -> HRESULT,
    fn get_Key(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPerceptionFrameSourcePropertiesChangedEventArgs> {
    #[inline] pub fn get_collection_change(&self) -> Result<foundation::collections::CollectionChange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CollectionChange)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_key(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Key)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrameSourcePropertiesChangedEventArgs: IPerceptionFrameSourcePropertiesChangedEventArgs}
DEFINE_IID!(IID_IPerceptionFrameSourcePropertyChangeResult, 506673418, 15504, 19746, 184, 152, 244, 43, 186, 100, 24, 255);
RT_INTERFACE!{interface IPerceptionFrameSourcePropertyChangeResult(IPerceptionFrameSourcePropertyChangeResultVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameSourcePropertyChangeResult] {
    fn get_Status(&self, out: *mut PerceptionFrameSourcePropertyChangeStatus) -> HRESULT,
    fn get_NewValue(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl ComPtr<IPerceptionFrameSourcePropertyChangeResult> {
    #[inline] pub fn get_status(&self) -> Result<PerceptionFrameSourcePropertyChangeStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_new_value(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_NewValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrameSourcePropertyChangeResult: IPerceptionFrameSourcePropertyChangeResult}
RT_ENUM! { enum PerceptionFrameSourcePropertyChangeStatus: i32 {
    Unknown = 0, Accepted = 1, LostControl = 2, PropertyNotSupported = 3, PropertyReadOnly = 4, ValueOutOfRange = 5,
}}
DEFINE_IID!(IID_IPerceptionInfraredFrame, 2961728118, 33950, 19578, 138, 230, 181, 96, 100, 83, 33, 83);
RT_INTERFACE!{interface IPerceptionInfraredFrame(IPerceptionInfraredFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrame] {
    #[cfg(feature="windows-media")] fn get_VideoFrame(&self, out: *mut *mut super::super::media::VideoFrame) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrame> {
    #[cfg(feature="windows-media")] #[inline] pub fn get_video_frame(&self) -> Result<Option<ComPtr<super::super::media::VideoFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrame: IPerceptionInfraredFrame}
DEFINE_IID!(IID_IPerceptionInfraredFrameArrivedEventArgs, 2675440327, 46269, 18519, 157, 80, 190, 142, 240, 117, 218, 239);
RT_INTERFACE!{interface IPerceptionInfraredFrameArrivedEventArgs(IPerceptionInfraredFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameArrivedEventArgs] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn TryOpenFrame(&self, out: *mut *mut PerceptionInfraredFrame) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameArrivedEventArgs> {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RelativeTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_open_frame(&self) -> Result<Option<ComPtr<PerceptionInfraredFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryOpenFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameArrivedEventArgs: IPerceptionInfraredFrameArrivedEventArgs}
DEFINE_IID!(IID_IPerceptionInfraredFrameReader, 2036387352, 54171, 20424, 160, 74, 146, 151, 52, 198, 117, 108);
RT_INTERFACE!{interface IPerceptionInfraredFrameReader(IPerceptionInfraredFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameReader] {
    fn add_FrameArrived(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameReader, PerceptionInfraredFrameArrivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Source(&self, out: *mut *mut PerceptionInfraredFrameSource) -> HRESULT,
    fn get_IsPaused(&self, out: *mut bool) -> HRESULT,
    fn put_IsPaused(&self, value: bool) -> HRESULT,
    fn TryReadLatestFrame(&self, out: *mut *mut PerceptionInfraredFrame) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameReader> {
    #[inline] pub fn add_frame_arrived(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameReader, PerceptionInfraredFrameArrivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_FrameArrived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_FrameArrived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<Option<ComPtr<PerceptionInfraredFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Source)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paused(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaused)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_paused(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsPaused)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_read_latest_frame(&self) -> Result<Option<ComPtr<PerceptionInfraredFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryReadLatestFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameReader: IPerceptionInfraredFrameReader}
DEFINE_IID!(IID_IPerceptionInfraredFrameSource, 1437632322, 6152, 18766, 158, 48, 157, 42, 123, 232, 247, 0);
RT_INTERFACE!{interface IPerceptionInfraredFrameSource(IPerceptionInfraredFrameSourceVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSource] {
    fn add_AvailableChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ActiveChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ActiveChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PropertiesChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PropertiesChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VideoProfileChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VideoProfileChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CameraIntrinsicsChanged(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CameraIntrinsicsChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Active(&self, out: *mut bool) -> HRESULT,
    fn get_IsControlled(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn get_SupportedVideoProfiles(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionVideoProfile>) -> HRESULT,
    fn get_AvailableVideoProfiles(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionVideoProfile>) -> HRESULT,
    fn get_VideoProfile(&self, out: *mut *mut PerceptionVideoProfile) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy20(&self) -> (),
    #[cfg(feature="windows-media")] fn get_CameraIntrinsics(&self, out: *mut *mut super::super::media::devices::core::CameraIntrinsics) -> HRESULT,
    fn AcquireControlSession(&self, out: *mut *mut PerceptionControlSession) -> HRESULT,
    fn CanControlIndependentlyFrom(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn IsCorrelatedWith(&self, targetId: HSTRING, out: *mut bool) -> HRESULT,
    fn TryGetTransformTo(&self, targetId: HSTRING, result: *mut foundation::numerics::Matrix4x4, out: *mut bool) -> HRESULT,
    fn TryGetDepthCorrelatedCameraIntrinsicsAsync(&self, target: *mut PerceptionDepthFrameSource, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>) -> HRESULT,
    fn TryGetDepthCorrelatedCoordinateMapperAsync(&self, targetId: HSTRING, depthFrameSourceToMapWith: *mut PerceptionDepthFrameSource, out: *mut *mut foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>) -> HRESULT,
    fn TrySetVideoProfileAsync(&self, controlSession: *mut PerceptionControlSession, profile: *mut PerceptionVideoProfile, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>) -> HRESULT,
    fn OpenReader(&self, out: *mut *mut PerceptionInfraredFrameReader) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameSource> {
    #[inline] pub fn add_available_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AvailableChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AvailableChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_active_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ActiveChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_active_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ActiveChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_properties_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSource, PerceptionFrameSourcePropertiesChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PropertiesChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_properties_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PropertiesChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_video_profile_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_VideoProfileChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_video_profile_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_VideoProfileChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_camera_intrinsics_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSource, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CameraIntrinsicsChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_camera_intrinsics_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CameraIntrinsicsChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Available)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_active(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Active)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_controlled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsControlled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_video_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionVideoProfile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available_video_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionVideoProfile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AvailableVideoProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_profile(&self) -> Result<Option<ComPtr<PerceptionVideoProfile>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoProfile)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn get_camera_intrinsics(&self) -> Result<Option<ComPtr<super::super::media::devices::core::CameraIntrinsics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CameraIntrinsics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn acquire_control_session(&self) -> Result<Option<ComPtr<PerceptionControlSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AcquireControlSession)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn can_control_independently_from(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).CanControlIndependentlyFrom)(self.deref() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_correlated_with(&self, targetId: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsCorrelatedWith)(self.deref() as *const _ as *mut _, targetId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn try_get_transform_to(&self, targetId: &HStringArg) -> Result<(foundation::numerics::Matrix4x4, bool)> { unsafe { 
        let mut result = zeroed(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryGetTransformTo)(self.deref() as *const _ as *mut _, targetId.get(), &mut result, &mut out);
        if hr == S_OK { Ok((result, out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_camera_intrinsics_async(&self, target: &ComPtr<PerceptionDepthFrameSource>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthCorrelatedCameraIntrinsics>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetDepthCorrelatedCameraIntrinsicsAsync)(self.deref() as *const _ as *mut _, target.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_get_depth_correlated_coordinate_mapper_async(&self, targetId: &HStringArg, depthFrameSourceToMapWith: &ComPtr<PerceptionDepthFrameSource>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionDepthCorrelatedCoordinateMapper>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryGetDepthCorrelatedCoordinateMapperAsync)(self.deref() as *const _ as *mut _, targetId.get(), depthFrameSourceToMapWith.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_video_profile_async(&self, controlSession: &ComPtr<PerceptionControlSession>, profile: &ComPtr<PerceptionVideoProfile>) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourcePropertyChangeResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TrySetVideoProfileAsync)(self.deref() as *const _ as *mut _, controlSession.deref() as *const _ as *mut _, profile.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_reader(&self) -> Result<Option<ComPtr<PerceptionInfraredFrameReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenReader)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSource: IPerceptionInfraredFrameSource}
impl RtActivatable<IPerceptionInfraredFrameSourceStatics> for PerceptionInfraredFrameSource {}
impl PerceptionInfraredFrameSource {
    #[inline] pub fn create_watcher() -> Result<Option<ComPtr<PerceptionInfraredFrameSourceWatcher>>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().create_watcher()
    }
    #[inline] pub fn find_all_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionInfraredFrameSource>>>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().find_all_async()
    }
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionInfraredFrameSource>>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().from_id_async(id)
    }
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> {
        <Self as RtActivatable<IPerceptionInfraredFrameSourceStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(PerceptionInfraredFrameSource(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,101,114,99,101,112,116,105,111,110,73,110,102,114,97,114,101,100,70,114,97,109,101,83,111,117,114,99,101,0]) [CLSID_PerceptionInfraredFrameSource]);
DEFINE_IID!(IID_IPerceptionInfraredFrameSource2, 3704936344, 19211, 17152, 141, 133, 65, 8, 23, 250, 160, 50);
RT_INTERFACE!{interface IPerceptionInfraredFrameSource2(IPerceptionInfraredFrameSource2Vtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSource2] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameSource2> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceAddedEventArgs, 1832075552, 38350, 18016, 144, 122, 217, 128, 53, 170, 43, 124);
RT_INTERFACE!{interface IPerceptionInfraredFrameSourceAddedEventArgs(IPerceptionInfraredFrameSourceAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceAddedEventArgs] {
    fn get_FrameSource(&self, out: *mut *mut PerceptionInfraredFrameSource) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameSourceAddedEventArgs> {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<ComPtr<PerceptionInfraredFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSourceAddedEventArgs: IPerceptionInfraredFrameSourceAddedEventArgs}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceRemovedEventArgs, 3927605361, 31344, 19041, 175, 148, 7, 48, 56, 83, 246, 149);
RT_INTERFACE!{interface IPerceptionInfraredFrameSourceRemovedEventArgs(IPerceptionInfraredFrameSourceRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceRemovedEventArgs] {
    fn get_FrameSource(&self, out: *mut *mut PerceptionInfraredFrameSource) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameSourceRemovedEventArgs> {
    #[inline] pub fn get_frame_source(&self) -> Result<Option<ComPtr<PerceptionInfraredFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSourceRemovedEventArgs: IPerceptionInfraredFrameSourceRemovedEventArgs}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceStatics, 1576258722, 504, 19079, 184, 89, 213, 229, 183, 225, 222, 71);
RT_INTERFACE!{static interface IPerceptionInfraredFrameSourceStatics(IPerceptionInfraredFrameSourceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceStatics] {
    fn CreateWatcher(&self, out: *mut *mut PerceptionInfraredFrameSourceWatcher) -> HRESULT,
    fn FindAllAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionInfraredFrameSource>>) -> HRESULT,
    fn FromIdAsync(&self, id: HSTRING, out: *mut *mut foundation::IAsyncOperation<PerceptionInfraredFrameSource>) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameSourceStatics> {
    #[inline] pub fn create_watcher(&self) -> Result<Option<ComPtr<PerceptionInfraredFrameSourceWatcher>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWatcher)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PerceptionInfraredFrameSource>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, id: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionInfraredFrameSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<PerceptionFrameSourceAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionInfraredFrameSourceWatcher, 943521689, 55052, 17485, 168, 176, 114, 12, 46, 102, 254, 59);
RT_INTERFACE!{interface IPerceptionInfraredFrameSourceWatcher(IPerceptionInfraredFrameSourceWatcherVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionInfraredFrameSourceWatcher] {
    fn add_SourceAdded(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceAddedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SourceRemoved(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceRemovedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SourceRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Stopped(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Stopped(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnumerationCompleted(&self, handler: *mut foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnumerationCompleted(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_Status(&self, out: *mut super::enumeration::DeviceWatcherStatus) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IPerceptionInfraredFrameSourceWatcher> {
    #[inline] pub fn add_source_added(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceAddedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SourceAdded)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SourceAdded)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_source_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, PerceptionInfraredFrameSourceRemovedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SourceRemoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_source_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SourceRemoved)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stopped(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Stopped)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stopped(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Stopped)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_enumeration_completed(&self, handler: &ComPtr<foundation::TypedEventHandler<PerceptionInfraredFrameSourceWatcher, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnumerationCompleted)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enumeration_completed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnumerationCompleted)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::enumeration::DeviceWatcherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionInfraredFrameSourceWatcher: IPerceptionInfraredFrameSourceWatcher}
DEFINE_IID!(IID_IPerceptionVideoProfile, 1970683555, 282, 18190, 130, 37, 111, 5, 173, 226, 86, 72);
RT_INTERFACE!{interface IPerceptionVideoProfile(IPerceptionVideoProfileVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoProfile] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_BitmapPixelFormat(&self, out: *mut super::super::graphics::imaging::BitmapPixelFormat) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_BitmapAlphaMode(&self, out: *mut super::super::graphics::imaging::BitmapAlphaMode) -> HRESULT,
    fn get_Width(&self, out: *mut i32) -> HRESULT,
    fn get_Height(&self, out: *mut i32) -> HRESULT,
    fn get_FrameDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn IsEqual(&self, other: *mut PerceptionVideoProfile, out: *mut bool) -> HRESULT
}}
impl ComPtr<IPerceptionVideoProfile> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_bitmap_pixel_format(&self) -> Result<super::super::graphics::imaging::BitmapPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BitmapPixelFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_bitmap_alpha_mode(&self) -> Result<super::super::graphics::imaging::BitmapAlphaMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BitmapAlphaMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Width)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Height)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_FrameDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_equal(&self, other: &ComPtr<PerceptionVideoProfile>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsEqual)(self.deref() as *const _ as *mut _, other.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionVideoProfile: IPerceptionVideoProfile}
pub mod provider { // Windows.Devices.Perception.Provider
use crate::prelude::*;
RT_CLASS!{static class KnownPerceptionFrameKind}
impl RtActivatable<IKnownPerceptionFrameKindStatics> for KnownPerceptionFrameKind {}
impl KnownPerceptionFrameKind {
    #[inline] pub fn get_color() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameKindStatics>>::get_activation_factory().get_color()
    }
    #[inline] pub fn get_depth() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameKindStatics>>::get_activation_factory().get_depth()
    }
    #[inline] pub fn get_infrared() -> Result<HString> {
        <Self as RtActivatable<IKnownPerceptionFrameKindStatics>>::get_activation_factory().get_infrared()
    }
}
DEFINE_CLSID!(KnownPerceptionFrameKind(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,75,110,111,119,110,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,75,105,110,100,0]) [CLSID_KnownPerceptionFrameKind]);
DEFINE_IID!(IID_IKnownPerceptionFrameKindStatics, 988172758, 38505, 16646, 159, 174, 72, 53, 193, 185, 97, 4);
RT_INTERFACE!{static interface IKnownPerceptionFrameKindStatics(IKnownPerceptionFrameKindStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownPerceptionFrameKindStatics] {
    fn get_Color(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Depth(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Infrared(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IKnownPerceptionFrameKindStatics> {
    #[inline] pub fn get_color(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Color)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_depth(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Depth)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_infrared(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Infrared)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionControlGroup, 388778114, 12249, 19534, 186, 52, 253, 242, 10, 115, 221, 229);
RT_INTERFACE!{interface IPerceptionControlGroup(IPerceptionControlGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionControlGroup] {
    fn get_FrameProviderIds(&self, out: *mut *mut foundation::collections::IVectorView<HString>) -> HRESULT
}}
impl ComPtr<IPerceptionControlGroup> {
    #[inline] pub fn get_frame_provider_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameProviderIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionControlGroup: IPerceptionControlGroup}
impl RtActivatable<IPerceptionControlGroupFactory> for PerceptionControlGroup {}
impl PerceptionControlGroup {
    #[inline] pub fn create(ids: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<PerceptionControlGroup>> {
        <Self as RtActivatable<IPerceptionControlGroupFactory>>::get_activation_factory().create(ids)
    }
}
DEFINE_CLSID!(PerceptionControlGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,110,116,114,111,108,71,114,111,117,112,0]) [CLSID_PerceptionControlGroup]);
DEFINE_IID!(IID_IPerceptionControlGroupFactory, 790295264, 47857, 17723, 190, 212, 205, 157, 70, 25, 21, 76);
RT_INTERFACE!{static interface IPerceptionControlGroupFactory(IPerceptionControlGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionControlGroupFactory] {
    fn Create(&self, ids: *mut foundation::collections::IIterable<HString>, out: *mut *mut PerceptionControlGroup) -> HRESULT
}}
impl ComPtr<IPerceptionControlGroupFactory> {
    #[inline] pub fn create(&self, ids: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<PerceptionControlGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, ids.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionCorrelation, 3021150850, 57333, 16455, 138, 25, 59, 77, 128, 95, 113, 118);
RT_INTERFACE!{interface IPerceptionCorrelation(IPerceptionCorrelationVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelation] {
    fn get_TargetId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::numerics::Vector3) -> HRESULT,
    fn get_Orientation(&self, out: *mut foundation::numerics::Quaternion) -> HRESULT
}}
impl ComPtr<IPerceptionCorrelation> {
    #[inline] pub fn get_target_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TargetId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::numerics::Vector3> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Position)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<foundation::numerics::Quaternion> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Orientation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionCorrelation: IPerceptionCorrelation}
impl RtActivatable<IPerceptionCorrelationFactory> for PerceptionCorrelation {}
impl PerceptionCorrelation {
    #[inline] pub fn create(targetId: &HStringArg, position: foundation::numerics::Vector3, orientation: foundation::numerics::Quaternion) -> Result<ComPtr<PerceptionCorrelation>> {
        <Self as RtActivatable<IPerceptionCorrelationFactory>>::get_activation_factory().create(targetId, position, orientation)
    }
}
DEFINE_CLSID!(PerceptionCorrelation(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,114,114,101,108,97,116,105,111,110,0]) [CLSID_PerceptionCorrelation]);
DEFINE_IID!(IID_IPerceptionCorrelationFactory, 3567698981, 10372, 19087, 129, 52, 40, 53, 215, 40, 108, 191);
RT_INTERFACE!{static interface IPerceptionCorrelationFactory(IPerceptionCorrelationFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationFactory] {
    fn Create(&self, targetId: HSTRING, position: foundation::numerics::Vector3, orientation: foundation::numerics::Quaternion, out: *mut *mut PerceptionCorrelation) -> HRESULT
}}
impl ComPtr<IPerceptionCorrelationFactory> {
    #[inline] pub fn create(&self, targetId: &HStringArg, position: foundation::numerics::Vector3, orientation: foundation::numerics::Quaternion) -> Result<ComPtr<PerceptionCorrelation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, targetId.get(), position, orientation, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionCorrelationGroup, 1965689094, 13991, 18363, 155, 121, 86, 204, 107, 116, 103, 112);
RT_INTERFACE!{interface IPerceptionCorrelationGroup(IPerceptionCorrelationGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationGroup] {
    fn get_RelativeLocations(&self, out: *mut *mut foundation::collections::IVectorView<PerceptionCorrelation>) -> HRESULT
}}
impl ComPtr<IPerceptionCorrelationGroup> {
    #[inline] pub fn get_relative_locations(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PerceptionCorrelation>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RelativeLocations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionCorrelationGroup: IPerceptionCorrelationGroup}
impl RtActivatable<IPerceptionCorrelationGroupFactory> for PerceptionCorrelationGroup {}
impl PerceptionCorrelationGroup {
    #[inline] pub fn create(relativeLocations: &ComPtr<foundation::collections::IIterable<PerceptionCorrelation>>) -> Result<ComPtr<PerceptionCorrelationGroup>> {
        <Self as RtActivatable<IPerceptionCorrelationGroupFactory>>::get_activation_factory().create(relativeLocations)
    }
}
DEFINE_CLSID!(PerceptionCorrelationGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,67,111,114,114,101,108,97,116,105,111,110,71,114,111,117,112,0]) [CLSID_PerceptionCorrelationGroup]);
DEFINE_IID!(IID_IPerceptionCorrelationGroupFactory, 2113806472, 25567, 18669, 131, 177, 74, 184, 41, 19, 41, 149);
RT_INTERFACE!{static interface IPerceptionCorrelationGroupFactory(IPerceptionCorrelationGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionCorrelationGroupFactory] {
    fn Create(&self, relativeLocations: *mut foundation::collections::IIterable<PerceptionCorrelation>, out: *mut *mut PerceptionCorrelationGroup) -> HRESULT
}}
impl ComPtr<IPerceptionCorrelationGroupFactory> {
    #[inline] pub fn create(&self, relativeLocations: &ComPtr<foundation::collections::IIterable<PerceptionCorrelation>>) -> Result<ComPtr<PerceptionCorrelationGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, relativeLocations.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionFaceAuthenticationGroup, 3892418580, 19089, 16816, 131, 166, 136, 26, 23, 117, 53, 62);
RT_INTERFACE!{interface IPerceptionFaceAuthenticationGroup(IPerceptionFaceAuthenticationGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFaceAuthenticationGroup] {
    fn get_FrameProviderIds(&self, out: *mut *mut foundation::collections::IVectorView<HString>) -> HRESULT
}}
impl ComPtr<IPerceptionFaceAuthenticationGroup> {
    #[inline] pub fn get_frame_provider_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameProviderIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFaceAuthenticationGroup: IPerceptionFaceAuthenticationGroup}
impl RtActivatable<IPerceptionFaceAuthenticationGroupFactory> for PerceptionFaceAuthenticationGroup {}
impl PerceptionFaceAuthenticationGroup {
    #[inline] pub fn create(ids: &ComPtr<foundation::collections::IIterable<HString>>, startHandler: &ComPtr<PerceptionStartFaceAuthenticationHandler>, stopHandler: &ComPtr<PerceptionStopFaceAuthenticationHandler>) -> Result<ComPtr<PerceptionFaceAuthenticationGroup>> {
        <Self as RtActivatable<IPerceptionFaceAuthenticationGroupFactory>>::get_activation_factory().create(ids, startHandler, stopHandler)
    }
}
DEFINE_CLSID!(PerceptionFaceAuthenticationGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,97,99,101,65,117,116,104,101,110,116,105,99,97,116,105,111,110,71,114,111,117,112,0]) [CLSID_PerceptionFaceAuthenticationGroup]);
DEFINE_IID!(IID_IPerceptionFaceAuthenticationGroupFactory, 3867805140, 46604, 16628, 188, 185, 242, 77, 70, 70, 115, 32);
RT_INTERFACE!{static interface IPerceptionFaceAuthenticationGroupFactory(IPerceptionFaceAuthenticationGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFaceAuthenticationGroupFactory] {
    fn Create(&self, ids: *mut foundation::collections::IIterable<HString>, startHandler: *mut PerceptionStartFaceAuthenticationHandler, stopHandler: *mut PerceptionStopFaceAuthenticationHandler, out: *mut *mut PerceptionFaceAuthenticationGroup) -> HRESULT
}}
impl ComPtr<IPerceptionFaceAuthenticationGroupFactory> {
    #[inline] pub fn create(&self, ids: &ComPtr<foundation::collections::IIterable<HString>>, startHandler: &ComPtr<PerceptionStartFaceAuthenticationHandler>, stopHandler: &ComPtr<PerceptionStopFaceAuthenticationHandler>) -> Result<ComPtr<PerceptionFaceAuthenticationGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, ids.deref() as *const _ as *mut _, startHandler.deref() as *const _ as *mut _, stopHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionFrame, 2097051685, 21691, 19869, 190, 197, 142, 246, 97, 81, 210, 172);
RT_INTERFACE!{interface IPerceptionFrame(IPerceptionFrameVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrame] {
    fn get_RelativeTime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RelativeTime(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::ValueSet) -> HRESULT,
    fn get_FrameData(&self, out: *mut *mut foundation::IMemoryBuffer) -> HRESULT
}}
impl ComPtr<IPerceptionFrame> {
    #[inline] pub fn get_relative_time(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RelativeTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_relative_time(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RelativeTime)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::ValueSet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_data(&self) -> Result<Option<ComPtr<foundation::IMemoryBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrame: IPerceptionFrame}
DEFINE_IID!(IID_IPerceptionFrameProvider, 2035251897, 45949, 15155, 161, 13, 48, 98, 100, 25, 206, 101);
RT_INTERFACE!{interface IPerceptionFrameProvider(IPerceptionFrameProviderVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProvider] {
    fn get_FrameProviderInfo(&self, out: *mut *mut PerceptionFrameProviderInfo) -> HRESULT,
    fn get_Available(&self, out: *mut bool) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IPropertySet) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn SetProperty(&self, value: *mut PerceptionPropertyChangeRequest) -> HRESULT
}}
impl ComPtr<IPerceptionFrameProvider> {
    #[inline] pub fn get_frame_provider_info(&self) -> Result<Option<ComPtr<PerceptionFrameProviderInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameProviderInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Available)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IPropertySet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_property(&self, value: &ComPtr<PerceptionPropertyChangeRequest>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetProperty)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionFrameProviderInfo, 3433650664, 31102, 20099, 155, 135, 3, 106, 116, 20, 47, 196);
RT_INTERFACE!{interface IPerceptionFrameProviderInfo(IPerceptionFrameProviderInfoVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderInfo] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_DeviceKind(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DeviceKind(&self, value: HSTRING) -> HRESULT,
    fn get_FrameKind(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FrameKind(&self, value: HSTRING) -> HRESULT,
    fn get_Hidden(&self, out: *mut bool) -> HRESULT,
    fn put_Hidden(&self, value: bool) -> HRESULT
}}
impl ComPtr<IPerceptionFrameProviderInfo> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_id(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Id)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DisplayName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_device_kind(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DeviceKind)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_frame_kind(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FrameKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_frame_kind(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_FrameKind)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_hidden(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Hidden)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_hidden(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Hidden)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionFrameProviderInfo: IPerceptionFrameProviderInfo}
impl RtActivatable<IActivationFactory> for PerceptionFrameProviderInfo {}
DEFINE_CLSID!(PerceptionFrameProviderInfo(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,80,114,111,118,105,100,101,114,73,110,102,111,0]) [CLSID_PerceptionFrameProviderInfo]);
DEFINE_IID!(IID_IPerceptionFrameProviderManager, 2841234951, 60115, 13279, 142, 193, 185, 36, 171, 224, 25, 196);
RT_INTERFACE!{interface IPerceptionFrameProviderManager(IPerceptionFrameProviderManagerVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderManager] {
    fn GetFrameProvider(&self, frameProviderInfo: *mut PerceptionFrameProviderInfo, out: *mut *mut IPerceptionFrameProvider) -> HRESULT
}}
impl ComPtr<IPerceptionFrameProviderManager> {
    #[inline] pub fn get_frame_provider(&self, frameProviderInfo: &ComPtr<PerceptionFrameProviderInfo>) -> Result<Option<ComPtr<IPerceptionFrameProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetFrameProvider)(self.deref() as *const _ as *mut _, frameProviderInfo.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class PerceptionFrameProviderManagerService}
impl RtActivatable<IPerceptionFrameProviderManagerServiceStatics> for PerceptionFrameProviderManagerService {}
impl PerceptionFrameProviderManagerService {
    #[inline] pub fn register_frame_provider_info(manager: &ComPtr<IPerceptionFrameProviderManager>, frameProviderInfo: &ComPtr<PerceptionFrameProviderInfo>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_frame_provider_info(manager, frameProviderInfo)
    }
    #[inline] pub fn unregister_frame_provider_info(manager: &ComPtr<IPerceptionFrameProviderManager>, frameProviderInfo: &ComPtr<PerceptionFrameProviderInfo>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_frame_provider_info(manager, frameProviderInfo)
    }
    #[inline] pub fn register_face_authentication_group(manager: &ComPtr<IPerceptionFrameProviderManager>, faceAuthenticationGroup: &ComPtr<PerceptionFaceAuthenticationGroup>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_face_authentication_group(manager, faceAuthenticationGroup)
    }
    #[inline] pub fn unregister_face_authentication_group(manager: &ComPtr<IPerceptionFrameProviderManager>, faceAuthenticationGroup: &ComPtr<PerceptionFaceAuthenticationGroup>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_face_authentication_group(manager, faceAuthenticationGroup)
    }
    #[inline] pub fn register_control_group(manager: &ComPtr<IPerceptionFrameProviderManager>, controlGroup: &ComPtr<PerceptionControlGroup>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_control_group(manager, controlGroup)
    }
    #[inline] pub fn unregister_control_group(manager: &ComPtr<IPerceptionFrameProviderManager>, controlGroup: &ComPtr<PerceptionControlGroup>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_control_group(manager, controlGroup)
    }
    #[inline] pub fn register_correlation_group(manager: &ComPtr<IPerceptionFrameProviderManager>, correlationGroup: &ComPtr<PerceptionCorrelationGroup>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().register_correlation_group(manager, correlationGroup)
    }
    #[inline] pub fn unregister_correlation_group(manager: &ComPtr<IPerceptionFrameProviderManager>, correlationGroup: &ComPtr<PerceptionCorrelationGroup>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().unregister_correlation_group(manager, correlationGroup)
    }
    #[inline] pub fn update_availability_for_provider(provider: &ComPtr<IPerceptionFrameProvider>, available: bool) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().update_availability_for_provider(provider, available)
    }
    #[inline] pub fn publish_frame_for_provider(provider: &ComPtr<IPerceptionFrameProvider>, frame: &ComPtr<PerceptionFrame>) -> Result<()> {
        <Self as RtActivatable<IPerceptionFrameProviderManagerServiceStatics>>::get_activation_factory().publish_frame_for_provider(provider, frame)
    }
}
DEFINE_CLSID!(PerceptionFrameProviderManagerService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,70,114,97,109,101,80,114,111,118,105,100,101,114,77,97,110,97,103,101,114,83,101,114,118,105,99,101,0]) [CLSID_PerceptionFrameProviderManagerService]);
DEFINE_IID!(IID_IPerceptionFrameProviderManagerServiceStatics, 2927855334, 51929, 17241, 143, 150, 142, 174, 81, 129, 5, 38);
RT_INTERFACE!{static interface IPerceptionFrameProviderManagerServiceStatics(IPerceptionFrameProviderManagerServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionFrameProviderManagerServiceStatics] {
    fn RegisterFrameProviderInfo(&self, manager: *mut IPerceptionFrameProviderManager, frameProviderInfo: *mut PerceptionFrameProviderInfo) -> HRESULT,
    fn UnregisterFrameProviderInfo(&self, manager: *mut IPerceptionFrameProviderManager, frameProviderInfo: *mut PerceptionFrameProviderInfo) -> HRESULT,
    fn RegisterFaceAuthenticationGroup(&self, manager: *mut IPerceptionFrameProviderManager, faceAuthenticationGroup: *mut PerceptionFaceAuthenticationGroup) -> HRESULT,
    fn UnregisterFaceAuthenticationGroup(&self, manager: *mut IPerceptionFrameProviderManager, faceAuthenticationGroup: *mut PerceptionFaceAuthenticationGroup) -> HRESULT,
    fn RegisterControlGroup(&self, manager: *mut IPerceptionFrameProviderManager, controlGroup: *mut PerceptionControlGroup) -> HRESULT,
    fn UnregisterControlGroup(&self, manager: *mut IPerceptionFrameProviderManager, controlGroup: *mut PerceptionControlGroup) -> HRESULT,
    fn RegisterCorrelationGroup(&self, manager: *mut IPerceptionFrameProviderManager, correlationGroup: *mut PerceptionCorrelationGroup) -> HRESULT,
    fn UnregisterCorrelationGroup(&self, manager: *mut IPerceptionFrameProviderManager, correlationGroup: *mut PerceptionCorrelationGroup) -> HRESULT,
    fn UpdateAvailabilityForProvider(&self, provider: *mut IPerceptionFrameProvider, available: bool) -> HRESULT,
    fn PublishFrameForProvider(&self, provider: *mut IPerceptionFrameProvider, frame: *mut PerceptionFrame) -> HRESULT
}}
impl ComPtr<IPerceptionFrameProviderManagerServiceStatics> {
    #[inline] pub fn register_frame_provider_info(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, frameProviderInfo: &ComPtr<PerceptionFrameProviderInfo>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RegisterFrameProviderInfo)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, frameProviderInfo.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_frame_provider_info(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, frameProviderInfo: &ComPtr<PerceptionFrameProviderInfo>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UnregisterFrameProviderInfo)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, frameProviderInfo.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_face_authentication_group(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, faceAuthenticationGroup: &ComPtr<PerceptionFaceAuthenticationGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RegisterFaceAuthenticationGroup)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, faceAuthenticationGroup.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_face_authentication_group(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, faceAuthenticationGroup: &ComPtr<PerceptionFaceAuthenticationGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UnregisterFaceAuthenticationGroup)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, faceAuthenticationGroup.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_control_group(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, controlGroup: &ComPtr<PerceptionControlGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RegisterControlGroup)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, controlGroup.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_control_group(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, controlGroup: &ComPtr<PerceptionControlGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UnregisterControlGroup)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, controlGroup.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn register_correlation_group(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, correlationGroup: &ComPtr<PerceptionCorrelationGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RegisterCorrelationGroup)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, correlationGroup.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn unregister_correlation_group(&self, manager: &ComPtr<IPerceptionFrameProviderManager>, correlationGroup: &ComPtr<PerceptionCorrelationGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UnregisterCorrelationGroup)(self.deref() as *const _ as *mut _, manager.deref() as *const _ as *mut _, correlationGroup.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn update_availability_for_provider(&self, provider: &ComPtr<IPerceptionFrameProvider>, available: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).UpdateAvailabilityForProvider)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, available);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn publish_frame_for_provider(&self, provider: &ComPtr<IPerceptionFrameProvider>, frame: &ComPtr<PerceptionFrame>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PublishFrameForProvider)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, frame.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionPropertyChangeRequest, 1012591441, 13579, 19960, 148, 20, 89, 224, 152, 21, 81, 11);
RT_INTERFACE!{interface IPerceptionPropertyChangeRequest(IPerceptionPropertyChangeRequestVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionPropertyChangeRequest] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_Status(&self, out: *mut super::PerceptionFrameSourcePropertyChangeStatus) -> HRESULT,
    fn put_Status(&self, value: super::PerceptionFrameSourcePropertyChangeStatus) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IPerceptionPropertyChangeRequest> {
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<super::PerceptionFrameSourcePropertyChangeStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_status(&self, value: super::PerceptionFrameSourcePropertyChangeStatus) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Status)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionPropertyChangeRequest: IPerceptionPropertyChangeRequest}
DEFINE_IID!(IID_PerceptionStartFaceAuthenticationHandler, 1954639146, 8336, 18032, 140, 72, 239, 57, 231, 255, 124, 38);
RT_DELEGATE!{delegate PerceptionStartFaceAuthenticationHandler(PerceptionStartFaceAuthenticationHandlerVtbl, PerceptionStartFaceAuthenticationHandlerImpl) [IID_PerceptionStartFaceAuthenticationHandler] {
    fn Invoke(&self, sender: *mut PerceptionFaceAuthenticationGroup, out: *mut bool) -> HRESULT
}}
impl ComPtr<PerceptionStartFaceAuthenticationHandler> {
    #[inline] pub fn invoke(&self, sender: &ComPtr<PerceptionFaceAuthenticationGroup>) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).Invoke)(self.deref() as *const _ as *mut _, sender.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_PerceptionStopFaceAuthenticationHandler, 947840682, 35277, 18462, 170, 222, 221, 146, 247, 11, 42, 215);
RT_DELEGATE!{delegate PerceptionStopFaceAuthenticationHandler(PerceptionStopFaceAuthenticationHandlerVtbl, PerceptionStopFaceAuthenticationHandlerImpl) [IID_PerceptionStopFaceAuthenticationHandler] {
    fn Invoke(&self, sender: *mut PerceptionFaceAuthenticationGroup) -> HRESULT
}}
impl ComPtr<PerceptionStopFaceAuthenticationHandler> {
    #[inline] pub fn invoke(&self, sender: &ComPtr<PerceptionFaceAuthenticationGroup>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Invoke)(self.deref() as *const _ as *mut _, sender.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPerceptionVideoFrameAllocator, 1278781402, 64984, 20180, 160, 57, 42, 111, 155, 35, 80, 56);
RT_INTERFACE!{interface IPerceptionVideoFrameAllocator(IPerceptionVideoFrameAllocatorVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoFrameAllocator] {
    fn AllocateFrame(&self, out: *mut *mut PerceptionFrame) -> HRESULT,
    #[cfg(feature="windows-media")] fn CopyFromVideoFrame(&self, frame: *mut crate::windows::media::VideoFrame, out: *mut *mut PerceptionFrame) -> HRESULT
}}
impl ComPtr<IPerceptionVideoFrameAllocator> {
    #[inline] pub fn allocate_frame(&self) -> Result<Option<ComPtr<PerceptionFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AllocateFrame)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-media")] #[inline] pub fn copy_from_video_frame(&self, frame: &ComPtr<crate::windows::media::VideoFrame>) -> Result<Option<ComPtr<PerceptionFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CopyFromVideoFrame)(self.deref() as *const _ as *mut _, frame.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PerceptionVideoFrameAllocator: IPerceptionVideoFrameAllocator}
impl RtActivatable<IPerceptionVideoFrameAllocatorFactory> for PerceptionVideoFrameAllocator {}
impl PerceptionVideoFrameAllocator {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(maxOutstandingFrameCountForWrite: u32, format: crate::windows::graphics::imaging::BitmapPixelFormat, resolution: foundation::Size, alpha: crate::windows::graphics::imaging::BitmapAlphaMode) -> Result<ComPtr<PerceptionVideoFrameAllocator>> {
        <Self as RtActivatable<IPerceptionVideoFrameAllocatorFactory>>::get_activation_factory().create(maxOutstandingFrameCountForWrite, format, resolution, alpha)
    }
}
DEFINE_CLSID!(PerceptionVideoFrameAllocator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,101,114,99,101,112,116,105,111,110,46,80,114,111,118,105,100,101,114,46,80,101,114,99,101,112,116,105,111,110,86,105,100,101,111,70,114,97,109,101,65,108,108,111,99,97,116,111,114,0]) [CLSID_PerceptionVideoFrameAllocator]);
DEFINE_IID!(IID_IPerceptionVideoFrameAllocatorFactory, 442020065, 59674, 18462, 184, 118, 168, 158, 43, 188, 107, 51);
RT_INTERFACE!{static interface IPerceptionVideoFrameAllocatorFactory(IPerceptionVideoFrameAllocatorFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPerceptionVideoFrameAllocatorFactory] {
    #[cfg(feature="windows-graphics")] fn Create(&self, maxOutstandingFrameCountForWrite: u32, format: crate::windows::graphics::imaging::BitmapPixelFormat, resolution: foundation::Size, alpha: crate::windows::graphics::imaging::BitmapAlphaMode, out: *mut *mut PerceptionVideoFrameAllocator) -> HRESULT
}}
impl ComPtr<IPerceptionVideoFrameAllocatorFactory> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn create(&self, maxOutstandingFrameCountForWrite: u32, format: crate::windows::graphics::imaging::BitmapPixelFormat, resolution: foundation::Size, alpha: crate::windows::graphics::imaging::BitmapAlphaMode) -> Result<ComPtr<PerceptionVideoFrameAllocator>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, maxOutstandingFrameCountForWrite, format, resolution, alpha, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Perception.Provider
} // Windows.Devices.Perception
pub mod pointofservice { // Windows.Devices.PointOfService
use crate::prelude::*;
DEFINE_IID!(IID_IBarcodeScanner, 3198369286, 45668, 20227, 169, 193, 69, 178, 15, 1, 19, 79);
RT_INTERFACE!{interface IBarcodeScanner(IBarcodeScannerVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScanner] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut *mut BarcodeScannerCapabilities) -> HRESULT,
    fn ClaimScannerAsync(&self, out: *mut *mut foundation::IAsyncOperation<ClaimedBarcodeScanner>) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetSupportedSymbologiesAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<u32>>) -> HRESULT,
    fn IsSymbologySupportedAsync(&self, barcodeSymbology: u32, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn RetrieveStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT,
    fn GetSupportedProfiles(&self, out: *mut *mut foundation::collections::IVectorView<HString>) -> HRESULT,
    fn IsProfileSupported(&self, profile: HSTRING, out: *mut bool) -> HRESULT,
    fn add_StatusUpdated(&self, handler: *mut foundation::TypedEventHandler<BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBarcodeScanner> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<ComPtr<BarcodeScannerCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_scanner_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedBarcodeScanner>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClaimScannerAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckHealthAsync)(self.deref() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_symbologies_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSupportedSymbologiesAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_symbology_supported_async(&self, barcodeSymbology: u32) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).IsSymbologySupportedAsync)(self.deref() as *const _ as *mut _, barcodeSymbology, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn retrieve_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RetrieveStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_profiles(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSupportedProfiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_profile_supported(&self, profile: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsProfileSupported)(self.deref() as *const _ as *mut _, profile.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScanner, BarcodeScannerStatusUpdatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusUpdated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusUpdated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScanner: IBarcodeScanner}
impl RtActivatable<IBarcodeScannerStatics> for BarcodeScanner {}
impl RtActivatable<IBarcodeScannerStatics2> for BarcodeScanner {}
impl BarcodeScanner {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScanner>>> {
        <Self as RtActivatable<IBarcodeScannerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScanner>>> {
        <Self as RtActivatable<IBarcodeScannerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBarcodeScannerStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IBarcodeScannerStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(BarcodeScanner(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,99,97,110,110,101,114,0]) [CLSID_BarcodeScanner]);
DEFINE_IID!(IID_IBarcodeScanner2, 2300662119, 36078, 17261, 137, 171, 141, 251, 67, 187, 66, 134);
RT_INTERFACE!{interface IBarcodeScanner2(IBarcodeScanner2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScanner2] {
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBarcodeScanner2> {
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerCapabilities, 3322319332, 62152, 17440, 163, 7, 177, 46, 246, 98, 40, 87);
RT_INTERFACE!{interface IBarcodeScannerCapabilities(IBarcodeScannerCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities] {
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsImagePreviewSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBarcodeScannerCapabilities> {
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerReportingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsReportingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsUpdatingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_image_preview_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsImagePreviewSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerCapabilities: IBarcodeScannerCapabilities}
DEFINE_IID!(IID_IBarcodeScannerCapabilities1, 2388308969, 3628, 18223, 161, 204, 238, 128, 84, 182, 166, 132);
RT_INTERFACE!{interface IBarcodeScannerCapabilities1(IBarcodeScannerCapabilities1Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities1] {
    fn get_IsSoftwareTriggerSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBarcodeScannerCapabilities1> {
    #[inline] pub fn get_is_software_trigger_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsSoftwareTriggerSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerCapabilities2, 4061253612, 57761, 20136, 154, 188, 146, 177, 89, 98, 112, 171);
RT_INTERFACE!{interface IBarcodeScannerCapabilities2(IBarcodeScannerCapabilities2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerCapabilities2] {
    fn get_IsVideoPreviewSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBarcodeScannerCapabilities2> {
    #[inline] pub fn get_is_video_preview_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsVideoPreviewSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerDataReceivedEventArgs, 1110747106, 60823, 18045, 173, 43, 1, 228, 67, 19, 169, 41);
RT_INTERFACE!{interface IBarcodeScannerDataReceivedEventArgs(IBarcodeScannerDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut *mut BarcodeScannerReport) -> HRESULT
}}
impl ComPtr<IBarcodeScannerDataReceivedEventArgs> {
    #[inline] pub fn get_report(&self) -> Result<Option<ComPtr<BarcodeScannerReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Report)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerDataReceivedEventArgs: IBarcodeScannerDataReceivedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerErrorOccurredEventArgs, 751984687, 53050, 16386, 167, 90, 197, 236, 70, 143, 10, 32);
RT_INTERFACE!{interface IBarcodeScannerErrorOccurredEventArgs(IBarcodeScannerErrorOccurredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerErrorOccurredEventArgs] {
    fn get_PartialInputData(&self, out: *mut *mut BarcodeScannerReport) -> HRESULT,
    fn get_IsRetriable(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorData(&self, out: *mut *mut UnifiedPosErrorData) -> HRESULT
}}
impl ComPtr<IBarcodeScannerErrorOccurredEventArgs> {
    #[inline] pub fn get_partial_input_data(&self) -> Result<Option<ComPtr<BarcodeScannerReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PartialInputData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_retriable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsRetriable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_data(&self) -> Result<Option<ComPtr<UnifiedPosErrorData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ErrorData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerErrorOccurredEventArgs: IBarcodeScannerErrorOccurredEventArgs}
DEFINE_IID!(IID_IBarcodeScannerImagePreviewReceivedEventArgs, 4088913541, 28299, 17230, 159, 88, 6, 239, 38, 188, 75, 175);
RT_INTERFACE!{interface IBarcodeScannerImagePreviewReceivedEventArgs(IBarcodeScannerImagePreviewReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerImagePreviewReceivedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_Preview(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamWithContentType) -> HRESULT
}}
impl ComPtr<IBarcodeScannerImagePreviewReceivedEventArgs> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_preview(&self) -> Result<Option<ComPtr<super::super::storage::streams::IRandomAccessStreamWithContentType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Preview)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerImagePreviewReceivedEventArgs: IBarcodeScannerImagePreviewReceivedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerReport, 1558501552, 42121, 19350, 134, 196, 240, 191, 138, 55, 117, 61);
RT_INTERFACE!{interface IBarcodeScannerReport(IBarcodeScannerReportVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerReport] {
    fn get_ScanDataType(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ScanData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ScanDataLabel(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IBarcodeScannerReport> {
    #[inline] pub fn get_scan_data_type(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScanDataType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_scan_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ScanData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_scan_data_label(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ScanDataLabel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerReport: IBarcodeScannerReport}
impl RtActivatable<IBarcodeScannerReportFactory> for BarcodeScannerReport {}
impl BarcodeScannerReport {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_instance(scanDataType: u32, scanData: &ComPtr<super::super::storage::streams::IBuffer>, scanDataLabel: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<BarcodeScannerReport>> {
        <Self as RtActivatable<IBarcodeScannerReportFactory>>::get_activation_factory().create_instance(scanDataType, scanData, scanDataLabel)
    }
}
DEFINE_CLSID!(BarcodeScannerReport(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,99,97,110,110,101,114,82,101,112,111,114,116,0]) [CLSID_BarcodeScannerReport]);
DEFINE_IID!(IID_IBarcodeScannerReportFactory, 2723443494, 8211, 17788, 137, 99, 73, 193, 93, 202, 120, 206);
RT_INTERFACE!{static interface IBarcodeScannerReportFactory(IBarcodeScannerReportFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerReportFactory] {
    #[cfg(feature="windows-storage")] fn CreateInstance(&self, scanDataType: u32, scanData: *mut super::super::storage::streams::IBuffer, scanDataLabel: *mut super::super::storage::streams::IBuffer, out: *mut *mut BarcodeScannerReport) -> HRESULT
}}
impl ComPtr<IBarcodeScannerReportFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_instance(&self, scanDataType: u32, scanData: &ComPtr<super::super::storage::streams::IBuffer>, scanDataLabel: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<BarcodeScannerReport>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, scanDataType, scanData.deref() as *const _ as *mut _, scanDataLabel.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStatics, 1561419631, 55881, 16872, 140, 140, 240, 203, 98, 169, 196, 252);
RT_INTERFACE!{static interface IBarcodeScannerStatics(IBarcodeScannerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<BarcodeScanner>) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<BarcodeScanner>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScanner>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScanner>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStatics2, 3093636211, 41839, 16391, 177, 208, 39, 158, 190, 146, 166, 86);
RT_INTERFACE!{static interface IBarcodeScannerStatics2(IBarcodeScannerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStatics2> {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.deref() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum BarcodeScannerStatus: i32 {
    Online = 0, Off = 1, Offline = 2, OffOrOffline = 3, Extended = 4,
}}
DEFINE_IID!(IID_IBarcodeScannerStatusUpdatedEventArgs, 895321478, 40003, 17963, 169, 26, 129, 109, 201, 127, 69, 44);
RT_INTERFACE!{interface IBarcodeScannerStatusUpdatedEventArgs(IBarcodeScannerStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut BarcodeScannerStatus) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStatusUpdatedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<BarcodeScannerStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStatusUpdatedEventArgs: IBarcodeScannerStatusUpdatedEventArgs}
RT_CLASS!{static class BarcodeSymbologies}
impl RtActivatable<IBarcodeSymbologiesStatics> for BarcodeSymbologies {}
impl RtActivatable<IBarcodeSymbologiesStatics2> for BarcodeSymbologies {}
impl BarcodeSymbologies {
    #[inline] pub fn get_unknown() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_unknown()
    }
    #[inline] pub fn get_ean8() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean8()
    }
    #[inline] pub fn get_ean8_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean8_add2()
    }
    #[inline] pub fn get_ean8_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean8_add5()
    }
    #[inline] pub fn get_eanv() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_eanv()
    }
    #[inline] pub fn get_eanv_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_eanv_add2()
    }
    #[inline] pub fn get_eanv_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_eanv_add5()
    }
    #[inline] pub fn get_ean13() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean13()
    }
    #[inline] pub fn get_ean13_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean13_add2()
    }
    #[inline] pub fn get_ean13_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean13_add5()
    }
    #[inline] pub fn get_isbn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_isbn()
    }
    #[inline] pub fn get_isbn_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_isbn_add5()
    }
    #[inline] pub fn get_ismn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ismn()
    }
    #[inline] pub fn get_ismn_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ismn_add2()
    }
    #[inline] pub fn get_ismn_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ismn_add5()
    }
    #[inline] pub fn get_issn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_issn()
    }
    #[inline] pub fn get_issn_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_issn_add2()
    }
    #[inline] pub fn get_issn_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_issn_add5()
    }
    #[inline] pub fn get_ean99() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean99()
    }
    #[inline] pub fn get_ean99_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean99_add2()
    }
    #[inline] pub fn get_ean99_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ean99_add5()
    }
    #[inline] pub fn get_upca() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upca()
    }
    #[inline] pub fn get_upca_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upca_add2()
    }
    #[inline] pub fn get_upca_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upca_add5()
    }
    #[inline] pub fn get_upce() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upce()
    }
    #[inline] pub fn get_upce_add2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upce_add2()
    }
    #[inline] pub fn get_upce_add5() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upce_add5()
    }
    #[inline] pub fn get_upc_coupon() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_upc_coupon()
    }
    #[inline] pub fn get_tf_std() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_std()
    }
    #[inline] pub fn get_tf_dis() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_dis()
    }
    #[inline] pub fn get_tf_int() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_int()
    }
    #[inline] pub fn get_tf_ind() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_ind()
    }
    #[inline] pub fn get_tf_mat() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_mat()
    }
    #[inline] pub fn get_tf_iata() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tf_iata()
    }
    #[inline] pub fn get_gs1_databar_type1() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1_databar_type1()
    }
    #[inline] pub fn get_gs1_databar_type2() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1_databar_type2()
    }
    #[inline] pub fn get_gs1_databar_type3() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1_databar_type3()
    }
    #[inline] pub fn get_code_39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_39()
    }
    #[inline] pub fn get_code_39_ex() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_39_ex()
    }
    #[inline] pub fn get_trioptic_39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_trioptic_39()
    }
    #[inline] pub fn get_code_32() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_32()
    }
    #[inline] pub fn get_pzn() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_pzn()
    }
    #[inline] pub fn get_code_93() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_93()
    }
    #[inline] pub fn get_code_93_ex() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_93_ex()
    }
    #[inline] pub fn get_code_128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_128()
    }
    #[inline] pub fn get_gs1128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1128()
    }
    #[inline] pub fn get_gs1128_coupon() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_gs1128_coupon()
    }
    #[inline] pub fn get_ucc_ean128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ucc_ean128()
    }
    #[inline] pub fn get_sisac() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_sisac()
    }
    #[inline] pub fn get_isbt() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_isbt()
    }
    #[inline] pub fn get_codabar() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codabar()
    }
    #[inline] pub fn get_code_11() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_11()
    }
    #[inline] pub fn get_msi() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_msi()
    }
    #[inline] pub fn get_plessey() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_plessey()
    }
    #[inline] pub fn get_telepen() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_telepen()
    }
    #[inline] pub fn get_code_16k() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_16k()
    }
    #[inline] pub fn get_codablock_a() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codablock_a()
    }
    #[inline] pub fn get_codablock_f() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codablock_f()
    }
    #[inline] pub fn get_codablock_128() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_codablock_128()
    }
    #[inline] pub fn get_code_49() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_code_49()
    }
    #[inline] pub fn get_aztec() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_aztec()
    }
    #[inline] pub fn get_data_code() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_data_code()
    }
    #[inline] pub fn get_data_matrix() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_data_matrix()
    }
    #[inline] pub fn get_han_xin() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_han_xin()
    }
    #[inline] pub fn get_maxicode() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_maxicode()
    }
    #[inline] pub fn get_micro_pdf417() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_micro_pdf417()
    }
    #[inline] pub fn get_micro_qr() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_micro_qr()
    }
    #[inline] pub fn get_pdf417() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_pdf417()
    }
    #[inline] pub fn get_qr() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_qr()
    }
    #[inline] pub fn get_ms_tag() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ms_tag()
    }
    #[inline] pub fn get_ccab() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ccab()
    }
    #[inline] pub fn get_ccc() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ccc()
    }
    #[inline] pub fn get_tlc39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_tlc39()
    }
    #[inline] pub fn get_aus_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_aus_post()
    }
    #[inline] pub fn get_can_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_can_post()
    }
    #[inline] pub fn get_china_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_china_post()
    }
    #[inline] pub fn get_dutch_kix() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_dutch_kix()
    }
    #[inline] pub fn get_info_mail() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_info_mail()
    }
    #[inline] pub fn get_italian_post_25() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_italian_post_25()
    }
    #[inline] pub fn get_italian_post_39() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_italian_post_39()
    }
    #[inline] pub fn get_japan_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_japan_post()
    }
    #[inline] pub fn get_korean_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_korean_post()
    }
    #[inline] pub fn get_sweden_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_sweden_post()
    }
    #[inline] pub fn get_uk_post() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_uk_post()
    }
    #[inline] pub fn get_us_intelligent() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_intelligent()
    }
    #[inline] pub fn get_us_intelligent_pkg() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_intelligent_pkg()
    }
    #[inline] pub fn get_us_planet() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_planet()
    }
    #[inline] pub fn get_us_post_net() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us_post_net()
    }
    #[inline] pub fn get_us4_state_fics() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_us4_state_fics()
    }
    #[inline] pub fn get_ocr_a() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ocr_a()
    }
    #[inline] pub fn get_ocr_b() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_ocr_b()
    }
    #[inline] pub fn get_micr() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_micr()
    }
    #[inline] pub fn get_extended_base() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_extended_base()
    }
    #[inline] pub fn get_name(scanDataType: u32) -> Result<HString> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics>>::get_activation_factory().get_name(scanDataType)
    }
    #[inline] pub fn get_gs1dw_code() -> Result<u32> {
        <Self as RtActivatable<IBarcodeSymbologiesStatics2>>::get_activation_factory().get_gs1dw_code()
    }
}
DEFINE_CLSID!(BarcodeSymbologies(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,66,97,114,99,111,100,101,83,121,109,98,111,108,111,103,105,101,115,0]) [CLSID_BarcodeSymbologies]);
DEFINE_IID!(IID_IBarcodeSymbologiesStatics, 3397732795, 1746, 17396, 164, 75, 198, 32, 103, 159, 216, 208);
RT_INTERFACE!{static interface IBarcodeSymbologiesStatics(IBarcodeSymbologiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologiesStatics] {
    fn get_Unknown(&self, out: *mut u32) -> HRESULT,
    fn get_Ean8(&self, out: *mut u32) -> HRESULT,
    fn get_Ean8Add2(&self, out: *mut u32) -> HRESULT,
    fn get_Ean8Add5(&self, out: *mut u32) -> HRESULT,
    fn get_Eanv(&self, out: *mut u32) -> HRESULT,
    fn get_EanvAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_EanvAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Ean13(&self, out: *mut u32) -> HRESULT,
    fn get_Ean13Add2(&self, out: *mut u32) -> HRESULT,
    fn get_Ean13Add5(&self, out: *mut u32) -> HRESULT,
    fn get_Isbn(&self, out: *mut u32) -> HRESULT,
    fn get_IsbnAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Ismn(&self, out: *mut u32) -> HRESULT,
    fn get_IsmnAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_IsmnAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Issn(&self, out: *mut u32) -> HRESULT,
    fn get_IssnAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_IssnAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Ean99(&self, out: *mut u32) -> HRESULT,
    fn get_Ean99Add2(&self, out: *mut u32) -> HRESULT,
    fn get_Ean99Add5(&self, out: *mut u32) -> HRESULT,
    fn get_Upca(&self, out: *mut u32) -> HRESULT,
    fn get_UpcaAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_UpcaAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_Upce(&self, out: *mut u32) -> HRESULT,
    fn get_UpceAdd2(&self, out: *mut u32) -> HRESULT,
    fn get_UpceAdd5(&self, out: *mut u32) -> HRESULT,
    fn get_UpcCoupon(&self, out: *mut u32) -> HRESULT,
    fn get_TfStd(&self, out: *mut u32) -> HRESULT,
    fn get_TfDis(&self, out: *mut u32) -> HRESULT,
    fn get_TfInt(&self, out: *mut u32) -> HRESULT,
    fn get_TfInd(&self, out: *mut u32) -> HRESULT,
    fn get_TfMat(&self, out: *mut u32) -> HRESULT,
    fn get_TfIata(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1DatabarType1(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1DatabarType2(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1DatabarType3(&self, out: *mut u32) -> HRESULT,
    fn get_Code39(&self, out: *mut u32) -> HRESULT,
    fn get_Code39Ex(&self, out: *mut u32) -> HRESULT,
    fn get_Trioptic39(&self, out: *mut u32) -> HRESULT,
    fn get_Code32(&self, out: *mut u32) -> HRESULT,
    fn get_Pzn(&self, out: *mut u32) -> HRESULT,
    fn get_Code93(&self, out: *mut u32) -> HRESULT,
    fn get_Code93Ex(&self, out: *mut u32) -> HRESULT,
    fn get_Code128(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1128(&self, out: *mut u32) -> HRESULT,
    fn get_Gs1128Coupon(&self, out: *mut u32) -> HRESULT,
    fn get_UccEan128(&self, out: *mut u32) -> HRESULT,
    fn get_Sisac(&self, out: *mut u32) -> HRESULT,
    fn get_Isbt(&self, out: *mut u32) -> HRESULT,
    fn get_Codabar(&self, out: *mut u32) -> HRESULT,
    fn get_Code11(&self, out: *mut u32) -> HRESULT,
    fn get_Msi(&self, out: *mut u32) -> HRESULT,
    fn get_Plessey(&self, out: *mut u32) -> HRESULT,
    fn get_Telepen(&self, out: *mut u32) -> HRESULT,
    fn get_Code16k(&self, out: *mut u32) -> HRESULT,
    fn get_CodablockA(&self, out: *mut u32) -> HRESULT,
    fn get_CodablockF(&self, out: *mut u32) -> HRESULT,
    fn get_Codablock128(&self, out: *mut u32) -> HRESULT,
    fn get_Code49(&self, out: *mut u32) -> HRESULT,
    fn get_Aztec(&self, out: *mut u32) -> HRESULT,
    fn get_DataCode(&self, out: *mut u32) -> HRESULT,
    fn get_DataMatrix(&self, out: *mut u32) -> HRESULT,
    fn get_HanXin(&self, out: *mut u32) -> HRESULT,
    fn get_Maxicode(&self, out: *mut u32) -> HRESULT,
    fn get_MicroPdf417(&self, out: *mut u32) -> HRESULT,
    fn get_MicroQr(&self, out: *mut u32) -> HRESULT,
    fn get_Pdf417(&self, out: *mut u32) -> HRESULT,
    fn get_Qr(&self, out: *mut u32) -> HRESULT,
    fn get_MsTag(&self, out: *mut u32) -> HRESULT,
    fn get_Ccab(&self, out: *mut u32) -> HRESULT,
    fn get_Ccc(&self, out: *mut u32) -> HRESULT,
    fn get_Tlc39(&self, out: *mut u32) -> HRESULT,
    fn get_AusPost(&self, out: *mut u32) -> HRESULT,
    fn get_CanPost(&self, out: *mut u32) -> HRESULT,
    fn get_ChinaPost(&self, out: *mut u32) -> HRESULT,
    fn get_DutchKix(&self, out: *mut u32) -> HRESULT,
    fn get_InfoMail(&self, out: *mut u32) -> HRESULT,
    fn get_ItalianPost25(&self, out: *mut u32) -> HRESULT,
    fn get_ItalianPost39(&self, out: *mut u32) -> HRESULT,
    fn get_JapanPost(&self, out: *mut u32) -> HRESULT,
    fn get_KoreanPost(&self, out: *mut u32) -> HRESULT,
    fn get_SwedenPost(&self, out: *mut u32) -> HRESULT,
    fn get_UkPost(&self, out: *mut u32) -> HRESULT,
    fn get_UsIntelligent(&self, out: *mut u32) -> HRESULT,
    fn get_UsIntelligentPkg(&self, out: *mut u32) -> HRESULT,
    fn get_UsPlanet(&self, out: *mut u32) -> HRESULT,
    fn get_UsPostNet(&self, out: *mut u32) -> HRESULT,
    fn get_Us4StateFics(&self, out: *mut u32) -> HRESULT,
    fn get_OcrA(&self, out: *mut u32) -> HRESULT,
    fn get_OcrB(&self, out: *mut u32) -> HRESULT,
    fn get_Micr(&self, out: *mut u32) -> HRESULT,
    fn get_ExtendedBase(&self, out: *mut u32) -> HRESULT,
    fn GetName(&self, scanDataType: u32, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBarcodeSymbologiesStatics> {
    #[inline] pub fn get_unknown(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Unknown)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean8(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean8)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean8_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean8Add2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean8_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean8Add5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eanv(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Eanv)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eanv_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EanvAdd2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_eanv_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EanvAdd5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean13(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean13)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean13_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean13Add2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean13_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean13Add5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_isbn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Isbn)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_isbn_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsbnAdd5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ismn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ismn)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ismn_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsmnAdd2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ismn_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsmnAdd5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_issn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Issn)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_issn_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IssnAdd2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_issn_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IssnAdd5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean99(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean99)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean99_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean99Add2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ean99_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ean99Add5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upca(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Upca)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upca_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpcaAdd2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upca_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpcaAdd5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upce(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Upce)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upce_add2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpceAdd2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upce_add5(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpceAdd5)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_upc_coupon(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpcCoupon)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_std(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TfStd)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_dis(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TfDis)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_int(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TfInt)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_ind(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TfInd)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_mat(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TfMat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tf_iata(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TfIata)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1_databar_type1(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gs1DatabarType1)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1_databar_type2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gs1DatabarType2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1_databar_type3(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gs1DatabarType3)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code39)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_39_ex(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code39Ex)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_trioptic_39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Trioptic39)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_32(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code32)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pzn(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Pzn)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_93(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code93)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_93_ex(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code93Ex)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code128)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gs1128)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_gs1128_coupon(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gs1128Coupon)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ucc_ean128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UccEan128)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sisac(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Sisac)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_isbt(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Isbt)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codabar(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Codabar)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_11(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code11)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_msi(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Msi)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_plessey(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Plessey)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_telepen(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Telepen)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_16k(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code16k)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codablock_a(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CodablockA)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codablock_f(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CodablockF)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_codablock_128(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Codablock128)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_code_49(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Code49)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aztec(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Aztec)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_matrix(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataMatrix)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_han_xin(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HanXin)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_maxicode(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Maxicode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_micro_pdf417(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MicroPdf417)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_micro_qr(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MicroQr)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pdf417(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Pdf417)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_qr(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Qr)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ms_tag(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MsTag)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ccab(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ccab)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ccc(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ccc)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_tlc39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Tlc39)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aus_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AusPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_china_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChinaPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_dutch_kix(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DutchKix)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_info_mail(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InfoMail)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_italian_post_25(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ItalianPost25)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_italian_post_39(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ItalianPost39)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_japan_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_JapanPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_korean_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_KoreanPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sweden_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SwedenPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_uk_post(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UkPost)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_intelligent(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsIntelligent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_intelligent_pkg(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsIntelligentPkg)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_planet(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsPlanet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us_post_net(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsPostNet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_us4_state_fics(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Us4StateFics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ocr_a(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OcrA)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ocr_b(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OcrB)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_micr(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Micr)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_base(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedBase)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self, scanDataType: u32) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetName)(self.deref() as *const _ as *mut _, scanDataType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeSymbologiesStatics2, 2339707124, 39376, 16575, 148, 36, 185, 29, 109, 212, 198, 224);
RT_INTERFACE!{static interface IBarcodeSymbologiesStatics2(IBarcodeSymbologiesStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologiesStatics2] {
    fn get_Gs1DWCode(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IBarcodeSymbologiesStatics2> {
    #[inline] pub fn get_gs1dw_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Gs1DWCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeSymbologyAttributes, 1715550840, 43898, 19162, 142, 206, 147, 96, 20, 178, 234, 215);
RT_INTERFACE!{interface IBarcodeSymbologyAttributes(IBarcodeSymbologyAttributesVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologyAttributes] {
    fn get_IsCheckDigitValidationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitValidationEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCheckDigitValidationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsCheckDigitTransmissionEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitTransmissionEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCheckDigitTransmissionSupported(&self, out: *mut bool) -> HRESULT,
    fn get_DecodeLength1(&self, out: *mut u32) -> HRESULT,
    fn put_DecodeLength1(&self, value: u32) -> HRESULT,
    fn get_DecodeLength2(&self, out: *mut u32) -> HRESULT,
    fn put_DecodeLength2(&self, value: u32) -> HRESULT,
    fn get_DecodeLengthKind(&self, out: *mut BarcodeSymbologyDecodeLengthKind) -> HRESULT,
    fn put_DecodeLengthKind(&self, value: BarcodeSymbologyDecodeLengthKind) -> HRESULT,
    fn get_IsDecodeLengthSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IBarcodeSymbologyAttributes> {
    #[inline] pub fn get_is_check_digit_validation_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCheckDigitValidationEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_validation_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsCheckDigitValidationEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_validation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCheckDigitValidationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_transmission_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCheckDigitTransmissionEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_transmission_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsCheckDigitTransmissionEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_transmission_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCheckDigitTransmissionSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_length1(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DecodeLength1)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_length1(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DecodeLength1)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_length2(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DecodeLength2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_length2(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DecodeLength2)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_decode_length_kind(&self) -> Result<BarcodeSymbologyDecodeLengthKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DecodeLengthKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_decode_length_kind(&self, value: BarcodeSymbologyDecodeLengthKind) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DecodeLengthKind)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_length_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDecodeLengthSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeSymbologyAttributes: IBarcodeSymbologyAttributes}
RT_ENUM! { enum BarcodeSymbologyDecodeLengthKind: i32 {
    AnyLength = 0, Discrete = 1, Range = 2,
}}
DEFINE_IID!(IID_ICashDrawer, 2676553160, 56916, 19182, 168, 144, 146, 11, 203, 254, 48, 252);
RT_INTERFACE!{interface ICashDrawer(ICashDrawerVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawer] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut *mut CashDrawerCapabilities) -> HRESULT,
    fn get_Status(&self, out: *mut *mut CashDrawerStatus) -> HRESULT,
    fn get_IsDrawerOpen(&self, out: *mut bool) -> HRESULT,
    fn get_DrawerEventSource(&self, out: *mut *mut CashDrawerEventSource) -> HRESULT,
    fn ClaimDrawerAsync(&self, out: *mut *mut foundation::IAsyncOperation<ClaimedCashDrawer>) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn add_StatusUpdated(&self, handler: *mut foundation::TypedEventHandler<CashDrawer, CashDrawerStatusUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ICashDrawer> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<ComPtr<CashDrawerCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<Option<ComPtr<CashDrawerStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_drawer_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDrawerOpen)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_drawer_event_source(&self) -> Result<Option<ComPtr<CashDrawerEventSource>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DrawerEventSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_drawer_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedCashDrawer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClaimDrawerAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckHealthAsync)(self.deref() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<CashDrawer, CashDrawerStatusUpdatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusUpdated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusUpdated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawer: ICashDrawer}
impl RtActivatable<ICashDrawerStatics> for CashDrawer {}
impl RtActivatable<ICashDrawerStatics2> for CashDrawer {}
impl CashDrawer {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<CashDrawer>>> {
        <Self as RtActivatable<ICashDrawerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<CashDrawer>>> {
        <Self as RtActivatable<ICashDrawerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ICashDrawerStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<ICashDrawerStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(CashDrawer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,67,97,115,104,68,114,97,119,101,114,0]) [CLSID_CashDrawer]);
DEFINE_IID!(IID_ICashDrawerCapabilities, 197582347, 59623, 19231, 177, 209, 62, 80, 26, 208, 130, 71);
RT_INTERFACE!{interface ICashDrawerCapabilities(ICashDrawerCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerCapabilities] {
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatusReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatusMultiDrawerDetectSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDrawerOpenSensorAvailable(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ICashDrawerCapabilities> {
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerReportingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsReportingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsUpdatingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_status_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatusReportingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_status_multi_drawer_detect_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatusMultiDrawerDetectSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_drawer_open_sensor_available(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDrawerOpenSensorAvailable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerCapabilities: ICashDrawerCapabilities}
DEFINE_IID!(IID_ICashDrawerCloseAlarm, 1811451079, 28515, 17166, 171, 59, 149, 215, 95, 251, 232, 127);
RT_INTERFACE!{interface ICashDrawerCloseAlarm(ICashDrawerCloseAlarmVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerCloseAlarm] {
    fn put_AlarmTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_AlarmTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BeepFrequency(&self, value: u32) -> HRESULT,
    fn get_BeepFrequency(&self, out: *mut u32) -> HRESULT,
    fn put_BeepDuration(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BeepDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BeepDelay(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_BeepDelay(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn add_AlarmTimeoutExpired(&self, handler: *mut foundation::TypedEventHandler<CashDrawerCloseAlarm, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AlarmTimeoutExpired(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn StartAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ICashDrawerCloseAlarm> {
    #[inline] pub fn set_alarm_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AlarmTimeout)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_alarm_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlarmTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_beep_frequency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BeepFrequency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_beep_frequency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BeepFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_beep_duration(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BeepDuration)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_beep_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BeepDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_beep_delay(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BeepDelay)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_beep_delay(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BeepDelay)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_alarm_timeout_expired(&self, handler: &ComPtr<foundation::TypedEventHandler<CashDrawerCloseAlarm, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AlarmTimeoutExpired)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_alarm_timeout_expired(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AlarmTimeoutExpired)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).StartAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerCloseAlarm: ICashDrawerCloseAlarm}
RT_CLASS!{class CashDrawerClosedEventArgs: ICashDrawerEventSourceEventArgs}
DEFINE_IID!(IID_ICashDrawerEventSource, 3758548076, 62201, 17455, 141, 214, 6, 193, 10, 66, 39, 186);
RT_INTERFACE!{interface ICashDrawerEventSource(ICashDrawerEventSourceVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerEventSource] {
    fn add_DrawerClosed(&self, handler: *mut foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerClosedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DrawerClosed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DrawerOpened(&self, handler: *mut foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerOpenedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DrawerOpened(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ICashDrawerEventSource> {
    #[inline] pub fn add_drawer_closed(&self, handler: &ComPtr<foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerClosedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DrawerClosed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_drawer_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DrawerClosed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_drawer_opened(&self, handler: &ComPtr<foundation::TypedEventHandler<CashDrawerEventSource, CashDrawerOpenedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DrawerOpened)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_drawer_opened(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DrawerOpened)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerEventSource: ICashDrawerEventSource}
DEFINE_IID!(IID_ICashDrawerEventSourceEventArgs, 1774926785, 5247, 16924, 156, 35, 9, 1, 35, 187, 120, 108);
RT_INTERFACE!{interface ICashDrawerEventSourceEventArgs(ICashDrawerEventSourceEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerEventSourceEventArgs] {
    fn get_CashDrawer(&self, out: *mut *mut CashDrawer) -> HRESULT
}}
impl ComPtr<ICashDrawerEventSourceEventArgs> {
    #[inline] pub fn get_cash_drawer(&self) -> Result<Option<ComPtr<CashDrawer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CashDrawer)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerOpenedEventArgs: ICashDrawerEventSourceEventArgs}
DEFINE_IID!(IID_ICashDrawerStatics, 3751843162, 54327, 20479, 181, 71, 221, 169, 105, 164, 248, 131);
RT_INTERFACE!{static interface ICashDrawerStatics(ICashDrawerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<CashDrawer>) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<CashDrawer>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ICashDrawerStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<CashDrawer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<CashDrawer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICashDrawerStatics2, 1048674593, 35906, 16616, 156, 14, 64, 41, 112, 72, 16, 76);
RT_INTERFACE!{static interface ICashDrawerStatics2(ICashDrawerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ICashDrawerStatics2> {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.deref() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICashDrawerStatus, 1807579327, 56481, 19974, 153, 235, 90, 246, 165, 174, 193, 8);
RT_INTERFACE!{interface ICashDrawerStatus(ICashDrawerStatusVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatus] {
    fn get_StatusKind(&self, out: *mut CashDrawerStatusKind) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ICashDrawerStatus> {
    #[inline] pub fn get_status_kind(&self) -> Result<CashDrawerStatusKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StatusKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerStatus: ICashDrawerStatus}
RT_ENUM! { enum CashDrawerStatusKind: i32 {
    Online = 0, Off = 1, Offline = 2, OffOrOffline = 3, Extended = 4,
}}
DEFINE_IID!(IID_ICashDrawerStatusUpdatedEventArgs, 816507274, 3440, 17820, 149, 83, 135, 225, 36, 197, 36, 136);
RT_INTERFACE!{interface ICashDrawerStatusUpdatedEventArgs(ICashDrawerStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICashDrawerStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut *mut CashDrawerStatus) -> HRESULT
}}
impl ComPtr<ICashDrawerStatusUpdatedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<Option<ComPtr<CashDrawerStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CashDrawerStatusUpdatedEventArgs: ICashDrawerStatusUpdatedEventArgs}
DEFINE_IID!(IID_IClaimedBarcodeScanner, 1248048284, 36772, 17202, 187, 38, 148, 93, 17, 216, 30, 15);
RT_INTERFACE!{interface IClaimedBarcodeScanner(IClaimedBarcodeScannerVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisabledOnDataReceived(&self, value: bool) -> HRESULT,
    fn get_IsDisabledOnDataReceived(&self, out: *mut bool) -> HRESULT,
    fn put_IsDecodeDataEnabled(&self, value: bool) -> HRESULT,
    fn get_IsDecodeDataEnabled(&self, out: *mut bool) -> HRESULT,
    fn EnableAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn DisableAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn RetainDevice(&self) -> HRESULT,
    fn SetActiveSymbologiesAsync(&self, symbologies: *mut foundation::collections::IIterable<u32>, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn SetActiveProfileAsync(&self, profile: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn add_DataReceived(&self, handler: *mut foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TriggerPressed(&self, handler: *mut foundation::EventHandler<ClaimedBarcodeScanner>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TriggerPressed(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_TriggerReleased(&self, handler: *mut foundation::EventHandler<ClaimedBarcodeScanner>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TriggerReleased(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: *mut foundation::EventHandler<ClaimedBarcodeScanner>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ImagePreviewReceived(&self, handler: *mut foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ImagePreviewReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ErrorOccurred(&self, handler: *mut foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedBarcodeScanner> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_disabled_on_data_received(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDisabledOnDataReceived)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_on_data_received(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDisabledOnDataReceived)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_decode_data_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDecodeDataEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_data_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDecodeDataEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).EnableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DisableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RetainDevice)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_active_symbologies_async(&self, symbologies: &ComPtr<foundation::collections::IIterable<u32>>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SetActiveSymbologiesAsync)(self.deref() as *const _ as *mut _, symbologies.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ResetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UpdateStatisticsAsync)(self.deref() as *const _ as *mut _, statistics.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_active_profile_async(&self, profile: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SetActiveProfileAsync)(self.deref() as *const _ as *mut _, profile.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_data_received(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerDataReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DataReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DataReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_trigger_pressed(&self, handler: &ComPtr<foundation::EventHandler<ClaimedBarcodeScanner>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_TriggerPressed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_trigger_pressed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_TriggerPressed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_trigger_released(&self, handler: &ComPtr<foundation::EventHandler<ClaimedBarcodeScanner>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_TriggerReleased)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_trigger_released(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_TriggerReleased)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &ComPtr<foundation::EventHandler<ClaimedBarcodeScanner>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_image_preview_received(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerImagePreviewReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ImagePreviewReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_image_preview_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ImagePreviewReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error_occurred(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedBarcodeScanner, BarcodeScannerErrorOccurredEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ErrorOccurred)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ErrorOccurred)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedBarcodeScanner: IClaimedBarcodeScanner}
DEFINE_IID!(IID_IClaimedBarcodeScanner1, 4128943372, 34129, 17076, 153, 140, 151, 12, 32, 33, 10, 34);
RT_INTERFACE!{interface IClaimedBarcodeScanner1(IClaimedBarcodeScanner1Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner1] {
    fn StartSoftwareTriggerAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn StopSoftwareTriggerAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IClaimedBarcodeScanner1> {
    #[inline] pub fn start_software_trigger_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).StartSoftwareTriggerAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_software_trigger_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).StopSoftwareTriggerAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScanner2, 3820330636, 11659, 20336, 138, 243, 52, 72, 190, 221, 95, 226);
RT_INTERFACE!{interface IClaimedBarcodeScanner2(IClaimedBarcodeScanner2Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner2] {
    fn GetSymbologyAttributesAsync(&self, barcodeSymbology: u32, out: *mut *mut foundation::IAsyncOperation<BarcodeSymbologyAttributes>) -> HRESULT,
    fn SetSymbologyAttributesAsync(&self, barcodeSymbology: u32, attributes: *mut BarcodeSymbologyAttributes, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<IClaimedBarcodeScanner2> {
    #[inline] pub fn get_symbology_attributes_async(&self, barcodeSymbology: u32) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeSymbologyAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSymbologyAttributesAsync)(self.deref() as *const _ as *mut _, barcodeSymbology, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_symbology_attributes_async(&self, barcodeSymbology: u32, attributes: &ComPtr<BarcodeSymbologyAttributes>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SetSymbologyAttributesAsync)(self.deref() as *const _ as *mut _, barcodeSymbology, attributes.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScanner3, 3872306224, 28974, 17916, 139, 134, 205, 85, 245, 174, 247, 157);
RT_INTERFACE!{interface IClaimedBarcodeScanner3(IClaimedBarcodeScanner3Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner3] {
    fn ShowVideoPreviewAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn HideVideoPreview(&self) -> HRESULT,
    fn put_IsVideoPreviewShownOnEnable(&self, value: bool) -> HRESULT,
    fn get_IsVideoPreviewShownOnEnable(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IClaimedBarcodeScanner3> {
    #[inline] pub fn show_video_preview_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ShowVideoPreviewAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn hide_video_preview(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).HideVideoPreview)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_is_video_preview_shown_on_enable(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsVideoPreviewShownOnEnable)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_video_preview_shown_on_enable(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsVideoPreviewShownOnEnable)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScanner4, 1565532055, 14186, 16808, 162, 48, 47, 55, 193, 148, 157, 222);
RT_INTERFACE!{interface IClaimedBarcodeScanner4(IClaimedBarcodeScanner4Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScanner4] {
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedBarcodeScanner4> {
    #[inline] pub fn add_closed(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Closed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Closed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedBarcodeScannerClosedEventArgs, 3481097353, 41516, 19557, 169, 1, 136, 215, 125, 131, 57, 84);
RT_INTERFACE!{interface IClaimedBarcodeScannerClosedEventArgs(IClaimedBarcodeScannerClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedBarcodeScannerClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedBarcodeScannerClosedEventArgs: IClaimedBarcodeScannerClosedEventArgs}
DEFINE_IID!(IID_IClaimedCashDrawer, 3393165743, 43960, 17089, 138, 132, 92, 102, 81, 47, 90, 117);
RT_INTERFACE!{interface IClaimedCashDrawer(IClaimedCashDrawerVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawer] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDrawerOpen(&self, out: *mut bool) -> HRESULT,
    fn get_CloseAlarm(&self, out: *mut *mut CashDrawerCloseAlarm) -> HRESULT,
    fn OpenDrawerAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn EnableAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn DisableAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RetainDeviceAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: *mut foundation::TypedEventHandler<ClaimedCashDrawer, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedCashDrawer> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_drawer_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDrawerOpen)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_close_alarm(&self) -> Result<Option<ComPtr<CashDrawerCloseAlarm>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CloseAlarm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn open_drawer_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenDrawerAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).EnableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DisableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RetainDeviceAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ResetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UpdateStatisticsAsync)(self.deref() as *const _ as *mut _, statistics.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedCashDrawer, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedCashDrawer: IClaimedCashDrawer}
DEFINE_IID!(IID_IClaimedCashDrawer2, 2629481890, 56898, 19803, 176, 193, 155, 87, 162, 186, 137, 195);
RT_INTERFACE!{interface IClaimedCashDrawer2(IClaimedCashDrawer2Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawer2] {
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedCashDrawer2> {
    #[inline] pub fn add_closed(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Closed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Closed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedCashDrawerClosedEventArgs, 3428269875, 16180, 19548, 186, 174, 222, 173, 241, 108, 215, 250);
RT_INTERFACE!{interface IClaimedCashDrawerClosedEventArgs(IClaimedCashDrawerClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedCashDrawerClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedCashDrawerClosedEventArgs: IClaimedCashDrawerClosedEventArgs}
DEFINE_IID!(IID_IClaimedJournalPrinter, 1743390256, 20861, 18559, 159, 223, 210, 224, 160, 162, 100, 165);
RT_INTERFACE!{interface IClaimedJournalPrinter(IClaimedJournalPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedJournalPrinter] {
    fn CreateJob(&self, out: *mut *mut JournalPrintJob) -> HRESULT
}}
impl ComPtr<IClaimedJournalPrinter> {
    #[inline] pub fn create_job(&self) -> Result<Option<ComPtr<JournalPrintJob>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateJob)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedJournalPrinter: IClaimedJournalPrinter}
DEFINE_IID!(IID_IClaimedLineDisplay, 302696816, 39541, 19151, 170, 231, 9, 151, 43, 207, 135, 148);
RT_INTERFACE!{interface IClaimedLineDisplay(IClaimedLineDisplayVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplay] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut *mut LineDisplayCapabilities) -> HRESULT,
    fn get_PhysicalDeviceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhysicalDeviceDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceServiceVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultWindow(&self, out: *mut *mut LineDisplayWindow) -> HRESULT,
    fn RetainDevice(&self) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: *mut foundation::TypedEventHandler<ClaimedLineDisplay, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedLineDisplay> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<ComPtr<LineDisplayCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhysicalDeviceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhysicalDeviceDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceControlDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceControlVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_service_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceServiceVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_window(&self) -> Result<Option<ComPtr<LineDisplayWindow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultWindow)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RetainDevice)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedLineDisplay, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedLineDisplay: IClaimedLineDisplay}
impl RtActivatable<IClaimedLineDisplayStatics> for ClaimedLineDisplay {}
impl ClaimedLineDisplay {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedLineDisplay>>> {
        <Self as RtActivatable<IClaimedLineDisplayStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IClaimedLineDisplayStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IClaimedLineDisplayStatics>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(ClaimedLineDisplay(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,67,108,97,105,109,101,100,76,105,110,101,68,105,115,112,108,97,121,0]) [CLSID_ClaimedLineDisplay]);
DEFINE_IID!(IID_IClaimedLineDisplay2, 2736551405, 16885, 20086, 160, 116, 121, 94, 71, 164, 110, 151);
RT_INTERFACE!{interface IClaimedLineDisplay2(IClaimedLineDisplay2Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplay2] {
    fn GetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn CheckPowerStatusAsync(&self, out: *mut *mut foundation::IAsyncOperation<LineDisplayPowerStatus>) -> HRESULT,
    fn add_StatusUpdated(&self, handler: *mut foundation::TypedEventHandler<ClaimedLineDisplay, LineDisplayStatusUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn get_SupportedScreenSizesInCharacters(&self, out: *mut *mut foundation::collections::IVectorView<foundation::Size>) -> HRESULT,
    fn get_MaxBitmapSizeInPixels(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_SupportedCharacterSets(&self, out: *mut *mut foundation::collections::IVectorView<i32>) -> HRESULT,
    fn get_CustomGlyphs(&self, out: *mut *mut LineDisplayCustomGlyphs) -> HRESULT,
    fn GetAttributes(&self, out: *mut *mut LineDisplayAttributes) -> HRESULT,
    fn TryUpdateAttributesAsync(&self, attributes: *mut LineDisplayAttributes, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TrySetDescriptorAsync(&self, descriptor: u32, descriptorState: LineDisplayDescriptorState, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryClearDescriptorsAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryCreateWindowAsync(&self, viewport: foundation::Rect, windowSize: foundation::Size, out: *mut *mut foundation::IAsyncOperation<LineDisplayWindow>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryStoreStorageFileBitmapAsync(&self, bitmap: *mut super::super::storage::StorageFile, out: *mut *mut foundation::IAsyncOperation<LineDisplayStoredBitmap>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryStoreStorageFileBitmapWithAlignmentAsync(&self, bitmap: *mut super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, out: *mut *mut foundation::IAsyncOperation<LineDisplayStoredBitmap>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryStoreStorageFileBitmapWithAlignmentAndWidthAsync(&self, bitmap: *mut super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32, out: *mut *mut foundation::IAsyncOperation<LineDisplayStoredBitmap>) -> HRESULT
}}
impl ComPtr<IClaimedLineDisplay2> {
    #[inline] pub fn get_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckHealthAsync)(self.deref() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_power_status_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplayPowerStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckPowerStatusAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedLineDisplay, LineDisplayStatusUpdatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusUpdated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusUpdated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_screen_sizes_in_characters(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<foundation::Size>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedScreenSizesInCharacters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_bitmap_size_in_pixels(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBitmapSizeInPixels)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_character_sets(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCharacterSets)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_glyphs(&self) -> Result<Option<ComPtr<LineDisplayCustomGlyphs>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CustomGlyphs)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_attributes(&self) -> Result<Option<ComPtr<LineDisplayAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAttributes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_update_attributes_async(&self, attributes: &ComPtr<LineDisplayAttributes>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryUpdateAttributesAsync)(self.deref() as *const _ as *mut _, attributes.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_set_descriptor_async(&self, descriptor: u32, descriptorState: LineDisplayDescriptorState) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TrySetDescriptorAsync)(self.deref() as *const _ as *mut _, descriptor, descriptorState, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_clear_descriptors_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryClearDescriptorsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_create_window_async(&self, viewport: foundation::Rect, windowSize: foundation::Size) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplayWindow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryCreateWindowAsync)(self.deref() as *const _ as *mut _, viewport, windowSize, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_store_storage_file_bitmap_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplayStoredBitmap>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryStoreStorageFileBitmapAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_store_storage_file_bitmap_with_alignment_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplayStoredBitmap>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryStoreStorageFileBitmapWithAlignmentAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, horizontalAlignment, verticalAlignment, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_store_storage_file_bitmap_with_alignment_and_width_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplayStoredBitmap>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryStoreStorageFileBitmapWithAlignmentAndWidthAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, horizontalAlignment, verticalAlignment, widthInPixels, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedLineDisplay3, 1680788882, 59860, 20172, 175, 117, 50, 156, 39, 76, 209, 143);
RT_INTERFACE!{interface IClaimedLineDisplay3(IClaimedLineDisplay3Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplay3] {
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedLineDisplay3> {
    #[inline] pub fn add_closed(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Closed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Closed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedLineDisplayClosedEventArgs, 4178965348, 54229, 20240, 181, 17, 144, 147, 158, 223, 172, 216);
RT_INTERFACE!{interface IClaimedLineDisplayClosedEventArgs(IClaimedLineDisplayClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplayClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedLineDisplayClosedEventArgs: IClaimedLineDisplayClosedEventArgs}
DEFINE_IID!(IID_IClaimedLineDisplayStatics, 2026543355, 35691, 18803, 134, 240, 62, 87, 12, 53, 24, 37);
RT_INTERFACE!{static interface IClaimedLineDisplayStatics(IClaimedLineDisplayStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedLineDisplayStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<ClaimedLineDisplay>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IClaimedLineDisplayStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedLineDisplay>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.deref() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedMagneticStripeReader, 1197254899, 37911, 18620, 185, 215, 65, 99, 167, 132, 76, 2);
RT_INTERFACE!{interface IClaimedMagneticStripeReader(IClaimedMagneticStripeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReader] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisabledOnDataReceived(&self, value: bool) -> HRESULT,
    fn get_IsDisabledOnDataReceived(&self, out: *mut bool) -> HRESULT,
    fn put_IsDecodeDataEnabled(&self, value: bool) -> HRESULT,
    fn get_IsDecodeDataEnabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsDeviceAuthenticated(&self, out: *mut bool) -> HRESULT,
    fn put_DataEncryptionAlgorithm(&self, value: u32) -> HRESULT,
    fn get_DataEncryptionAlgorithm(&self, out: *mut u32) -> HRESULT,
    fn put_TracksToRead(&self, value: MagneticStripeReaderTrackIds) -> HRESULT,
    fn get_TracksToRead(&self, out: *mut MagneticStripeReaderTrackIds) -> HRESULT,
    fn put_IsTransmitSentinelsEnabled(&self, value: bool) -> HRESULT,
    fn get_IsTransmitSentinelsEnabled(&self, out: *mut bool) -> HRESULT,
    fn EnableAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn DisableAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn RetainDevice(&self) -> HRESULT,
    fn SetErrorReportingType(&self, value: MagneticStripeReaderErrorReportingType) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-storage")] fn RetrieveDeviceAuthenticationDataAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT,
    fn AuthenticateDeviceAsync(&self, responseTokenSize: u32, responseToken: *mut u8, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn DeAuthenticateDeviceAsync(&self, responseTokenSize: u32, responseToken: *mut u8, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn UpdateKeyAsync(&self, key: HSTRING, keyName: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn add_BankCardDataReceived(&self, handler: *mut foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BankCardDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AamvaCardDataReceived(&self, handler: *mut foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AamvaCardDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_VendorSpecificDataReceived(&self, handler: *mut foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VendorSpecificDataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: *mut foundation::EventHandler<ClaimedMagneticStripeReader>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ErrorOccurred(&self, handler: *mut foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorOccurred(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedMagneticStripeReader> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_disabled_on_data_received(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDisabledOnDataReceived)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_disabled_on_data_received(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDisabledOnDataReceived)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_decode_data_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDecodeDataEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_data_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDecodeDataEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_device_authenticated(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDeviceAuthenticated)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_encryption_algorithm(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DataEncryptionAlgorithm)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_encryption_algorithm(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataEncryptionAlgorithm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_tracks_to_read(&self, value: MagneticStripeReaderTrackIds) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_TracksToRead)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_tracks_to_read(&self) -> Result<MagneticStripeReaderTrackIds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TracksToRead)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_transmit_sentinels_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsTransmitSentinelsEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_transmit_sentinels_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsTransmitSentinelsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).EnableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DisableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).RetainDevice)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_error_reporting_type(&self, value: MagneticStripeReaderErrorReportingType) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetErrorReportingType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn retrieve_device_authentication_data_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RetrieveDeviceAuthenticationDataAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn authenticate_device_async(&self, responseToken: &[u8]) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AuthenticateDeviceAsync)(self.deref() as *const _ as *mut _, responseToken.len() as u32, responseToken.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn de_authenticate_device_async(&self, responseToken: &[u8]) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DeAuthenticateDeviceAsync)(self.deref() as *const _ as *mut _, responseToken.len() as u32, responseToken.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_key_async(&self, key: &HStringArg, keyName: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UpdateKeyAsync)(self.deref() as *const _ as *mut _, key.get(), keyName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ResetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UpdateStatisticsAsync)(self.deref() as *const _ as *mut _, statistics.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_bank_card_data_received(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderBankCardDataReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_BankCardDataReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_bank_card_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_BankCardDataReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_aamva_card_data_received(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderAamvaCardDataReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AamvaCardDataReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_aamva_card_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AamvaCardDataReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_vendor_specific_data_received(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_VendorSpecificDataReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_vendor_specific_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_VendorSpecificDataReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &ComPtr<foundation::EventHandler<ClaimedMagneticStripeReader>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_error_occurred(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedMagneticStripeReader, MagneticStripeReaderErrorOccurredEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ErrorOccurred)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_occurred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ErrorOccurred)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedMagneticStripeReader: IClaimedMagneticStripeReader}
DEFINE_IID!(IID_IClaimedMagneticStripeReader2, 594522079, 58076, 19837, 156, 120, 6, 13, 242, 191, 41, 40);
RT_INTERFACE!{interface IClaimedMagneticStripeReader2(IClaimedMagneticStripeReader2Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReader2] {
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedMagneticStripeReader2> {
    #[inline] pub fn add_closed(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Closed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Closed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedMagneticStripeReaderClosedEventArgs, 346925370, 44493, 19584, 172, 218, 195, 234, 237, 38, 71, 225);
RT_INTERFACE!{interface IClaimedMagneticStripeReaderClosedEventArgs(IClaimedMagneticStripeReaderClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedMagneticStripeReaderClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedMagneticStripeReaderClosedEventArgs: IClaimedMagneticStripeReaderClosedEventArgs}
DEFINE_IID!(IID_IClaimedPosPrinter, 1835322892, 57406, 19220, 163, 142, 194, 140, 52, 184, 99, 83);
RT_INTERFACE!{interface IClaimedPosPrinter(IClaimedPosPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinter] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_CharacterSet(&self, value: u32) -> HRESULT,
    fn get_CharacterSet(&self, out: *mut u32) -> HRESULT,
    fn get_IsCoverOpen(&self, out: *mut bool) -> HRESULT,
    fn put_IsCharacterSetMappingEnabled(&self, value: bool) -> HRESULT,
    fn get_IsCharacterSetMappingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_MapMode(&self, value: PosPrinterMapMode) -> HRESULT,
    fn get_MapMode(&self, out: *mut PosPrinterMapMode) -> HRESULT,
    fn get_Receipt(&self, out: *mut *mut ClaimedReceiptPrinter) -> HRESULT,
    fn get_Slip(&self, out: *mut *mut ClaimedSlipPrinter) -> HRESULT,
    fn get_Journal(&self, out: *mut *mut ClaimedJournalPrinter) -> HRESULT,
    fn EnableAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn DisableAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RetainDeviceAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn ResetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn UpdateStatisticsAsync(&self, statistics: *mut foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_ReleaseDeviceRequested(&self, handler: *mut foundation::TypedEventHandler<ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReleaseDeviceRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedPosPrinter> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_character_set(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CharacterSet)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_character_set(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacterSet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cover_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCoverOpen)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_character_set_mapping_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsCharacterSetMappingEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_character_set_mapping_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCharacterSetMappingEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_map_mode(&self, value: PosPrinterMapMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_MapMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_map_mode(&self) -> Result<PosPrinterMapMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MapMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_receipt(&self) -> Result<Option<ComPtr<ClaimedReceiptPrinter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Receipt)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_slip(&self) -> Result<Option<ComPtr<ClaimedSlipPrinter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Slip)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_journal(&self) -> Result<Option<ComPtr<ClaimedJournalPrinter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Journal)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn enable_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).EnableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn disable_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DisableAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn retain_device_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RetainDeviceAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn reset_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ResetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn update_statistics_async(&self, statistics: &ComPtr<foundation::collections::IIterable<foundation::collections::IKeyValuePair<HString, HString>>>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UpdateStatisticsAsync)(self.deref() as *const _ as *mut _, statistics.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_release_device_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedPosPrinter, PosPrinterReleaseDeviceRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_release_device_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReleaseDeviceRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedPosPrinter: IClaimedPosPrinter}
DEFINE_IID!(IID_IClaimedPosPrinter2, 1542955989, 20888, 17274, 130, 223, 88, 153, 147, 250, 119, 225);
RT_INTERFACE!{interface IClaimedPosPrinter2(IClaimedPosPrinter2Vtbl): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinter2] {
    fn add_Closed(&self, handler: *mut foundation::TypedEventHandler<ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IClaimedPosPrinter2> {
    #[inline] pub fn add_closed(&self, handler: &ComPtr<foundation::TypedEventHandler<ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Closed)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_closed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Closed)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IClaimedPosPrinterClosedEventArgs, 3803685499, 19776, 18205, 146, 237, 99, 55, 91, 24, 199, 136);
RT_INTERFACE!{interface IClaimedPosPrinterClosedEventArgs(IClaimedPosPrinterClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedPosPrinterClosedEventArgs] {
    
}}
RT_CLASS!{class ClaimedPosPrinterClosedEventArgs: IClaimedPosPrinterClosedEventArgs}
DEFINE_IID!(IID_IClaimedReceiptPrinter, 2597485172, 56673, 20194, 152, 55, 91, 93, 114, 213, 56, 185);
RT_INTERFACE!{interface IClaimedReceiptPrinter(IClaimedReceiptPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedReceiptPrinter] {
    fn get_SidewaysMaxLines(&self, out: *mut u32) -> HRESULT,
    fn get_SidewaysMaxChars(&self, out: *mut u32) -> HRESULT,
    fn get_LinesToPaperCut(&self, out: *mut u32) -> HRESULT,
    fn get_PageSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_PrintArea(&self, out: *mut foundation::Rect) -> HRESULT,
    fn CreateJob(&self, out: *mut *mut ReceiptPrintJob) -> HRESULT
}}
impl ComPtr<IClaimedReceiptPrinter> {
    #[inline] pub fn get_sideways_max_lines(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SidewaysMaxLines)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sideways_max_chars(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SidewaysMaxChars)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lines_to_paper_cut(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LinesToPaperCut)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_page_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PageSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_print_area(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PrintArea)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn create_job(&self) -> Result<Option<ComPtr<ReceiptPrintJob>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateJob)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedReceiptPrinter: IClaimedReceiptPrinter}
DEFINE_IID!(IID_IClaimedSlipPrinter, 3177050098, 44944, 20106, 183, 123, 227, 174, 156, 166, 58, 127);
RT_INTERFACE!{interface IClaimedSlipPrinter(IClaimedSlipPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IClaimedSlipPrinter] {
    fn get_SidewaysMaxLines(&self, out: *mut u32) -> HRESULT,
    fn get_SidewaysMaxChars(&self, out: *mut u32) -> HRESULT,
    fn get_MaxLines(&self, out: *mut u32) -> HRESULT,
    fn get_LinesNearEndToEnd(&self, out: *mut u32) -> HRESULT,
    fn get_PrintSide(&self, out: *mut PosPrinterPrintSide) -> HRESULT,
    fn get_PageSize(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_PrintArea(&self, out: *mut foundation::Rect) -> HRESULT,
    fn OpenJaws(&self) -> HRESULT,
    fn CloseJaws(&self) -> HRESULT,
    fn InsertSlipAsync(&self, timeout: foundation::TimeSpan, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RemoveSlipAsync(&self, timeout: foundation::TimeSpan, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn ChangePrintSide(&self, printSide: PosPrinterPrintSide) -> HRESULT,
    fn CreateJob(&self, out: *mut *mut SlipPrintJob) -> HRESULT
}}
impl ComPtr<IClaimedSlipPrinter> {
    #[inline] pub fn get_sideways_max_lines(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SidewaysMaxLines)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sideways_max_chars(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SidewaysMaxChars)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_lines(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxLines)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_lines_near_end_to_end(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LinesNearEndToEnd)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_print_side(&self) -> Result<PosPrinterPrintSide> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PrintSide)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_page_size(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PageSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_print_area(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PrintArea)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_jaws(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).OpenJaws)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn close_jaws(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).CloseJaws)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn insert_slip_async(&self, timeout: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).InsertSlipAsync)(self.deref() as *const _ as *mut _, timeout, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn remove_slip_async(&self, timeout: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RemoveSlipAsync)(self.deref() as *const _ as *mut _, timeout, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn change_print_side(&self, printSide: PosPrinterPrintSide) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ChangePrintSide)(self.deref() as *const _ as *mut _, printSide);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_job(&self) -> Result<Option<ComPtr<SlipPrintJob>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateJob)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ClaimedSlipPrinter: IClaimedSlipPrinter}
DEFINE_IID!(IID_ICommonClaimedPosPrinterStation, 3085657768, 65162, 19707, 139, 66, 227, 91, 40, 12, 178, 124);
RT_INTERFACE!{interface ICommonClaimedPosPrinterStation(ICommonClaimedPosPrinterStationVtbl): IInspectable(IInspectableVtbl) [IID_ICommonClaimedPosPrinterStation] {
    fn put_CharactersPerLine(&self, value: u32) -> HRESULT,
    fn get_CharactersPerLine(&self, out: *mut u32) -> HRESULT,
    fn put_LineHeight(&self, value: u32) -> HRESULT,
    fn get_LineHeight(&self, out: *mut u32) -> HRESULT,
    fn put_LineSpacing(&self, value: u32) -> HRESULT,
    fn get_LineSpacing(&self, out: *mut u32) -> HRESULT,
    fn get_LineWidth(&self, out: *mut u32) -> HRESULT,
    fn put_IsLetterQuality(&self, value: bool) -> HRESULT,
    fn get_IsLetterQuality(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperNearEnd(&self, out: *mut bool) -> HRESULT,
    fn put_ColorCartridge(&self, value: PosPrinterColorCartridge) -> HRESULT,
    fn get_ColorCartridge(&self, out: *mut PosPrinterColorCartridge) -> HRESULT,
    fn get_IsCoverOpen(&self, out: *mut bool) -> HRESULT,
    fn get_IsCartridgeRemoved(&self, out: *mut bool) -> HRESULT,
    fn get_IsCartridgeEmpty(&self, out: *mut bool) -> HRESULT,
    fn get_IsHeadCleaning(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperEmpty(&self, out: *mut bool) -> HRESULT,
    fn get_IsReadyToPrint(&self, out: *mut bool) -> HRESULT,
    fn ValidateData(&self, data: HSTRING, out: *mut bool) -> HRESULT
}}
impl ComPtr<ICommonClaimedPosPrinterStation> {
    #[inline] pub fn set_characters_per_line(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CharactersPerLine)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_characters_per_line(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharactersPerLine)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_line_height(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_LineHeight)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_line_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LineHeight)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_line_spacing(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_LineSpacing)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_line_spacing(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LineSpacing)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_line_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LineWidth)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_letter_quality(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsLetterQuality)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_letter_quality(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsLetterQuality)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_near_end(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaperNearEnd)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color_cartridge(&self, value: PosPrinterColorCartridge) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ColorCartridge)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_color_cartridge(&self) -> Result<PosPrinterColorCartridge> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ColorCartridge)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cover_open(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCoverOpen)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cartridge_removed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCartridgeRemoved)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cartridge_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCartridgeEmpty)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_head_cleaning(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsHeadCleaning)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_empty(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaperEmpty)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_ready_to_print(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsReadyToPrint)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn validate_data(&self, data: &HStringArg) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).ValidateData)(self.deref() as *const _ as *mut _, data.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICommonPosPrintStationCapabilities, 3730526922, 57390, 16617, 158, 94, 27, 72, 142, 106, 172, 252);
RT_INTERFACE!{interface ICommonPosPrintStationCapabilities(ICommonPosPrintStationCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICommonPosPrintStationCapabilities] {
    fn get_IsPrinterPresent(&self, out: *mut bool) -> HRESULT,
    fn get_IsDualColorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_ColorCartridgeCapabilities(&self, out: *mut PosPrinterColorCapabilities) -> HRESULT,
    fn get_CartridgeSensors(&self, out: *mut PosPrinterCartridgeSensors) -> HRESULT,
    fn get_IsBoldSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsItalicSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsUnderlineSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDoubleHighPrintSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDoubleWidePrintSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsDoubleHighDoubleWidePrintSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperEmptySensorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPaperNearEndSensorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedCharactersPerLine(&self, out: *mut *mut foundation::collections::IVectorView<u32>) -> HRESULT
}}
impl ComPtr<ICommonPosPrintStationCapabilities> {
    #[inline] pub fn get_is_printer_present(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPrinterPresent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_dual_color_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDualColorSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_color_cartridge_capabilities(&self) -> Result<PosPrinterColorCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ColorCartridgeCapabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cartridge_sensors(&self) -> Result<PosPrinterCartridgeSensors> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CartridgeSensors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_bold_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBoldSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_italic_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsItalicSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_underline_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsUnderlineSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_double_high_print_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDoubleHighPrintSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_double_wide_print_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDoubleWidePrintSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_double_high_double_wide_print_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDoubleHighDoubleWidePrintSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_empty_sensor_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaperEmptySensorSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_paper_near_end_sensor_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPaperNearEndSensorSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_characters_per_line(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCharactersPerLine)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICommonReceiptSlipCapabilities, 153643915, 39027, 19717, 191, 190, 71, 39, 166, 3, 143, 105);
RT_INTERFACE!{interface ICommonReceiptSlipCapabilities(ICommonReceiptSlipCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ICommonReceiptSlipCapabilities] {
    fn get_IsBarcodeSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsBitmapSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsLeft90RotationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsRight90RotationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Is180RotationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsPrintAreaSupported(&self, out: *mut bool) -> HRESULT,
    fn get_RuledLineCapabilities(&self, out: *mut PosPrinterRuledLineCapabilities) -> HRESULT,
    fn get_SupportedBarcodeRotations(&self, out: *mut *mut foundation::collections::IVectorView<PosPrinterRotation>) -> HRESULT,
    fn get_SupportedBitmapRotations(&self, out: *mut *mut foundation::collections::IVectorView<PosPrinterRotation>) -> HRESULT
}}
impl ComPtr<ICommonReceiptSlipCapabilities> {
    #[inline] pub fn get_is_barcode_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBarcodeSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_bitmap_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBitmapSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_left_90_rotation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsLeft90RotationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_right_90_rotation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsRight90RotationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_180_rotation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Is180RotationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_print_area_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPrintAreaSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ruled_line_capabilities(&self) -> Result<PosPrinterRuledLineCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RuledLineCapabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_barcode_rotations(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PosPrinterRotation>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedBarcodeRotations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_bitmap_rotations(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<PosPrinterRotation>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedBitmapRotations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IJournalPrinterCapabilities, 995937347, 57415, 17507, 187, 88, 23, 181, 186, 29, 128, 86);
RT_INTERFACE!{interface IJournalPrinterCapabilities(IJournalPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IJournalPrinterCapabilities] {
    
}}
RT_CLASS!{class JournalPrinterCapabilities: IJournalPrinterCapabilities}
RT_CLASS!{class JournalPrintJob: IPosPrinterJob}
DEFINE_IID!(IID_ILineDisplay, 620093262, 15513, 17634, 183, 63, 229, 27, 227, 99, 122, 140);
RT_INTERFACE!{interface ILineDisplay(ILineDisplayVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplay] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut *mut LineDisplayCapabilities) -> HRESULT,
    fn get_PhysicalDeviceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhysicalDeviceDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlDescription(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceControlVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DeviceServiceVersion(&self, out: *mut HSTRING) -> HRESULT,
    fn ClaimAsync(&self, out: *mut *mut foundation::IAsyncOperation<ClaimedLineDisplay>) -> HRESULT
}}
impl ComPtr<ILineDisplay> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<ComPtr<LineDisplayCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhysicalDeviceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical_device_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PhysicalDeviceDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceControlDescription)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_control_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceControlVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_service_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceServiceVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedLineDisplay>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClaimAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplay: ILineDisplay}
impl RtActivatable<ILineDisplayStatics> for LineDisplay {}
impl RtActivatable<ILineDisplayStatics2> for LineDisplay {}
impl LineDisplay {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplay>>> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<LineDisplay>>> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<ILineDisplayStatics>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
    #[inline] pub fn get_statistics_category_selector() -> Result<Option<ComPtr<LineDisplayStatisticsCategorySelector>>> {
        <Self as RtActivatable<ILineDisplayStatics2>>::get_activation_factory().get_statistics_category_selector()
    }
}
DEFINE_CLSID!(LineDisplay(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,76,105,110,101,68,105,115,112,108,97,121,0]) [CLSID_LineDisplay]);
DEFINE_IID!(IID_ILineDisplay2, 3264652840, 61252, 16627, 189, 28, 176, 76, 106, 92, 220, 125);
RT_INTERFACE!{interface ILineDisplay2(ILineDisplay2Vtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplay2] {
    fn CheckPowerStatusAsync(&self, out: *mut *mut foundation::IAsyncOperation<LineDisplayPowerStatus>) -> HRESULT
}}
impl ComPtr<ILineDisplay2> {
    #[inline] pub fn check_power_status_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplayPowerStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckPowerStatusAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILineDisplayAttributes, 3246254492, 8858, 19476, 166, 241, 180, 228, 177, 254, 173, 146);
RT_INTERFACE!{interface ILineDisplayAttributes(ILineDisplayAttributesVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayAttributes] {
    fn get_IsPowerNotifyEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsPowerNotifyEnabled(&self, value: bool) -> HRESULT,
    fn get_Brightness(&self, out: *mut i32) -> HRESULT,
    fn put_Brightness(&self, value: i32) -> HRESULT,
    fn get_BlinkRate(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_BlinkRate(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_ScreenSizeInCharacters(&self, out: *mut foundation::Size) -> HRESULT,
    fn put_ScreenSizeInCharacters(&self, value: foundation::Size) -> HRESULT,
    fn get_CharacterSet(&self, out: *mut i32) -> HRESULT,
    fn put_CharacterSet(&self, value: i32) -> HRESULT,
    fn get_IsCharacterSetMappingEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsCharacterSetMappingEnabled(&self, value: bool) -> HRESULT,
    fn get_CurrentWindow(&self, out: *mut *mut LineDisplayWindow) -> HRESULT,
    fn put_CurrentWindow(&self, value: *mut LineDisplayWindow) -> HRESULT
}}
impl ComPtr<ILineDisplayAttributes> {
    #[inline] pub fn get_is_power_notify_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPowerNotifyEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_power_notify_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsPowerNotifyEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Brightness)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Brightness)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_blink_rate(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BlinkRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_blink_rate(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BlinkRate)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_screen_size_in_characters(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScreenSizeInCharacters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_screen_size_in_characters(&self, value: foundation::Size) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ScreenSizeInCharacters)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_character_set(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CharacterSet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_character_set(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CharacterSet)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_character_set_mapping_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCharacterSetMappingEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_character_set_mapping_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsCharacterSetMappingEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_current_window(&self) -> Result<Option<ComPtr<LineDisplayWindow>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CurrentWindow)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_current_window(&self, value: &ComPtr<LineDisplayWindow>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CurrentWindow)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayAttributes: ILineDisplayAttributes}
DEFINE_IID!(IID_ILineDisplayCapabilities, 1511372241, 36293, 19356, 145, 114, 48, 62, 71, 183, 12, 85);
RT_INTERFACE!{interface ILineDisplayCapabilities(ILineDisplayCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayCapabilities] {
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_CanChangeScreenSize(&self, out: *mut bool) -> HRESULT,
    fn get_CanDisplayBitmaps(&self, out: *mut bool) -> HRESULT,
    fn get_CanReadCharacterAtCursor(&self, out: *mut bool) -> HRESULT,
    fn get_CanMapCharacterSets(&self, out: *mut bool) -> HRESULT,
    fn get_CanDisplayCustomGlyphs(&self, out: *mut bool) -> HRESULT,
    fn get_CanReverse(&self, out: *mut LineDisplayTextAttributeGranularity) -> HRESULT,
    fn get_CanBlink(&self, out: *mut LineDisplayTextAttributeGranularity) -> HRESULT,
    fn get_CanChangeBlinkRate(&self, out: *mut bool) -> HRESULT,
    fn get_IsBrightnessSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsCursorSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsHorizontalMarqueeSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsVerticalMarqueeSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsInterCharacterWaitSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SupportedDescriptors(&self, out: *mut u32) -> HRESULT,
    fn get_SupportedWindows(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ILineDisplayCapabilities> {
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsReportingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsUpdatingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerReportingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_change_screen_size(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanChangeScreenSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_display_bitmaps(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanDisplayBitmaps)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_read_character_at_cursor(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanReadCharacterAtCursor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_map_character_sets(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanMapCharacterSets)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_display_custom_glyphs(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanDisplayCustomGlyphs)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_reverse(&self) -> Result<LineDisplayTextAttributeGranularity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanReverse)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_blink(&self) -> Result<LineDisplayTextAttributeGranularity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanBlink)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_change_blink_rate(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanChangeBlinkRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_brightness_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBrightnessSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_cursor_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCursorSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_horizontal_marquee_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsHorizontalMarqueeSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_vertical_marquee_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsVerticalMarqueeSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_inter_character_wait_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsInterCharacterWaitSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_descriptors(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SupportedDescriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_windows(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SupportedWindows)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCapabilities: ILineDisplayCapabilities}
DEFINE_IID!(IID_ILineDisplayCursor, 3974102085, 30026, 20027, 171, 43, 21, 17, 129, 8, 86, 5);
RT_INTERFACE!{interface ILineDisplayCursor(ILineDisplayCursorVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayCursor] {
    fn get_CanCustomize(&self, out: *mut bool) -> HRESULT,
    fn get_IsBlinkSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsBlockSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsHalfBlockSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsUnderlineSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsReverseSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsOtherSupported(&self, out: *mut bool) -> HRESULT,
    fn GetAttributes(&self, out: *mut *mut LineDisplayCursorAttributes) -> HRESULT,
    fn TryUpdateAttributesAsync(&self, attributes: *mut LineDisplayCursorAttributes, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ILineDisplayCursor> {
    #[inline] pub fn get_can_customize(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanCustomize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_blink_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBlinkSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_block_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBlockSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_half_block_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsHalfBlockSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_underline_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsUnderlineSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_reverse_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsReverseSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_other_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsOtherSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attributes(&self) -> Result<Option<ComPtr<LineDisplayCursorAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAttributes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_update_attributes_async(&self, attributes: &ComPtr<LineDisplayCursorAttributes>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryUpdateAttributesAsync)(self.deref() as *const _ as *mut _, attributes.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCursor: ILineDisplayCursor}
DEFINE_IID!(IID_ILineDisplayCursorAttributes, 1311593726, 20477, 16784, 170, 225, 206, 40, 95, 32, 200, 150);
RT_INTERFACE!{interface ILineDisplayCursorAttributes(ILineDisplayCursorAttributesVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayCursorAttributes] {
    fn get_IsBlinkEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsBlinkEnabled(&self, value: bool) -> HRESULT,
    fn get_CursorType(&self, out: *mut LineDisplayCursorType) -> HRESULT,
    fn put_CursorType(&self, value: LineDisplayCursorType) -> HRESULT,
    fn get_IsAutoAdvanceEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsAutoAdvanceEnabled(&self, value: bool) -> HRESULT,
    fn get_Position(&self, out: *mut foundation::Point) -> HRESULT,
    fn put_Position(&self, value: foundation::Point) -> HRESULT
}}
impl ComPtr<ILineDisplayCursorAttributes> {
    #[inline] pub fn get_is_blink_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBlinkEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_blink_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsBlinkEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cursor_type(&self) -> Result<LineDisplayCursorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CursorType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cursor_type(&self, value: LineDisplayCursorType) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CursorType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_auto_advance_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsAutoAdvanceEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_auto_advance_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsAutoAdvanceEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_position(&self) -> Result<foundation::Point> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Position)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_position(&self, value: foundation::Point) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Position)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCursorAttributes: ILineDisplayCursorAttributes}
RT_ENUM! { enum LineDisplayCursorType: i32 {
    None = 0, Block = 1, HalfBlock = 2, Underline = 3, Reverse = 4, Other = 5,
}}
DEFINE_IID!(IID_ILineDisplayCustomGlyphs, 576190012, 62051, 17649, 161, 160, 231, 80, 166, 160, 236, 84);
RT_INTERFACE!{interface ILineDisplayCustomGlyphs(ILineDisplayCustomGlyphsVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayCustomGlyphs] {
    fn get_SizeInPixels(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_SupportedGlyphCodes(&self, out: *mut *mut foundation::collections::IVectorView<u32>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryRedefineAsync(&self, glyphCode: u32, glyphData: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ILineDisplayCustomGlyphs> {
    #[inline] pub fn get_size_in_pixels(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SizeInPixels)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_glyph_codes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedGlyphCodes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_redefine_async(&self, glyphCode: u32, glyphData: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryRedefineAsync)(self.deref() as *const _ as *mut _, glyphCode, glyphData.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayCustomGlyphs: ILineDisplayCustomGlyphs}
RT_ENUM! { enum LineDisplayDescriptorState: i32 {
    Off = 0, On = 1, Blink = 2,
}}
RT_ENUM! { enum LineDisplayHorizontalAlignment: i32 {
    Left = 0, Center = 1, Right = 2,
}}
DEFINE_IID!(IID_ILineDisplayMarquee, 2748530238, 62570, 19322, 188, 33, 83, 235, 59, 87, 248, 180);
RT_INTERFACE!{interface ILineDisplayMarquee(ILineDisplayMarqueeVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayMarquee] {
    fn get_Format(&self, out: *mut LineDisplayMarqueeFormat) -> HRESULT,
    fn put_Format(&self, value: LineDisplayMarqueeFormat) -> HRESULT,
    fn get_RepeatWaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_RepeatWaitInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_ScrollWaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_ScrollWaitInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn TryStartScrollingAsync(&self, direction: LineDisplayScrollDirection, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryStopScrollingAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ILineDisplayMarquee> {
    #[inline] pub fn get_format(&self) -> Result<LineDisplayMarqueeFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Format)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: LineDisplayMarqueeFormat) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Format)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_repeat_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RepeatWaitInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_repeat_wait_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RepeatWaitInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_scroll_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScrollWaitInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scroll_wait_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ScrollWaitInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_start_scrolling_async(&self, direction: LineDisplayScrollDirection) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryStartScrollingAsync)(self.deref() as *const _ as *mut _, direction, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_stop_scrolling_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryStopScrollingAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayMarquee: ILineDisplayMarquee}
RT_ENUM! { enum LineDisplayMarqueeFormat: i32 {
    None = 0, Walk = 1, Place = 2,
}}
RT_ENUM! { enum LineDisplayPowerStatus: i32 {
    Unknown = 0, Online = 1, Off = 2, Offline = 3, OffOrOffline = 4,
}}
RT_ENUM! { enum LineDisplayScrollDirection: i32 {
    Up = 0, Down = 1, Left = 2, Right = 3,
}}
DEFINE_IID!(IID_ILineDisplayStatics, 36552886, 4528, 18064, 149, 71, 11, 57, 197, 175, 33, 20);
RT_INTERFACE!{static interface ILineDisplayStatics(ILineDisplayStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<LineDisplay>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<LineDisplay>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ILineDisplayStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplay>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<LineDisplay>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.deref() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILineDisplayStatics2, 1611415324, 30635, 18792, 167, 222, 192, 47, 241, 105, 242, 204);
RT_INTERFACE!{static interface ILineDisplayStatics2(ILineDisplayStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatics2] {
    fn get_StatisticsCategorySelector(&self, out: *mut *mut LineDisplayStatisticsCategorySelector) -> HRESULT
}}
impl ComPtr<ILineDisplayStatics2> {
    #[inline] pub fn get_statistics_category_selector(&self) -> Result<Option<ComPtr<LineDisplayStatisticsCategorySelector>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StatisticsCategorySelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILineDisplayStatisticsCategorySelector, 3038889067, 37492, 19748, 148, 243, 182, 1, 123, 131, 36, 68);
RT_INTERFACE!{interface ILineDisplayStatisticsCategorySelector(ILineDisplayStatisticsCategorySelectorVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatisticsCategorySelector] {
    fn get_AllStatistics(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UnifiedPosStatistics(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ManufacturerStatistics(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ILineDisplayStatisticsCategorySelector> {
    #[inline] pub fn get_all_statistics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AllStatistics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_unified_pos_statistics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UnifiedPosStatistics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_manufacturer_statistics(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ManufacturerStatistics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayStatisticsCategorySelector: ILineDisplayStatisticsCategorySelector}
DEFINE_IID!(IID_ILineDisplayStatusUpdatedEventArgs, 3721755674, 34555, 20154, 147, 209, 111, 94, 218, 82, 183, 82);
RT_INTERFACE!{interface ILineDisplayStatusUpdatedEventArgs(ILineDisplayStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut LineDisplayPowerStatus) -> HRESULT
}}
impl ComPtr<ILineDisplayStatusUpdatedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<LineDisplayPowerStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayStatusUpdatedEventArgs: ILineDisplayStatusUpdatedEventArgs}
DEFINE_IID!(IID_ILineDisplayStoredBitmap, 4129378651, 55326, 17338, 191, 27, 188, 250, 60, 120, 91, 160);
RT_INTERFACE!{interface ILineDisplayStoredBitmap(ILineDisplayStoredBitmapVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayStoredBitmap] {
    fn get_EscapeSequence(&self, out: *mut HSTRING) -> HRESULT,
    fn TryDeleteAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ILineDisplayStoredBitmap> {
    #[inline] pub fn get_escape_sequence(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EscapeSequence)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_delete_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDeleteAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayStoredBitmap: ILineDisplayStoredBitmap}
RT_ENUM! { enum LineDisplayTextAttribute: i32 {
    Normal = 0, Blink = 1, Reverse = 2, ReverseBlink = 3,
}}
RT_ENUM! { enum LineDisplayTextAttributeGranularity: i32 {
    NotSupported = 0, EntireDisplay = 1, PerCharacter = 2,
}}
RT_ENUM! { enum LineDisplayVerticalAlignment: i32 {
    Top = 0, Center = 1, Bottom = 2,
}}
DEFINE_IID!(IID_ILineDisplayWindow, 3525308148, 9060, 19429, 190, 225, 133, 22, 128, 175, 73, 100);
RT_INTERFACE!{interface ILineDisplayWindow(ILineDisplayWindowVtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayWindow] {
    fn get_SizeInCharacters(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_InterCharacterWaitInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_InterCharacterWaitInterval(&self, value: foundation::TimeSpan) -> HRESULT,
    fn TryRefreshAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryDisplayTextAsync(&self, text: HSTRING, displayAttribute: LineDisplayTextAttribute, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryDisplayTextAtPositionAsync(&self, text: HSTRING, displayAttribute: LineDisplayTextAttribute, startPosition: foundation::Point, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryDisplayTextNormalAsync(&self, text: HSTRING, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryScrollTextAsync(&self, direction: LineDisplayScrollDirection, numberOfColumnsOrRows: u32, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryClearTextAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ILineDisplayWindow> {
    #[inline] pub fn get_size_in_characters(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SizeInCharacters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_inter_character_wait_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InterCharacterWaitInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_inter_character_wait_interval(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_InterCharacterWaitInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn try_refresh_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryRefreshAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_text_async(&self, text: &HStringArg, displayAttribute: LineDisplayTextAttribute) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayTextAsync)(self.deref() as *const _ as *mut _, text.get(), displayAttribute, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_text_at_position_async(&self, text: &HStringArg, displayAttribute: LineDisplayTextAttribute, startPosition: foundation::Point) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayTextAtPositionAsync)(self.deref() as *const _ as *mut _, text.get(), displayAttribute, startPosition, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_text_normal_async(&self, text: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayTextNormalAsync)(self.deref() as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_scroll_text_async(&self, direction: LineDisplayScrollDirection, numberOfColumnsOrRows: u32) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryScrollTextAsync)(self.deref() as *const _ as *mut _, direction, numberOfColumnsOrRows, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_clear_text_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryClearTextAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LineDisplayWindow: ILineDisplayWindow}
DEFINE_IID!(IID_ILineDisplayWindow2, 2841436902, 48600, 17253, 142, 17, 222, 148, 222, 141, 255, 2);
RT_INTERFACE!{interface ILineDisplayWindow2(ILineDisplayWindow2Vtbl): IInspectable(IInspectableVtbl) [IID_ILineDisplayWindow2] {
    fn get_Cursor(&self, out: *mut *mut LineDisplayCursor) -> HRESULT,
    fn get_Marquee(&self, out: *mut *mut LineDisplayMarquee) -> HRESULT,
    fn ReadCharacterAtCursorAsync(&self, out: *mut *mut foundation::IAsyncOperation<u32>) -> HRESULT,
    fn TryDisplayStoredBitmapAtCursorAsync(&self, bitmap: *mut LineDisplayStoredBitmap, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtCursorAsync(&self, bitmap: *mut super::super::storage::StorageFile, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtCursorWithAlignmentAsync(&self, bitmap: *mut super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtCursorWithAlignmentAndWidthAsync(&self, bitmap: *mut super::super::storage::StorageFile, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtPointAsync(&self, bitmap: *mut super::super::storage::StorageFile, offsetInPixels: foundation::Point, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryDisplayStorageFileBitmapAtPointWithWidthAsync(&self, bitmap: *mut super::super::storage::StorageFile, offsetInPixels: foundation::Point, widthInPixels: i32, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ILineDisplayWindow2> {
    #[inline] pub fn get_cursor(&self) -> Result<Option<ComPtr<LineDisplayCursor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Cursor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_marquee(&self) -> Result<Option<ComPtr<LineDisplayMarquee>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Marquee)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn read_character_at_cursor_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadCharacterAtCursorAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_display_stored_bitmap_at_cursor_async(&self, bitmap: &ComPtr<LineDisplayStoredBitmap>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayStoredBitmapAtCursorAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_cursor_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayStorageFileBitmapAtCursorAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_cursor_with_alignment_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayStorageFileBitmapAtCursorWithAlignmentAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, horizontalAlignment, verticalAlignment, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_cursor_with_alignment_and_width_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>, horizontalAlignment: LineDisplayHorizontalAlignment, verticalAlignment: LineDisplayVerticalAlignment, widthInPixels: i32) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayStorageFileBitmapAtCursorWithAlignmentAndWidthAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, horizontalAlignment, verticalAlignment, widthInPixels, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_point_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>, offsetInPixels: foundation::Point) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayStorageFileBitmapAtPointAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, offsetInPixels, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_display_storage_file_bitmap_at_point_with_width_async(&self, bitmap: &ComPtr<super::super::storage::StorageFile>, offsetInPixels: foundation::Point, widthInPixels: i32) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryDisplayStorageFileBitmapAtPointWithWidthAsync)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, offsetInPixels, widthInPixels, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagneticStripeReader, 445820949, 18371, 18058, 147, 51, 12, 101, 23, 87, 72, 131);
RT_INTERFACE!{interface IMagneticStripeReader(IMagneticStripeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReader] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut *mut MagneticStripeReaderCapabilities) -> HRESULT,
    fn get_SupportedCardTypes(&self, outSize: *mut u32, out: *mut *mut u32) -> HRESULT,
    fn get_DeviceAuthenticationProtocol(&self, out: *mut MagneticStripeReaderAuthenticationProtocol) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ClaimReaderAsync(&self, out: *mut *mut foundation::IAsyncOperation<ClaimedMagneticStripeReader>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn RetrieveStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT,
    fn GetErrorReportingType(&self, out: *mut MagneticStripeReaderErrorReportingType) -> HRESULT,
    fn add_StatusUpdated(&self, handler: *mut foundation::TypedEventHandler<MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IMagneticStripeReader> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<ComPtr<MagneticStripeReaderCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_card_types(&self) -> Result<ComArray<u32>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCardTypes)(self.deref() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_authentication_protocol(&self) -> Result<MagneticStripeReaderAuthenticationProtocol> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DeviceAuthenticationProtocol)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckHealthAsync)(self.deref() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_reader_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedMagneticStripeReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClaimReaderAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn retrieve_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RetrieveStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_error_reporting_type(&self) -> Result<MagneticStripeReaderErrorReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetErrorReportingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<MagneticStripeReader, MagneticStripeReaderStatusUpdatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusUpdated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusUpdated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReader: IMagneticStripeReader}
impl RtActivatable<IMagneticStripeReaderStatics> for MagneticStripeReader {}
impl RtActivatable<IMagneticStripeReaderStatics2> for MagneticStripeReader {}
impl MagneticStripeReader {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<MagneticStripeReader>>> {
        <Self as RtActivatable<IMagneticStripeReaderStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<MagneticStripeReader>>> {
        <Self as RtActivatable<IMagneticStripeReaderStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMagneticStripeReaderStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IMagneticStripeReaderStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(MagneticStripeReader(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,0]) [CLSID_MagneticStripeReader]);
DEFINE_IID!(IID_IMagneticStripeReaderAamvaCardDataReceivedEventArgs, 172735825, 49942, 18704, 135, 243, 122, 98, 186, 134, 45, 49);
RT_INTERFACE!{interface IMagneticStripeReaderAamvaCardDataReceivedEventArgs(IMagneticStripeReaderAamvaCardDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderAamvaCardDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut *mut MagneticStripeReaderReport) -> HRESULT,
    fn get_LicenseNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Restrictions(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Class(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Endorsements(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BirthDate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FirstName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Surname(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Suffix(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Gender(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HairColor(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EyeColor(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Height(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Weight(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderAamvaCardDataReceivedEventArgs> {
    #[inline] pub fn get_report(&self) -> Result<Option<ComPtr<MagneticStripeReaderReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Report)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_license_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_LicenseNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ExpirationDate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_restrictions(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Restrictions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_class(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Class)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_endorsements(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Endorsements)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_birth_date(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BirthDate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_first_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FirstName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_surname(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Surname)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_suffix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Suffix)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_gender(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Gender)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_hair_color(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HairColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_eye_color(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EyeColor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Height)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_weight(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Weight)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Address)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_city(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_City)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_postal_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PostalCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderAamvaCardDataReceivedEventArgs: IMagneticStripeReaderAamvaCardDataReceivedEventArgs}
RT_ENUM! { enum MagneticStripeReaderAuthenticationLevel: i32 {
    NotSupported = 0, Optional = 1, Required = 2,
}}
RT_ENUM! { enum MagneticStripeReaderAuthenticationProtocol: i32 {
    None = 0, ChallengeResponse = 1,
}}
DEFINE_IID!(IID_IMagneticStripeReaderBankCardDataReceivedEventArgs, 781551651, 41754, 18275, 136, 44, 35, 114, 94, 57, 176, 142);
RT_INTERFACE!{interface IMagneticStripeReaderBankCardDataReceivedEventArgs(IMagneticStripeReaderBankCardDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderBankCardDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut *mut MagneticStripeReaderReport) -> HRESULT,
    fn get_AccountNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceCode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FirstName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MiddleInitial(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Surname(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Suffix(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderBankCardDataReceivedEventArgs> {
    #[inline] pub fn get_report(&self) -> Result<Option<ComPtr<MagneticStripeReaderReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Report)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_account_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AccountNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_expiration_date(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ExpirationDate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_code(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_title(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Title)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_first_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FirstName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_middle_initial(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MiddleInitial)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_surname(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Surname)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_suffix(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Suffix)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderBankCardDataReceivedEventArgs: IMagneticStripeReaderBankCardDataReceivedEventArgs}
DEFINE_IID!(IID_IMagneticStripeReaderCapabilities, 1898479772, 50240, 17570, 164, 103, 70, 145, 117, 208, 40, 150);
RT_INTERFACE!{interface IMagneticStripeReaderCapabilities(IMagneticStripeReaderCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderCapabilities] {
    fn get_CardAuthentication(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedEncryptionAlgorithms(&self, out: *mut u32) -> HRESULT,
    fn get_AuthenticationLevel(&self, out: *mut MagneticStripeReaderAuthenticationLevel) -> HRESULT,
    fn get_IsIsoSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsJisOneSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsJisTwoSupported(&self, out: *mut bool) -> HRESULT,
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsTrackDataMaskingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsTransmitSentinelsSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderCapabilities> {
    #[inline] pub fn get_card_authentication(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CardAuthentication)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_encryption_algorithms(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SupportedEncryptionAlgorithms)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_authentication_level(&self) -> Result<MagneticStripeReaderAuthenticationLevel> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AuthenticationLevel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_iso_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsIsoSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_jis_one_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsJisOneSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_jis_two_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsJisTwoSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerReportingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsReportingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsUpdatingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_track_data_masking_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsTrackDataMaskingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_transmit_sentinels_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsTransmitSentinelsSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderCapabilities: IMagneticStripeReaderCapabilities}
RT_CLASS!{static class MagneticStripeReaderCardTypes}
impl RtActivatable<IMagneticStripeReaderCardTypesStatics> for MagneticStripeReaderCardTypes {}
impl MagneticStripeReaderCardTypes {
    #[inline] pub fn get_unknown() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_unknown()
    }
    #[inline] pub fn get_bank() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_bank()
    }
    #[inline] pub fn get_aamva() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_aamva()
    }
    #[inline] pub fn get_extended_base() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderCardTypesStatics>>::get_activation_factory().get_extended_base()
    }
}
DEFINE_CLSID!(MagneticStripeReaderCardTypes(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,67,97,114,100,84,121,112,101,115,0]) [CLSID_MagneticStripeReaderCardTypes]);
DEFINE_IID!(IID_IMagneticStripeReaderCardTypesStatics, 1385114717, 10630, 18255, 132, 84, 124, 205, 5, 146, 141, 95);
RT_INTERFACE!{static interface IMagneticStripeReaderCardTypesStatics(IMagneticStripeReaderCardTypesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderCardTypesStatics] {
    fn get_Unknown(&self, out: *mut u32) -> HRESULT,
    fn get_Bank(&self, out: *mut u32) -> HRESULT,
    fn get_Aamva(&self, out: *mut u32) -> HRESULT,
    fn get_ExtendedBase(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderCardTypesStatics> {
    #[inline] pub fn get_unknown(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Unknown)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bank(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Bank)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_aamva(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Aamva)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_base(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedBase)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{static class MagneticStripeReaderEncryptionAlgorithms}
impl RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics> for MagneticStripeReaderEncryptionAlgorithms {}
impl MagneticStripeReaderEncryptionAlgorithms {
    #[inline] pub fn get_none() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics>>::get_activation_factory().get_none()
    }
    #[inline] pub fn get_triple_des_dukpt() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics>>::get_activation_factory().get_triple_des_dukpt()
    }
    #[inline] pub fn get_extended_base() -> Result<u32> {
        <Self as RtActivatable<IMagneticStripeReaderEncryptionAlgorithmsStatics>>::get_activation_factory().get_extended_base()
    }
}
DEFINE_CLSID!(MagneticStripeReaderEncryptionAlgorithms(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,77,97,103,110,101,116,105,99,83,116,114,105,112,101,82,101,97,100,101,114,69,110,99,114,121,112,116,105,111,110,65,108,103,111,114,105,116,104,109,115,0]) [CLSID_MagneticStripeReaderEncryptionAlgorithms]);
DEFINE_IID!(IID_IMagneticStripeReaderEncryptionAlgorithmsStatics, 1404400464, 50139, 18260, 156, 0, 65, 57, 35, 116, 161, 9);
RT_INTERFACE!{static interface IMagneticStripeReaderEncryptionAlgorithmsStatics(IMagneticStripeReaderEncryptionAlgorithmsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderEncryptionAlgorithmsStatics] {
    fn get_None(&self, out: *mut u32) -> HRESULT,
    fn get_TripleDesDukpt(&self, out: *mut u32) -> HRESULT,
    fn get_ExtendedBase(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderEncryptionAlgorithmsStatics> {
    #[inline] pub fn get_none(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_None)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_triple_des_dukpt(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TripleDesDukpt)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_base(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedBase)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagneticStripeReaderErrorOccurredEventArgs, 535689565, 11396, 16813, 183, 120, 242, 53, 106, 120, 154, 177);
RT_INTERFACE!{interface IMagneticStripeReaderErrorOccurredEventArgs(IMagneticStripeReaderErrorOccurredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderErrorOccurredEventArgs] {
    fn get_Track1Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_Track2Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_Track3Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_Track4Status(&self, out: *mut MagneticStripeReaderTrackErrorType) -> HRESULT,
    fn get_ErrorData(&self, out: *mut *mut UnifiedPosErrorData) -> HRESULT,
    fn get_PartialInputData(&self, out: *mut *mut MagneticStripeReaderReport) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderErrorOccurredEventArgs> {
    #[inline] pub fn get_track1_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Track1Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track2_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Track2Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track3_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Track3Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track4_status(&self) -> Result<MagneticStripeReaderTrackErrorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Track4Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_data(&self) -> Result<Option<ComPtr<UnifiedPosErrorData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ErrorData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_partial_input_data(&self) -> Result<Option<ComPtr<MagneticStripeReaderReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PartialInputData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderErrorOccurredEventArgs: IMagneticStripeReaderErrorOccurredEventArgs}
RT_ENUM! { enum MagneticStripeReaderErrorReportingType: i32 {
    CardLevel = 0, TrackLevel = 1,
}}
DEFINE_IID!(IID_IMagneticStripeReaderReport, 1784373319, 39344, 16776, 190, 241, 237, 223, 121, 247, 143, 230);
RT_INTERFACE!{interface IMagneticStripeReaderReport(IMagneticStripeReaderReportVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderReport] {
    fn get_CardType(&self, out: *mut u32) -> HRESULT,
    fn get_Track1(&self, out: *mut *mut MagneticStripeReaderTrackData) -> HRESULT,
    fn get_Track2(&self, out: *mut *mut MagneticStripeReaderTrackData) -> HRESULT,
    fn get_Track3(&self, out: *mut *mut MagneticStripeReaderTrackData) -> HRESULT,
    fn get_Track4(&self, out: *mut *mut MagneticStripeReaderTrackData) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, HString>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_CardAuthenticationData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_CardAuthenticationDataLength(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AdditionalSecurityInformation(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderReport> {
    #[inline] pub fn get_card_type(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CardType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_track1(&self) -> Result<Option<ComPtr<MagneticStripeReaderTrackData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Track1)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track2(&self) -> Result<Option<ComPtr<MagneticStripeReaderTrackData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Track2)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track3(&self) -> Result<Option<ComPtr<MagneticStripeReaderTrackData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Track3)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_track4(&self) -> Result<Option<ComPtr<MagneticStripeReaderTrackData>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Track4)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_card_authentication_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CardAuthenticationData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_card_authentication_data_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CardAuthenticationDataLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_additional_security_information(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AdditionalSecurityInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderReport: IMagneticStripeReaderReport}
DEFINE_IID!(IID_IMagneticStripeReaderStatics, 3294604106, 61399, 18272, 165, 206, 21, 176, 228, 126, 148, 235);
RT_INTERFACE!{static interface IMagneticStripeReaderStatics(IMagneticStripeReaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<MagneticStripeReader>) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<MagneticStripeReader>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<MagneticStripeReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<MagneticStripeReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagneticStripeReaderStatics2, 2360197986, 54887, 18682, 134, 188, 245, 174, 17, 137, 38, 43);
RT_INTERFACE!{static interface IMagneticStripeReaderStatics2(IMagneticStripeReaderStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderStatics2> {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.deref() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum MagneticStripeReaderStatus: i32 {
    Unauthenticated = 0, Authenticated = 1, Extended = 2,
}}
DEFINE_IID!(IID_IMagneticStripeReaderStatusUpdatedEventArgs, 164391856, 12898, 16413, 158, 138, 232, 13, 99, 88, 144, 107);
RT_INTERFACE!{interface IMagneticStripeReaderStatusUpdatedEventArgs(IMagneticStripeReaderStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut MagneticStripeReaderStatus) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderStatusUpdatedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<MagneticStripeReaderStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderStatusUpdatedEventArgs: IMagneticStripeReaderStatusUpdatedEventArgs}
DEFINE_IID!(IID_IMagneticStripeReaderTrackData, 273479281, 19101, 17518, 171, 197, 32, 64, 35, 7, 186, 54);
RT_INTERFACE!{interface IMagneticStripeReaderTrackData(IMagneticStripeReaderTrackDataVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderTrackData] {
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_DiscretionaryData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_EncryptedData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderTrackData> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Data)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_discretionary_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DiscretionaryData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_encrypted_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EncryptedData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderTrackData: IMagneticStripeReaderTrackData}
RT_ENUM! { enum MagneticStripeReaderTrackErrorType: i32 {
    None = 0, StartSentinelError = 1, EndSentinelError = 2, ParityError = 3, LrcError = 4, Unknown = -1,
}}
RT_ENUM! { enum MagneticStripeReaderTrackIds: i32 {
    None = 0, Track1 = 1, Track2 = 2, Track3 = 4, Track4 = 8,
}}
DEFINE_IID!(IID_IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, 2936689940, 22988, 19040, 153, 232, 153, 165, 61, 172, 229, 170);
RT_INTERFACE!{interface IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs] {
    fn get_Report(&self, out: *mut *mut MagneticStripeReaderReport) -> HRESULT
}}
impl ComPtr<IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs> {
    #[inline] pub fn get_report(&self) -> Result<Option<ComPtr<MagneticStripeReaderReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Report)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs: IMagneticStripeReaderVendorSpecificCardDataReceivedEventArgs}
RT_ENUM! { enum PosConnectionTypes: u32 {
    Local = 1, IP = 2, Bluetooth = 4, All = 4294967295,
}}
DEFINE_IID!(IID_IPosPrinter, 704889102, 39449, 18945, 153, 79, 18, 223, 173, 106, 220, 191);
RT_INTERFACE!{interface IPosPrinter(IPosPrinterVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinter] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Capabilities(&self, out: *mut *mut PosPrinterCapabilities) -> HRESULT,
    fn get_SupportedCharacterSets(&self, out: *mut *mut foundation::collections::IVectorView<u32>) -> HRESULT,
    fn get_SupportedTypeFaces(&self, out: *mut *mut foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_Status(&self, out: *mut *mut PosPrinterStatus) -> HRESULT,
    fn ClaimPrinterAsync(&self, out: *mut *mut foundation::IAsyncOperation<ClaimedPosPrinter>) -> HRESULT,
    fn CheckHealthAsync(&self, level: UnifiedPosHealthCheckLevel, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetStatisticsAsync(&self, statisticsCategories: *mut foundation::collections::IIterable<HString>, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn add_StatusUpdated(&self, handler: *mut foundation::TypedEventHandler<PosPrinter, PosPrinterStatusUpdatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IPosPrinter> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<Option<ComPtr<PosPrinterCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_character_sets(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCharacterSets)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_type_faces(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedTypeFaces)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<Option<ComPtr<PosPrinterStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn claim_printer_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ClaimedPosPrinter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClaimPrinterAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn check_health_async(&self, level: UnifiedPosHealthCheckLevel) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CheckHealthAsync)(self.deref() as *const _ as *mut _, level, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_statistics_async(&self, statisticsCategories: &ComPtr<foundation::collections::IIterable<HString>>) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetStatisticsAsync)(self.deref() as *const _ as *mut _, statisticsCategories.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_status_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<PosPrinter, PosPrinterStatusUpdatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusUpdated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusUpdated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinter: IPosPrinter}
impl RtActivatable<IPosPrinterStatics> for PosPrinter {}
impl RtActivatable<IPosPrinterStatics2> for PosPrinter {}
impl PosPrinter {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<PosPrinter>>> {
        <Self as RtActivatable<IPosPrinterStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PosPrinter>>> {
        <Self as RtActivatable<IPosPrinterStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPosPrinterStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_connection_types(connectionTypes: PosConnectionTypes) -> Result<HString> {
        <Self as RtActivatable<IPosPrinterStatics2>>::get_activation_factory().get_device_selector_with_connection_types(connectionTypes)
    }
}
DEFINE_CLSID!(PosPrinter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,111,115,80,114,105,110,116,101,114,0]) [CLSID_PosPrinter]);
RT_ENUM! { enum PosPrinterAlignment: i32 {
    Left = 0, Center = 1, Right = 2,
}}
RT_ENUM! { enum PosPrinterBarcodeTextPosition: i32 {
    None = 0, Above = 1, Below = 2,
}}
DEFINE_IID!(IID_IPosPrinterCapabilities, 3454621473, 17280, 18821, 173, 197, 57, 219, 48, 205, 147, 188);
RT_INTERFACE!{interface IPosPrinterCapabilities(IPosPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterCapabilities] {
    fn get_PowerReportingType(&self, out: *mut UnifiedPosPowerReportingType) -> HRESULT,
    fn get_IsStatisticsReportingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsStatisticsUpdatingSupported(&self, out: *mut bool) -> HRESULT,
    fn get_DefaultCharacterSet(&self, out: *mut u32) -> HRESULT,
    fn get_HasCoverSensor(&self, out: *mut bool) -> HRESULT,
    fn get_CanMapCharacterSet(&self, out: *mut bool) -> HRESULT,
    fn get_IsTransactionSupported(&self, out: *mut bool) -> HRESULT,
    fn get_Receipt(&self, out: *mut *mut ReceiptPrinterCapabilities) -> HRESULT,
    fn get_Slip(&self, out: *mut *mut SlipPrinterCapabilities) -> HRESULT,
    fn get_Journal(&self, out: *mut *mut JournalPrinterCapabilities) -> HRESULT
}}
impl ComPtr<IPosPrinterCapabilities> {
    #[inline] pub fn get_power_reporting_type(&self) -> Result<UnifiedPosPowerReportingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerReportingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_reporting_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsReportingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_statistics_updating_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStatisticsUpdatingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_character_set(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DefaultCharacterSet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_has_cover_sensor(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HasCoverSensor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_can_map_character_set(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanMapCharacterSet)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_transaction_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsTransactionSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_receipt(&self) -> Result<Option<ComPtr<ReceiptPrinterCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Receipt)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_slip(&self) -> Result<Option<ComPtr<SlipPrinterCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Slip)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_journal(&self) -> Result<Option<ComPtr<JournalPrinterCapabilities>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Journal)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinterCapabilities: IPosPrinterCapabilities}
RT_ENUM! { enum PosPrinterCartridgeSensors: u32 {
    None = 0, Removed = 1, Empty = 2, HeadCleaning = 4, NearEnd = 8,
}}
RT_CLASS!{static class PosPrinterCharacterSetIds}
impl RtActivatable<IPosPrinterCharacterSetIdsStatics> for PosPrinterCharacterSetIds {}
impl PosPrinterCharacterSetIds {
    #[inline] pub fn get_utf16le() -> Result<u32> {
        <Self as RtActivatable<IPosPrinterCharacterSetIdsStatics>>::get_activation_factory().get_utf16le()
    }
    #[inline] pub fn get_ascii() -> Result<u32> {
        <Self as RtActivatable<IPosPrinterCharacterSetIdsStatics>>::get_activation_factory().get_ascii()
    }
    #[inline] pub fn get_ansi() -> Result<u32> {
        <Self as RtActivatable<IPosPrinterCharacterSetIdsStatics>>::get_activation_factory().get_ansi()
    }
}
DEFINE_CLSID!(PosPrinterCharacterSetIds(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,111,115,80,114,105,110,116,101,114,67,104,97,114,97,99,116,101,114,83,101,116,73,100,115,0]) [CLSID_PosPrinterCharacterSetIds]);
DEFINE_IID!(IID_IPosPrinterCharacterSetIdsStatics, 1550884607, 28826, 20455, 178, 21, 6, 167, 72, 163, 139, 57);
RT_INTERFACE!{static interface IPosPrinterCharacterSetIdsStatics(IPosPrinterCharacterSetIdsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterCharacterSetIdsStatics] {
    fn get_Utf16LE(&self, out: *mut u32) -> HRESULT,
    fn get_Ascii(&self, out: *mut u32) -> HRESULT,
    fn get_Ansi(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IPosPrinterCharacterSetIdsStatics> {
    #[inline] pub fn get_utf16le(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Utf16LE)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ascii(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ascii)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ansi(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Ansi)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum PosPrinterColorCapabilities: u32 {
    None = 0, Primary = 1, Custom1 = 2, Custom2 = 4, Custom3 = 8, Custom4 = 16, Custom5 = 32, Custom6 = 64, Cyan = 128, Magenta = 256, Yellow = 512, Full = 1024,
}}
RT_ENUM! { enum PosPrinterColorCartridge: i32 {
    Unknown = 0, Primary = 1, Custom1 = 2, Custom2 = 3, Custom3 = 4, Custom4 = 5, Custom5 = 6, Custom6 = 7, Cyan = 8, Magenta = 9, Yellow = 10,
}}
DEFINE_IID!(IID_IPosPrinterJob, 2593390684, 1557, 17809, 165, 143, 48, 248, 126, 223, 226, 228);
RT_INTERFACE!{interface IPosPrinterJob(IPosPrinterJobVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterJob] {
    fn Print(&self, data: HSTRING) -> HRESULT,
    fn PrintLine(&self, data: HSTRING) -> HRESULT,
    fn PrintNewline(&self) -> HRESULT,
    fn ExecuteAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<IPosPrinterJob> {
    #[inline] pub fn print(&self, data: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Print)(self.deref() as *const _ as *mut _, data.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_line(&self, data: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintLine)(self.deref() as *const _ as *mut _, data.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_newline(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintNewline)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn execute_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ExecuteAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PosPrinterLineDirection: i32 {
    Horizontal = 0, Vertical = 1,
}}
RT_ENUM! { enum PosPrinterLineStyle: i32 {
    SingleSolid = 0, DoubleSolid = 1, Broken = 2, Chain = 3,
}}
RT_ENUM! { enum PosPrinterMapMode: i32 {
    Dots = 0, Twips = 1, English = 2, Metric = 3,
}}
RT_ENUM! { enum PosPrinterMarkFeedCapabilities: u32 {
    None = 0, ToTakeUp = 1, ToCutter = 2, ToCurrentTopOfForm = 4, ToNextTopOfForm = 8,
}}
RT_ENUM! { enum PosPrinterMarkFeedKind: i32 {
    ToTakeUp = 0, ToCutter = 1, ToCurrentTopOfForm = 2, ToNextTopOfForm = 3,
}}
RT_ENUM! { enum PosPrinterPrintSide: i32 {
    Unknown = 0, Side1 = 1, Side2 = 2,
}}
DEFINE_IID!(IID_IPosPrinterReleaseDeviceRequestedEventArgs, 734765913, 7407, 16562, 158, 203, 249, 39, 248, 86, 174, 60);
RT_INTERFACE!{interface IPosPrinterReleaseDeviceRequestedEventArgs(IPosPrinterReleaseDeviceRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterReleaseDeviceRequestedEventArgs] {
    
}}
RT_CLASS!{class PosPrinterReleaseDeviceRequestedEventArgs: IPosPrinterReleaseDeviceRequestedEventArgs}
RT_ENUM! { enum PosPrinterRotation: i32 {
    Normal = 0, Right90 = 1, Left90 = 2, Rotate180 = 3,
}}
RT_ENUM! { enum PosPrinterRuledLineCapabilities: u32 {
    None = 0, Horizontal = 1, Vertical = 2,
}}
DEFINE_IID!(IID_IPosPrinterStatics, 2363544810, 4911, 19679, 166, 74, 45, 13, 124, 150, 168, 91);
RT_INTERFACE!{static interface IPosPrinterStatics(IPosPrinterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<PosPrinter>) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<PosPrinter>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPosPrinterStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<PosPrinter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PosPrinter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPosPrinterStatics2, 4006423580, 45264, 17127, 177, 55, 184, 155, 22, 36, 77, 65);
RT_INTERFACE!{static interface IPosPrinterStatics2(IPosPrinterStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatics2] {
    fn GetDeviceSelectorWithConnectionTypes(&self, connectionTypes: PosConnectionTypes, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPosPrinterStatics2> {
    #[inline] pub fn get_device_selector_with_connection_types(&self, connectionTypes: PosConnectionTypes) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithConnectionTypes)(self.deref() as *const _ as *mut _, connectionTypes, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPosPrinterStatus, 3522217776, 55872, 17192, 191, 118, 81, 86, 250, 51, 183, 71);
RT_INTERFACE!{interface IPosPrinterStatus(IPosPrinterStatusVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatus] {
    fn get_StatusKind(&self, out: *mut PosPrinterStatusKind) -> HRESULT,
    fn get_ExtendedStatus(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IPosPrinterStatus> {
    #[inline] pub fn get_status_kind(&self) -> Result<PosPrinterStatusKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StatusKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_status(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinterStatus: IPosPrinterStatus}
RT_ENUM! { enum PosPrinterStatusKind: i32 {
    Online = 0, Off = 1, Offline = 2, OffOrOffline = 3, Extended = 4,
}}
DEFINE_IID!(IID_IPosPrinterStatusUpdatedEventArgs, 786139103, 5030, 17037, 186, 129, 176, 231, 195, 229, 163, 205);
RT_INTERFACE!{interface IPosPrinterStatusUpdatedEventArgs(IPosPrinterStatusUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPosPrinterStatusUpdatedEventArgs] {
    fn get_Status(&self, out: *mut *mut PosPrinterStatus) -> HRESULT
}}
impl ComPtr<IPosPrinterStatusUpdatedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<Option<ComPtr<PosPrinterStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PosPrinterStatusUpdatedEventArgs: IPosPrinterStatusUpdatedEventArgs}
DEFINE_IID!(IID_IReceiptOrSlipJob, 1394710974, 51395, 19906, 137, 233, 92, 74, 55, 179, 77, 220);
RT_INTERFACE!{interface IReceiptOrSlipJob(IReceiptOrSlipJobVtbl): IInspectable(IInspectableVtbl) [IID_IReceiptOrSlipJob] {
    fn SetBarcodeRotation(&self, value: PosPrinterRotation) -> HRESULT,
    fn SetPrintRotation(&self, value: PosPrinterRotation, includeBitmaps: bool) -> HRESULT,
    fn SetPrintArea(&self, value: foundation::Rect) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetBitmap(&self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetBitmapCustomWidthStandardAlign(&self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetCustomAlignedBitmap(&self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetBitmapCustomWidthCustomAlign(&self, bitmapNumber: u32, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> HRESULT,
    fn PrintSavedBitmap(&self, bitmapNumber: u32) -> HRESULT,
    fn DrawRuledLine(&self, positionList: HSTRING, lineDirection: PosPrinterLineDirection, lineWidth: u32, lineStyle: PosPrinterLineStyle, lineColor: u32) -> HRESULT,
    fn PrintBarcode(&self, data: HSTRING, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment) -> HRESULT,
    fn PrintBarcodeCustomAlign(&self, data: HSTRING, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignmentDistance: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintBitmap(&self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintBitmapCustomWidthStandardAlign(&self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignment: PosPrinterAlignment, width: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintCustomAlignedBitmap(&self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn PrintBitmapCustomWidthCustomAlign(&self, bitmap: *mut super::super::graphics::imaging::BitmapFrame, alignmentDistance: u32, width: u32) -> HRESULT
}}
impl ComPtr<IReceiptOrSlipJob> {
    #[inline] pub fn set_barcode_rotation(&self, value: PosPrinterRotation) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetBarcodeRotation)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_print_rotation(&self, value: PosPrinterRotation, includeBitmaps: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetPrintRotation)(self.deref() as *const _ as *mut _, value, includeBitmaps);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_print_area(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetPrintArea)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap(&self, bitmapNumber: u32, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignment: PosPrinterAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetBitmap)(self.deref() as *const _ as *mut _, bitmapNumber, bitmap.deref() as *const _ as *mut _, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap_custom_width_standard_align(&self, bitmapNumber: u32, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignment: PosPrinterAlignment, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetBitmapCustomWidthStandardAlign)(self.deref() as *const _ as *mut _, bitmapNumber, bitmap.deref() as *const _ as *mut _, alignment, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_custom_aligned_bitmap(&self, bitmapNumber: u32, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignmentDistance: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetCustomAlignedBitmap)(self.deref() as *const _ as *mut _, bitmapNumber, bitmap.deref() as *const _ as *mut _, alignmentDistance);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_bitmap_custom_width_custom_align(&self, bitmapNumber: u32, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignmentDistance: u32, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetBitmapCustomWidthCustomAlign)(self.deref() as *const _ as *mut _, bitmapNumber, bitmap.deref() as *const _ as *mut _, alignmentDistance, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_saved_bitmap(&self, bitmapNumber: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintSavedBitmap)(self.deref() as *const _ as *mut _, bitmapNumber);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn draw_ruled_line(&self, positionList: &HStringArg, lineDirection: PosPrinterLineDirection, lineWidth: u32, lineStyle: PosPrinterLineStyle, lineColor: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).DrawRuledLine)(self.deref() as *const _ as *mut _, positionList.get(), lineDirection, lineWidth, lineStyle, lineColor);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_barcode(&self, data: &HStringArg, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignment: PosPrinterAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintBarcode)(self.deref() as *const _ as *mut _, data.get(), symbology, height, width, textPosition, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn print_barcode_custom_align(&self, data: &HStringArg, symbology: u32, height: u32, width: u32, textPosition: PosPrinterBarcodeTextPosition, alignmentDistance: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintBarcodeCustomAlign)(self.deref() as *const _ as *mut _, data.get(), symbology, height, width, textPosition, alignmentDistance);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_bitmap(&self, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignment: PosPrinterAlignment) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintBitmap)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, alignment);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_bitmap_custom_width_standard_align(&self, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignment: PosPrinterAlignment, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintBitmapCustomWidthStandardAlign)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, alignment, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_custom_aligned_bitmap(&self, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignmentDistance: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintCustomAlignedBitmap)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, alignmentDistance);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn print_bitmap_custom_width_custom_align(&self, bitmap: &ComPtr<super::super::graphics::imaging::BitmapFrame>, alignmentDistance: u32, width: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).PrintBitmapCustomWidthCustomAlign)(self.deref() as *const _ as *mut _, bitmap.deref() as *const _ as *mut _, alignmentDistance, width);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IReceiptPrinterCapabilities, 3102782863, 20904, 17404, 155, 213, 141, 226, 114, 166, 65, 91);
RT_INTERFACE!{interface IReceiptPrinterCapabilities(IReceiptPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IReceiptPrinterCapabilities] {
    fn get_CanCutPaper(&self, out: *mut bool) -> HRESULT,
    fn get_IsStampSupported(&self, out: *mut bool) -> HRESULT,
    fn get_MarkFeedCapabilities(&self, out: *mut PosPrinterMarkFeedCapabilities) -> HRESULT
}}
impl ComPtr<IReceiptPrinterCapabilities> {
    #[inline] pub fn get_can_cut_paper(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanCutPaper)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_stamp_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStampSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_mark_feed_capabilities(&self) -> Result<PosPrinterMarkFeedCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MarkFeedCapabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ReceiptPrinterCapabilities: IReceiptPrinterCapabilities}
DEFINE_IID!(IID_IReceiptPrintJob, 2861958766, 44205, 19321, 157, 15, 192, 207, 192, 141, 199, 123);
RT_INTERFACE!{interface IReceiptPrintJob(IReceiptPrintJobVtbl): IInspectable(IInspectableVtbl) [IID_IReceiptPrintJob] {
    fn MarkFeed(&self, kind: PosPrinterMarkFeedKind) -> HRESULT,
    fn CutPaper(&self, percentage: f64) -> HRESULT,
    fn CutPaperDefault(&self) -> HRESULT
}}
impl ComPtr<IReceiptPrintJob> {
    #[inline] pub fn mark_feed(&self, kind: PosPrinterMarkFeedKind) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).MarkFeed)(self.deref() as *const _ as *mut _, kind);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cut_paper(&self, percentage: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).CutPaper)(self.deref() as *const _ as *mut _, percentage);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn cut_paper_default(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).CutPaperDefault)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ReceiptPrintJob: IReceiptPrintJob}
DEFINE_IID!(IID_ISlipPrinterCapabilities, 2578539417, 18572, 16727, 138, 194, 159, 87, 247, 8, 211, 219);
RT_INTERFACE!{interface ISlipPrinterCapabilities(ISlipPrinterCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_ISlipPrinterCapabilities] {
    fn get_IsFullLengthSupported(&self, out: *mut bool) -> HRESULT,
    fn get_IsBothSidesPrintingSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ISlipPrinterCapabilities> {
    #[inline] pub fn get_is_full_length_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsFullLengthSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_both_sides_printing_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsBothSidesPrintingSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SlipPrinterCapabilities: ISlipPrinterCapabilities}
RT_CLASS!{class SlipPrintJob: IReceiptOrSlipJob}
DEFINE_IID!(IID_IUnifiedPosErrorData, 731483194, 21852, 18569, 142, 216, 197, 153, 187, 58, 113, 42);
RT_INTERFACE!{interface IUnifiedPosErrorData(IUnifiedPosErrorDataVtbl): IInspectable(IInspectableVtbl) [IID_IUnifiedPosErrorData] {
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Severity(&self, out: *mut UnifiedPosErrorSeverity) -> HRESULT,
    fn get_Reason(&self, out: *mut UnifiedPosErrorReason) -> HRESULT,
    fn get_ExtendedReason(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IUnifiedPosErrorData> {
    #[inline] pub fn get_message(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Message)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_severity(&self) -> Result<UnifiedPosErrorSeverity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Severity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reason(&self) -> Result<UnifiedPosErrorReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Reason)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_extended_reason(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ExtendedReason)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UnifiedPosErrorData: IUnifiedPosErrorData}
impl RtActivatable<IUnifiedPosErrorDataFactory> for UnifiedPosErrorData {}
impl UnifiedPosErrorData {
    #[inline] pub fn create_instance(message: &HStringArg, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extendedReason: u32) -> Result<ComPtr<UnifiedPosErrorData>> {
        <Self as RtActivatable<IUnifiedPosErrorDataFactory>>::get_activation_factory().create_instance(message, severity, reason, extendedReason)
    }
}
DEFINE_CLSID!(UnifiedPosErrorData(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,85,110,105,102,105,101,100,80,111,115,69,114,114,111,114,68,97,116,97,0]) [CLSID_UnifiedPosErrorData]);
DEFINE_IID!(IID_IUnifiedPosErrorDataFactory, 1268262225, 8190, 17691, 163, 104, 99, 224, 206, 70, 95, 90);
RT_INTERFACE!{static interface IUnifiedPosErrorDataFactory(IUnifiedPosErrorDataFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUnifiedPosErrorDataFactory] {
    fn CreateInstance(&self, message: HSTRING, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extendedReason: u32, out: *mut *mut UnifiedPosErrorData) -> HRESULT
}}
impl ComPtr<IUnifiedPosErrorDataFactory> {
    #[inline] pub fn create_instance(&self, message: &HStringArg, severity: UnifiedPosErrorSeverity, reason: UnifiedPosErrorReason, extendedReason: u32) -> Result<ComPtr<UnifiedPosErrorData>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateInstance)(self.deref() as *const _ as *mut _, message.get(), severity, reason, extendedReason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UnifiedPosErrorReason: i32 {
    UnknownErrorReason = 0, NoService = 1, Disabled = 2, Illegal = 3, NoHardware = 4, Closed = 5, Offline = 6, Failure = 7, Timeout = 8, Busy = 9, Extended = 10,
}}
RT_ENUM! { enum UnifiedPosErrorSeverity: i32 {
    UnknownErrorSeverity = 0, Warning = 1, Recoverable = 2, Unrecoverable = 3, AssistanceRequired = 4, Fatal = 5,
}}
RT_ENUM! { enum UnifiedPosHealthCheckLevel: i32 {
    UnknownHealthCheckLevel = 0, POSInternal = 1, External = 2, Interactive = 3,
}}
RT_ENUM! { enum UnifiedPosPowerReportingType: i32 {
    UnknownPowerReportingType = 0, Standard = 1, Advanced = 2,
}}
pub mod provider { // Windows.Devices.PointOfService.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IBarcodeScannerDisableScannerRequest, 2297231296, 14265, 17013, 142, 119, 200, 229, 42, 229, 169, 200);
RT_INTERFACE!{interface IBarcodeScannerDisableScannerRequest(IBarcodeScannerDisableScannerRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDisableScannerRequest] {
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerDisableScannerRequest> {
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerDisableScannerRequest: IBarcodeScannerDisableScannerRequest}
DEFINE_IID!(IID_IBarcodeScannerDisableScannerRequest2, 3437225509, 26051, 19660, 180, 87, 243, 156, 122, 158, 166, 13);
RT_INTERFACE!{interface IBarcodeScannerDisableScannerRequest2(IBarcodeScannerDisableScannerRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDisableScannerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerDisableScannerRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerDisableScannerRequestEventArgs, 1879499074, 59394, 18165, 182, 4, 53, 42, 21, 206, 146, 50);
RT_INTERFACE!{interface IBarcodeScannerDisableScannerRequestEventArgs(IBarcodeScannerDisableScannerRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerDisableScannerRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerDisableScannerRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerDisableScannerRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerDisableScannerRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerDisableScannerRequestEventArgs: IBarcodeScannerDisableScannerRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerEnableScannerRequest, 3233016250, 33130, 17707, 189, 119, 183, 228, 83, 236, 68, 109);
RT_INTERFACE!{interface IBarcodeScannerEnableScannerRequest(IBarcodeScannerEnableScannerRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerEnableScannerRequest] {
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerEnableScannerRequest> {
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerEnableScannerRequest: IBarcodeScannerEnableScannerRequest}
DEFINE_IID!(IID_IBarcodeScannerEnableScannerRequest2, 1906635432, 39173, 16812, 145, 33, 182, 69, 145, 106, 132, 161);
RT_INTERFACE!{interface IBarcodeScannerEnableScannerRequest2(IBarcodeScannerEnableScannerRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerEnableScannerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerEnableScannerRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerEnableScannerRequestEventArgs, 2506920985, 31566, 17489, 140, 65, 142, 16, 207, 188, 91, 65);
RT_INTERFACE!{interface IBarcodeScannerEnableScannerRequestEventArgs(IBarcodeScannerEnableScannerRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerEnableScannerRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerEnableScannerRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerEnableScannerRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerEnableScannerRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerEnableScannerRequestEventArgs: IBarcodeScannerEnableScannerRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerFrameReader, 3687262983, 25795, 18475, 147, 200, 101, 251, 51, 194, 34, 8);
RT_INTERFACE!{interface IBarcodeScannerFrameReader(IBarcodeScannerFrameReaderVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerFrameReader] {
    fn StartAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn StopAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn TryAcquireLatestFrameAsync(&self, out: *mut *mut foundation::IAsyncOperation<BarcodeScannerVideoFrame>) -> HRESULT,
    fn get_Connection(&self, out: *mut *mut BarcodeScannerProviderConnection) -> HRESULT,
    fn add_FrameArrived(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerFrameReader, BarcodeScannerFrameReaderFrameArrivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_FrameArrived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBarcodeScannerFrameReader> {
    #[inline] pub fn start_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).StartAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn stop_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).StopAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_acquire_latest_frame_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScannerVideoFrame>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryAcquireLatestFrameAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection(&self) -> Result<Option<ComPtr<BarcodeScannerProviderConnection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Connection)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_frame_arrived(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerFrameReader, BarcodeScannerFrameReaderFrameArrivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_FrameArrived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_frame_arrived(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_FrameArrived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerFrameReader: IBarcodeScannerFrameReader}
DEFINE_IID!(IID_IBarcodeScannerFrameReaderFrameArrivedEventArgs, 2965100036, 21757, 17261, 134, 41, 113, 46, 120, 114, 35, 221);
RT_INTERFACE!{interface IBarcodeScannerFrameReaderFrameArrivedEventArgs(IBarcodeScannerFrameReaderFrameArrivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerFrameReaderFrameArrivedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerFrameReaderFrameArrivedEventArgs> {
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerFrameReaderFrameArrivedEventArgs: IBarcodeScannerFrameReaderFrameArrivedEventArgs}
DEFINE_IID!(IID_IBarcodeScannerGetSymbologyAttributesRequest, 2541012074, 22756, 19551, 184, 233, 228, 20, 103, 99, 39, 0);
RT_INTERFACE!{interface IBarcodeScannerGetSymbologyAttributesRequest(IBarcodeScannerGetSymbologyAttributesRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerGetSymbologyAttributesRequest] {
    fn get_Symbology(&self, out: *mut u32) -> HRESULT,
    fn ReportCompletedAsync(&self, attributes: *mut super::BarcodeSymbologyAttributes, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerGetSymbologyAttributesRequest> {
    #[inline] pub fn get_symbology(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Symbology)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self, attributes: &ComPtr<super::BarcodeSymbologyAttributes>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, attributes.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerGetSymbologyAttributesRequest: IBarcodeScannerGetSymbologyAttributesRequest}
DEFINE_IID!(IID_IBarcodeScannerGetSymbologyAttributesRequest2, 1785342739, 30120, 18939, 184, 82, 191, 185, 61, 118, 10, 247);
RT_INTERFACE!{interface IBarcodeScannerGetSymbologyAttributesRequest2(IBarcodeScannerGetSymbologyAttributesRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerGetSymbologyAttributesRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerGetSymbologyAttributesRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerGetSymbologyAttributesRequestEventArgs, 2139741758, 64349, 18748, 180, 2, 53, 107, 36, 213, 116, 166);
RT_INTERFACE!{interface IBarcodeScannerGetSymbologyAttributesRequestEventArgs(IBarcodeScannerGetSymbologyAttributesRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerGetSymbologyAttributesRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerGetSymbologyAttributesRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerGetSymbologyAttributesRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerGetSymbologyAttributesRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerGetSymbologyAttributesRequestEventArgs: IBarcodeScannerGetSymbologyAttributesRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerHideVideoPreviewRequest, 4199464575, 26224, 16609, 185, 11, 187, 16, 216, 212, 37, 250);
RT_INTERFACE!{interface IBarcodeScannerHideVideoPreviewRequest(IBarcodeScannerHideVideoPreviewRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerHideVideoPreviewRequest] {
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerHideVideoPreviewRequest> {
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerHideVideoPreviewRequest: IBarcodeScannerHideVideoPreviewRequest}
DEFINE_IID!(IID_IBarcodeScannerHideVideoPreviewRequest2, 2116567901, 38932, 17181, 162, 242, 214, 36, 140, 90, 212, 181);
RT_INTERFACE!{interface IBarcodeScannerHideVideoPreviewRequest2(IBarcodeScannerHideVideoPreviewRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerHideVideoPreviewRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerHideVideoPreviewRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerHideVideoPreviewRequestEventArgs, 379748860, 54974, 19399, 157, 241, 51, 116, 31, 62, 173, 234);
RT_INTERFACE!{interface IBarcodeScannerHideVideoPreviewRequestEventArgs(IBarcodeScannerHideVideoPreviewRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerHideVideoPreviewRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerHideVideoPreviewRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerHideVideoPreviewRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerHideVideoPreviewRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerHideVideoPreviewRequestEventArgs: IBarcodeScannerHideVideoPreviewRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerProviderConnection, 3024800749, 2874, 20387, 134, 197, 73, 30, 163, 7, 128, 235);
RT_INTERFACE!{interface IBarcodeScannerProviderConnection(IBarcodeScannerProviderConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerProviderConnection] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedSymbologies(&self, out: *mut *mut foundation::collections::IVector<u32>) -> HRESULT,
    fn get_CompanyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyName(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Version(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Version(&self, value: HSTRING) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn ReportScannedDataAsync(&self, report: *mut super::BarcodeScannerReport, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportTriggerStateAsync(&self, state: BarcodeScannerTriggerState, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportErrorAsync(&self, errorData: *mut super::UnifiedPosErrorData, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportErrorAsyncWithScanReport(&self, errorData: *mut super::UnifiedPosErrorData, isRetriable: bool, scanReport: *mut super::BarcodeScannerReport, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn add_EnableScannerRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerEnableScannerRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnableScannerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_DisableScannerRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerDisableScannerRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DisableScannerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SetActiveSymbologiesRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetActiveSymbologiesRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SetActiveSymbologiesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StartSoftwareTriggerRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStartSoftwareTriggerRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StartSoftwareTriggerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_StopSoftwareTriggerRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStopSoftwareTriggerRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StopSoftwareTriggerRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_GetBarcodeSymbologyAttributesRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerGetSymbologyAttributesRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GetBarcodeSymbologyAttributesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SetBarcodeSymbologyAttributesRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetSymbologyAttributesRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SetBarcodeSymbologyAttributesRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_HideVideoPreviewRequested(&self, handler: *mut foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerHideVideoPreviewRequestEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HideVideoPreviewRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBarcodeScannerProviderConnection> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_video_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VideoDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_symbologies(&self) -> Result<Option<ComPtr<foundation::collections::IVector<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedSymbologies)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_company_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CompanyName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_company_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CompanyName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Name)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_version(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Version)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_version(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Version)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn report_scanned_data_async(&self, report: &ComPtr<super::BarcodeScannerReport>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportScannedDataAsync)(self.deref() as *const _ as *mut _, report.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_trigger_state_async(&self, state: BarcodeScannerTriggerState) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportTriggerStateAsync)(self.deref() as *const _ as *mut _, state, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_error_async(&self, errorData: &ComPtr<super::UnifiedPosErrorData>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportErrorAsync)(self.deref() as *const _ as *mut _, errorData.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_error_async_with_scan_report(&self, errorData: &ComPtr<super::UnifiedPosErrorData>, isRetriable: bool, scanReport: &ComPtr<super::BarcodeScannerReport>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportErrorAsyncWithScanReport)(self.deref() as *const _ as *mut _, errorData.deref() as *const _ as *mut _, isRetriable, scanReport.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_enable_scanner_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerEnableScannerRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_EnableScannerRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_enable_scanner_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_EnableScannerRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_disable_scanner_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerDisableScannerRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DisableScannerRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_disable_scanner_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DisableScannerRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_set_active_symbologies_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetActiveSymbologiesRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SetActiveSymbologiesRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_set_active_symbologies_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SetActiveSymbologiesRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_start_software_trigger_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStartSoftwareTriggerRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StartSoftwareTriggerRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_start_software_trigger_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StartSoftwareTriggerRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_stop_software_trigger_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerStopSoftwareTriggerRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StopSoftwareTriggerRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_stop_software_trigger_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StopSoftwareTriggerRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_get_barcode_symbology_attributes_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerGetSymbologyAttributesRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_GetBarcodeSymbologyAttributesRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_get_barcode_symbology_attributes_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_GetBarcodeSymbologyAttributesRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_set_barcode_symbology_attributes_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerSetSymbologyAttributesRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SetBarcodeSymbologyAttributesRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_set_barcode_symbology_attributes_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SetBarcodeSymbologyAttributesRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_hide_video_preview_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<BarcodeScannerProviderConnection, BarcodeScannerHideVideoPreviewRequestEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_HideVideoPreviewRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_hide_video_preview_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_HideVideoPreviewRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerProviderConnection: IBarcodeScannerProviderConnection}
DEFINE_IID!(IID_IBarcodeScannerProviderConnection2, 3197850573, 4404, 16780, 160, 107, 4, 66, 58, 115, 243, 215);
RT_INTERFACE!{interface IBarcodeScannerProviderConnection2(IBarcodeScannerProviderConnection2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerProviderConnection2] {
    fn CreateFrameReaderAsync(&self, out: *mut *mut foundation::IAsyncOperation<BarcodeScannerFrameReader>) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateFrameReaderWithFormatAsync(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat, out: *mut *mut foundation::IAsyncOperation<BarcodeScannerFrameReader>) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn CreateFrameReaderWithFormatAndSizeAsync(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat, preferredSize: crate::windows::graphics::imaging::BitmapSize, out: *mut *mut foundation::IAsyncOperation<BarcodeScannerFrameReader>) -> HRESULT
}}
impl ComPtr<IBarcodeScannerProviderConnection2> {
    #[inline] pub fn create_frame_reader_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScannerFrameReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFrameReaderAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_frame_reader_with_format_async(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScannerFrameReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFrameReaderWithFormatAsync)(self.deref() as *const _ as *mut _, preferredFormat, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn create_frame_reader_with_format_and_size_async(&self, preferredFormat: crate::windows::graphics::imaging::BitmapPixelFormat, preferredSize: crate::windows::graphics::imaging::BitmapSize) -> Result<ComPtr<foundation::IAsyncOperation<BarcodeScannerFrameReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFrameReaderWithFormatAndSizeAsync)(self.deref() as *const _ as *mut _, preferredFormat, preferredSize, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerProviderTriggerDetails, 1350921602, 9443, 18638, 153, 199, 112, 170, 193, 203, 201, 247);
RT_INTERFACE!{interface IBarcodeScannerProviderTriggerDetails(IBarcodeScannerProviderTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut *mut BarcodeScannerProviderConnection) -> HRESULT
}}
impl ComPtr<IBarcodeScannerProviderTriggerDetails> {
    #[inline] pub fn get_connection(&self) -> Result<Option<ComPtr<BarcodeScannerProviderConnection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Connection)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerProviderTriggerDetails: IBarcodeScannerProviderTriggerDetails}
DEFINE_IID!(IID_IBarcodeScannerSetActiveSymbologiesRequest, 3678352057, 63450, 16801, 159, 121, 7, 188, 217, 95, 11, 223);
RT_INTERFACE!{interface IBarcodeScannerSetActiveSymbologiesRequest(IBarcodeScannerSetActiveSymbologiesRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetActiveSymbologiesRequest] {
    fn get_Symbologies(&self, out: *mut *mut foundation::collections::IVectorView<u32>) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerSetActiveSymbologiesRequest> {
    #[inline] pub fn get_symbologies(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Symbologies)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetActiveSymbologiesRequest: IBarcodeScannerSetActiveSymbologiesRequest}
DEFINE_IID!(IID_IBarcodeScannerSetActiveSymbologiesRequest2, 4127157983, 64154, 18249, 177, 27, 232, 252, 203, 117, 188, 107);
RT_INTERFACE!{interface IBarcodeScannerSetActiveSymbologiesRequest2(IBarcodeScannerSetActiveSymbologiesRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetActiveSymbologiesRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerSetActiveSymbologiesRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerSetActiveSymbologiesRequestEventArgs, 103832314, 31734, 19794, 128, 26, 51, 2, 114, 246, 10, 225);
RT_INTERFACE!{interface IBarcodeScannerSetActiveSymbologiesRequestEventArgs(IBarcodeScannerSetActiveSymbologiesRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetActiveSymbologiesRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerSetActiveSymbologiesRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerSetActiveSymbologiesRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerSetActiveSymbologiesRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetActiveSymbologiesRequestEventArgs: IBarcodeScannerSetActiveSymbologiesRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerSetSymbologyAttributesRequest, 855343439, 41855, 18608, 172, 234, 220, 225, 72, 15, 18, 174);
RT_INTERFACE!{interface IBarcodeScannerSetSymbologyAttributesRequest(IBarcodeScannerSetSymbologyAttributesRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetSymbologyAttributesRequest] {
    fn get_Symbology(&self, out: *mut u32) -> HRESULT,
    fn get_Attributes(&self, out: *mut *mut super::BarcodeSymbologyAttributes) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerSetSymbologyAttributesRequest> {
    #[inline] pub fn get_symbology(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Symbology)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_attributes(&self) -> Result<Option<ComPtr<super::BarcodeSymbologyAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Attributes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetSymbologyAttributesRequest: IBarcodeScannerSetSymbologyAttributesRequest}
DEFINE_IID!(IID_IBarcodeScannerSetSymbologyAttributesRequest2, 3757817793, 56232, 19319, 190, 30, 181, 108, 215, 47, 101, 179);
RT_INTERFACE!{interface IBarcodeScannerSetSymbologyAttributesRequest2(IBarcodeScannerSetSymbologyAttributesRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetSymbologyAttributesRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerSetSymbologyAttributesRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerSetSymbologyAttributesRequestEventArgs, 2998441993, 38948, 18388, 133, 189, 208, 7, 123, 170, 123, 210);
RT_INTERFACE!{interface IBarcodeScannerSetSymbologyAttributesRequestEventArgs(IBarcodeScannerSetSymbologyAttributesRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerSetSymbologyAttributesRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerSetSymbologyAttributesRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerSetSymbologyAttributesRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerSetSymbologyAttributesRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerSetSymbologyAttributesRequestEventArgs: IBarcodeScannerSetSymbologyAttributesRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerStartSoftwareTriggerRequest, 3824843559, 65378, 17492, 175, 74, 203, 97, 68, 163, 227, 247);
RT_INTERFACE!{interface IBarcodeScannerStartSoftwareTriggerRequest(IBarcodeScannerStartSoftwareTriggerRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStartSoftwareTriggerRequest] {
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStartSoftwareTriggerRequest> {
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStartSoftwareTriggerRequest: IBarcodeScannerStartSoftwareTriggerRequest}
DEFINE_IID!(IID_IBarcodeScannerStartSoftwareTriggerRequest2, 3950158428, 26200, 18277, 166, 142, 50, 116, 130, 101, 61, 235);
RT_INTERFACE!{interface IBarcodeScannerStartSoftwareTriggerRequest2(IBarcodeScannerStartSoftwareTriggerRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStartSoftwareTriggerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStartSoftwareTriggerRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStartSoftwareTriggerRequestEventArgs, 587585603, 51343, 20283, 140, 59, 211, 223, 7, 16, 81, 236);
RT_INTERFACE!{interface IBarcodeScannerStartSoftwareTriggerRequestEventArgs(IBarcodeScannerStartSoftwareTriggerRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStartSoftwareTriggerRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerStartSoftwareTriggerRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStartSoftwareTriggerRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerStartSoftwareTriggerRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStartSoftwareTriggerRequestEventArgs: IBarcodeScannerStartSoftwareTriggerRequestEventArgs}
DEFINE_IID!(IID_IBarcodeScannerStopSoftwareTriggerRequest, 1872736053, 57991, 19624, 183, 13, 90, 145, 214, 148, 246, 104);
RT_INTERFACE!{interface IBarcodeScannerStopSoftwareTriggerRequest(IBarcodeScannerStopSoftwareTriggerRequestVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStopSoftwareTriggerRequest] {
    fn ReportCompletedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStopSoftwareTriggerRequest> {
    #[inline] pub fn report_completed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportCompletedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStopSoftwareTriggerRequest: IBarcodeScannerStopSoftwareTriggerRequest}
DEFINE_IID!(IID_IBarcodeScannerStopSoftwareTriggerRequest2, 3411527133, 65104, 18936, 160, 180, 189, 194, 48, 129, 77, 162);
RT_INTERFACE!{interface IBarcodeScannerStopSoftwareTriggerRequest2(IBarcodeScannerStopSoftwareTriggerRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStopSoftwareTriggerRequest2] {
    fn ReportFailedWithFailedReasonAsync(&self, reason: i32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedWithFailedReasonAndDescriptionAsync(&self, reason: i32, failedReasonDescription: HSTRING, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStopSoftwareTriggerRequest2> {
    #[inline] pub fn report_failed_with_failed_reason_async(&self, reason: i32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAsync)(self.deref() as *const _ as *mut _, reason, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn report_failed_with_failed_reason_and_description_async(&self, reason: i32, failedReasonDescription: &HStringArg) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReportFailedWithFailedReasonAndDescriptionAsync)(self.deref() as *const _ as *mut _, reason, failedReasonDescription.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarcodeScannerStopSoftwareTriggerRequestEventArgs, 3938665552, 20151, 18458, 146, 115, 20, 122, 39, 59, 153, 184);
RT_INTERFACE!{interface IBarcodeScannerStopSoftwareTriggerRequestEventArgs(IBarcodeScannerStopSoftwareTriggerRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerStopSoftwareTriggerRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut BarcodeScannerStopSoftwareTriggerRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut foundation::Deferral) -> HRESULT
}}
impl ComPtr<IBarcodeScannerStopSoftwareTriggerRequestEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<BarcodeScannerStopSoftwareTriggerRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<foundation::Deferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerStopSoftwareTriggerRequestEventArgs: IBarcodeScannerStopSoftwareTriggerRequestEventArgs}
RT_ENUM! { enum BarcodeScannerTriggerState: i32 {
    Released = 0, Pressed = 1,
}}
DEFINE_IID!(IID_IBarcodeScannerVideoFrame, 2119717448, 40439, 16673, 161, 117, 128, 29, 128, 0, 17, 46);
RT_INTERFACE!{interface IBarcodeScannerVideoFrame(IBarcodeScannerVideoFrameVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeScannerVideoFrame] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_Format(&self, out: *mut crate::windows::graphics::imaging::BitmapPixelFormat) -> HRESULT,
    fn get_Width(&self, out: *mut u32) -> HRESULT,
    fn get_Height(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_PixelData(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IBarcodeScannerVideoFrame> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_format(&self) -> Result<crate::windows::graphics::imaging::BitmapPixelFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Format)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_width(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Width)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_height(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Height)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_pixel_data(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PixelData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeScannerVideoFrame: IBarcodeScannerVideoFrame}
DEFINE_IID!(IID_IBarcodeSymbologyAttributesBuilder, 3313175743, 58613, 16569, 132, 207, 230, 63, 186, 234, 66, 180);
RT_INTERFACE!{interface IBarcodeSymbologyAttributesBuilder(IBarcodeSymbologyAttributesBuilderVtbl): IInspectable(IInspectableVtbl) [IID_IBarcodeSymbologyAttributesBuilder] {
    fn get_IsCheckDigitValidationSupported(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitValidationSupported(&self, value: bool) -> HRESULT,
    fn get_IsCheckDigitTransmissionSupported(&self, out: *mut bool) -> HRESULT,
    fn put_IsCheckDigitTransmissionSupported(&self, value: bool) -> HRESULT,
    fn get_IsDecodeLengthSupported(&self, out: *mut bool) -> HRESULT,
    fn put_IsDecodeLengthSupported(&self, value: bool) -> HRESULT,
    fn CreateAttributes(&self, out: *mut *mut super::BarcodeSymbologyAttributes) -> HRESULT
}}
impl ComPtr<IBarcodeSymbologyAttributesBuilder> {
    #[inline] pub fn get_is_check_digit_validation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCheckDigitValidationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_validation_supported(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsCheckDigitValidationSupported)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_check_digit_transmission_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsCheckDigitTransmissionSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_check_digit_transmission_supported(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsCheckDigitTransmissionSupported)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_decode_length_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDecodeLengthSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_decode_length_supported(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDecodeLengthSupported)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_attributes(&self) -> Result<Option<ComPtr<super::BarcodeSymbologyAttributes>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateAttributes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarcodeSymbologyAttributesBuilder: IBarcodeSymbologyAttributesBuilder}
impl RtActivatable<IActivationFactory> for BarcodeSymbologyAttributesBuilder {}
DEFINE_CLSID!(BarcodeSymbologyAttributesBuilder(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,105,110,116,79,102,83,101,114,118,105,99,101,46,80,114,111,118,105,100,101,114,46,66,97,114,99,111,100,101,83,121,109,98,111,108,111,103,121,65,116,116,114,105,98,117,116,101,115,66,117,105,108,100,101,114,0]) [CLSID_BarcodeSymbologyAttributesBuilder]);
} // Windows.Devices.PointOfService.Provider
} // Windows.Devices.PointOfService
pub mod portable { // Windows.Devices.Portable
use crate::prelude::*;
RT_CLASS!{static class ServiceDevice}
impl RtActivatable<IServiceDeviceStatics> for ServiceDevice {}
impl ServiceDevice {
    #[inline] pub fn get_device_selector(serviceType: ServiceDeviceType) -> Result<HString> {
        <Self as RtActivatable<IServiceDeviceStatics>>::get_activation_factory().get_device_selector(serviceType)
    }
    #[inline] pub fn get_device_selector_from_service_id(serviceId: Guid) -> Result<HString> {
        <Self as RtActivatable<IServiceDeviceStatics>>::get_activation_factory().get_device_selector_from_service_id(serviceId)
    }
}
DEFINE_CLSID!(ServiceDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,114,116,97,98,108,101,46,83,101,114,118,105,99,101,68,101,118,105,99,101,0]) [CLSID_ServiceDevice]);
DEFINE_IID!(IID_IServiceDeviceStatics, 2827097313, 22983, 18976, 171, 166, 159, 103, 7, 147, 114, 48);
RT_INTERFACE!{static interface IServiceDeviceStatics(IServiceDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IServiceDeviceStatics] {
    fn GetDeviceSelector(&self, serviceType: ServiceDeviceType, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromServiceId(&self, serviceId: Guid, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IServiceDeviceStatics> {
    #[inline] pub fn get_device_selector(&self, serviceType: ServiceDeviceType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, serviceType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_service_id(&self, serviceId: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromServiceId)(self.deref() as *const _ as *mut _, serviceId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ServiceDeviceType: i32 {
    CalendarService = 0, ContactsService = 1, DeviceStatusService = 2, NotesService = 3, RingtonesService = 4, SmsService = 5, TasksService = 6,
}}
RT_CLASS!{static class StorageDevice}
impl RtActivatable<IStorageDeviceStatics> for StorageDevice {}
impl StorageDevice {
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<ComPtr<super::super::storage::StorageFolder>>> {
        <Self as RtActivatable<IStorageDeviceStatics>>::get_activation_factory().from_id(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IStorageDeviceStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(StorageDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,114,116,97,98,108,101,46,83,116,111,114,97,103,101,68,101,118,105,99,101,0]) [CLSID_StorageDevice]);
DEFINE_IID!(IID_IStorageDeviceStatics, 1590576366, 6947, 19922, 134, 82, 188, 22, 79, 0, 49, 40);
RT_INTERFACE!{static interface IStorageDeviceStatics(IStorageDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStorageDeviceStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn FromId(&self, deviceId: HSTRING, out: *mut *mut super::super::storage::StorageFolder) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IStorageDeviceStatics> {
    #[cfg(feature="windows-storage")] #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<ComPtr<super::super::storage::StorageFolder>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromId)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Portable
pub mod power { // Windows.Devices.Power
use crate::prelude::*;
DEFINE_IID!(IID_IBattery, 3163115462, 114, 18376, 139, 93, 97, 74, 170, 122, 67, 126);
RT_INTERFACE!{interface IBattery(IBatteryVtbl): IInspectable(IInspectableVtbl) [IID_IBattery] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn GetReport(&self, out: *mut *mut BatteryReport) -> HRESULT,
    fn add_ReportUpdated(&self, handler: *mut foundation::TypedEventHandler<Battery, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReportUpdated(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBattery> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_report(&self) -> Result<Option<ComPtr<BatteryReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_report_updated(&self, handler: &ComPtr<foundation::TypedEventHandler<Battery, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReportUpdated)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_report_updated(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReportUpdated)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Battery: IBattery}
impl RtActivatable<IBatteryStatics> for Battery {}
impl Battery {
    #[inline] pub fn get_aggregate_battery() -> Result<Option<ComPtr<Battery>>> {
        <Self as RtActivatable<IBatteryStatics>>::get_activation_factory().get_aggregate_battery()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Battery>>> {
        <Self as RtActivatable<IBatteryStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBatteryStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(Battery(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,111,119,101,114,46,66,97,116,116,101,114,121,0]) [CLSID_Battery]);
DEFINE_IID!(IID_IBatteryReport, 3380972602, 19987, 16906, 168, 208, 36, 241, 143, 57, 84, 1);
RT_INTERFACE!{interface IBatteryReport(IBatteryReportVtbl): IInspectable(IInspectableVtbl) [IID_IBatteryReport] {
    fn get_ChargeRateInMilliwatts(&self, out: *mut *mut foundation::IReference<i32>) -> HRESULT,
    fn get_DesignCapacityInMilliwattHours(&self, out: *mut *mut foundation::IReference<i32>) -> HRESULT,
    fn get_FullChargeCapacityInMilliwattHours(&self, out: *mut *mut foundation::IReference<i32>) -> HRESULT,
    fn get_RemainingCapacityInMilliwattHours(&self, out: *mut *mut foundation::IReference<i32>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_Status(&self, out: *mut super::super::system::power::BatteryStatus) -> HRESULT
}}
impl ComPtr<IBatteryReport> {
    #[inline] pub fn get_charge_rate_in_milliwatts(&self) -> Result<Option<ComPtr<foundation::IReference<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ChargeRateInMilliwatts)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_design_capacity_in_milliwatt_hours(&self) -> Result<Option<ComPtr<foundation::IReference<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DesignCapacityInMilliwattHours)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_full_charge_capacity_in_milliwatt_hours(&self) -> Result<Option<ComPtr<foundation::IReference<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FullChargeCapacityInMilliwattHours)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_remaining_capacity_in_milliwatt_hours(&self) -> Result<Option<ComPtr<foundation::IReference<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RemainingCapacityInMilliwattHours)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_status(&self) -> Result<super::super::system::power::BatteryStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BatteryReport: IBatteryReport}
DEFINE_IID!(IID_IBatteryStatics, 2043507382, 40542, 17490, 190, 166, 223, 205, 84, 30, 89, 127);
RT_INTERFACE!{static interface IBatteryStatics(IBatteryStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBatteryStatics] {
    fn get_AggregateBattery(&self, out: *mut *mut Battery) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Battery>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBatteryStatics> {
    #[inline] pub fn get_aggregate_battery(&self) -> Result<Option<ComPtr<Battery>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AggregateBattery)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Battery>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Power
pub mod printers { // Windows.Devices.Printers
use crate::prelude::*;
DEFINE_IID!(IID_IPrint3DDevice, 68959513, 38675, 17058, 152, 19, 125, 195, 51, 116, 40, 211);
RT_INTERFACE!{interface IPrint3DDevice(IPrint3DDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DDevice] {
    fn get_PrintSchema(&self, out: *mut *mut PrintSchema) -> HRESULT
}}
impl ComPtr<IPrint3DDevice> {
    #[inline] pub fn get_print_schema(&self) -> Result<Option<ComPtr<PrintSchema>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PrintSchema)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DDevice: IPrint3DDevice}
impl RtActivatable<IPrint3DDeviceStatics> for Print3DDevice {}
impl Print3DDevice {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Print3DDevice>>> {
        <Self as RtActivatable<IPrint3DDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPrint3DDeviceStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(Print3DDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,114,105,110,116,101,114,115,46,80,114,105,110,116,51,68,68,101,118,105,99,101,0]) [CLSID_Print3DDevice]);
DEFINE_IID!(IID_IPrint3DDeviceStatics, 4259537418, 26573, 16823, 163, 68, 81, 80, 161, 253, 117, 181);
RT_INTERFACE!{static interface IPrint3DDeviceStatics(IPrint3DDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DDeviceStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Print3DDevice>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPrint3DDeviceStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Print3DDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPrintSchema, 3266937622, 9912, 19451, 129, 56, 159, 150, 44, 34, 163, 91);
RT_INTERFACE!{interface IPrintSchema(IPrintSchemaVtbl): IInspectable(IInspectableVtbl) [IID_IPrintSchema] {
    #[cfg(feature="windows-storage")] fn GetDefaultPrintTicketAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetCapabilitiesAsync(&self, constrainTicket: *mut super::super::storage::streams::IRandomAccessStreamWithContentType, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn MergeAndValidateWithDefaultPrintTicketAsync(&self, deltaTicket: *mut super::super::storage::streams::IRandomAccessStreamWithContentType, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> HRESULT
}}
impl ComPtr<IPrintSchema> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_default_print_ticket_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultPrintTicketAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_capabilities_async(&self, constrainTicket: &ComPtr<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCapabilitiesAsync)(self.deref() as *const _ as *mut _, constrainTicket.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn merge_and_validate_with_default_print_ticket_async(&self, deltaTicket: &ComPtr<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).MergeAndValidateWithDefaultPrintTicketAsync)(self.deref() as *const _ as *mut _, deltaTicket.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintSchema: IPrintSchema}
pub mod extensions { // Windows.Devices.Printers.Extensions
use crate::prelude::*;
DEFINE_IID!(IID_IPrint3DWorkflow, 3312415933, 13929, 19046, 171, 66, 200, 21, 25, 48, 205, 52);
RT_INTERFACE!{interface IPrint3DWorkflow(IPrint3DWorkflowVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflow] {
    fn get_DeviceID(&self, out: *mut HSTRING) -> HRESULT,
    fn GetPrintModelPackage(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_IsPrintReady(&self, out: *mut bool) -> HRESULT,
    fn put_IsPrintReady(&self, value: bool) -> HRESULT,
    fn add_PrintRequested(&self, eventHandler: *mut foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrintRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PrintRequested(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IPrint3DWorkflow> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceID)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_print_model_package(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetPrintModelPackage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_is_print_ready(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsPrintReady)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_print_ready(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsPrintReady)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_print_requested(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrintRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PrintRequested)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_print_requested(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PrintRequested)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflow: IPrint3DWorkflow}
DEFINE_IID!(IID_IPrint3DWorkflow2, 2728838479, 35521, 18712, 151, 65, 227, 79, 48, 4, 35, 158);
RT_INTERFACE!{interface IPrint3DWorkflow2(IPrint3DWorkflow2Vtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflow2] {
    fn add_PrinterChanged(&self, eventHandler: *mut foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrinterChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PrinterChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IPrint3DWorkflow2> {
    #[inline] pub fn add_printer_changed(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<Print3DWorkflow, Print3DWorkflowPrinterChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PrinterChanged)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_printer_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PrinterChanged)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum Print3DWorkflowDetail: i32 {
    Unknown = 0, ModelExceedsPrintBed = 1, UploadFailed = 2, InvalidMaterialSelection = 3, InvalidModel = 4, ModelNotManifold = 5, InvalidPrintTicket = 6,
}}
DEFINE_IID!(IID_IPrint3DWorkflowPrinterChangedEventArgs, 1159881730, 38396, 18503, 147, 179, 19, 77, 191, 92, 96, 247);
RT_INTERFACE!{interface IPrint3DWorkflowPrinterChangedEventArgs(IPrint3DWorkflowPrinterChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowPrinterChangedEventArgs] {
    fn get_NewDeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IPrint3DWorkflowPrinterChangedEventArgs> {
    #[inline] pub fn get_new_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_NewDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflowPrinterChangedEventArgs: IPrint3DWorkflowPrinterChangedEventArgs}
DEFINE_IID!(IID_IPrint3DWorkflowPrintRequestedEventArgs, 435734616, 23240, 19285, 138, 95, 230, 21, 103, 218, 251, 77);
RT_INTERFACE!{interface IPrint3DWorkflowPrintRequestedEventArgs(IPrint3DWorkflowPrintRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowPrintRequestedEventArgs] {
    fn get_Status(&self, out: *mut Print3DWorkflowStatus) -> HRESULT,
    fn SetExtendedStatus(&self, value: Print3DWorkflowDetail) -> HRESULT,
    fn SetSource(&self, source: *mut IInspectable) -> HRESULT,
    fn SetSourceChanged(&self, value: bool) -> HRESULT
}}
impl ComPtr<IPrint3DWorkflowPrintRequestedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<Print3DWorkflowStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_extended_status(&self, value: Print3DWorkflowDetail) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetExtendedStatus)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_source(&self, source: &ComPtr<IInspectable>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetSource)(self.deref() as *const _ as *mut _, source.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_source_changed(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetSourceChanged)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Print3DWorkflowPrintRequestedEventArgs: IPrint3DWorkflowPrintRequestedEventArgs}
RT_ENUM! { enum Print3DWorkflowStatus: i32 {
    Abandoned = 0, Canceled = 1, Failed = 2, Slicing = 3, Submitted = 4,
}}
RT_CLASS!{static class PrintExtensionContext}
impl RtActivatable<IPrintExtensionContextStatic> for PrintExtensionContext {}
impl PrintExtensionContext {
    #[inline] pub fn from_device_id(deviceId: &HStringArg) -> Result<Option<ComPtr<IInspectable>>> {
        <Self as RtActivatable<IPrintExtensionContextStatic>>::get_activation_factory().from_device_id(deviceId)
    }
}
DEFINE_CLSID!(PrintExtensionContext(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,114,105,110,116,101,114,115,46,69,120,116,101,110,115,105,111,110,115,46,80,114,105,110,116,69,120,116,101,110,115,105,111,110,67,111,110,116,101,120,116,0]) [CLSID_PrintExtensionContext]);
DEFINE_IID!(IID_IPrintExtensionContextStatic, 3876429761, 65401, 19108, 140, 155, 12, 147, 174, 223, 222, 138);
RT_INTERFACE!{static interface IPrintExtensionContextStatic(IPrintExtensionContextStaticVtbl): IInspectable(IInspectableVtbl) [IID_IPrintExtensionContextStatic] {
    fn FromDeviceId(&self, deviceId: HSTRING, out: *mut *mut IInspectable) -> HRESULT
}}
impl ComPtr<IPrintExtensionContextStatic> {
    #[inline] pub fn from_device_id(&self, deviceId: &HStringArg) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromDeviceId)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPrintNotificationEventDetails, 3759033482, 18472, 19873, 139, 184, 134, 114, 223, 133, 21, 231);
RT_INTERFACE!{interface IPrintNotificationEventDetails(IPrintNotificationEventDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPrintNotificationEventDetails] {
    fn get_PrinterName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EventData(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EventData(&self, value: HSTRING) -> HRESULT
}}
impl ComPtr<IPrintNotificationEventDetails> {
    #[inline] pub fn get_printer_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PrinterName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_event_data(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EventData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_event_data(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_EventData)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintNotificationEventDetails: IPrintNotificationEventDetails}
DEFINE_IID!(IID_IPrintTaskConfiguration, 3821151313, 15012, 18565, 146, 64, 49, 31, 95, 143, 190, 157);
RT_INTERFACE!{interface IPrintTaskConfiguration(IPrintTaskConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfiguration] {
    fn get_PrinterExtensionContext(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn add_SaveRequested(&self, eventHandler: *mut foundation::TypedEventHandler<PrintTaskConfiguration, PrintTaskConfigurationSaveRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SaveRequested(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IPrintTaskConfiguration> {
    #[inline] pub fn get_printer_extension_context(&self) -> Result<Option<ComPtr<IInspectable>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PrinterExtensionContext)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_save_requested(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<PrintTaskConfiguration, PrintTaskConfigurationSaveRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SaveRequested)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_save_requested(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SaveRequested)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfiguration: IPrintTaskConfiguration}
DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequest, 4004458443, 25118, 19298, 172, 119, 178, 129, 204, 224, 141, 96);
RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequest(IPrintTaskConfigurationSaveRequestVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequest] {
    fn Cancel(&self) -> HRESULT,
    fn Save(&self, printerExtensionContext: *mut IInspectable) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut PrintTaskConfigurationSaveRequestedDeferral) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<IPrintTaskConfigurationSaveRequest> {
    #[inline] pub fn cancel(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Cancel)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn save(&self, printerExtensionContext: &ComPtr<IInspectable>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Save)(self.deref() as *const _ as *mut _, printerExtensionContext.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<PrintTaskConfigurationSaveRequestedDeferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Deadline)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfigurationSaveRequest: IPrintTaskConfigurationSaveRequest}
DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequestedDeferral, 3914978664, 63273, 17572, 135, 29, 189, 6, 40, 105, 106, 51);
RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequestedDeferral(IPrintTaskConfigurationSaveRequestedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequestedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ComPtr<IPrintTaskConfigurationSaveRequestedDeferral> {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Complete)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfigurationSaveRequestedDeferral: IPrintTaskConfigurationSaveRequestedDeferral}
DEFINE_IID!(IID_IPrintTaskConfigurationSaveRequestedEventArgs, 3765184633, 3425, 18744, 145, 208, 150, 164, 91, 238, 132, 121);
RT_INTERFACE!{interface IPrintTaskConfigurationSaveRequestedEventArgs(IPrintTaskConfigurationSaveRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskConfigurationSaveRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut PrintTaskConfigurationSaveRequest) -> HRESULT
}}
impl ComPtr<IPrintTaskConfigurationSaveRequestedEventArgs> {
    #[inline] pub fn get_request(&self) -> Result<Option<ComPtr<PrintTaskConfigurationSaveRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PrintTaskConfigurationSaveRequestedEventArgs: IPrintTaskConfigurationSaveRequestedEventArgs}
} // Windows.Devices.Printers.Extensions
} // Windows.Devices.Printers
pub mod pwm { // Windows.Devices.Pwm
use crate::prelude::*;
DEFINE_IID!(IID_IPwmController, 3294583941, 53992, 17103, 155, 214, 207, 94, 208, 41, 230, 167);
RT_INTERFACE!{interface IPwmController(IPwmControllerVtbl): IInspectable(IInspectableVtbl) [IID_IPwmController] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn get_ActualFrequency(&self, out: *mut f64) -> HRESULT,
    fn SetDesiredFrequency(&self, desiredFrequency: f64, out: *mut f64) -> HRESULT,
    fn get_MinFrequency(&self, out: *mut f64) -> HRESULT,
    fn get_MaxFrequency(&self, out: *mut f64) -> HRESULT,
    fn OpenPin(&self, pinNumber: i32, out: *mut *mut PwmPin) -> HRESULT
}}
impl ComPtr<IPwmController> {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_actual_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ActualFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_frequency(&self, desiredFrequency: f64) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).SetDesiredFrequency)(self.deref() as *const _ as *mut _, desiredFrequency, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn open_pin(&self, pinNumber: i32) -> Result<Option<ComPtr<PwmPin>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).OpenPin)(self.deref() as *const _ as *mut _, pinNumber, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PwmController: IPwmController}
impl RtActivatable<IPwmControllerStatics> for PwmController {}
impl RtActivatable<IPwmControllerStatics2> for PwmController {}
impl RtActivatable<IPwmControllerStatics3> for PwmController {}
impl PwmController {
    #[inline] pub fn get_controllers_async(provider: &ComPtr<provider::IPwmProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PwmController>>>> {
        <Self as RtActivatable<IPwmControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<PwmController>>> {
        <Self as RtActivatable<IPwmControllerStatics2>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPwmControllerStatics3>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_friendly_name(friendlyName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IPwmControllerStatics3>>::get_activation_factory().get_device_selector_from_friendly_name(friendlyName)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PwmController>>> {
        <Self as RtActivatable<IPwmControllerStatics3>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(PwmController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,80,119,109,46,80,119,109,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_PwmController]);
DEFINE_IID!(IID_IPwmControllerStatics, 1113832865, 35142, 17412, 189, 72, 129, 221, 18, 74, 244, 217);
RT_INTERFACE!{static interface IPwmControllerStatics(IPwmControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics] {
    fn GetControllersAsync(&self, provider: *mut provider::IPwmProvider, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<PwmController>>) -> HRESULT
}}
impl ComPtr<IPwmControllerStatics> {
    #[inline] pub fn get_controllers_async(&self, provider: &ComPtr<provider::IPwmProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PwmController>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmControllerStatics2, 1157389087, 61721, 19421, 151, 173, 247, 110, 249, 134, 115, 109);
RT_INTERFACE!{static interface IPwmControllerStatics2(IPwmControllerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics2] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<PwmController>) -> HRESULT
}}
impl ComPtr<IPwmControllerStatics2> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<PwmController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmControllerStatics3, 2992117873, 553, 17220, 174, 63, 155, 124, 208, 230, 107, 148);
RT_INTERFACE!{static interface IPwmControllerStatics3(IPwmControllerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerStatics3] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromFriendlyName(&self, friendlyName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<PwmController>) -> HRESULT
}}
impl ComPtr<IPwmControllerStatics3> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_friendly_name(&self, friendlyName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromFriendlyName)(self.deref() as *const _ as *mut _, friendlyName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<PwmController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmPin, 580333000, 50895, 18465, 183, 249, 198, 69, 79, 182, 175, 121);
RT_INTERFACE!{interface IPwmPin(IPwmPinVtbl): IInspectable(IInspectableVtbl) [IID_IPwmPin] {
    fn get_Controller(&self, out: *mut *mut PwmController) -> HRESULT,
    fn GetActiveDutyCyclePercentage(&self, out: *mut f64) -> HRESULT,
    fn SetActiveDutyCyclePercentage(&self, dutyCyclePercentage: f64) -> HRESULT,
    fn get_Polarity(&self, out: *mut PwmPulsePolarity) -> HRESULT,
    fn put_Polarity(&self, value: PwmPulsePolarity) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT,
    fn get_IsStarted(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IPwmPin> {
    #[inline] pub fn get_controller(&self) -> Result<Option<ComPtr<PwmController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Controller)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_duty_cycle_percentage(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetActiveDutyCyclePercentage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_active_duty_cycle_percentage(&self, dutyCyclePercentage: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetActiveDutyCyclePercentage)(self.deref() as *const _ as *mut _, dutyCyclePercentage);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_polarity(&self) -> Result<PwmPulsePolarity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Polarity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_polarity(&self, value: PwmPulsePolarity) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Polarity)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_started(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsStarted)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PwmPin: IPwmPin}
RT_ENUM! { enum PwmPulsePolarity: i32 {
    ActiveHigh = 0, ActiveLow = 1,
}}
pub mod provider { // Windows.Devices.Pwm.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IPwmControllerProvider, 318789947, 58083, 16548, 183, 217, 72, 223, 240, 55, 122, 82);
RT_INTERFACE!{interface IPwmControllerProvider(IPwmControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_IPwmControllerProvider] {
    fn get_PinCount(&self, out: *mut i32) -> HRESULT,
    fn get_ActualFrequency(&self, out: *mut f64) -> HRESULT,
    fn SetDesiredFrequency(&self, frequency: f64, out: *mut f64) -> HRESULT,
    fn get_MaxFrequency(&self, out: *mut f64) -> HRESULT,
    fn get_MinFrequency(&self, out: *mut f64) -> HRESULT,
    fn AcquirePin(&self, pin: i32) -> HRESULT,
    fn ReleasePin(&self, pin: i32) -> HRESULT,
    fn EnablePin(&self, pin: i32) -> HRESULT,
    fn DisablePin(&self, pin: i32) -> HRESULT,
    fn SetPulseParameters(&self, pin: i32, dutyCycle: f64, invertPolarity: bool) -> HRESULT
}}
impl ComPtr<IPwmControllerProvider> {
    #[inline] pub fn get_pin_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_actual_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ActualFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_frequency(&self, frequency: f64) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).SetDesiredFrequency)(self.deref() as *const _ as *mut _, frequency, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_frequency(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn acquire_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).AcquirePin)(self.deref() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn release_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ReleasePin)(self.deref() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn enable_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).EnablePin)(self.deref() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn disable_pin(&self, pin: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).DisablePin)(self.deref() as *const _ as *mut _, pin);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn set_pulse_parameters(&self, pin: i32, dutyCycle: f64, invertPolarity: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetPulseParameters)(self.deref() as *const _ as *mut _, pin, dutyCycle, invertPolarity);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPwmProvider, 2737836584, 21233, 18352, 147, 73, 102, 186, 67, 210, 89, 2);
RT_INTERFACE!{interface IPwmProvider(IPwmProviderVtbl): IInspectable(IInspectableVtbl) [IID_IPwmProvider] {
    fn GetControllers(&self, out: *mut *mut foundation::collections::IVectorView<IPwmControllerProvider>) -> HRESULT
}}
impl ComPtr<IPwmProvider> {
    #[inline] pub fn get_controllers(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<IPwmControllerProvider>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Pwm.Provider
} // Windows.Devices.Pwm
pub mod radios { // Windows.Devices.Radios
use crate::prelude::*;
DEFINE_IID!(IID_IRadio, 622926047, 45886, 16746, 135, 95, 28, 243, 138, 226, 216, 62);
RT_INTERFACE!{interface IRadio(IRadioVtbl): IInspectable(IInspectableVtbl) [IID_IRadio] {
    fn SetStateAsync(&self, value: RadioState, out: *mut *mut foundation::IAsyncOperation<RadioAccessStatus>) -> HRESULT,
    fn add_StateChanged(&self, handler: *mut foundation::TypedEventHandler<Radio, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StateChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn get_State(&self, out: *mut RadioState) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut RadioKind) -> HRESULT
}}
impl ComPtr<IRadio> {
    #[inline] pub fn set_state_async(&self, value: RadioState) -> Result<ComPtr<foundation::IAsyncOperation<RadioAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SetStateAsync)(self.deref() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_state_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Radio, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StateChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_state_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StateChanged)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_state(&self) -> Result<RadioState> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<RadioKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Kind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class Radio: IRadio}
impl RtActivatable<IRadioStatics> for Radio {}
impl Radio {
    #[inline] pub fn get_radios_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<Radio>>>> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().get_radios_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Radio>>> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<RadioAccessStatus>>> {
        <Self as RtActivatable<IRadioStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(Radio(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,82,97,100,105,111,115,46,82,97,100,105,111,0]) [CLSID_Radio]);
RT_ENUM! { enum RadioAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
RT_ENUM! { enum RadioKind: i32 {
    Other = 0, WiFi = 1, MobileBroadband = 2, Bluetooth = 3, FM = 4,
}}
RT_ENUM! { enum RadioState: i32 {
    Unknown = 0, On = 1, Off = 2, Disabled = 3,
}}
DEFINE_IID!(IID_IRadioStatics, 1605804334, 26571, 18094, 170, 233, 101, 145, 159, 134, 239, 244);
RT_INTERFACE!{static interface IRadioStatics(IRadioStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRadioStatics] {
    fn GetRadiosAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<Radio>>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Radio>) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<RadioAccessStatus>) -> HRESULT
}}
impl ComPtr<IRadioStatics> {
    #[inline] pub fn get_radios_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<Radio>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRadiosAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Radio>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<RadioAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Radios
pub mod scanners { // Windows.Devices.Scanners
use crate::prelude::*;
DEFINE_IID!(IID_IImageScanner, 1403555704, 21144, 18592, 141, 163, 128, 135, 81, 150, 101, 224);
RT_INTERFACE!{interface IImageScanner(IImageScannerVtbl): IInspectable(IInspectableVtbl) [IID_IImageScanner] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultScanSource(&self, out: *mut ImageScannerScanSource) -> HRESULT,
    fn IsScanSourceSupported(&self, value: ImageScannerScanSource, out: *mut bool) -> HRESULT,
    fn get_FlatbedConfiguration(&self, out: *mut *mut ImageScannerFlatbedConfiguration) -> HRESULT,
    fn get_FeederConfiguration(&self, out: *mut *mut ImageScannerFeederConfiguration) -> HRESULT,
    fn get_AutoConfiguration(&self, out: *mut *mut ImageScannerAutoConfiguration) -> HRESULT,
    fn IsPreviewSupported(&self, scanSource: ImageScannerScanSource, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ScanPreviewToStreamAsync(&self, scanSource: ImageScannerScanSource, targetStream: *mut super::super::storage::streams::IRandomAccessStream, out: *mut *mut foundation::IAsyncOperation<ImageScannerPreviewResult>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ScanFilesToFolderAsync(&self, scanSource: ImageScannerScanSource, storageFolder: *mut super::super::storage::StorageFolder, out: *mut *mut foundation::IAsyncOperationWithProgress<ImageScannerScanResult, u32>) -> HRESULT
}}
impl ComPtr<IImageScanner> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_scan_source(&self) -> Result<ImageScannerScanSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DefaultScanSource)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn is_scan_source_supported(&self, value: ImageScannerScanSource) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsScanSourceSupported)(self.deref() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_flatbed_configuration(&self) -> Result<Option<ComPtr<ImageScannerFlatbedConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FlatbedConfiguration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_feeder_configuration(&self) -> Result<Option<ComPtr<ImageScannerFeederConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_FeederConfiguration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_configuration(&self) -> Result<Option<ComPtr<ImageScannerAutoConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AutoConfiguration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn is_preview_supported(&self, scanSource: ImageScannerScanSource) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsPreviewSupported)(self.deref() as *const _ as *mut _, scanSource, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn scan_preview_to_stream_async(&self, scanSource: ImageScannerScanSource, targetStream: &ComPtr<super::super::storage::streams::IRandomAccessStream>) -> Result<ComPtr<foundation::IAsyncOperation<ImageScannerPreviewResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ScanPreviewToStreamAsync)(self.deref() as *const _ as *mut _, scanSource, targetStream.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn scan_files_to_folder_async(&self, scanSource: ImageScannerScanSource, storageFolder: &ComPtr<super::super::storage::StorageFolder>) -> Result<ComPtr<foundation::IAsyncOperationWithProgress<ImageScannerScanResult, u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ScanFilesToFolderAsync)(self.deref() as *const _ as *mut _, scanSource, storageFolder.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScanner: IImageScanner}
impl RtActivatable<IImageScannerStatics> for ImageScanner {}
impl ImageScanner {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ImageScanner>>> {
        <Self as RtActivatable<IImageScannerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IImageScannerStatics>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(ImageScanner(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,99,97,110,110,101,114,115,46,73,109,97,103,101,83,99,97,110,110,101,114,0]) [CLSID_ImageScanner]);
RT_CLASS!{class ImageScannerAutoConfiguration: IImageScannerFormatConfiguration}
RT_ENUM! { enum ImageScannerAutoCroppingMode: i32 {
    Disabled = 0, SingleRegion = 1, MultipleRegion = 2,
}}
RT_ENUM! { enum ImageScannerColorMode: i32 {
    Color = 0, Grayscale = 1, Monochrome = 2, AutoColor = 3,
}}
DEFINE_IID!(IID_IImageScannerFeederConfiguration, 1958587630, 64151, 19479, 130, 128, 64, 227, 156, 109, 204, 103);
RT_INTERFACE!{interface IImageScannerFeederConfiguration(IImageScannerFeederConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerFeederConfiguration] {
    fn get_CanAutoDetectPageSize(&self, out: *mut bool) -> HRESULT,
    fn get_AutoDetectPageSize(&self, out: *mut bool) -> HRESULT,
    fn put_AutoDetectPageSize(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_PageSize(&self, out: *mut super::super::graphics::printing::PrintMediaSize) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_PageSize(&self, value: super::super::graphics::printing::PrintMediaSize) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_PageOrientation(&self, out: *mut super::super::graphics::printing::PrintOrientation) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_PageOrientation(&self, value: super::super::graphics::printing::PrintOrientation) -> HRESULT,
    fn get_PageSizeDimensions(&self, out: *mut foundation::Size) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-graphics")] fn IsPageSizeSupported(&self, pageSize: super::super::graphics::printing::PrintMediaSize, pageOrientation: super::super::graphics::printing::PrintOrientation, out: *mut bool) -> HRESULT,
    fn get_MaxNumberOfPages(&self, out: *mut u32) -> HRESULT,
    fn put_MaxNumberOfPages(&self, value: u32) -> HRESULT,
    fn get_CanScanDuplex(&self, out: *mut bool) -> HRESULT,
    fn get_Duplex(&self, out: *mut bool) -> HRESULT,
    fn put_Duplex(&self, value: bool) -> HRESULT,
    fn get_CanScanAhead(&self, out: *mut bool) -> HRESULT,
    fn get_ScanAhead(&self, out: *mut bool) -> HRESULT,
    fn put_ScanAhead(&self, value: bool) -> HRESULT
}}
impl ComPtr<IImageScannerFeederConfiguration> {
    #[inline] pub fn get_can_auto_detect_page_size(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanAutoDetectPageSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_detect_page_size(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AutoDetectPageSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_detect_page_size(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AutoDetectPageSize)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_page_size(&self) -> Result<super::super::graphics::printing::PrintMediaSize> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PageSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_page_size(&self, value: super::super::graphics::printing::PrintMediaSize) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PageSize)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_page_orientation(&self) -> Result<super::super::graphics::printing::PrintOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PageOrientation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_page_orientation(&self, value: super::super::graphics::printing::PrintOrientation) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PageOrientation)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_page_size_dimensions(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PageSizeDimensions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn is_page_size_supported(&self, pageSize: super::super::graphics::printing::PrintMediaSize, pageOrientation: super::super::graphics::printing::PrintOrientation) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsPageSizeSupported)(self.deref() as *const _ as *mut _, pageSize, pageOrientation, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_number_of_pages(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxNumberOfPages)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_number_of_pages(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_MaxNumberOfPages)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_scan_duplex(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanScanDuplex)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_duplex(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Duplex)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_duplex(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Duplex)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_can_scan_ahead(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CanScanAhead)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_scan_ahead(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ScanAhead)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_scan_ahead(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ScanAhead)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScannerFeederConfiguration: IImageScannerFormatConfiguration}
RT_CLASS!{class ImageScannerFlatbedConfiguration: IImageScannerFormatConfiguration}
RT_ENUM! { enum ImageScannerFormat: i32 {
    Jpeg = 0, Png = 1, DeviceIndependentBitmap = 2, Tiff = 3, Xps = 4, OpenXps = 5, Pdf = 6,
}}
DEFINE_IID!(IID_IImageScannerFormatConfiguration, 2921815313, 56031, 16400, 191, 16, 204, 165, 200, 61, 203, 176);
RT_INTERFACE!{interface IImageScannerFormatConfiguration(IImageScannerFormatConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerFormatConfiguration] {
    fn get_DefaultFormat(&self, out: *mut ImageScannerFormat) -> HRESULT,
    fn get_Format(&self, out: *mut ImageScannerFormat) -> HRESULT,
    fn put_Format(&self, value: ImageScannerFormat) -> HRESULT,
    fn IsFormatSupported(&self, value: ImageScannerFormat, out: *mut bool) -> HRESULT
}}
impl ComPtr<IImageScannerFormatConfiguration> {
    #[inline] pub fn get_default_format(&self) -> Result<ImageScannerFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DefaultFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_format(&self) -> Result<ImageScannerFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Format)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: ImageScannerFormat) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Format)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_format_supported(&self, value: ImageScannerFormat) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsFormatSupported)(self.deref() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageScannerPreviewResult, 146275982, 34961, 17437, 190, 156, 23, 111, 161, 9, 200, 187);
RT_INTERFACE!{interface IImageScannerPreviewResult(IImageScannerPreviewResultVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerPreviewResult] {
    fn get_Succeeded(&self, out: *mut bool) -> HRESULT,
    fn get_Format(&self, out: *mut ImageScannerFormat) -> HRESULT
}}
impl ComPtr<IImageScannerPreviewResult> {
    #[inline] pub fn get_succeeded(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Succeeded)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_format(&self) -> Result<ImageScannerFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Format)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScannerPreviewResult: IImageScannerPreviewResult}
RT_STRUCT! { struct ImageScannerResolution {
    DpiX: f32, DpiY: f32,
}}
DEFINE_IID!(IID_IImageScannerScanResult, 3373671629, 36919, 20040, 132, 193, 172, 9, 117, 7, 107, 197);
RT_INTERFACE!{interface IImageScannerScanResult(IImageScannerScanResultVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerScanResult] {
    #[cfg(feature="windows-storage")] fn get_ScannedFiles(&self, out: *mut *mut foundation::collections::IVectorView<super::super::storage::StorageFile>) -> HRESULT
}}
impl ComPtr<IImageScannerScanResult> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_scanned_files(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::storage::StorageFile>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ScannedFiles)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ImageScannerScanResult: IImageScannerScanResult}
RT_ENUM! { enum ImageScannerScanSource: i32 {
    Default = 0, Flatbed = 1, Feeder = 2, AutoConfigured = 3,
}}
DEFINE_IID!(IID_IImageScannerSourceConfiguration, 3216310357, 2884, 19586, 158, 137, 32, 95, 156, 35, 78, 89);
RT_INTERFACE!{interface IImageScannerSourceConfiguration(IImageScannerSourceConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerSourceConfiguration] {
    fn get_MinScanArea(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_MaxScanArea(&self, out: *mut foundation::Size) -> HRESULT,
    fn get_SelectedScanRegion(&self, out: *mut foundation::Rect) -> HRESULT,
    fn put_SelectedScanRegion(&self, value: foundation::Rect) -> HRESULT,
    fn get_AutoCroppingMode(&self, out: *mut ImageScannerAutoCroppingMode) -> HRESULT,
    fn put_AutoCroppingMode(&self, value: ImageScannerAutoCroppingMode) -> HRESULT,
    fn IsAutoCroppingModeSupported(&self, value: ImageScannerAutoCroppingMode, out: *mut bool) -> HRESULT,
    fn get_MinResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_MaxResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_OpticalResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_DesiredResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn put_DesiredResolution(&self, value: ImageScannerResolution) -> HRESULT,
    fn get_ActualResolution(&self, out: *mut ImageScannerResolution) -> HRESULT,
    fn get_DefaultColorMode(&self, out: *mut ImageScannerColorMode) -> HRESULT,
    fn get_ColorMode(&self, out: *mut ImageScannerColorMode) -> HRESULT,
    fn put_ColorMode(&self, value: ImageScannerColorMode) -> HRESULT,
    fn IsColorModeSupported(&self, value: ImageScannerColorMode, out: *mut bool) -> HRESULT,
    fn get_MinBrightness(&self, out: *mut i32) -> HRESULT,
    fn get_MaxBrightness(&self, out: *mut i32) -> HRESULT,
    fn get_BrightnessStep(&self, out: *mut u32) -> HRESULT,
    fn get_DefaultBrightness(&self, out: *mut i32) -> HRESULT,
    fn get_Brightness(&self, out: *mut i32) -> HRESULT,
    fn put_Brightness(&self, value: i32) -> HRESULT,
    fn get_MinContrast(&self, out: *mut i32) -> HRESULT,
    fn get_MaxContrast(&self, out: *mut i32) -> HRESULT,
    fn get_ContrastStep(&self, out: *mut u32) -> HRESULT,
    fn get_DefaultContrast(&self, out: *mut i32) -> HRESULT,
    fn get_Contrast(&self, out: *mut i32) -> HRESULT,
    fn put_Contrast(&self, value: i32) -> HRESULT
}}
impl ComPtr<IImageScannerSourceConfiguration> {
    #[inline] pub fn get_min_scan_area(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinScanArea)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_scan_area(&self) -> Result<foundation::Size> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxScanArea)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_selected_scan_region(&self) -> Result<foundation::Rect> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SelectedScanRegion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_selected_scan_region(&self, value: foundation::Rect) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SelectedScanRegion)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_cropping_mode(&self) -> Result<ImageScannerAutoCroppingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AutoCroppingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_cropping_mode(&self, value: ImageScannerAutoCroppingMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AutoCroppingMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_auto_cropping_mode_supported(&self, value: ImageScannerAutoCroppingMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsAutoCroppingModeSupported)(self.deref() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_optical_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OpticalResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_desired_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DesiredResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_desired_resolution(&self, value: ImageScannerResolution) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DesiredResolution)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_actual_resolution(&self) -> Result<ImageScannerResolution> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ActualResolution)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_color_mode(&self) -> Result<ImageScannerColorMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DefaultColorMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_color_mode(&self) -> Result<ImageScannerColorMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ColorMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_color_mode(&self, value: ImageScannerColorMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ColorMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_color_mode_supported(&self, value: ImageScannerColorMode) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsColorModeSupported)(self.deref() as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinBrightness)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBrightness)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BrightnessStep)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DefaultBrightness)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_brightness(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Brightness)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_brightness(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Brightness)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_min_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinContrast)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxContrast)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contrast_step(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ContrastStep)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_default_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DefaultContrast)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_contrast(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Contrast)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_contrast(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Contrast)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IImageScannerStatics, 3159877390, 55300, 17527, 159, 181, 185, 17, 181, 71, 56, 151);
RT_INTERFACE!{static interface IImageScannerStatics(IImageScannerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IImageScannerStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<ImageScanner>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IImageScannerStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ImageScanner>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Scanners
pub mod sensors { // Windows.Devices.Sensors
use crate::prelude::*;
DEFINE_IID!(IID_IAccelerometer, 3742909768, 10001, 19879, 128, 152, 75, 130, 32, 93, 60, 125);
RT_INTERFACE!{interface IAccelerometer(IAccelerometerVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer] {
    fn GetCurrentReading(&self, out: *mut *mut AccelerometerReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Accelerometer, AccelerometerReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_Shaken(&self, handler: *mut foundation::TypedEventHandler<Accelerometer, AccelerometerShakenEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Shaken(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IAccelerometer> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<AccelerometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Accelerometer, AccelerometerReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_shaken(&self, handler: &ComPtr<foundation::TypedEventHandler<Accelerometer, AccelerometerShakenEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_Shaken)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_shaken(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_Shaken)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Accelerometer: IAccelerometer}
impl RtActivatable<IAccelerometerStatics> for Accelerometer {}
impl RtActivatable<IAccelerometerStatics2> for Accelerometer {}
impl RtActivatable<IAccelerometerStatics3> for Accelerometer {}
impl Accelerometer {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Accelerometer>>> {
        <Self as RtActivatable<IAccelerometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_default_with_accelerometer_reading_type(readingType: AccelerometerReadingType) -> Result<Option<ComPtr<Accelerometer>>> {
        <Self as RtActivatable<IAccelerometerStatics2>>::get_activation_factory().get_default_with_accelerometer_reading_type(readingType)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Accelerometer>>> {
        <Self as RtActivatable<IAccelerometerStatics3>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector(readingType: AccelerometerReadingType) -> Result<HString> {
        <Self as RtActivatable<IAccelerometerStatics3>>::get_activation_factory().get_device_selector(readingType)
    }
}
DEFINE_CLSID!(Accelerometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,99,99,101,108,101,114,111,109,101,116,101,114,0]) [CLSID_Accelerometer]);
DEFINE_IID!(IID_IAccelerometer2, 3908080366, 18788, 16410, 182, 2, 34, 13, 113, 83, 198, 10);
RT_INTERFACE!{interface IAccelerometer2(IAccelerometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ComPtr<IAccelerometer2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometer3, 2279604778, 60800, 18923, 191, 138, 164, 234, 49, 229, 205, 132);
RT_INTERFACE!{interface IAccelerometer3(IAccelerometer3Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IAccelerometer3> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometer4, 490159183, 17107, 17842, 129, 68, 171, 127, 182, 101, 235, 89);
RT_INTERFACE!{interface IAccelerometer4(IAccelerometer4Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometer4] {
    fn get_ReadingType(&self, out: *mut AccelerometerReadingType) -> HRESULT
}}
impl ComPtr<IAccelerometer4> {
    #[inline] pub fn get_reading_type(&self) -> Result<AccelerometerReadingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerDeviceId, 2125227177, 38869, 17517, 171, 90, 145, 125, 249, 185, 106, 44);
RT_INTERFACE!{interface IAccelerometerDeviceId(IAccelerometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAccelerometerDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerReading, 3120462539, 54097, 16559, 139, 182, 122, 169, 174, 100, 31, 183);
RT_INTERFACE!{interface IAccelerometerReading(IAccelerometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AccelerationX(&self, out: *mut f64) -> HRESULT,
    fn get_AccelerationY(&self, out: *mut f64) -> HRESULT,
    fn get_AccelerationZ(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IAccelerometerReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_acceleration_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AccelerationX)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_acceleration_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AccelerationY)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_acceleration_z(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AccelerationZ)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AccelerometerReading: IAccelerometerReading}
DEFINE_IID!(IID_IAccelerometerReading2, 176573090, 5550, 19008, 190, 85, 219, 88, 215, 222, 115, 137);
RT_INTERFACE!{interface IAccelerometerReading2(IAccelerometerReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IAccelerometerReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerReadingChangedEventArgs, 9815643, 46764, 18266, 159, 68, 139, 50, 211, 90, 63, 37);
RT_INTERFACE!{interface IAccelerometerReadingChangedEventArgs(IAccelerometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut AccelerometerReading) -> HRESULT
}}
impl ComPtr<IAccelerometerReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<AccelerometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AccelerometerReadingChangedEventArgs: IAccelerometerReadingChangedEventArgs}
RT_ENUM! { enum AccelerometerReadingType: i32 {
    Standard = 0, Linear = 1, Gravity = 2,
}}
DEFINE_IID!(IID_IAccelerometerShakenEventArgs, 2516517329, 18984, 20277, 152, 232, 129, 120, 170, 228, 8, 74);
RT_INTERFACE!{interface IAccelerometerShakenEventArgs(IAccelerometerShakenEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerShakenEventArgs] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<IAccelerometerShakenEventArgs> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AccelerometerShakenEventArgs: IAccelerometerShakenEventArgs}
DEFINE_IID!(IID_IAccelerometerStatics, 2783087476, 23175, 18989, 190, 204, 15, 144, 110, 160, 97, 221);
RT_INTERFACE!{static interface IAccelerometerStatics(IAccelerometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics] {
    fn GetDefault(&self, out: *mut *mut Accelerometer) -> HRESULT
}}
impl ComPtr<IAccelerometerStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Accelerometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerStatics2, 3301213231, 55403, 18053, 178, 215, 51, 150, 247, 152, 213, 123);
RT_INTERFACE!{static interface IAccelerometerStatics2(IAccelerometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics2] {
    fn GetDefaultWithAccelerometerReadingType(&self, readingType: AccelerometerReadingType, out: *mut *mut Accelerometer) -> HRESULT
}}
impl ComPtr<IAccelerometerStatics2> {
    #[inline] pub fn get_default_with_accelerometer_reading_type(&self, readingType: AccelerometerReadingType) -> Result<Option<ComPtr<Accelerometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultWithAccelerometerReadingType)(self.deref() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAccelerometerStatics3, 2648840399, 17757, 19699, 130, 0, 112, 225, 65, 3, 64, 248);
RT_INTERFACE!{static interface IAccelerometerStatics3(IAccelerometerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAccelerometerStatics3] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Accelerometer>) -> HRESULT,
    fn GetDeviceSelector(&self, readingType: AccelerometerReadingType, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IAccelerometerStatics3> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Accelerometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self, readingType: AccelerometerReadingType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IActivitySensor, 3447350028, 64351, 18667, 176, 155, 162, 112, 141, 28, 97, 239);
RT_INTERFACE!{interface IActivitySensor(IActivitySensorVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensor] {
    fn GetCurrentReadingAsync(&self, out: *mut *mut foundation::IAsyncOperation<ActivitySensorReading>) -> HRESULT,
    fn get_SubscribedActivities(&self, out: *mut *mut foundation::collections::IVector<ActivityType>) -> HRESULT,
    fn get_PowerInMilliwatts(&self, out: *mut f64) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedActivities(&self, out: *mut *mut foundation::collections::IVectorView<ActivityType>) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<ActivitySensor, ActivitySensorReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IActivitySensor> {
    #[inline] pub fn get_current_reading_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ActivitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReadingAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_subscribed_activities(&self) -> Result<Option<ComPtr<foundation::collections::IVector<ActivityType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SubscribedActivities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_power_in_milliwatts(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerInMilliwatts)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_activities(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<ActivityType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedActivities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<ActivitySensor, ActivitySensorReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensor: IActivitySensor}
impl RtActivatable<IActivitySensorStatics> for ActivitySensor {}
impl ActivitySensor {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<ActivitySensor>>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ActivitySensor>>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_system_history_async(fromTime: foundation::DateTime) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_system_history_async(fromTime)
    }
    #[inline] pub fn get_system_history_with_duration_async(fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>>> {
        <Self as RtActivatable<IActivitySensorStatics>>::get_activation_factory().get_system_history_with_duration_async(fromTime, duration)
    }
}
DEFINE_CLSID!(ActivitySensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,99,116,105,118,105,116,121,83,101,110,115,111,114,0]) [CLSID_ActivitySensor]);
DEFINE_IID!(IID_IActivitySensorReading, 2232572566, 5234, 16546, 178, 174, 225, 239, 41, 34, 108, 120);
RT_INTERFACE!{interface IActivitySensorReading(IActivitySensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Activity(&self, out: *mut ActivityType) -> HRESULT,
    fn get_Confidence(&self, out: *mut ActivitySensorReadingConfidence) -> HRESULT
}}
impl ComPtr<IActivitySensorReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_activity(&self) -> Result<ActivityType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Activity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_confidence(&self) -> Result<ActivitySensorReadingConfidence> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Confidence)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorReading: IActivitySensorReading}
DEFINE_IID!(IID_IActivitySensorReadingChangedEventArgs, 3728238359, 44726, 20167, 148, 106, 217, 204, 25, 185, 81, 236);
RT_INTERFACE!{interface IActivitySensorReadingChangedEventArgs(IActivitySensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut ActivitySensorReading) -> HRESULT
}}
impl ComPtr<IActivitySensorReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<ActivitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorReadingChangedEventArgs: IActivitySensorReadingChangedEventArgs}
DEFINE_IID!(IID_IActivitySensorReadingChangeReport, 1329342741, 55611, 18365, 150, 10, 242, 15, 178, 243, 34, 185);
RT_INTERFACE!{interface IActivitySensorReadingChangeReport(IActivitySensorReadingChangeReportVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorReadingChangeReport] {
    fn get_Reading(&self, out: *mut *mut ActivitySensorReading) -> HRESULT
}}
impl ComPtr<IActivitySensorReadingChangeReport> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<ActivitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorReadingChangeReport: IActivitySensorReadingChangeReport}
RT_ENUM! { enum ActivitySensorReadingConfidence: i32 {
    High = 0, Low = 1,
}}
DEFINE_IID!(IID_IActivitySensorStatics, 2803764893, 61067, 17873, 178, 91, 8, 204, 13, 249, 42, 182);
RT_INTERFACE!{static interface IActivitySensorStatics(IActivitySensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<ActivitySensor>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<ActivitySensor>) -> HRESULT,
    fn GetSystemHistoryAsync(&self, fromTime: foundation::DateTime, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>) -> HRESULT,
    fn GetSystemHistoryWithDurationAsync(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>) -> HRESULT
}}
impl ComPtr<IActivitySensorStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<ActivitySensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<ActivitySensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_async(&self, fromTime: foundation::DateTime) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSystemHistoryAsync)(self.deref() as *const _ as *mut _, fromTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_with_duration_async(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<ActivitySensorReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSystemHistoryWithDurationAsync)(self.deref() as *const _ as *mut _, fromTime, duration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IActivitySensorTriggerDetails, 748578322, 47562, 18039, 178, 99, 36, 50, 151, 247, 157, 58);
RT_INTERFACE!{interface IActivitySensorTriggerDetails(IActivitySensorTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorTriggerDetails] {
    fn ReadReports(&self, out: *mut *mut foundation::collections::IVectorView<ActivitySensorReadingChangeReport>) -> HRESULT
}}
impl ComPtr<IActivitySensorTriggerDetails> {
    #[inline] pub fn read_reports(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<ActivitySensorReadingChangeReport>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ReadReports)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ActivitySensorTriggerDetails: IActivitySensorTriggerDetails}
RT_ENUM! { enum ActivityType: i32 {
    Unknown = 0, Idle = 1, Stationary = 2, Fidgeting = 3, Walking = 4, Running = 5, InVehicle = 6, Biking = 7,
}}
DEFINE_IID!(IID_IAltimeter, 1928353789, 36612, 18929, 180, 167, 244, 227, 99, 183, 1, 162);
RT_INTERFACE!{interface IAltimeter(IAltimeterVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeter] {
    fn GetCurrentReading(&self, out: *mut *mut AltimeterReading) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Altimeter, AltimeterReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IAltimeter> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<AltimeterReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Altimeter, AltimeterReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Altimeter: IAltimeter}
impl RtActivatable<IAltimeterStatics> for Altimeter {}
impl Altimeter {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Altimeter>>> {
        <Self as RtActivatable<IAltimeterStatics>>::get_activation_factory().get_default()
    }
}
DEFINE_CLSID!(Altimeter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,65,108,116,105,109,101,116,101,114,0]) [CLSID_Altimeter]);
DEFINE_IID!(IID_IAltimeter2, 3376880633, 10973, 18677, 159, 8, 61, 12, 118, 96, 217, 56);
RT_INTERFACE!{interface IAltimeter2(IAltimeter2Vtbl): IInspectable(IInspectableVtbl) [IID_IAltimeter2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IAltimeter2> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAltimeterReading, 4226346867, 32606, 18632, 170, 26, 241, 243, 190, 252, 17, 68);
RT_INTERFACE!{interface IAltimeterReading(IAltimeterReadingVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AltitudeChangeInMeters(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IAltimeterReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_altitude_change_in_meters(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AltitudeChangeInMeters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class AltimeterReading: IAltimeterReading}
DEFINE_IID!(IID_IAltimeterReading2, 1413094361, 27915, 17074, 189, 105, 188, 143, 174, 15, 120, 44);
RT_INTERFACE!{interface IAltimeterReading2(IAltimeterReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IAltimeterReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IAltimeterReadingChangedEventArgs, 1885982839, 17517, 18423, 153, 140, 235, 194, 59, 69, 228, 162);
RT_INTERFACE!{interface IAltimeterReadingChangedEventArgs(IAltimeterReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut AltimeterReading) -> HRESULT
}}
impl ComPtr<IAltimeterReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<AltimeterReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class AltimeterReadingChangedEventArgs: IAltimeterReadingChangedEventArgs}
DEFINE_IID!(IID_IAltimeterStatics, 2662651843, 58796, 18382, 142, 239, 211, 113, 129, 104, 192, 31);
RT_INTERFACE!{static interface IAltimeterStatics(IAltimeterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAltimeterStatics] {
    fn GetDefault(&self, out: *mut *mut Altimeter) -> HRESULT
}}
impl ComPtr<IAltimeterStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Altimeter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometer, 2470737320, 30911, 17711, 176, 23, 240, 32, 156, 230, 218, 180);
RT_INTERFACE!{interface IBarometer(IBarometerVtbl): IInspectable(IInspectableVtbl) [IID_IBarometer] {
    fn GetCurrentReading(&self, out: *mut *mut BarometerReading) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Barometer, BarometerReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IBarometer> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<BarometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Barometer, BarometerReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Barometer: IBarometer}
impl RtActivatable<IBarometerStatics> for Barometer {}
impl RtActivatable<IBarometerStatics2> for Barometer {}
impl Barometer {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Barometer>>> {
        <Self as RtActivatable<IBarometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Barometer>>> {
        <Self as RtActivatable<IBarometerStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IBarometerStatics2>>::get_activation_factory().get_device_selector()
    }
}
DEFINE_CLSID!(Barometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,66,97,114,111,109,101,116,101,114,0]) [CLSID_Barometer]);
DEFINE_IID!(IID_IBarometer2, 851231768, 16107, 19716, 149, 116, 118, 51, 168, 120, 31, 159);
RT_INTERFACE!{interface IBarometer2(IBarometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarometer2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IBarometer2> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometerReading, 4122596070, 7670, 18970, 167, 173, 50, 29, 79, 93, 178, 71);
RT_INTERFACE!{interface IBarometerReading(IBarometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IBarometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_StationPressureInHectopascals(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IBarometerReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_station_pressure_in_hectopascals(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StationPressureInHectopascals)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class BarometerReading: IBarometerReading}
DEFINE_IID!(IID_IBarometerReading2, 2242004203, 37061, 18549, 137, 28, 56, 101, 180, 195, 87, 231);
RT_INTERFACE!{interface IBarometerReading2(IBarometerReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarometerReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IBarometerReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometerReadingChangedEventArgs, 1032098911, 891, 16463, 155, 187, 98, 50, 214, 149, 67, 195);
RT_INTERFACE!{interface IBarometerReadingChangedEventArgs(IBarometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBarometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut BarometerReading) -> HRESULT
}}
impl ComPtr<IBarometerReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<BarometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class BarometerReadingChangedEventArgs: IBarometerReadingChangedEventArgs}
DEFINE_IID!(IID_IBarometerStatics, 678110986, 739, 20358, 132, 252, 253, 216, 146, 181, 148, 15);
RT_INTERFACE!{static interface IBarometerStatics(IBarometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBarometerStatics] {
    fn GetDefault(&self, out: *mut *mut Barometer) -> HRESULT
}}
impl ComPtr<IBarometerStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Barometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IBarometerStatics2, 2412163559, 38399, 17580, 135, 142, 214, 92, 131, 8, 195, 76);
RT_INTERFACE!{static interface IBarometerStatics2(IBarometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBarometerStatics2] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Barometer>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IBarometerStatics2> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Barometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompass, 691010196, 6981, 16444, 186, 6, 177, 6, 219, 166, 154, 100);
RT_INTERFACE!{interface ICompass(ICompassVtbl): IInspectable(IInspectableVtbl) [IID_ICompass] {
    fn GetCurrentReading(&self, out: *mut *mut CompassReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Compass, CompassReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ICompass> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<CompassReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Compass, CompassReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Compass: ICompass}
impl RtActivatable<ICompassStatics> for Compass {}
impl RtActivatable<ICompassStatics2> for Compass {}
impl Compass {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Compass>>> {
        <Self as RtActivatable<ICompassStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ICompassStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Compass>>> {
        <Self as RtActivatable<ICompassStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Compass(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,67,111,109,112,97,115,115,0]) [CLSID_Compass]);
DEFINE_IID!(IID_ICompass2, 921857289, 51159, 17231, 180, 97, 151, 157, 223, 194, 50, 47);
RT_INTERFACE!{interface ICompass2(ICompass2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompass2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ComPtr<ICompass2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompass3, 2753855515, 50666, 19781, 160, 236, 75, 121, 31, 4, 26, 137);
RT_INTERFACE!{interface ICompass3(ICompass3Vtbl): IInspectable(IInspectableVtbl) [IID_ICompass3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ICompass3> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassDeviceId, 3514944041, 45189, 19229, 135, 10, 79, 245, 123, 167, 79, 212);
RT_INTERFACE!{interface ICompassDeviceId(ICompassDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_ICompassDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ICompassDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassReading, 2190545192, 20797, 19913, 183, 129, 94, 237, 251, 240, 45, 12);
RT_INTERFACE!{interface ICompassReading(ICompassReadingVtbl): IInspectable(IInspectableVtbl) [IID_ICompassReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_HeadingMagneticNorth(&self, out: *mut f64) -> HRESULT,
    fn get_HeadingTrueNorth(&self, out: *mut *mut foundation::IReference<f64>) -> HRESULT
}}
impl ComPtr<ICompassReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heading_magnetic_north(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeadingMagneticNorth)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_heading_true_north(&self) -> Result<Option<ComPtr<foundation::IReference<f64>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_HeadingTrueNorth)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompassReading: ICompassReading}
DEFINE_IID!(IID_ICompassReading2, 2973394462, 20923, 18962, 190, 221, 173, 71, 255, 135, 210, 232);
RT_INTERFACE!{interface ICompassReading2(ICompassReading2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompassReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<ICompassReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassReadingChangedEventArgs, 2400537008, 59580, 19582, 176, 9, 78, 65, 223, 19, 112, 114);
RT_INTERFACE!{interface ICompassReadingChangedEventArgs(ICompassReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICompassReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut CompassReading) -> HRESULT
}}
impl ComPtr<ICompassReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<CompassReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CompassReadingChangedEventArgs: ICompassReadingChangedEventArgs}
DEFINE_IID!(IID_ICompassReadingHeadingAccuracy, 3881907534, 35089, 16631, 158, 22, 110, 204, 125, 174, 197, 222);
RT_INTERFACE!{interface ICompassReadingHeadingAccuracy(ICompassReadingHeadingAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_ICompassReadingHeadingAccuracy] {
    fn get_HeadingAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl ComPtr<ICompassReadingHeadingAccuracy> {
    #[inline] pub fn get_heading_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_HeadingAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassStatics, 2596050911, 22252, 19493, 181, 77, 64, 166, 139, 181, 178, 105);
RT_INTERFACE!{static interface ICompassStatics(ICompassStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICompassStatics] {
    fn GetDefault(&self, out: *mut *mut Compass) -> HRESULT
}}
impl ComPtr<ICompassStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Compass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICompassStatics2, 181276333, 15274, 18832, 156, 228, 190, 9, 19, 117, 78, 210);
RT_INTERFACE!{static interface ICompassStatics2(ICompassStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ICompassStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Compass>) -> HRESULT
}}
impl ComPtr<ICompassStatics2> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Compass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometer, 4256803268, 33969, 19618, 151, 99, 155, 88, 149, 6, 199, 12);
RT_INTERFACE!{interface IGyrometer(IGyrometerVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometer] {
    fn GetCurrentReading(&self, out: *mut *mut GyrometerReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Gyrometer, GyrometerReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IGyrometer> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<GyrometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Gyrometer, GyrometerReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Gyrometer: IGyrometer}
impl RtActivatable<IGyrometerStatics> for Gyrometer {}
impl RtActivatable<IGyrometerStatics2> for Gyrometer {}
impl Gyrometer {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Gyrometer>>> {
        <Self as RtActivatable<IGyrometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IGyrometerStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Gyrometer>>> {
        <Self as RtActivatable<IGyrometerStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Gyrometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,71,121,114,111,109,101,116,101,114,0]) [CLSID_Gyrometer]);
DEFINE_IID!(IID_IGyrometer2, 1675568195, 36072, 16835, 172, 68, 134, 152, 129, 11, 85, 127);
RT_INTERFACE!{interface IGyrometer2(IGyrometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IGyrometer2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ComPtr<IGyrometer2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometer3, 1567590613, 36796, 17540, 145, 75, 82, 138, 223, 217, 71, 177);
RT_INTERFACE!{interface IGyrometer3(IGyrometer3Vtbl): IInspectable(IInspectableVtbl) [IID_IGyrometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IGyrometer3> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerDeviceId, 518383992, 35234, 17013, 158, 149, 113, 38, 244, 112, 135, 96);
RT_INTERFACE!{interface IGyrometerDeviceId(IGyrometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IGyrometerDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerReading, 3017203292, 7908, 17775, 157, 231, 226, 73, 59, 92, 142, 3);
RT_INTERFACE!{interface IGyrometerReading(IGyrometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AngularVelocityX(&self, out: *mut f64) -> HRESULT,
    fn get_AngularVelocityY(&self, out: *mut f64) -> HRESULT,
    fn get_AngularVelocityZ(&self, out: *mut f64) -> HRESULT
}}
impl ComPtr<IGyrometerReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity_x(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AngularVelocityX)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity_y(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AngularVelocityY)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angular_velocity_z(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AngularVelocityZ)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class GyrometerReading: IGyrometerReading}
DEFINE_IID!(IID_IGyrometerReading2, 380625212, 11145, 17595, 130, 43, 209, 225, 85, 111, 240, 155);
RT_INTERFACE!{interface IGyrometerReading2(IGyrometerReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IGyrometerReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerReadingChangedEventArgs, 266279061, 28574, 17102, 141, 88, 56, 140, 10, 184, 53, 109);
RT_INTERFACE!{interface IGyrometerReadingChangedEventArgs(IGyrometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut GyrometerReading) -> HRESULT
}}
impl ComPtr<IGyrometerReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<GyrometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class GyrometerReadingChangedEventArgs: IGyrometerReadingChangedEventArgs}
DEFINE_IID!(IID_IGyrometerStatics, 2209802185, 58525, 19257, 134, 230, 205, 85, 75, 228, 197, 193);
RT_INTERFACE!{static interface IGyrometerStatics(IGyrometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerStatics] {
    fn GetDefault(&self, out: *mut *mut Gyrometer) -> HRESULT
}}
impl ComPtr<IGyrometerStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Gyrometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IGyrometerStatics2, 4018403233, 55040, 16900, 150, 19, 121, 198, 177, 97, 223, 78);
RT_INTERFACE!{static interface IGyrometerStatics2(IGyrometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IGyrometerStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Gyrometer>) -> HRESULT
}}
impl ComPtr<IGyrometerStatics2> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Gyrometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IHingeAngleReading, 2748138937, 7153, 20325, 167, 4, 226, 218, 4, 241, 130, 192);
RT_INTERFACE!{interface IHingeAngleReading(IHingeAngleReadingVtbl): IInspectable(IInspectableVtbl) [IID_IHingeAngleReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AngleInDegrees(&self, out: *mut f64) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IHingeAngleReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_angle_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AngleInDegrees)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HingeAngleReading: IHingeAngleReading}
DEFINE_IID!(IID_IHingeAngleSensor, 3922968066, 49119, 17279, 140, 41, 136, 199, 115, 147, 211, 9);
RT_INTERFACE!{interface IHingeAngleSensor(IHingeAngleSensorVtbl): IInspectable(IInspectableVtbl) [IID_IHingeAngleSensor] {
    fn GetCurrentReadingAsync(&self, out: *mut *mut foundation::IAsyncOperation<HingeAngleReading>) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MinReportThresholdInDegrees(&self, out: *mut f64) -> HRESULT,
    fn get_ReportThresholdInDegrees(&self, out: *mut f64) -> HRESULT,
    fn put_ReportThresholdInDegrees(&self, value: f64) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IHingeAngleSensor> {
    #[inline] pub fn get_current_reading_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReadingAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min_report_threshold_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinReportThresholdInDegrees)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_report_threshold_in_degrees(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportThresholdInDegrees)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_threshold_in_degrees(&self, value: f64) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportThresholdInDegrees)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<HingeAngleSensor, HingeAngleSensorReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class HingeAngleSensor: IHingeAngleSensor}
impl RtActivatable<IHingeAngleSensorStatics> for HingeAngleSensor {}
impl HingeAngleSensor {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleSensor>>> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_related_to_adjacent_panels_async(firstPanelId: &HStringArg, secondPanelId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleSensor>>> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().get_related_to_adjacent_panels_async(firstPanelId, secondPanelId)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleSensor>>> {
        <Self as RtActivatable<IHingeAngleSensorStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(HingeAngleSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,72,105,110,103,101,65,110,103,108,101,83,101,110,115,111,114,0]) [CLSID_HingeAngleSensor]);
DEFINE_IID!(IID_IHingeAngleSensorReadingChangedEventArgs, 618222987, 64208, 17080, 168, 84, 120, 146, 48, 73, 161, 186);
RT_INTERFACE!{interface IHingeAngleSensorReadingChangedEventArgs(IHingeAngleSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHingeAngleSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut HingeAngleReading) -> HRESULT
}}
impl ComPtr<IHingeAngleSensorReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<HingeAngleReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class HingeAngleSensorReadingChangedEventArgs: IHingeAngleSensorReadingChangedEventArgs}
DEFINE_IID!(IID_IHingeAngleSensorStatics, 3082172688, 64433, 16675, 137, 206, 78, 163, 78, 176, 223, 202);
RT_INTERFACE!{static interface IHingeAngleSensorStatics(IHingeAngleSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHingeAngleSensorStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<HingeAngleSensor>) -> HRESULT,
    fn GetRelatedToAdjacentPanelsAsync(&self, firstPanelId: HSTRING, secondPanelId: HSTRING, out: *mut *mut foundation::IAsyncOperation<HingeAngleSensor>) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<HingeAngleSensor>) -> HRESULT
}}
impl ComPtr<IHingeAngleSensorStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_related_to_adjacent_panels_async(&self, firstPanelId: &HStringArg, secondPanelId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetRelatedToAdjacentPanelsAsync)(self.deref() as *const _ as *mut _, firstPanelId.get(), secondPanelId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<HingeAngleSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometer, 642304623, 8838, 16495, 145, 97, 240, 196, 189, 128, 110, 191);
RT_INTERFACE!{interface IInclinometer(IInclinometerVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometer] {
    fn GetCurrentReading(&self, out: *mut *mut InclinometerReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Inclinometer, InclinometerReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IInclinometer> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<InclinometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Inclinometer, InclinometerReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Inclinometer: IInclinometer}
impl RtActivatable<IInclinometerStatics> for Inclinometer {}
impl RtActivatable<IInclinometerStatics2> for Inclinometer {}
impl RtActivatable<IInclinometerStatics3> for Inclinometer {}
impl RtActivatable<IInclinometerStatics4> for Inclinometer {}
impl Inclinometer {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Inclinometer>>> {
        <Self as RtActivatable<IInclinometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_default_for_relative_readings() -> Result<Option<ComPtr<Inclinometer>>> {
        <Self as RtActivatable<IInclinometerStatics2>>::get_activation_factory().get_default_for_relative_readings()
    }
    #[inline] pub fn get_default_with_sensor_reading_type(sensorReadingtype: SensorReadingType) -> Result<Option<ComPtr<Inclinometer>>> {
        <Self as RtActivatable<IInclinometerStatics3>>::get_activation_factory().get_default_with_sensor_reading_type(sensorReadingtype)
    }
    #[inline] pub fn get_device_selector(readingType: SensorReadingType) -> Result<HString> {
        <Self as RtActivatable<IInclinometerStatics4>>::get_activation_factory().get_device_selector(readingType)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Inclinometer>>> {
        <Self as RtActivatable<IInclinometerStatics4>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Inclinometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,73,110,99,108,105,110,111,109,101,116,101,114,0]) [CLSID_Inclinometer]);
DEFINE_IID!(IID_IInclinometer2, 43987859, 10418, 17912, 187, 22, 97, 232, 106, 127, 174, 110);
RT_INTERFACE!{interface IInclinometer2(IInclinometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometer2] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT,
    fn get_ReadingType(&self, out: *mut SensorReadingType) -> HRESULT
}}
impl ComPtr<IInclinometer2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reading_type(&self) -> Result<SensorReadingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometer3, 973688836, 55141, 17284, 163, 215, 2, 131, 243, 171, 230, 174);
RT_INTERFACE!{interface IInclinometer3(IInclinometer3Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IInclinometer3> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerDeviceId, 32053634, 16895, 17414, 174, 131, 98, 33, 15, 241, 111, 227);
RT_INTERFACE!{interface IInclinometerDeviceId(IInclinometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IInclinometerDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerReading, 2672095317, 46838, 18815, 177, 39, 26, 119, 94, 80, 20, 88);
RT_INTERFACE!{interface IInclinometerReading(IInclinometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PitchDegrees(&self, out: *mut f32) -> HRESULT,
    fn get_RollDegrees(&self, out: *mut f32) -> HRESULT,
    fn get_YawDegrees(&self, out: *mut f32) -> HRESULT
}}
impl ComPtr<IInclinometerReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pitch_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PitchDegrees)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_roll_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RollDegrees)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_yaw_degrees(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_YawDegrees)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class InclinometerReading: IInclinometerReading}
DEFINE_IID!(IID_IInclinometerReading2, 1326860161, 59659, 18008, 137, 21, 1, 3, 224, 138, 128, 90);
RT_INTERFACE!{interface IInclinometerReading2(IInclinometerReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IInclinometerReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerReadingChangedEventArgs, 1256791489, 59371, 18744, 133, 17, 174, 13, 107, 68, 4, 56);
RT_INTERFACE!{interface IInclinometerReadingChangedEventArgs(IInclinometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut InclinometerReading) -> HRESULT
}}
impl ComPtr<IInclinometerReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<InclinometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class InclinometerReadingChangedEventArgs: IInclinometerReadingChangedEventArgs}
DEFINE_IID!(IID_IInclinometerReadingYawAccuracy, 3025397888, 8163, 18822, 162, 87, 230, 236, 226, 114, 57, 73);
RT_INTERFACE!{interface IInclinometerReadingYawAccuracy(IInclinometerReadingYawAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerReadingYawAccuracy] {
    fn get_YawAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl ComPtr<IInclinometerReadingYawAccuracy> {
    #[inline] pub fn get_yaw_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_YawAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics, 4063151441, 39984, 17722, 139, 73, 60, 62, 235, 51, 203, 97);
RT_INTERFACE!{static interface IInclinometerStatics(IInclinometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics] {
    fn GetDefault(&self, out: *mut *mut Inclinometer) -> HRESULT
}}
impl ComPtr<IInclinometerStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Inclinometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics2, 71276405, 27166, 18844, 134, 224, 99, 140, 26, 134, 75, 0);
RT_INTERFACE!{static interface IInclinometerStatics2(IInclinometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics2] {
    fn GetDefaultForRelativeReadings(&self, out: *mut *mut Inclinometer) -> HRESULT
}}
impl ComPtr<IInclinometerStatics2> {
    #[inline] pub fn get_default_for_relative_readings(&self) -> Result<Option<ComPtr<Inclinometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultForRelativeReadings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics3, 3181003392, 47386, 18473, 147, 146, 171, 192, 182, 189, 242, 180);
RT_INTERFACE!{static interface IInclinometerStatics3(IInclinometerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics3] {
    fn GetDefaultWithSensorReadingType(&self, sensorReadingtype: SensorReadingType, out: *mut *mut Inclinometer) -> HRESULT
}}
impl ComPtr<IInclinometerStatics3> {
    #[inline] pub fn get_default_with_sensor_reading_type(&self, sensorReadingtype: SensorReadingType) -> Result<Option<ComPtr<Inclinometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultWithSensorReadingType)(self.deref() as *const _ as *mut _, sensorReadingtype, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IInclinometerStatics4, 3904542457, 28293, 19075, 174, 208, 215, 205, 204, 152, 86, 200);
RT_INTERFACE!{static interface IInclinometerStatics4(IInclinometerStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IInclinometerStatics4] {
    fn GetDeviceSelector(&self, readingType: SensorReadingType, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Inclinometer>) -> HRESULT
}}
impl ComPtr<IInclinometerStatics4> {
    #[inline] pub fn get_device_selector(&self, readingType: SensorReadingType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Inclinometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensor, 4165732120, 3156, 18350, 146, 46, 120, 159, 87, 251, 3, 160);
RT_INTERFACE!{interface ILightSensor(ILightSensorVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensor] {
    fn GetCurrentReading(&self, out: *mut *mut LightSensorReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<LightSensor, LightSensorReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ILightSensor> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<LightSensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<LightSensor, LightSensorReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class LightSensor: ILightSensor}
impl RtActivatable<ILightSensorStatics> for LightSensor {}
impl RtActivatable<ILightSensorStatics2> for LightSensor {}
impl LightSensor {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<LightSensor>>> {
        <Self as RtActivatable<ILightSensorStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ILightSensorStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<LightSensor>>> {
        <Self as RtActivatable<ILightSensorStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(LightSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,76,105,103,104,116,83,101,110,115,111,114,0]) [CLSID_LightSensor]);
DEFINE_IID!(IID_ILightSensor2, 1214981352, 43340, 16528, 143, 72, 9, 247, 130, 169, 247, 213);
RT_INTERFACE!{interface ILightSensor2(ILightSensor2Vtbl): IInspectable(IInspectableVtbl) [IID_ILightSensor2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ILightSensor2> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorDeviceId, 2146322936, 2811, 20305, 135, 240, 108, 38, 55, 92, 233, 79);
RT_INTERFACE!{interface ILightSensorDeviceId(ILightSensorDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ILightSensorDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorReading, 4292829952, 8828, 19755, 179, 2, 252, 1, 66, 72, 92, 104);
RT_INTERFACE!{interface ILightSensorReading(ILightSensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_IlluminanceInLux(&self, out: *mut f32) -> HRESULT
}}
impl ComPtr<ILightSensorReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_illuminance_in_lux(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IlluminanceInLux)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class LightSensorReading: ILightSensorReading}
DEFINE_IID!(IID_ILightSensorReading2, 3075547525, 17571, 17609, 129, 144, 158, 246, 222, 10, 138, 116);
RT_INTERFACE!{interface ILightSensorReading2(ILightSensorReading2Vtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<ILightSensorReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorReadingChangedEventArgs, 2745365711, 9611, 16908, 184, 171, 142, 221, 96, 30, 207, 80);
RT_INTERFACE!{interface ILightSensorReadingChangedEventArgs(ILightSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut LightSensorReading) -> HRESULT
}}
impl ComPtr<ILightSensorReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<LightSensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class LightSensorReadingChangedEventArgs: ILightSensorReadingChangedEventArgs}
DEFINE_IID!(IID_ILightSensorStatics, 1172016260, 50088, 18206, 154, 83, 100, 87, 250, 216, 124, 14);
RT_INTERFACE!{static interface ILightSensorStatics(ILightSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorStatics] {
    fn GetDefault(&self, out: *mut *mut LightSensor) -> HRESULT
}}
impl ComPtr<ILightSensorStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<LightSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ILightSensorStatics2, 247506512, 56774, 16555, 172, 227, 236, 51, 89, 212, 44, 81);
RT_INTERFACE!{static interface ILightSensorStatics2(ILightSensorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ILightSensorStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<LightSensor>) -> HRESULT
}}
impl ComPtr<ILightSensorStatics2> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<LightSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometer, 1213162094, 54217, 16657, 179, 246, 44, 241, 250, 164, 24, 213);
RT_INTERFACE!{interface IMagnetometer(IMagnetometerVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometer] {
    fn GetCurrentReading(&self, out: *mut *mut MagnetometerReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Magnetometer, MagnetometerReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IMagnetometer> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<MagnetometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Magnetometer, MagnetometerReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Magnetometer: IMagnetometer}
impl RtActivatable<IMagnetometerStatics> for Magnetometer {}
impl RtActivatable<IMagnetometerStatics2> for Magnetometer {}
impl Magnetometer {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<Magnetometer>>> {
        <Self as RtActivatable<IMagnetometerStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IMagnetometerStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Magnetometer>>> {
        <Self as RtActivatable<IMagnetometerStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(Magnetometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,77,97,103,110,101,116,111,109,101,116,101,114,0]) [CLSID_Magnetometer]);
DEFINE_IID!(IID_IMagnetometer2, 3026545797, 9974, 17483, 169, 226, 162, 63, 150, 108, 211, 104);
RT_INTERFACE!{interface IMagnetometer2(IMagnetometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometer2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ComPtr<IMagnetometer2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometer3, 3197361020, 42533, 18671, 172, 247, 250, 193, 4, 131, 38, 113);
RT_INTERFACE!{interface IMagnetometer3(IMagnetometer3Vtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometer3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IMagnetometer3> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum MagnetometerAccuracy: i32 {
    Unknown = 0, Unreliable = 1, Approximate = 2, High = 3,
}}
DEFINE_IID!(IID_IMagnetometerDeviceId, 1488230594, 32331, 16460, 159, 197, 93, 232, 180, 14, 186, 227);
RT_INTERFACE!{interface IMagnetometerDeviceId(IMagnetometerDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IMagnetometerDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometerReading, 204260365, 60413, 20060, 187, 17, 175, 194, 155, 60, 174, 97);
RT_INTERFACE!{interface IMagnetometerReading(IMagnetometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_MagneticFieldX(&self, out: *mut f32) -> HRESULT,
    fn get_MagneticFieldY(&self, out: *mut f32) -> HRESULT,
    fn get_MagneticFieldZ(&self, out: *mut f32) -> HRESULT,
    fn get_DirectionalAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl ComPtr<IMagnetometerReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magnetic_field_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MagneticFieldX)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magnetic_field_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MagneticFieldY)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_magnetic_field_z(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MagneticFieldZ)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_directional_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DirectionalAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class MagnetometerReading: IMagnetometerReading}
DEFINE_IID!(IID_IMagnetometerReading2, 3569966177, 25049, 16459, 163, 40, 6, 111, 23, 122, 20, 9);
RT_INTERFACE!{interface IMagnetometerReading2(IMagnetometerReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IMagnetometerReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometerReadingChangedEventArgs, 401270898, 11961, 20199, 138, 208, 49, 39, 83, 125, 148, 155);
RT_INTERFACE!{interface IMagnetometerReadingChangedEventArgs(IMagnetometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut MagnetometerReading) -> HRESULT
}}
impl ComPtr<IMagnetometerReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<MagnetometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class MagnetometerReadingChangedEventArgs: IMagnetometerReadingChangedEventArgs}
DEFINE_IID!(IID_IMagnetometerStatics, 2235327692, 1688, 19930, 166, 223, 156, 185, 204, 74, 180, 10);
RT_INTERFACE!{static interface IMagnetometerStatics(IMagnetometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerStatics] {
    fn GetDefault(&self, out: *mut *mut Magnetometer) -> HRESULT
}}
impl ComPtr<IMagnetometerStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<Magnetometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IMagnetometerStatics2, 738728432, 65478, 20361, 160, 111, 24, 250, 16, 121, 41, 51);
RT_INTERFACE!{static interface IMagnetometerStatics2(IMagnetometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IMagnetometerStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Magnetometer>) -> HRESULT
}}
impl ComPtr<IMagnetometerStatics2> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Magnetometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensor, 1580549685, 53099, 19555, 171, 216, 16, 37, 43, 11, 246, 236);
RT_INTERFACE!{interface IOrientationSensor(IOrientationSensorVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensor] {
    fn GetCurrentReading(&self, out: *mut *mut OrientationSensorReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<OrientationSensor, OrientationSensorReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IOrientationSensor> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<OrientationSensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<OrientationSensor, OrientationSensorReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class OrientationSensor: IOrientationSensor}
impl RtActivatable<IOrientationSensorStatics> for OrientationSensor {}
impl RtActivatable<IOrientationSensorStatics2> for OrientationSensor {}
impl RtActivatable<IOrientationSensorStatics3> for OrientationSensor {}
impl RtActivatable<IOrientationSensorStatics4> for OrientationSensor {}
impl OrientationSensor {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<OrientationSensor>>> {
        <Self as RtActivatable<IOrientationSensorStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_default_for_relative_readings() -> Result<Option<ComPtr<OrientationSensor>>> {
        <Self as RtActivatable<IOrientationSensorStatics2>>::get_activation_factory().get_default_for_relative_readings()
    }
    #[inline] pub fn get_default_with_sensor_reading_type(sensorReadingtype: SensorReadingType) -> Result<Option<ComPtr<OrientationSensor>>> {
        <Self as RtActivatable<IOrientationSensorStatics3>>::get_activation_factory().get_default_with_sensor_reading_type(sensorReadingtype)
    }
    #[inline] pub fn get_default_with_sensor_reading_type_and_sensor_optimization_goal(sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<Option<ComPtr<OrientationSensor>>> {
        <Self as RtActivatable<IOrientationSensorStatics3>>::get_activation_factory().get_default_with_sensor_reading_type_and_sensor_optimization_goal(sensorReadingType, optimizationGoal)
    }
    #[inline] pub fn get_device_selector(readingType: SensorReadingType) -> Result<HString> {
        <Self as RtActivatable<IOrientationSensorStatics4>>::get_activation_factory().get_device_selector(readingType)
    }
    #[inline] pub fn get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(readingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<HString> {
        <Self as RtActivatable<IOrientationSensorStatics4>>::get_activation_factory().get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(readingType, optimizationGoal)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<OrientationSensor>>> {
        <Self as RtActivatable<IOrientationSensorStatics4>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(OrientationSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,79,114,105,101,110,116,97,116,105,111,110,83,101,110,115,111,114,0]) [CLSID_OrientationSensor]);
DEFINE_IID!(IID_IOrientationSensor2, 227691769, 12063, 18889, 128, 66, 74, 24, 19, 214, 119, 96);
RT_INTERFACE!{interface IOrientationSensor2(IOrientationSensor2Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensor2] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT,
    fn get_ReadingType(&self, out: *mut SensorReadingType) -> HRESULT
}}
impl ComPtr<IOrientationSensor2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_reading_type(&self) -> Result<SensorReadingType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensor3, 751720333, 25707, 18629, 183, 238, 68, 253, 196, 198, 170, 253);
RT_INTERFACE!{interface IOrientationSensor3(IOrientationSensor3Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensor3] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<IOrientationSensor3> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorDeviceId, 1516877384, 19497, 18924, 178, 143, 234, 29, 17, 123, 102, 240);
RT_INTERFACE!{interface IOrientationSensorDeviceId(IOrientationSensorDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<IOrientationSensorDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorReading, 1196870035, 26005, 18583, 188, 198, 213, 55, 238, 117, 117, 100);
RT_INTERFACE!{interface IOrientationSensorReading(IOrientationSensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_RotationMatrix(&self, out: *mut *mut SensorRotationMatrix) -> HRESULT,
    fn get_Quaternion(&self, out: *mut *mut SensorQuaternion) -> HRESULT
}}
impl ComPtr<IOrientationSensorReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rotation_matrix(&self) -> Result<Option<ComPtr<SensorRotationMatrix>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RotationMatrix)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_quaternion(&self) -> Result<Option<ComPtr<SensorQuaternion>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Quaternion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OrientationSensorReading: IOrientationSensorReading}
DEFINE_IID!(IID_IOrientationSensorReading2, 5729887, 18936, 19461, 158, 7, 36, 250, 199, 148, 8, 195);
RT_INTERFACE!{interface IOrientationSensorReading2(IOrientationSensorReading2Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<IOrientationSensorReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorReadingChangedEventArgs, 19665286, 50106, 18108, 174, 101, 122, 152, 153, 108, 191, 184);
RT_INTERFACE!{interface IOrientationSensorReadingChangedEventArgs(IOrientationSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut OrientationSensorReading) -> HRESULT
}}
impl ComPtr<IOrientationSensorReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<OrientationSensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class OrientationSensorReadingChangedEventArgs: IOrientationSensorReadingChangedEventArgs}
DEFINE_IID!(IID_IOrientationSensorReadingYawAccuracy, 3517749284, 16218, 18850, 188, 123, 17, 128, 188, 56, 205, 43);
RT_INTERFACE!{interface IOrientationSensorReadingYawAccuracy(IOrientationSensorReadingYawAccuracyVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorReadingYawAccuracy] {
    fn get_YawAccuracy(&self, out: *mut MagnetometerAccuracy) -> HRESULT
}}
impl ComPtr<IOrientationSensorReadingYawAccuracy> {
    #[inline] pub fn get_yaw_accuracy(&self) -> Result<MagnetometerAccuracy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_YawAccuracy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics, 284133138, 64332, 17034, 137, 139, 39, 101, 228, 9, 230, 105);
RT_INTERFACE!{static interface IOrientationSensorStatics(IOrientationSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics] {
    fn GetDefault(&self, out: *mut *mut OrientationSensor) -> HRESULT
}}
impl ComPtr<IOrientationSensorStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<OrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics2, 1507462411, 54282, 19569, 146, 118, 138, 39, 42, 10, 102, 25);
RT_INTERFACE!{static interface IOrientationSensorStatics2(IOrientationSensorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics2] {
    fn GetDefaultForRelativeReadings(&self, out: *mut *mut OrientationSensor) -> HRESULT
}}
impl ComPtr<IOrientationSensorStatics2> {
    #[inline] pub fn get_default_for_relative_readings(&self) -> Result<Option<ComPtr<OrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultForRelativeReadings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics3, 3626821920, 10103, 16639, 159, 89, 214, 84, 176, 133, 241, 47);
RT_INTERFACE!{static interface IOrientationSensorStatics3(IOrientationSensorStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics3] {
    fn GetDefaultWithSensorReadingType(&self, sensorReadingtype: SensorReadingType, out: *mut *mut OrientationSensor) -> HRESULT,
    fn GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal(&self, sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal, out: *mut *mut OrientationSensor) -> HRESULT
}}
impl ComPtr<IOrientationSensorStatics3> {
    #[inline] pub fn get_default_with_sensor_reading_type(&self, sensorReadingtype: SensorReadingType) -> Result<Option<ComPtr<OrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultWithSensorReadingType)(self.deref() as *const _ as *mut _, sensorReadingtype, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_with_sensor_reading_type_and_sensor_optimization_goal(&self, sensorReadingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<Option<ComPtr<OrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultWithSensorReadingTypeAndSensorOptimizationGoal)(self.deref() as *const _ as *mut _, sensorReadingType, optimizationGoal, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IOrientationSensorStatics4, 2793401173, 11397, 19240, 160, 254, 88, 196, 178, 4, 149, 245);
RT_INTERFACE!{static interface IOrientationSensorStatics4(IOrientationSensorStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IOrientationSensorStatics4] {
    fn GetDeviceSelector(&self, readingType: SensorReadingType, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal(&self, readingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<OrientationSensor>) -> HRESULT
}}
impl ComPtr<IOrientationSensorStatics4> {
    #[inline] pub fn get_device_selector(&self, readingType: SensorReadingType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, readingType, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_sensor_reading_type_and_sensor_optimization_goal(&self, readingType: SensorReadingType, optimizationGoal: SensorOptimizationGoal) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithSensorReadingTypeAndSensorOptimizationGoal)(self.deref() as *const _ as *mut _, readingType, optimizationGoal, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<OrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPedometer, 2585657661, 15768, 17912, 137, 32, 142, 78, 202, 202, 95, 151);
RT_INTERFACE!{interface IPedometer(IPedometerVtbl): IInspectable(IInspectableVtbl) [IID_IPedometer] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PowerInMilliwatts(&self, out: *mut f64) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<Pedometer, PedometerReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IPedometer> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_power_in_milliwatts(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PowerInMilliwatts)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<Pedometer, PedometerReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class Pedometer: IPedometer}
impl RtActivatable<IPedometerStatics> for Pedometer {}
impl RtActivatable<IPedometerStatics2> for Pedometer {}
impl Pedometer {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Pedometer>>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<Pedometer>>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_system_history_async(fromTime: foundation::DateTime) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_system_history_async(fromTime)
    }
    #[inline] pub fn get_system_history_with_duration_async(fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>>> {
        <Self as RtActivatable<IPedometerStatics>>::get_activation_factory().get_system_history_with_duration_async(fromTime, duration)
    }
    #[inline] pub fn get_readings_from_trigger_details(triggerDetails: &ComPtr<SensorDataThresholdTriggerDetails>) -> Result<Option<ComPtr<foundation::collections::IVectorView<PedometerReading>>>> {
        <Self as RtActivatable<IPedometerStatics2>>::get_activation_factory().get_readings_from_trigger_details(triggerDetails)
    }
}
DEFINE_CLSID!(Pedometer(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,101,100,111,109,101,116,101,114,0]) [CLSID_Pedometer]);
DEFINE_IID!(IID_IPedometer2, 3852732127, 11137, 19165, 178, 255, 119, 171, 108, 152, 186, 25);
RT_INTERFACE!{interface IPedometer2(IPedometer2Vtbl): IInspectable(IInspectableVtbl) [IID_IPedometer2] {
    fn GetCurrentReadings(&self, out: *mut *mut foundation::collections::IMapView<PedometerStepKind, PedometerReading>) -> HRESULT
}}
impl ComPtr<IPedometer2> {
    #[inline] pub fn get_current_readings(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<PedometerStepKind, PedometerReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReadings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PedometerDataThreshold: ISensorDataThreshold}
impl RtActivatable<IPedometerDataThresholdFactory> for PedometerDataThreshold {}
impl PedometerDataThreshold {
    #[inline] pub fn create(sensor: &ComPtr<Pedometer>, stepGoal: i32) -> Result<ComPtr<PedometerDataThreshold>> {
        <Self as RtActivatable<IPedometerDataThresholdFactory>>::get_activation_factory().create(sensor, stepGoal)
    }
}
DEFINE_CLSID!(PedometerDataThreshold(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,101,100,111,109,101,116,101,114,68,97,116,97,84,104,114,101,115,104,111,108,100,0]) [CLSID_PedometerDataThreshold]);
DEFINE_IID!(IID_IPedometerDataThresholdFactory, 3417149264, 31316, 18027, 144, 16, 119, 161, 98, 252, 165, 215);
RT_INTERFACE!{static interface IPedometerDataThresholdFactory(IPedometerDataThresholdFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerDataThresholdFactory] {
    fn Create(&self, sensor: *mut Pedometer, stepGoal: i32, out: *mut *mut PedometerDataThreshold) -> HRESULT
}}
impl ComPtr<IPedometerDataThresholdFactory> {
    #[inline] pub fn create(&self, sensor: &ComPtr<Pedometer>, stepGoal: i32) -> Result<ComPtr<PedometerDataThreshold>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, sensor.deref() as *const _ as *mut _, stepGoal, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPedometerReading, 575003892, 43233, 17199, 137, 106, 190, 13, 217, 176, 45, 36);
RT_INTERFACE!{interface IPedometerReading(IPedometerReadingVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerReading] {
    fn get_StepKind(&self, out: *mut PedometerStepKind) -> HRESULT,
    fn get_CumulativeSteps(&self, out: *mut i32) -> HRESULT,
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_CumulativeStepsDuration(&self, out: *mut foundation::TimeSpan) -> HRESULT
}}
impl ComPtr<IPedometerReading> {
    #[inline] pub fn get_step_kind(&self) -> Result<PedometerStepKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StepKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative_steps(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CumulativeSteps)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_cumulative_steps_duration(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CumulativeStepsDuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PedometerReading: IPedometerReading}
DEFINE_IID!(IID_IPedometerReadingChangedEventArgs, 4166378622, 43964, 17494, 134, 168, 37, 207, 43, 51, 55, 66);
RT_INTERFACE!{interface IPedometerReadingChangedEventArgs(IPedometerReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut PedometerReading) -> HRESULT
}}
impl ComPtr<IPedometerReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<PedometerReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class PedometerReadingChangedEventArgs: IPedometerReadingChangedEventArgs}
DEFINE_IID!(IID_IPedometerStatics, 2191002159, 16515, 19963, 180, 17, 147, 142, 160, 244, 185, 70);
RT_INTERFACE!{static interface IPedometerStatics(IPedometerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPedometerStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<Pedometer>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<Pedometer>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetSystemHistoryAsync(&self, fromTime: foundation::DateTime, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>) -> HRESULT,
    fn GetSystemHistoryWithDurationAsync(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>) -> HRESULT
}}
impl ComPtr<IPedometerStatics> {
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<Pedometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<Pedometer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_async(&self, fromTime: foundation::DateTime) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSystemHistoryAsync)(self.deref() as *const _ as *mut _, fromTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_system_history_with_duration_async(&self, fromTime: foundation::DateTime, duration: foundation::TimeSpan) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<PedometerReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSystemHistoryWithDurationAsync)(self.deref() as *const _ as *mut _, fromTime, duration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IPedometerStatics2, 2046150331, 52750, 16691, 180, 126, 134, 39, 234, 114, 246, 119);
RT_INTERFACE!{static interface IPedometerStatics2(IPedometerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPedometerStatics2] {
    fn GetReadingsFromTriggerDetails(&self, triggerDetails: *mut SensorDataThresholdTriggerDetails, out: *mut *mut foundation::collections::IVectorView<PedometerReading>) -> HRESULT
}}
impl ComPtr<IPedometerStatics2> {
    #[inline] pub fn get_readings_from_trigger_details(&self, triggerDetails: &ComPtr<SensorDataThresholdTriggerDetails>) -> Result<Option<ComPtr<foundation::collections::IVectorView<PedometerReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetReadingsFromTriggerDetails)(self.deref() as *const _ as *mut _, triggerDetails.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum PedometerStepKind: i32 {
    Unknown = 0, Walking = 1, Running = 2,
}}
DEFINE_IID!(IID_IProximitySensor, 1421899448, 60667, 18756, 185, 40, 116, 252, 80, 77, 71, 238);
RT_INTERFACE!{interface IProximitySensor(IProximitySensorVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensor] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MaxDistanceInMillimeters(&self, out: *mut *mut foundation::IReference<u32>) -> HRESULT,
    fn get_MinDistanceInMillimeters(&self, out: *mut *mut foundation::IReference<u32>) -> HRESULT,
    fn GetCurrentReading(&self, out: *mut *mut ProximitySensorReading) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<ProximitySensor, ProximitySensorReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn CreateDisplayOnOffController(&self, out: *mut *mut ProximitySensorDisplayOnOffController) -> HRESULT
}}
impl ComPtr<IProximitySensor> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_distance_in_millimeters(&self) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MaxDistanceInMillimeters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_min_distance_in_millimeters(&self) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MinDistanceInMillimeters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<ProximitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<ProximitySensor, ProximitySensorReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn create_display_on_off_controller(&self) -> Result<Option<ComPtr<ProximitySensorDisplayOnOffController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateDisplayOnOffController)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensor: IProximitySensor}
impl RtActivatable<IProximitySensorStatics> for ProximitySensor {}
impl RtActivatable<IProximitySensorStatics2> for ProximitySensor {}
impl ProximitySensor {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IProximitySensorStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id(sensorId: &HStringArg) -> Result<Option<ComPtr<ProximitySensor>>> {
        <Self as RtActivatable<IProximitySensorStatics>>::get_activation_factory().from_id(sensorId)
    }
    #[inline] pub fn get_readings_from_trigger_details(triggerDetails: &ComPtr<SensorDataThresholdTriggerDetails>) -> Result<Option<ComPtr<foundation::collections::IVectorView<ProximitySensorReading>>>> {
        <Self as RtActivatable<IProximitySensorStatics2>>::get_activation_factory().get_readings_from_trigger_details(triggerDetails)
    }
}
DEFINE_CLSID!(ProximitySensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,114,111,120,105,109,105,116,121,83,101,110,115,111,114,0]) [CLSID_ProximitySensor]);
RT_CLASS!{class ProximitySensorDataThreshold: ISensorDataThreshold}
impl RtActivatable<IProximitySensorDataThresholdFactory> for ProximitySensorDataThreshold {}
impl ProximitySensorDataThreshold {
    #[inline] pub fn create(sensor: &ComPtr<ProximitySensor>) -> Result<ComPtr<ProximitySensorDataThreshold>> {
        <Self as RtActivatable<IProximitySensorDataThresholdFactory>>::get_activation_factory().create(sensor)
    }
}
DEFINE_CLSID!(ProximitySensorDataThreshold(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,80,114,111,120,105,109,105,116,121,83,101,110,115,111,114,68,97,116,97,84,104,114,101,115,104,111,108,100,0]) [CLSID_ProximitySensorDataThreshold]);
DEFINE_IID!(IID_IProximitySensorDataThresholdFactory, 2421866785, 27943, 19155, 157, 181, 100, 103, 242, 165, 173, 157);
RT_INTERFACE!{static interface IProximitySensorDataThresholdFactory(IProximitySensorDataThresholdFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorDataThresholdFactory] {
    fn Create(&self, sensor: *mut ProximitySensor, out: *mut *mut ProximitySensorDataThreshold) -> HRESULT
}}
impl ComPtr<IProximitySensorDataThresholdFactory> {
    #[inline] pub fn create(&self, sensor: &ComPtr<ProximitySensor>) -> Result<ComPtr<ProximitySensorDataThreshold>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, sensor.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensorDisplayOnOffController: foundation::IClosable}
DEFINE_IID!(IID_IProximitySensorReading, 1898089817, 4909, 19807, 143, 249, 47, 13, 184, 117, 28, 237);
RT_INTERFACE!{interface IProximitySensorReading(IProximitySensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_IsDetected(&self, out: *mut bool) -> HRESULT,
    fn get_DistanceInMillimeters(&self, out: *mut *mut foundation::IReference<u32>) -> HRESULT
}}
impl ComPtr<IProximitySensorReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_detected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDetected)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_distance_in_millimeters(&self) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DistanceInMillimeters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensorReading: IProximitySensorReading}
DEFINE_IID!(IID_IProximitySensorReadingChangedEventArgs, 3485660006, 50152, 16637, 140, 195, 103, 226, 137, 0, 73, 56);
RT_INTERFACE!{interface IProximitySensorReadingChangedEventArgs(IProximitySensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut ProximitySensorReading) -> HRESULT
}}
impl ComPtr<IProximitySensorReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<ProximitySensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class ProximitySensorReadingChangedEventArgs: IProximitySensorReadingChangedEventArgs}
DEFINE_IID!(IID_IProximitySensorStatics, 689464905, 25193, 20055, 165, 173, 130, 190, 128, 129, 51, 146);
RT_INTERFACE!{static interface IProximitySensorStatics(IProximitySensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromId(&self, sensorId: HSTRING, out: *mut *mut ProximitySensor) -> HRESULT
}}
impl ComPtr<IProximitySensorStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id(&self, sensorId: &HStringArg) -> Result<Option<ComPtr<ProximitySensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromId)(self.deref() as *const _ as *mut _, sensorId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IProximitySensorStatics2, 3421795246, 59850, 16943, 173, 103, 76, 61, 37, 223, 53, 12);
RT_INTERFACE!{static interface IProximitySensorStatics2(IProximitySensorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IProximitySensorStatics2] {
    fn GetReadingsFromTriggerDetails(&self, triggerDetails: *mut SensorDataThresholdTriggerDetails, out: *mut *mut foundation::collections::IVectorView<ProximitySensorReading>) -> HRESULT
}}
impl ComPtr<IProximitySensorStatics2> {
    #[inline] pub fn get_readings_from_trigger_details(&self, triggerDetails: &ComPtr<SensorDataThresholdTriggerDetails>) -> Result<Option<ComPtr<foundation::collections::IVectorView<ProximitySensorReading>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetReadingsFromTriggerDetails)(self.deref() as *const _ as *mut _, triggerDetails.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISensorDataThreshold, 1423633505, 65099, 19975, 178, 96, 58, 76, 223, 190, 57, 110);
RT_INTERFACE!{interface ISensorDataThreshold(ISensorDataThresholdVtbl): IInspectable(IInspectableVtbl) [IID_ISensorDataThreshold] {
    
}}
DEFINE_IID!(IID_ISensorDataThresholdTriggerDetails, 2433151415, 59533, 18609, 188, 144, 97, 156, 123, 52, 147, 145);
RT_INTERFACE!{interface ISensorDataThresholdTriggerDetails(ISensorDataThresholdTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISensorDataThresholdTriggerDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SensorType(&self, out: *mut SensorType) -> HRESULT
}}
impl ComPtr<ISensorDataThresholdTriggerDetails> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sensor_type(&self) -> Result<SensorType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SensorType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SensorDataThresholdTriggerDetails: ISensorDataThresholdTriggerDetails}
RT_ENUM! { enum SensorOptimizationGoal: i32 {
    Precision = 0, PowerEfficiency = 1,
}}
DEFINE_IID!(IID_ISensorQuaternion, 3385182247, 50972, 18151, 157, 163, 54, 161, 147, 178, 50, 188);
RT_INTERFACE!{interface ISensorQuaternion(ISensorQuaternionVtbl): IInspectable(IInspectableVtbl) [IID_ISensorQuaternion] {
    fn get_W(&self, out: *mut f32) -> HRESULT,
    fn get_X(&self, out: *mut f32) -> HRESULT,
    fn get_Y(&self, out: *mut f32) -> HRESULT,
    fn get_Z(&self, out: *mut f32) -> HRESULT
}}
impl ComPtr<ISensorQuaternion> {
    #[inline] pub fn get_w(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_W)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_x(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_X)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_y(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Y)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_z(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Z)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SensorQuaternion: ISensorQuaternion}
RT_ENUM! { enum SensorReadingType: i32 {
    Absolute = 0, Relative = 1,
}}
DEFINE_IID!(IID_ISensorRotationMatrix, 171792999, 8948, 17298, 149, 56, 101, 208, 189, 6, 74, 166);
RT_INTERFACE!{interface ISensorRotationMatrix(ISensorRotationMatrixVtbl): IInspectable(IInspectableVtbl) [IID_ISensorRotationMatrix] {
    fn get_M11(&self, out: *mut f32) -> HRESULT,
    fn get_M12(&self, out: *mut f32) -> HRESULT,
    fn get_M13(&self, out: *mut f32) -> HRESULT,
    fn get_M21(&self, out: *mut f32) -> HRESULT,
    fn get_M22(&self, out: *mut f32) -> HRESULT,
    fn get_M23(&self, out: *mut f32) -> HRESULT,
    fn get_M31(&self, out: *mut f32) -> HRESULT,
    fn get_M32(&self, out: *mut f32) -> HRESULT,
    fn get_M33(&self, out: *mut f32) -> HRESULT
}}
impl ComPtr<ISensorRotationMatrix> {
    #[inline] pub fn get_m11(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M11)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m12(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M12)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m13(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M13)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m21(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M21)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m22(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M22)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m23(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M23)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m31(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M31)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m32(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M32)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_m33(&self) -> Result<f32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_M33)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SensorRotationMatrix: ISensorRotationMatrix}
RT_ENUM! { enum SensorType: i32 {
    Accelerometer = 0, ActivitySensor = 1, Barometer = 2, Compass = 3, CustomSensor = 4, Gyroscope = 5, ProximitySensor = 6, Inclinometer = 7, LightSensor = 8, OrientationSensor = 9, Pedometer = 10, RelativeInclinometer = 11, RelativeOrientationSensor = 12, SimpleOrientationSensor = 13,
}}
RT_ENUM! { enum SimpleOrientation: i32 {
    NotRotated = 0, Rotated90DegreesCounterclockwise = 1, Rotated180DegreesCounterclockwise = 2, Rotated270DegreesCounterclockwise = 3, Faceup = 4, Facedown = 5,
}}
DEFINE_IID!(IID_ISimpleOrientationSensor, 1609906262, 8522, 19950, 163, 249, 97, 111, 26, 176, 111, 253);
RT_INTERFACE!{interface ISimpleOrientationSensor(ISimpleOrientationSensorVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensor] {
    fn GetCurrentOrientation(&self, out: *mut SimpleOrientation) -> HRESULT,
    fn add_OrientationChanged(&self, handler: *mut foundation::TypedEventHandler<SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OrientationChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ISimpleOrientationSensor> {
    #[inline] pub fn get_current_orientation(&self) -> Result<SimpleOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetCurrentOrientation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_orientation_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<SimpleOrientationSensor, SimpleOrientationSensorOrientationChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_OrientationChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_orientation_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_OrientationChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleOrientationSensor: ISimpleOrientationSensor}
impl RtActivatable<ISimpleOrientationSensorStatics> for SimpleOrientationSensor {}
impl RtActivatable<ISimpleOrientationSensorStatics2> for SimpleOrientationSensor {}
impl SimpleOrientationSensor {
    #[inline] pub fn get_default() -> Result<Option<ComPtr<SimpleOrientationSensor>>> {
        <Self as RtActivatable<ISimpleOrientationSensorStatics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISimpleOrientationSensorStatics2>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SimpleOrientationSensor>>> {
        <Self as RtActivatable<ISimpleOrientationSensorStatics2>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(SimpleOrientationSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,83,105,109,112,108,101,79,114,105,101,110,116,97,116,105,111,110,83,101,110,115,111,114,0]) [CLSID_SimpleOrientationSensor]);
DEFINE_IID!(IID_ISimpleOrientationSensor2, 2725750680, 34928, 17726, 139, 214, 184, 245, 216, 215, 148, 27);
RT_INTERFACE!{interface ISimpleOrientationSensor2(ISimpleOrientationSensor2Vtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensor2] {
    #[cfg(feature="windows-graphics")] fn put_ReadingTransform(&self, value: super::super::graphics::display::DisplayOrientations) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn get_ReadingTransform(&self, out: *mut super::super::graphics::display::DisplayOrientations) -> HRESULT
}}
impl ComPtr<ISimpleOrientationSensor2> {
    #[cfg(feature="windows-graphics")] #[inline] pub fn set_reading_transform(&self, value: super::super::graphics::display::DisplayOrientations) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadingTransform)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-graphics")] #[inline] pub fn get_reading_transform(&self) -> Result<super::super::graphics::display::DisplayOrientations> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadingTransform)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleOrientationSensorDeviceId, 4223666891, 15222, 16886, 128, 145, 48, 239, 230, 70, 211, 207);
RT_INTERFACE!{interface ISimpleOrientationSensorDeviceId(ISimpleOrientationSensorDeviceIdVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorDeviceId] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ISimpleOrientationSensorDeviceId> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleOrientationSensorOrientationChangedEventArgs, 3168126560, 9172, 19276, 162, 46, 186, 129, 173, 224, 198, 1);
RT_INTERFACE!{interface ISimpleOrientationSensorOrientationChangedEventArgs(ISimpleOrientationSensorOrientationChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorOrientationChangedEventArgs] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Orientation(&self, out: *mut SimpleOrientation) -> HRESULT
}}
impl ComPtr<ISimpleOrientationSensorOrientationChangedEventArgs> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_orientation(&self) -> Result<SimpleOrientation> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Orientation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SimpleOrientationSensorOrientationChangedEventArgs: ISimpleOrientationSensorOrientationChangedEventArgs}
DEFINE_IID!(IID_ISimpleOrientationSensorStatics, 1928136303, 28842, 16582, 155, 27, 52, 51, 247, 69, 155, 78);
RT_INTERFACE!{static interface ISimpleOrientationSensorStatics(ISimpleOrientationSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorStatics] {
    fn GetDefault(&self, out: *mut *mut SimpleOrientationSensor) -> HRESULT
}}
impl ComPtr<ISimpleOrientationSensorStatics> {
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<SimpleOrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISimpleOrientationSensorStatics2, 2224004223, 45368, 19985, 137, 16, 162, 162, 163, 181, 109, 131);
RT_INTERFACE!{static interface ISimpleOrientationSensorStatics2(ISimpleOrientationSensorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISimpleOrientationSensorStatics2] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<SimpleOrientationSensor>) -> HRESULT
}}
impl ComPtr<ISimpleOrientationSensorStatics2> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SimpleOrientationSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
pub mod custom { // Windows.Devices.Sensors.Custom
use crate::prelude::*;
DEFINE_IID!(IID_ICustomSensor, 2704734637, 16436, 19277, 153, 221, 83, 26, 172, 100, 156, 9);
RT_INTERFACE!{interface ICustomSensor(ICustomSensorVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensor] {
    fn GetCurrentReading(&self, out: *mut *mut CustomSensorReading) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT,
    fn put_ReportInterval(&self, value: u32) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn add_ReadingChanged(&self, handler: *mut foundation::TypedEventHandler<CustomSensor, CustomSensorReadingChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ReadingChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ICustomSensor> {
    #[inline] pub fn get_current_reading(&self) -> Result<Option<ComPtr<CustomSensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetCurrentReading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_minimum_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinimumReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_report_interval(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportInterval)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_interval(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_reading_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<CustomSensor, CustomSensorReadingChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ReadingChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_reading_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ReadingChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSensor: ICustomSensor}
impl RtActivatable<ICustomSensorStatics> for CustomSensor {}
impl CustomSensor {
    #[inline] pub fn get_device_selector(interfaceId: Guid) -> Result<HString> {
        <Self as RtActivatable<ICustomSensorStatics>>::get_activation_factory().get_device_selector(interfaceId)
    }
    #[inline] pub fn from_id_async(sensorId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<CustomSensor>>> {
        <Self as RtActivatable<ICustomSensorStatics>>::get_activation_factory().from_id_async(sensorId)
    }
}
DEFINE_CLSID!(CustomSensor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,110,115,111,114,115,46,67,117,115,116,111,109,46,67,117,115,116,111,109,83,101,110,115,111,114,0]) [CLSID_CustomSensor]);
DEFINE_IID!(IID_ICustomSensor2, 551235857, 60504, 19871, 191, 189, 231, 120, 37, 8, 133, 16);
RT_INTERFACE!{interface ICustomSensor2(ICustomSensor2Vtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensor2] {
    fn put_ReportLatency(&self, value: u32) -> HRESULT,
    fn get_ReportLatency(&self, out: *mut u32) -> HRESULT,
    fn get_MaxBatchSize(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ICustomSensor2> {
    #[inline] pub fn set_report_latency(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReportLatency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_report_latency(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReportLatency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_batch_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxBatchSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICustomSensorReading, 1677741901, 17514, 17254, 168, 122, 95, 150, 50, 104, 236, 83);
RT_INTERFACE!{interface ICustomSensorReading(ICustomSensorReadingVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorReading] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl ComPtr<ICustomSensorReading> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::IMapView<HString, IInspectable>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSensorReading: ICustomSensorReading}
DEFINE_IID!(IID_ICustomSensorReading2, 574396650, 49011, 18834, 154, 72, 211, 200, 151, 89, 76, 203);
RT_INTERFACE!{interface ICustomSensorReading2(ICustomSensorReading2Vtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorReading2] {
    fn get_PerformanceCount(&self, out: *mut *mut foundation::IReference<foundation::TimeSpan>) -> HRESULT
}}
impl ComPtr<ICustomSensorReading2> {
    #[inline] pub fn get_performance_count(&self) -> Result<Option<ComPtr<foundation::IReference<foundation::TimeSpan>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PerformanceCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ICustomSensorReadingChangedEventArgs, 1797267491, 53245, 19649, 143, 240, 226, 24, 35, 215, 111, 204);
RT_INTERFACE!{interface ICustomSensorReadingChangedEventArgs(ICustomSensorReadingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorReadingChangedEventArgs] {
    fn get_Reading(&self, out: *mut *mut CustomSensorReading) -> HRESULT
}}
impl ComPtr<ICustomSensorReadingChangedEventArgs> {
    #[inline] pub fn get_reading(&self) -> Result<Option<ComPtr<CustomSensorReading>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reading)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CustomSensorReadingChangedEventArgs: ICustomSensorReadingChangedEventArgs}
DEFINE_IID!(IID_ICustomSensorStatics, 2569032399, 62498, 19581, 131, 107, 231, 220, 116, 167, 18, 75);
RT_INTERFACE!{static interface ICustomSensorStatics(ICustomSensorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICustomSensorStatics] {
    fn GetDeviceSelector(&self, interfaceId: Guid, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, sensorId: HSTRING, out: *mut *mut foundation::IAsyncOperation<CustomSensor>) -> HRESULT
}}
impl ComPtr<ICustomSensorStatics> {
    #[inline] pub fn get_device_selector(&self, interfaceId: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, interfaceId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, sensorId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<CustomSensor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, sensorId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Sensors.Custom
} // Windows.Devices.Sensors
pub mod serialcommunication { // Windows.Devices.SerialCommunication
use crate::prelude::*;
DEFINE_IID!(IID_IErrorReceivedEventArgs, 4240883545, 4739, 19850, 191, 223, 86, 107, 51, 221, 178, 143);
RT_INTERFACE!{interface IErrorReceivedEventArgs(IErrorReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IErrorReceivedEventArgs] {
    fn get_Error(&self, out: *mut SerialError) -> HRESULT
}}
impl ComPtr<IErrorReceivedEventArgs> {
    #[inline] pub fn get_error(&self) -> Result<SerialError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class ErrorReceivedEventArgs: IErrorReceivedEventArgs}
DEFINE_IID!(IID_IPinChangedEventArgs, 2730433968, 64668, 17927, 147, 208, 250, 94, 131, 67, 238, 34);
RT_INTERFACE!{interface IPinChangedEventArgs(IPinChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPinChangedEventArgs] {
    fn get_PinChange(&self, out: *mut SerialPinChange) -> HRESULT
}}
impl ComPtr<IPinChangedEventArgs> {
    #[inline] pub fn get_pin_change(&self) -> Result<SerialPinChange> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PinChange)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class PinChangedEventArgs: IPinChangedEventArgs}
DEFINE_IID!(IID_ISerialDevice, 3783773382, 8720, 16719, 182, 90, 245, 85, 58, 3, 55, 42);
RT_INTERFACE!{interface ISerialDevice(ISerialDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ISerialDevice] {
    fn get_BaudRate(&self, out: *mut u32) -> HRESULT,
    fn put_BaudRate(&self, value: u32) -> HRESULT,
    fn get_BreakSignalState(&self, out: *mut bool) -> HRESULT,
    fn put_BreakSignalState(&self, value: bool) -> HRESULT,
    fn get_BytesReceived(&self, out: *mut u32) -> HRESULT,
    fn get_CarrierDetectState(&self, out: *mut bool) -> HRESULT,
    fn get_ClearToSendState(&self, out: *mut bool) -> HRESULT,
    fn get_DataBits(&self, out: *mut u16) -> HRESULT,
    fn put_DataBits(&self, value: u16) -> HRESULT,
    fn get_DataSetReadyState(&self, out: *mut bool) -> HRESULT,
    fn get_Handshake(&self, out: *mut SerialHandshake) -> HRESULT,
    fn put_Handshake(&self, value: SerialHandshake) -> HRESULT,
    fn get_IsDataTerminalReadyEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDataTerminalReadyEnabled(&self, value: bool) -> HRESULT,
    fn get_IsRequestToSendEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsRequestToSendEnabled(&self, value: bool) -> HRESULT,
    fn get_Parity(&self, out: *mut SerialParity) -> HRESULT,
    fn put_Parity(&self, value: SerialParity) -> HRESULT,
    fn get_PortName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ReadTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_ReadTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    fn get_StopBits(&self, out: *mut SerialStopBitCount) -> HRESULT,
    fn put_StopBits(&self, value: SerialStopBitCount) -> HRESULT,
    fn get_UsbVendorId(&self, out: *mut u16) -> HRESULT,
    fn get_UsbProductId(&self, out: *mut u16) -> HRESULT,
    fn get_WriteTimeout(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn put_WriteTimeout(&self, value: foundation::TimeSpan) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy27(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut *mut super::super::storage::streams::IInputStream) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy28(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut *mut super::super::storage::streams::IOutputStream) -> HRESULT,
    fn add_ErrorReceived(&self, reportHandler: *mut foundation::TypedEventHandler<SerialDevice, ErrorReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ErrorReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_PinChanged(&self, reportHandler: *mut foundation::TypedEventHandler<SerialDevice, PinChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PinChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ISerialDevice> {
    #[inline] pub fn get_baud_rate(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BaudRate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_baud_rate(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BaudRate)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_break_signal_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BreakSignalState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_break_signal_state(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BreakSignalState)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_bytes_received(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BytesReceived)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_carrier_detect_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CarrierDetectState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_clear_to_send_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClearToSendState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_data_bits(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataBits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_bits(&self, value: u16) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DataBits)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_set_ready_state(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataSetReadyState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_handshake(&self) -> Result<SerialHandshake> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Handshake)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_handshake(&self, value: SerialHandshake) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Handshake)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_data_terminal_ready_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDataTerminalReadyEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_data_terminal_ready_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDataTerminalReadyEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_request_to_send_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsRequestToSendEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_request_to_send_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsRequestToSendEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_parity(&self) -> Result<SerialParity> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Parity)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_parity(&self, value: SerialParity) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Parity)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_port_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PortName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_read_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_read_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadTimeout)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_stop_bits(&self) -> Result<SerialStopBitCount> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_StopBits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_stop_bits(&self, value: SerialStopBitCount) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_StopBits)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_usb_vendor_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsbVendorId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_usb_product_id(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UsbProductId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_write_timeout(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteTimeout)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_write_timeout(&self, value: foundation::TimeSpan) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_WriteTimeout)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IInputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IOutputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_error_received(&self, reportHandler: &ComPtr<foundation::TypedEventHandler<SerialDevice, ErrorReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ErrorReceived)(self.deref() as *const _ as *mut _, reportHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_error_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ErrorReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_pin_changed(&self, reportHandler: &ComPtr<foundation::TypedEventHandler<SerialDevice, PinChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_PinChanged)(self.deref() as *const _ as *mut _, reportHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_pin_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_PinChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SerialDevice: ISerialDevice}
impl RtActivatable<ISerialDeviceStatics> for SerialDevice {}
impl SerialDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_port_name(portName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().get_device_selector_from_port_name(portName)
    }
    #[inline] pub fn get_device_selector_from_usb_vid_pid(vendorId: u16, productId: u16) -> Result<HString> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().get_device_selector_from_usb_vid_pid(vendorId, productId)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SerialDevice>>> {
        <Self as RtActivatable<ISerialDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(SerialDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,101,114,105,97,108,67,111,109,109,117,110,105,99,97,116,105,111,110,46,83,101,114,105,97,108,68,101,118,105,99,101,0]) [CLSID_SerialDevice]);
DEFINE_IID!(IID_ISerialDeviceStatics, 93080176, 2102, 18835, 174, 26, 182, 26, 227, 190, 5, 107);
RT_INTERFACE!{static interface ISerialDeviceStatics(ISerialDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISerialDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromPortName(&self, portName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromUsbVidPid(&self, vendorId: u16, productId: u16, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<SerialDevice>) -> HRESULT
}}
impl ComPtr<ISerialDeviceStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_port_name(&self, portName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromPortName)(self.deref() as *const _ as *mut _, portName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_usb_vid_pid(&self, vendorId: u16, productId: u16) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromUsbVidPid)(self.deref() as *const _ as *mut _, vendorId, productId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SerialDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SerialError: i32 {
    Frame = 0, BufferOverrun = 1, ReceiveFull = 2, ReceiveParity = 3, TransmitFull = 4,
}}
RT_ENUM! { enum SerialHandshake: i32 {
    None = 0, RequestToSend = 1, XOnXOff = 2, RequestToSendXOnXOff = 3,
}}
RT_ENUM! { enum SerialParity: i32 {
    None = 0, Odd = 1, Even = 2, Mark = 3, Space = 4,
}}
RT_ENUM! { enum SerialPinChange: i32 {
    BreakSignal = 0, CarrierDetect = 1, ClearToSend = 2, DataSetReady = 3, RingIndicator = 4,
}}
RT_ENUM! { enum SerialStopBitCount: i32 {
    One = 0, OnePointFive = 1, Two = 2,
}}
} // Windows.Devices.SerialCommunication
pub mod smartcards { // Windows.Devices.SmartCards
use crate::prelude::*;
DEFINE_IID!(IID_ICardAddedEventArgs, 414969752, 61835, 19923, 177, 24, 223, 178, 200, 226, 60, 198);
RT_INTERFACE!{interface ICardAddedEventArgs(ICardAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICardAddedEventArgs] {
    fn get_SmartCard(&self, out: *mut *mut SmartCard) -> HRESULT
}}
impl ComPtr<ICardAddedEventArgs> {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<ComPtr<SmartCard>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SmartCard)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CardAddedEventArgs: ICardAddedEventArgs}
DEFINE_IID!(IID_ICardRemovedEventArgs, 355670703, 8919, 18757, 175, 201, 3, 180, 111, 66, 166, 205);
RT_INTERFACE!{interface ICardRemovedEventArgs(ICardRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICardRemovedEventArgs] {
    fn get_SmartCard(&self, out: *mut *mut SmartCard) -> HRESULT
}}
impl ComPtr<ICardRemovedEventArgs> {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<ComPtr<SmartCard>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SmartCard)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class CardRemovedEventArgs: ICardRemovedEventArgs}
DEFINE_IID!(IID_IKnownSmartCardAppletIds, 2063915224, 38324, 19592, 140, 234, 65, 30, 85, 81, 30, 252);
RT_INTERFACE!{static interface IKnownSmartCardAppletIds(IKnownSmartCardAppletIdsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownSmartCardAppletIds] {
    #[cfg(feature="windows-storage")] fn get_PaymentSystemEnvironment(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ProximityPaymentSystemEnvironment(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IKnownSmartCardAppletIds> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_payment_system_environment(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PaymentSystemEnvironment)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_proximity_payment_system_environment(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProximityPaymentSystemEnvironment)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{static class KnownSmartCardAppletIds}
impl RtActivatable<IKnownSmartCardAppletIds> for KnownSmartCardAppletIds {}
impl KnownSmartCardAppletIds {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_payment_system_environment() -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> {
        <Self as RtActivatable<IKnownSmartCardAppletIds>>::get_activation_factory().get_payment_system_environment()
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn get_proximity_payment_system_environment() -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> {
        <Self as RtActivatable<IKnownSmartCardAppletIds>>::get_activation_factory().get_proximity_payment_system_environment()
    }
}
DEFINE_CLSID!(KnownSmartCardAppletIds(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,75,110,111,119,110,83,109,97,114,116,67,97,114,100,65,112,112,108,101,116,73,100,115,0]) [CLSID_KnownSmartCardAppletIds]);
DEFINE_IID!(IID_ISmartCard, 460425329, 25652, 17396, 181, 90, 106, 41, 98, 56, 112, 170);
RT_INTERFACE!{interface ISmartCard(ISmartCardVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCard] {
    fn get_Reader(&self, out: *mut *mut SmartCardReader) -> HRESULT,
    fn GetStatusAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardStatus>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetAnswerToResetAsync(&self, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT
}}
impl ComPtr<ISmartCard> {
    #[inline] pub fn get_reader(&self) -> Result<Option<ComPtr<SmartCardReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Reader)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetStatusAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_answer_to_reset_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAnswerToResetAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCard: ISmartCard}
RT_ENUM! { enum SmartCardActivationPolicyChangeResult: i32 {
    Denied = 0, Allowed = 1,
}}
DEFINE_IID!(IID_ISmartCardAppletIdGroup, 2108777958, 25188, 22260, 94, 3, 200, 99, 133, 57, 94, 177);
RT_INTERFACE!{interface ISmartCardAppletIdGroup(ISmartCardAppletIdGroupVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroup] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_AppletIds(&self, out: *mut *mut foundation::collections::IVector<super::super::storage::streams::IBuffer>) -> HRESULT,
    fn get_SmartCardEmulationCategory(&self, out: *mut SmartCardEmulationCategory) -> HRESULT,
    fn put_SmartCardEmulationCategory(&self, value: SmartCardEmulationCategory) -> HRESULT,
    fn get_SmartCardEmulationType(&self, out: *mut SmartCardEmulationType) -> HRESULT,
    fn put_SmartCardEmulationType(&self, value: SmartCardEmulationType) -> HRESULT,
    fn get_AutomaticEnablement(&self, out: *mut bool) -> HRESULT,
    fn put_AutomaticEnablement(&self, value: bool) -> HRESULT
}}
impl ComPtr<ISmartCardAppletIdGroup> {
    #[inline] pub fn get_display_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DisplayName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_display_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DisplayName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_applet_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVector<super::super::storage::streams::IBuffer>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AppletIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_smart_card_emulation_category(&self) -> Result<SmartCardEmulationCategory> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SmartCardEmulationCategory)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_smart_card_emulation_category(&self, value: SmartCardEmulationCategory) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SmartCardEmulationCategory)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_smart_card_emulation_type(&self) -> Result<SmartCardEmulationType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SmartCardEmulationType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_smart_card_emulation_type(&self, value: SmartCardEmulationType) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SmartCardEmulationType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_automatic_enablement(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AutomaticEnablement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_automatic_enablement(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AutomaticEnablement)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardAppletIdGroup: ISmartCardAppletIdGroup}
impl RtActivatable<ISmartCardAppletIdGroupFactory> for SmartCardAppletIdGroup {}
impl RtActivatable<ISmartCardAppletIdGroupStatics> for SmartCardAppletIdGroup {}
impl RtActivatable<IActivationFactory> for SmartCardAppletIdGroup {}
impl SmartCardAppletIdGroup {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(displayName: &HStringArg, appletIds: &ComPtr<foundation::collections::IVector<super::super::storage::streams::IBuffer>>, emulationCategory: SmartCardEmulationCategory, emulationType: SmartCardEmulationType) -> Result<ComPtr<SmartCardAppletIdGroup>> {
        <Self as RtActivatable<ISmartCardAppletIdGroupFactory>>::get_activation_factory().create(displayName, appletIds, emulationCategory, emulationType)
    }
    #[inline] pub fn get_max_applet_ids() -> Result<u16> {
        <Self as RtActivatable<ISmartCardAppletIdGroupStatics>>::get_activation_factory().get_max_applet_ids()
    }
}
DEFINE_CLSID!(SmartCardAppletIdGroup(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,65,112,112,108,101,116,73,100,71,114,111,117,112,0]) [CLSID_SmartCardAppletIdGroup]);
DEFINE_IID!(IID_ISmartCardAppletIdGroup2, 1796143580, 39254, 19042, 141, 78, 211, 122, 104, 235, 195, 166);
RT_INTERFACE!{interface ISmartCardAppletIdGroup2(ISmartCardAppletIdGroup2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroup2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut foundation::collections::ValueSet) -> HRESULT,
    fn get_SecureUserAuthenticationRequired(&self, out: *mut bool) -> HRESULT,
    fn put_SecureUserAuthenticationRequired(&self, value: bool) -> HRESULT
}}
impl ComPtr<ISmartCardAppletIdGroup2> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_logo(&self) -> Result<Option<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Logo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_logo(&self, value: &ComPtr<super::super::storage::streams::IRandomAccessStreamReference>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Logo)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_description(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Description)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_description(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Description)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_properties(&self) -> Result<Option<ComPtr<foundation::collections::ValueSet>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Properties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_secure_user_authentication_required(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SecureUserAuthenticationRequired)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_secure_user_authentication_required(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SecureUserAuthenticationRequired)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardAppletIdGroupActivationPolicy: i32 {
    Disabled = 0, ForegroundOverride = 1, Enabled = 2,
}}
DEFINE_IID!(IID_ISmartCardAppletIdGroupFactory, 2433084237, 19045, 20033, 128, 97, 203, 232, 63, 54, 149, 229);
RT_INTERFACE!{static interface ISmartCardAppletIdGroupFactory(ISmartCardAppletIdGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, displayName: HSTRING, appletIds: *mut foundation::collections::IVector<super::super::storage::streams::IBuffer>, emulationCategory: SmartCardEmulationCategory, emulationType: SmartCardEmulationType, out: *mut *mut SmartCardAppletIdGroup) -> HRESULT
}}
impl ComPtr<ISmartCardAppletIdGroupFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, displayName: &HStringArg, appletIds: &ComPtr<foundation::collections::IVector<super::super::storage::streams::IBuffer>>, emulationCategory: SmartCardEmulationCategory, emulationType: SmartCardEmulationType) -> Result<ComPtr<SmartCardAppletIdGroup>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, displayName.get(), appletIds.deref() as *const _ as *mut _, emulationCategory, emulationType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAppletIdGroupRegistration, 3742501073, 12731, 21910, 67, 177, 109, 105, 160, 37, 123, 58);
RT_INTERFACE!{interface ISmartCardAppletIdGroupRegistration(ISmartCardAppletIdGroupRegistrationVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupRegistration] {
    fn get_ActivationPolicy(&self, out: *mut SmartCardAppletIdGroupActivationPolicy) -> HRESULT,
    fn get_AppletIdGroup(&self, out: *mut *mut SmartCardAppletIdGroup) -> HRESULT,
    fn RequestActivationPolicyChangeAsync(&self, policy: SmartCardAppletIdGroupActivationPolicy, out: *mut *mut foundation::IAsyncOperation<SmartCardActivationPolicyChangeResult>) -> HRESULT,
    fn get_Id(&self, out: *mut Guid) -> HRESULT,
    fn SetAutomaticResponseApdusAsync(&self, apdus: *mut foundation::collections::IIterable<SmartCardAutomaticResponseApdu>, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<ISmartCardAppletIdGroupRegistration> {
    #[inline] pub fn get_activation_policy(&self) -> Result<SmartCardAppletIdGroupActivationPolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ActivationPolicy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_applet_id_group(&self) -> Result<Option<ComPtr<SmartCardAppletIdGroup>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AppletIdGroup)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_activation_policy_change_async(&self, policy: SmartCardAppletIdGroupActivationPolicy) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardActivationPolicyChangeResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestActivationPolicyChangeAsync)(self.deref() as *const _ as *mut _, policy, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_automatic_response_apdus_async(&self, apdus: &ComPtr<foundation::collections::IIterable<SmartCardAutomaticResponseApdu>>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SetAutomaticResponseApdusAsync)(self.deref() as *const _ as *mut _, apdus.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardAppletIdGroupRegistration: ISmartCardAppletIdGroupRegistration}
DEFINE_IID!(IID_ISmartCardAppletIdGroupRegistration2, 1599408344, 39079, 20270, 145, 217, 108, 252, 206, 218, 64, 127);
RT_INTERFACE!{interface ISmartCardAppletIdGroupRegistration2(ISmartCardAppletIdGroupRegistration2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupRegistration2] {
    fn get_SmartCardReaderId(&self, out: *mut HSTRING) -> HRESULT,
    fn SetPropertiesAsync(&self, props: *mut foundation::collections::ValueSet, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<ISmartCardAppletIdGroupRegistration2> {
    #[inline] pub fn get_smart_card_reader_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SmartCardReaderId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_properties_async(&self, props: &ComPtr<foundation::collections::ValueSet>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SetPropertiesAsync)(self.deref() as *const _ as *mut _, props.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAppletIdGroupStatics, 2871564713, 59244, 17871, 191, 29, 144, 234, 166, 32, 89, 39);
RT_INTERFACE!{static interface ISmartCardAppletIdGroupStatics(ISmartCardAppletIdGroupStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAppletIdGroupStatics] {
    fn get_MaxAppletIds(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<ISmartCardAppletIdGroupStatics> {
    #[inline] pub fn get_max_applet_ids(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxAppletIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAutomaticResponseApdu, 1377119147, 50750, 17713, 168, 87, 215, 86, 217, 155, 152, 106);
RT_INTERFACE!{interface ISmartCardAutomaticResponseApdu(ISmartCardAutomaticResponseApduVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApdu] {
    #[cfg(feature="windows-storage")] fn get_CommandApdu(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_CommandApdu(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_CommandApduBitMask(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_CommandApduBitMask(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_ShouldMatchLength(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldMatchLength(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AppletId(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_AppletId(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ResponseApdu(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_ResponseApdu(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<ISmartCardAutomaticResponseApdu> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_command_apdu(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CommandApdu)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_command_apdu(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CommandApdu)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_command_apdu_bit_mask(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CommandApduBitMask)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_command_apdu_bit_mask(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CommandApduBitMask)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_should_match_length(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ShouldMatchLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_should_match_length(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ShouldMatchLength)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_applet_id(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AppletId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_applet_id(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AppletId)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_response_apdu(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ResponseApdu)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_response_apdu(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ResponseApdu)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardAutomaticResponseApdu: ISmartCardAutomaticResponseApdu}
impl RtActivatable<ISmartCardAutomaticResponseApduFactory> for SmartCardAutomaticResponseApdu {}
impl SmartCardAutomaticResponseApdu {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(commandApdu: &ComPtr<super::super::storage::streams::IBuffer>, responseApdu: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<SmartCardAutomaticResponseApdu>> {
        <Self as RtActivatable<ISmartCardAutomaticResponseApduFactory>>::get_activation_factory().create(commandApdu, responseApdu)
    }
}
DEFINE_CLSID!(SmartCardAutomaticResponseApdu(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,65,117,116,111,109,97,116,105,99,82,101,115,112,111,110,115,101,65,112,100,117,0]) [CLSID_SmartCardAutomaticResponseApdu]);
DEFINE_IID!(IID_ISmartCardAutomaticResponseApdu2, 1152301844, 21917, 17713, 78, 81, 137, 219, 111, 168, 165, 122);
RT_INTERFACE!{interface ISmartCardAutomaticResponseApdu2(ISmartCardAutomaticResponseApdu2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApdu2] {
    fn get_InputState(&self, out: *mut *mut foundation::IReference<u32>) -> HRESULT,
    fn put_InputState(&self, value: *mut foundation::IReference<u32>) -> HRESULT,
    fn get_OutputState(&self, out: *mut *mut foundation::IReference<u32>) -> HRESULT,
    fn put_OutputState(&self, value: *mut foundation::IReference<u32>) -> HRESULT
}}
impl ComPtr<ISmartCardAutomaticResponseApdu2> {
    #[inline] pub fn get_input_state(&self) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InputState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_input_state(&self, value: &ComPtr<foundation::IReference<u32>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_InputState)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_output_state(&self) -> Result<Option<ComPtr<foundation::IReference<u32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutputState)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_output_state(&self, value: &ComPtr<foundation::IReference<u32>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_OutputState)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAutomaticResponseApdu3, 3208895092, 25974, 17298, 147, 103, 254, 59, 201, 226, 212, 150);
RT_INTERFACE!{interface ISmartCardAutomaticResponseApdu3(ISmartCardAutomaticResponseApdu3Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApdu3] {
    fn get_AllowWhenCryptogramGeneratorNotPrepared(&self, out: *mut bool) -> HRESULT,
    fn put_AllowWhenCryptogramGeneratorNotPrepared(&self, value: bool) -> HRESULT
}}
impl ComPtr<ISmartCardAutomaticResponseApdu3> {
    #[inline] pub fn get_allow_when_cryptogram_generator_not_prepared(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AllowWhenCryptogramGeneratorNotPrepared)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_allow_when_cryptogram_generator_not_prepared(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AllowWhenCryptogramGeneratorNotPrepared)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardAutomaticResponseApduFactory, 3917390586, 53292, 19541, 176, 42, 140, 255, 127, 169, 240, 91);
RT_INTERFACE!{static interface ISmartCardAutomaticResponseApduFactory(ISmartCardAutomaticResponseApduFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardAutomaticResponseApduFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, commandApdu: *mut super::super::storage::streams::IBuffer, responseApdu: *mut super::super::storage::streams::IBuffer, out: *mut *mut SmartCardAutomaticResponseApdu) -> HRESULT
}}
impl ComPtr<ISmartCardAutomaticResponseApduFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(&self, commandApdu: &ComPtr<super::super::storage::streams::IBuffer>, responseApdu: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<SmartCardAutomaticResponseApdu>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, commandApdu.deref() as *const _ as *mut _, responseApdu.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardAutomaticResponseStatus: i32 {
    None = 0, Success = 1, UnknownError = 2,
}}
DEFINE_IID!(IID_ISmartCardChallengeContext, 422204185, 51652, 18759, 129, 204, 68, 121, 74, 97, 239, 145);
RT_INTERFACE!{interface ISmartCardChallengeContext(ISmartCardChallengeContextVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardChallengeContext] {
    #[cfg(feature="windows-storage")] fn get_Challenge(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn VerifyResponseAsync(&self, response: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ProvisionAsync(&self, response: *mut super::super::storage::streams::IBuffer, formatCard: bool, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ProvisionAsyncWithNewCardId(&self, response: *mut super::super::storage::streams::IBuffer, formatCard: bool, newCardId: Guid, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ChangeAdministrativeKeyAsync(&self, response: *mut super::super::storage::streams::IBuffer, newAdministrativeKey: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncAction) -> HRESULT
}}
impl ComPtr<ISmartCardChallengeContext> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_challenge(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Challenge)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn verify_response_async(&self, response: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).VerifyResponseAsync)(self.deref() as *const _ as *mut _, response.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn provision_async(&self, response: &ComPtr<super::super::storage::streams::IBuffer>, formatCard: bool) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ProvisionAsync)(self.deref() as *const _ as *mut _, response.deref() as *const _ as *mut _, formatCard, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn provision_async_with_new_card_id(&self, response: &ComPtr<super::super::storage::streams::IBuffer>, formatCard: bool, newCardId: Guid) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ProvisionAsyncWithNewCardId)(self.deref() as *const _ as *mut _, response.deref() as *const _ as *mut _, formatCard, newCardId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn change_administrative_key_async(&self, response: &ComPtr<super::super::storage::streams::IBuffer>, newAdministrativeKey: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ChangeAdministrativeKeyAsync)(self.deref() as *const _ as *mut _, response.deref() as *const _ as *mut _, newAdministrativeKey.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardChallengeContext: ISmartCardChallengeContext}
DEFINE_IID!(IID_ISmartCardConnect, 803178469, 653, 18718, 160, 88, 51, 130, 195, 152, 111, 64);
RT_INTERFACE!{interface ISmartCardConnect(ISmartCardConnectVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardConnect] {
    fn ConnectAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardConnection>) -> HRESULT
}}
impl ComPtr<ISmartCardConnect> {
    #[inline] pub fn connect_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardConnection>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardConnection, 2128320794, 43034, 18364, 166, 73, 21, 107, 230, 183, 242, 49);
RT_INTERFACE!{interface ISmartCardConnection(ISmartCardConnectionVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardConnection] {
    #[cfg(feature="windows-storage")] fn TransmitAsync(&self, command: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT
}}
impl ComPtr<ISmartCardConnection> {
    #[cfg(feature="windows-storage")] #[inline] pub fn transmit_async(&self, command: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TransmitAsync)(self.deref() as *const _ as *mut _, command.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardConnection: ISmartCardConnection}
RT_ENUM! { enum SmartCardCryptogramAlgorithm: i32 {
    None = 0, CbcMac = 1, Cvc3Umd = 2, DecimalizedMsd = 3, Cvc3MD = 4, Sha1 = 5, SignedDynamicApplicationData = 6, RsaPkcs1 = 7, Sha256Hmac = 8,
}}
DEFINE_IID!(IID_ISmartCardCryptogramGenerator, 3818870907, 60883, 20041, 181, 148, 15, 245, 228, 208, 199, 111);
RT_INTERFACE!{interface ISmartCardCryptogramGenerator(ISmartCardCryptogramGeneratorVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGenerator] {
    fn get_SupportedCryptogramMaterialTypes(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramMaterialType>) -> HRESULT,
    fn get_SupportedCryptogramAlgorithms(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>) -> HRESULT,
    fn get_SupportedCryptogramMaterialPackageFormats(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageFormat>) -> HRESULT,
    fn get_SupportedCryptogramMaterialPackageConfirmationResponseFormats(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat>) -> HRESULT,
    fn get_SupportedSmartCardCryptogramStorageKeyCapabilities(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCapabilities>) -> HRESULT,
    fn DeleteCryptogramMaterialStorageKeyAsync(&self, storageKeyName: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT,
    fn CreateCryptogramMaterialStorageKeyAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: HSTRING, algorithm: SmartCardCryptogramStorageKeyAlgorithm, capabilities: SmartCardCryptogramStorageKeyCapabilities, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-security")] fn RequestCryptogramMaterialStorageKeyInfoAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: HSTRING, format: super::super::security::cryptography::core::CryptographicPublicKeyBlobType, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramStorageKeyInfo>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn ImportCryptogramMaterialPackageAsync(&self, format: SmartCardCryptogramMaterialPackageFormat, storageKeyName: HSTRING, materialPackageName: HSTRING, cryptogramMaterialPackage: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn TryProvePossessionOfCryptogramMaterialPackageAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, responseFormat: SmartCardCryptogramMaterialPackageConfirmationResponseFormat, materialPackageName: HSTRING, materialName: HSTRING, challenge: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramMaterialPossessionProof>) -> HRESULT,
    fn RequestUnlockCryptogramMaterialForUseAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT,
    fn DeleteCryptogramMaterialPackageAsync(&self, materialPackageName: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGenerator> {
    #[inline] pub fn get_supported_cryptogram_material_types(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramMaterialType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCryptogramMaterialTypes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_cryptogram_algorithms(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCryptogramAlgorithms)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_cryptogram_material_package_formats(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageFormat>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCryptogramMaterialPackageFormats)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_cryptogram_material_package_confirmation_response_formats(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedCryptogramMaterialPackageConfirmationResponseFormats)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_smart_card_cryptogram_storage_key_capabilities(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCapabilities>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedSmartCardCryptogramStorageKeyCapabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_cryptogram_material_storage_key_async(&self, storageKeyName: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DeleteCryptogramMaterialStorageKeyAsync)(self.deref() as *const _ as *mut _, storageKeyName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_cryptogram_material_storage_key_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: &HStringArg, algorithm: SmartCardCryptogramStorageKeyAlgorithm, capabilities: SmartCardCryptogramStorageKeyCapabilities) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateCryptogramMaterialStorageKeyAsync)(self.deref() as *const _ as *mut _, promptingBehavior, storageKeyName.get(), algorithm, capabilities, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn request_cryptogram_material_storage_key_info_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, storageKeyName: &HStringArg, format: super::super::security::cryptography::core::CryptographicPublicKeyBlobType) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramStorageKeyInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestCryptogramMaterialStorageKeyInfoAsync)(self.deref() as *const _ as *mut _, promptingBehavior, storageKeyName.get(), format, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn import_cryptogram_material_package_async(&self, format: SmartCardCryptogramMaterialPackageFormat, storageKeyName: &HStringArg, materialPackageName: &HStringArg, cryptogramMaterialPackage: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ImportCryptogramMaterialPackageAsync)(self.deref() as *const _ as *mut _, format, storageKeyName.get(), materialPackageName.get(), cryptogramMaterialPackage.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_prove_possession_of_cryptogram_material_package_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, responseFormat: SmartCardCryptogramMaterialPackageConfirmationResponseFormat, materialPackageName: &HStringArg, materialName: &HStringArg, challenge: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramMaterialPossessionProof>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryProvePossessionOfCryptogramMaterialPackageAsync)(self.deref() as *const _ as *mut _, promptingBehavior, responseFormat, materialPackageName.get(), materialName.get(), challenge.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_unlock_cryptogram_material_for_use_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestUnlockCryptogramMaterialForUseAsync)(self.deref() as *const _ as *mut _, promptingBehavior, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_cryptogram_material_package_async(&self, materialPackageName: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DeleteCryptogramMaterialPackageAsync)(self.deref() as *const _ as *mut _, materialPackageName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGenerator: ISmartCardCryptogramGenerator}
impl RtActivatable<ISmartCardCryptogramGeneratorStatics> for SmartCardCryptogramGenerator {}
impl RtActivatable<ISmartCardCryptogramGeneratorStatics2> for SmartCardCryptogramGenerator {}
impl SmartCardCryptogramGenerator {
    #[inline] pub fn get_smart_card_cryptogram_generator_async() -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGenerator>>> {
        <Self as RtActivatable<ISmartCardCryptogramGeneratorStatics>>::get_activation_factory().get_smart_card_cryptogram_generator_async()
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<ISmartCardCryptogramGeneratorStatics2>>::get_activation_factory().is_supported()
    }
}
DEFINE_CLSID!(SmartCardCryptogramGenerator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,110,101,114,97,116,111,114,0]) [CLSID_SmartCardCryptogramGenerator]);
DEFINE_IID!(IID_ISmartCardCryptogramGenerator2, 1897310772, 23917, 19274, 150, 163, 239, 164, 125, 42, 126, 37);
RT_INTERFACE!{interface ISmartCardCryptogramGenerator2(ISmartCardCryptogramGenerator2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGenerator2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn ValidateRequestApduAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, apduToValidate: *mut super::super::storage::streams::IBuffer, cryptogramPlacementSteps: *mut foundation::collections::IIterable<SmartCardCryptogramPlacementStep>, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT,
    fn GetAllCryptogramStorageKeyCharacteristicsAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>) -> HRESULT,
    fn GetAllCryptogramMaterialPackageCharacteristicsAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>) -> HRESULT,
    fn GetAllCryptogramMaterialPackageCharacteristicsWithStorageKeyAsync(&self, storageKeyName: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>) -> HRESULT,
    fn GetAllCryptogramMaterialCharacteristicsAsync(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, materialPackageName: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGenerator2> {
    #[cfg(feature="windows-storage")] #[inline] pub fn validate_request_apdu_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, apduToValidate: &ComPtr<super::super::storage::streams::IBuffer>, cryptogramPlacementSteps: &ComPtr<foundation::collections::IIterable<SmartCardCryptogramPlacementStep>>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ValidateRequestApduAsync)(self.deref() as *const _ as *mut _, promptingBehavior, apduToValidate.deref() as *const _ as *mut _, cryptogramPlacementSteps.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_storage_key_characteristics_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllCryptogramStorageKeyCharacteristicsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_material_package_characteristics_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllCryptogramMaterialPackageCharacteristicsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_material_package_characteristics_with_storage_key_async(&self, storageKeyName: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllCryptogramMaterialPackageCharacteristicsWithStorageKeyAsync)(self.deref() as *const _ as *mut _, storageKeyName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_all_cryptogram_material_characteristics_async(&self, promptingBehavior: SmartCardUnlockPromptingBehavior, materialPackageName: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAllCryptogramMaterialCharacteristicsAsync)(self.deref() as *const _ as *mut _, promptingBehavior, materialPackageName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardCryptogramGeneratorOperationStatus: i32 {
    Success = 0, AuthorizationFailed = 1, AuthorizationCanceled = 2, AuthorizationRequired = 3, CryptogramMaterialPackageStorageKeyExists = 4, NoCryptogramMaterialPackageStorageKey = 5, NoCryptogramMaterialPackage = 6, UnsupportedCryptogramMaterialPackage = 7, UnknownCryptogramMaterialName = 8, InvalidCryptogramMaterialUsage = 9, ApduResponseNotSent = 10, OtherError = 11, ValidationFailed = 12, NotSupported = 13,
}}
DEFINE_IID!(IID_ISmartCardCryptogramGeneratorStatics, 160643344, 52124, 16405, 150, 125, 82, 52, 243, 176, 41, 0);
RT_INTERFACE!{static interface ISmartCardCryptogramGeneratorStatics(ISmartCardCryptogramGeneratorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGeneratorStatics] {
    fn GetSmartCardCryptogramGeneratorAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGenerator>) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGeneratorStatics> {
    #[inline] pub fn get_smart_card_cryptogram_generator_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGenerator>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSmartCardCryptogramGeneratorAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardCryptogramGeneratorStatics2, 163444197, 46269, 20003, 165, 136, 116, 70, 146, 4, 193, 40);
RT_INTERFACE!{static interface ISmartCardCryptogramGeneratorStatics2(ISmartCardCryptogramGeneratorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGeneratorStatics2] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGeneratorStatics2> {
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult, 664330281, 54919, 19602, 134, 198, 57, 158, 154, 14, 203, 9);
RT_INTERFACE!{interface ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResultVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    fn get_Characteristics(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramMaterialCharacteristics>) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult> {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OperationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramMaterialCharacteristics>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult: ISmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult {}
DEFINE_CLSID!(SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,116,65,108,108,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,82,101,115,117,108,116,0]) [CLSID_SmartCardCryptogramGetAllCryptogramMaterialCharacteristicsResult]);
DEFINE_IID!(IID_ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult, 1315605084, 38771, 18116, 163, 47, 177, 229, 67, 21, 158, 4);
RT_INTERFACE!{interface ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResultVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    fn get_Characteristics(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageCharacteristics>) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult> {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OperationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageCharacteristics>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult: ISmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult {}
DEFINE_CLSID!(SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,116,65,108,108,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,80,97,99,107,97,103,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,82,101,115,117,108,116,0]) [CLSID_SmartCardCryptogramGetAllCryptogramMaterialPackageCharacteristicsResult]);
DEFINE_IID!(IID_ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult, 2356996183, 42983, 18589, 185, 214, 54, 128, 97, 81, 80, 18);
RT_INTERFACE!{interface ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResultVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    fn get_Characteristics(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCharacteristics>) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult> {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OperationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_characteristics(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramStorageKeyCharacteristics>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Characteristics)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult: ISmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult {}
DEFINE_CLSID!(SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,71,101,116,65,108,108,67,114,121,112,116,111,103,114,97,109,83,116,111,114,97,103,101,75,101,121,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,82,101,115,117,108,116,0]) [CLSID_SmartCardCryptogramGetAllCryptogramStorageKeyCharacteristicsResult]);
DEFINE_IID!(IID_ISmartCardCryptogramMaterialCharacteristics, 4238001612, 49623, 16723, 146, 59, 162, 212, 60, 108, 141, 73);
RT_INTERFACE!{interface ISmartCardCryptogramMaterialCharacteristics(ISmartCardCryptogramMaterialCharacteristicsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramMaterialCharacteristics] {
    fn get_MaterialName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllowedAlgorithms(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>) -> HRESULT,
    fn get_AllowedProofOfPossessionAlgorithms(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat>) -> HRESULT,
    fn get_AllowedValidations(&self, out: *mut *mut foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>) -> HRESULT,
    fn get_MaterialType(&self, out: *mut SmartCardCryptogramMaterialType) -> HRESULT,
    fn get_ProtectionMethod(&self, out: *mut SmartCardCryptogramMaterialProtectionMethod) -> HRESULT,
    fn get_ProtectionVersion(&self, out: *mut i32) -> HRESULT,
    fn get_MaterialLength(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramMaterialCharacteristics> {
    #[inline] pub fn get_material_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MaterialName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allowed_algorithms(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AllowedAlgorithms)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allowed_proof_of_possession_algorithms(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramMaterialPackageConfirmationResponseFormat>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AllowedProofOfPossessionAlgorithms)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_allowed_validations(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmartCardCryptogramAlgorithm>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AllowedValidations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_material_type(&self) -> Result<SmartCardCryptogramMaterialType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaterialType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_method(&self) -> Result<SmartCardCryptogramMaterialProtectionMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionMethod)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protection_version(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtectionVersion)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_material_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaterialLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramMaterialCharacteristics: ISmartCardCryptogramMaterialCharacteristics}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramMaterialCharacteristics {}
DEFINE_CLSID!(SmartCardCryptogramMaterialCharacteristics(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,0]) [CLSID_SmartCardCryptogramMaterialCharacteristics]);
DEFINE_IID!(IID_ISmartCardCryptogramMaterialPackageCharacteristics, 4290088479, 1682, 19527, 147, 207, 52, 217, 31, 157, 205, 0);
RT_INTERFACE!{interface ISmartCardCryptogramMaterialPackageCharacteristics(ISmartCardCryptogramMaterialPackageCharacteristicsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramMaterialPackageCharacteristics] {
    fn get_PackageName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StorageKeyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DateImported(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PackageFormat(&self, out: *mut SmartCardCryptogramMaterialPackageFormat) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramMaterialPackageCharacteristics> {
    #[inline] pub fn get_package_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PackageName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_storage_key_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StorageKeyName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_imported(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DateImported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_package_format(&self) -> Result<SmartCardCryptogramMaterialPackageFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PackageFormat)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramMaterialPackageCharacteristics: ISmartCardCryptogramMaterialPackageCharacteristics}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramMaterialPackageCharacteristics {}
DEFINE_CLSID!(SmartCardCryptogramMaterialPackageCharacteristics(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,77,97,116,101,114,105,97,108,80,97,99,107,97,103,101,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,0]) [CLSID_SmartCardCryptogramMaterialPackageCharacteristics]);
RT_ENUM! { enum SmartCardCryptogramMaterialPackageConfirmationResponseFormat: i32 {
    None = 0, VisaHmac = 1,
}}
RT_ENUM! { enum SmartCardCryptogramMaterialPackageFormat: i32 {
    None = 0, JweRsaPki = 1,
}}
DEFINE_IID!(IID_ISmartCardCryptogramMaterialPossessionProof, 3854150540, 41281, 16693, 154, 221, 176, 210, 227, 170, 31, 201);
RT_INTERFACE!{interface ISmartCardCryptogramMaterialPossessionProof(ISmartCardCryptogramMaterialPossessionProofVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramMaterialPossessionProof] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Proof(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramMaterialPossessionProof> {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OperationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_proof(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Proof)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramMaterialPossessionProof: ISmartCardCryptogramMaterialPossessionProof}
RT_ENUM! { enum SmartCardCryptogramMaterialProtectionMethod: i32 {
    None = 0, WhiteBoxing = 1,
}}
RT_ENUM! { enum SmartCardCryptogramMaterialType: i32 {
    None = 0, StaticDataAuthentication = 1, TripleDes112 = 2, Aes = 3, RsaPkcs1 = 4,
}}
RT_ENUM! { enum SmartCardCryptogramPlacementOptions: u32 {
    None = 0, UnitsAreInNibbles = 1, ChainOutput = 2,
}}
DEFINE_IID!(IID_ISmartCardCryptogramPlacementStep, 2491089899, 33602, 18322, 162, 229, 146, 86, 54, 55, 138, 83);
RT_INTERFACE!{interface ISmartCardCryptogramPlacementStep(ISmartCardCryptogramPlacementStepVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramPlacementStep] {
    fn get_Algorithm(&self, out: *mut SmartCardCryptogramAlgorithm) -> HRESULT,
    fn put_Algorithm(&self, value: SmartCardCryptogramAlgorithm) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SourceData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SourceData(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_CryptogramMaterialPackageName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CryptogramMaterialPackageName(&self, value: HSTRING) -> HRESULT,
    fn get_CryptogramMaterialName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CryptogramMaterialName(&self, value: HSTRING) -> HRESULT,
    fn get_TemplateOffset(&self, out: *mut i32) -> HRESULT,
    fn put_TemplateOffset(&self, value: i32) -> HRESULT,
    fn get_CryptogramOffset(&self, out: *mut i32) -> HRESULT,
    fn put_CryptogramOffset(&self, value: i32) -> HRESULT,
    fn get_CryptogramLength(&self, out: *mut i32) -> HRESULT,
    fn put_CryptogramLength(&self, value: i32) -> HRESULT,
    fn get_CryptogramPlacementOptions(&self, out: *mut SmartCardCryptogramPlacementOptions) -> HRESULT,
    fn put_CryptogramPlacementOptions(&self, value: SmartCardCryptogramPlacementOptions) -> HRESULT,
    fn get_ChainedOutputStep(&self, out: *mut *mut SmartCardCryptogramPlacementStep) -> HRESULT,
    fn put_ChainedOutputStep(&self, value: *mut SmartCardCryptogramPlacementStep) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramPlacementStep> {
    #[inline] pub fn get_algorithm(&self) -> Result<SmartCardCryptogramAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Algorithm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_algorithm(&self, value: SmartCardCryptogramAlgorithm) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Algorithm)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_source_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SourceData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_source_data(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SourceData)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_material_package_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CryptogramMaterialPackageName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_material_package_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CryptogramMaterialPackageName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_material_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CryptogramMaterialName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_material_name(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CryptogramMaterialName)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_template_offset(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TemplateOffset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_template_offset(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_TemplateOffset)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_offset(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CryptogramOffset)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_offset(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CryptogramOffset)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CryptogramLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CryptogramLength)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_cryptogram_placement_options(&self) -> Result<SmartCardCryptogramPlacementOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CryptogramPlacementOptions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cryptogram_placement_options(&self, value: SmartCardCryptogramPlacementOptions) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CryptogramPlacementOptions)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_chained_output_step(&self) -> Result<Option<ComPtr<SmartCardCryptogramPlacementStep>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ChainedOutputStep)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_chained_output_step(&self, value: &ComPtr<SmartCardCryptogramPlacementStep>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ChainedOutputStep)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramPlacementStep: ISmartCardCryptogramPlacementStep}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramPlacementStep {}
DEFINE_CLSID!(SmartCardCryptogramPlacementStep(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,80,108,97,99,101,109,101,110,116,83,116,101,112,0]) [CLSID_SmartCardCryptogramPlacementStep]);
RT_ENUM! { enum SmartCardCryptogramStorageKeyAlgorithm: i32 {
    None = 0, Rsa2048 = 1,
}}
RT_ENUM! { enum SmartCardCryptogramStorageKeyCapabilities: u32 {
    None = 0, HardwareProtection = 1, UnlockPrompt = 2,
}}
DEFINE_IID!(IID_ISmartCardCryptogramStorageKeyCharacteristics, 2236765294, 17495, 18469, 180, 100, 99, 84, 113, 163, 159, 92);
RT_INTERFACE!{interface ISmartCardCryptogramStorageKeyCharacteristics(ISmartCardCryptogramStorageKeyCharacteristicsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramStorageKeyCharacteristics] {
    fn get_StorageKeyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DateCreated(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_Algorithm(&self, out: *mut SmartCardCryptogramStorageKeyAlgorithm) -> HRESULT,
    fn get_Capabilities(&self, out: *mut SmartCardCryptogramStorageKeyCapabilities) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramStorageKeyCharacteristics> {
    #[inline] pub fn get_storage_key_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StorageKeyName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_date_created(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DateCreated)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_algorithm(&self) -> Result<SmartCardCryptogramStorageKeyAlgorithm> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Algorithm)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<SmartCardCryptogramStorageKeyCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramStorageKeyCharacteristics: ISmartCardCryptogramStorageKeyCharacteristics}
impl RtActivatable<IActivationFactory> for SmartCardCryptogramStorageKeyCharacteristics {}
DEFINE_CLSID!(SmartCardCryptogramStorageKeyCharacteristics(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,67,114,121,112,116,111,103,114,97,109,83,116,111,114,97,103,101,75,101,121,67,104,97,114,97,99,116,101,114,105,115,116,105,99,115,0]) [CLSID_SmartCardCryptogramStorageKeyCharacteristics]);
DEFINE_IID!(IID_ISmartCardCryptogramStorageKeyInfo, 2008084493, 45207, 20321, 162, 106, 149, 97, 99, 156, 156, 58);
RT_INTERFACE!{interface ISmartCardCryptogramStorageKeyInfo(ISmartCardCryptogramStorageKeyInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramStorageKeyInfo] {
    fn get_OperationStatus(&self, out: *mut SmartCardCryptogramGeneratorOperationStatus) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn get_PublicKeyBlobType(&self, out: *mut super::super::security::cryptography::core::CryptographicPublicKeyBlobType) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_PublicKey(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_AttestationStatus(&self, out: *mut SmartCardCryptographicKeyAttestationStatus) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Attestation(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_AttestationCertificateChain(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_Capabilities(&self, out: *mut SmartCardCryptogramStorageKeyCapabilities) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramStorageKeyInfo> {
    #[inline] pub fn get_operation_status(&self) -> Result<SmartCardCryptogramGeneratorOperationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OperationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_public_key_blob_type(&self) -> Result<super::super::security::cryptography::core::CryptographicPublicKeyBlobType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PublicKeyBlobType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_public_key(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PublicKey)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_attestation_status(&self) -> Result<SmartCardCryptographicKeyAttestationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AttestationStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_attestation(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Attestation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_attestation_certificate_chain(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AttestationCertificateChain)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_capabilities(&self) -> Result<SmartCardCryptogramStorageKeyCapabilities> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Capabilities)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardCryptogramStorageKeyInfo: ISmartCardCryptogramStorageKeyInfo}
DEFINE_IID!(IID_ISmartCardCryptogramStorageKeyInfo2, 278777, 63485, 16765, 137, 225, 251, 176, 56, 42, 220, 77);
RT_INTERFACE!{interface ISmartCardCryptogramStorageKeyInfo2(ISmartCardCryptogramStorageKeyInfo2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardCryptogramStorageKeyInfo2] {
    fn get_OperationalRequirements(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ISmartCardCryptogramStorageKeyInfo2> {
    #[inline] pub fn get_operational_requirements(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OperationalRequirements)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardCryptographicKeyAttestationStatus: i32 {
    NoAttestation = 0, SoftwareKeyWithoutTpm = 1, SoftwareKeyWithTpm = 2, TpmKeyUnknownAttestationStatus = 3, TpmKeyWithoutAttestationCapability = 4, TpmKeyWithTemporaryAttestationFailure = 5, TpmKeyWithLongTermAttestationFailure = 6, TpmKeyWithAttestation = 7,
}}
RT_ENUM! { enum SmartCardEmulationCategory: i32 {
    Other = 0, Payment = 1,
}}
RT_ENUM! { enum SmartCardEmulationType: i32 {
    Host = 0, Uicc = 1, EmbeddedSE = 2,
}}
DEFINE_IID!(IID_ISmartCardEmulator, 3753445042, 34654, 18405, 128, 119, 232, 191, 241, 177, 198, 251);
RT_INTERFACE!{interface ISmartCardEmulator(ISmartCardEmulatorVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulator] {
    fn get_EnablementPolicy(&self, out: *mut SmartCardEmulatorEnablementPolicy) -> HRESULT
}}
impl ComPtr<ISmartCardEmulator> {
    #[inline] pub fn get_enablement_policy(&self) -> Result<SmartCardEmulatorEnablementPolicy> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EnablementPolicy)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulator: ISmartCardEmulator}
impl RtActivatable<ISmartCardEmulatorStatics> for SmartCardEmulator {}
impl RtActivatable<ISmartCardEmulatorStatics2> for SmartCardEmulator {}
impl RtActivatable<ISmartCardEmulatorStatics3> for SmartCardEmulator {}
impl SmartCardEmulator {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<SmartCardEmulator>>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_applet_id_group_registrations_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCardAppletIdGroupRegistration>>>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().get_applet_id_group_registrations_async()
    }
    #[inline] pub fn register_applet_id_group_async(appletIdGroup: &ComPtr<SmartCardAppletIdGroup>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardAppletIdGroupRegistration>>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().register_applet_id_group_async(appletIdGroup)
    }
    #[inline] pub fn unregister_applet_id_group_async(registration: &ComPtr<SmartCardAppletIdGroupRegistration>) -> Result<ComPtr<foundation::IAsyncAction>> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().unregister_applet_id_group_async(registration)
    }
    #[inline] pub fn get_max_applet_id_group_registrations() -> Result<u16> {
        <Self as RtActivatable<ISmartCardEmulatorStatics2>>::get_activation_factory().get_max_applet_id_group_registrations()
    }
    #[inline] pub fn is_supported() -> Result<bool> {
        <Self as RtActivatable<ISmartCardEmulatorStatics3>>::get_activation_factory().is_supported()
    }
}
DEFINE_CLSID!(SmartCardEmulator(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,69,109,117,108,97,116,111,114,0]) [CLSID_SmartCardEmulator]);
DEFINE_IID!(IID_ISmartCardEmulator2, 4265590968, 34089, 16666, 128, 123, 72, 237, 194, 160, 171, 68);
RT_INTERFACE!{interface ISmartCardEmulator2(ISmartCardEmulator2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulator2] {
    fn add_ApduReceived(&self, value: *mut foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorApduReceivedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ApduReceived(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn add_ConnectionDeactivated(&self, value: *mut foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorConnectionDeactivatedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionDeactivated(&self, value: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn IsHostCardEmulationSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ISmartCardEmulator2> {
    #[inline] pub fn add_apdu_received(&self, value: &ComPtr<foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorApduReceivedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ApduReceived)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_apdu_received(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ApduReceived)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_deactivated(&self, value: &ComPtr<foundation::TypedEventHandler<SmartCardEmulator, SmartCardEmulatorConnectionDeactivatedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ConnectionDeactivated)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_deactivated(&self, value: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ConnectionDeactivated)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn is_host_card_emulation_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsHostCardEmulationSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorApduReceivedEventArgs, 3579647350, 27090, 21299, 91, 95, 248, 192, 214, 233, 240, 159);
RT_INTERFACE!{interface ISmartCardEmulatorApduReceivedEventArgs(ISmartCardEmulatorApduReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorApduReceivedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_CommandApdu(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_ConnectionProperties(&self, out: *mut *mut SmartCardEmulatorConnectionProperties) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn TryRespondAsync(&self, responseApdu: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn get_AutomaticResponseStatus(&self, out: *mut SmartCardAutomaticResponseStatus) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorApduReceivedEventArgs> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_command_apdu(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CommandApdu)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_properties(&self) -> Result<Option<ComPtr<SmartCardEmulatorConnectionProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_async(&self, responseApdu: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryRespondAsync)(self.deref() as *const _ as *mut _, responseApdu.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_automatic_response_status(&self) -> Result<SmartCardAutomaticResponseStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AutomaticResponseStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulatorApduReceivedEventArgs: ISmartCardEmulatorApduReceivedEventArgs}
DEFINE_IID!(IID_ISmartCardEmulatorApduReceivedEventArgs2, 2348367344, 8929, 16952, 134, 16, 148, 206, 74, 150, 84, 37);
RT_INTERFACE!{interface ISmartCardEmulatorApduReceivedEventArgs2(ISmartCardEmulatorApduReceivedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorApduReceivedEventArgs2] {
    fn get_State(&self, out: *mut u32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryRespondWithStateAsync(&self, responseApdu: *mut super::super::storage::streams::IBuffer, nextState: *mut foundation::IReference<u32>, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorApduReceivedEventArgs2> {
    #[inline] pub fn get_state(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_State)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_with_state_async(&self, responseApdu: &ComPtr<super::super::storage::streams::IBuffer>, nextState: &ComPtr<foundation::IReference<u32>>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryRespondWithStateAsync)(self.deref() as *const _ as *mut _, responseApdu.deref() as *const _ as *mut _, nextState.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorApduReceivedEventArgsWithCryptograms, 3578837703, 47039, 20009, 146, 148, 12, 74, 195, 201, 65, 189);
RT_INTERFACE!{interface ISmartCardEmulatorApduReceivedEventArgsWithCryptograms(ISmartCardEmulatorApduReceivedEventArgsWithCryptogramsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorApduReceivedEventArgsWithCryptograms] {
    #[cfg(feature="windows-storage")] fn TryRespondWithCryptogramsAsync(&self, responseTemplate: *mut super::super::storage::streams::IBuffer, cryptogramPlacementSteps: *mut foundation::collections::IIterable<SmartCardCryptogramPlacementStep>, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn TryRespondWithCryptogramsAndStateAsync(&self, responseTemplate: *mut super::super::storage::streams::IBuffer, cryptogramPlacementSteps: *mut foundation::collections::IIterable<SmartCardCryptogramPlacementStep>, nextState: *mut foundation::IReference<u32>, out: *mut *mut foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorApduReceivedEventArgsWithCryptograms> {
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_with_cryptograms_async(&self, responseTemplate: &ComPtr<super::super::storage::streams::IBuffer>, cryptogramPlacementSteps: &ComPtr<foundation::collections::IIterable<SmartCardCryptogramPlacementStep>>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryRespondWithCryptogramsAsync)(self.deref() as *const _ as *mut _, responseTemplate.deref() as *const _ as *mut _, cryptogramPlacementSteps.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn try_respond_with_cryptograms_and_state_async(&self, responseTemplate: &ComPtr<super::super::storage::streams::IBuffer>, cryptogramPlacementSteps: &ComPtr<foundation::collections::IIterable<SmartCardCryptogramPlacementStep>>, nextState: &ComPtr<foundation::IReference<u32>>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardCryptogramGeneratorOperationStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryRespondWithCryptogramsAndStateAsync)(self.deref() as *const _ as *mut _, responseTemplate.deref() as *const _ as *mut _, cryptogramPlacementSteps.deref() as *const _ as *mut _, nextState.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorConnectionDeactivatedEventArgs, 562485459, 50667, 21090, 67, 223, 98, 160, 161, 181, 85, 87);
RT_INTERFACE!{interface ISmartCardEmulatorConnectionDeactivatedEventArgs(ISmartCardEmulatorConnectionDeactivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorConnectionDeactivatedEventArgs] {
    fn get_ConnectionProperties(&self, out: *mut *mut SmartCardEmulatorConnectionProperties) -> HRESULT,
    fn get_Reason(&self, out: *mut SmartCardEmulatorConnectionDeactivatedReason) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorConnectionDeactivatedEventArgs> {
    #[inline] pub fn get_connection_properties(&self) -> Result<Option<ComPtr<SmartCardEmulatorConnectionProperties>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionProperties)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_reason(&self) -> Result<SmartCardEmulatorConnectionDeactivatedReason> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Reason)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulatorConnectionDeactivatedEventArgs: ISmartCardEmulatorConnectionDeactivatedEventArgs}
RT_ENUM! { enum SmartCardEmulatorConnectionDeactivatedReason: i32 {
    ConnectionLost = 0, ConnectionRedirected = 1,
}}
DEFINE_IID!(IID_ISmartCardEmulatorConnectionProperties, 1311548910, 63849, 20605, 108, 249, 52, 226, 209, 141, 243, 17);
RT_INTERFACE!{interface ISmartCardEmulatorConnectionProperties(ISmartCardEmulatorConnectionPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorConnectionProperties] {
    fn get_Id(&self, out: *mut Guid) -> HRESULT,
    fn get_Source(&self, out: *mut SmartCardEmulatorConnectionSource) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorConnectionProperties> {
    #[inline] pub fn get_id(&self) -> Result<Guid> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_source(&self) -> Result<SmartCardEmulatorConnectionSource> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Source)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardEmulatorConnectionProperties: ISmartCardEmulatorConnectionProperties}
RT_ENUM! { enum SmartCardEmulatorConnectionSource: i32 {
    Unknown = 0, NfcReader = 1,
}}
RT_ENUM! { enum SmartCardEmulatorEnablementPolicy: i32 {
    Never = 0, Always = 1, ScreenOn = 2, ScreenUnlocked = 3,
}}
DEFINE_IID!(IID_ISmartCardEmulatorStatics, 2057043019, 50387, 18767, 184, 162, 98, 21, 216, 30, 133, 178);
RT_INTERFACE!{static interface ISmartCardEmulatorStatics(ISmartCardEmulatorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardEmulator>) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardEmulator>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorStatics2, 1773051786, 46965, 18571, 132, 54, 108, 30, 40, 237, 115, 31);
RT_INTERFACE!{static interface ISmartCardEmulatorStatics2(ISmartCardEmulatorStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorStatics2] {
    fn GetAppletIdGroupRegistrationsAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCardAppletIdGroupRegistration>>) -> HRESULT,
    fn RegisterAppletIdGroupAsync(&self, appletIdGroup: *mut SmartCardAppletIdGroup, out: *mut *mut foundation::IAsyncOperation<SmartCardAppletIdGroupRegistration>) -> HRESULT,
    fn UnregisterAppletIdGroupAsync(&self, registration: *mut SmartCardAppletIdGroupRegistration, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn get_MaxAppletIdGroupRegistrations(&self, out: *mut u16) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorStatics2> {
    #[inline] pub fn get_applet_id_group_registrations_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCardAppletIdGroupRegistration>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAppletIdGroupRegistrationsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn register_applet_id_group_async(&self, appletIdGroup: &ComPtr<SmartCardAppletIdGroup>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardAppletIdGroupRegistration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RegisterAppletIdGroupAsync)(self.deref() as *const _ as *mut _, appletIdGroup.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn unregister_applet_id_group_async(&self, registration: &ComPtr<SmartCardAppletIdGroupRegistration>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).UnregisterAppletIdGroupAsync)(self.deref() as *const _ as *mut _, registration.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_applet_id_group_registrations(&self) -> Result<u16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxAppletIdGroupRegistrations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardEmulatorStatics3, 1508512810, 40713, 17397, 133, 101, 207, 168, 20, 142, 76, 178);
RT_INTERFACE!{static interface ISmartCardEmulatorStatics3(ISmartCardEmulatorStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardEmulatorStatics3] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ISmartCardEmulatorStatics3> {
    #[inline] pub fn is_supported(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).IsSupported)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardLaunchBehavior: i32 {
    Default = 0, AboveLock = 1,
}}
RT_ENUM! { enum SmartCardPinCharacterPolicyOption: i32 {
    Allow = 0, RequireAtLeastOne = 1, Disallow = 2,
}}
DEFINE_IID!(IID_ISmartCardPinPolicy, 406643076, 19894, 18497, 172, 158, 42, 193, 243, 155, 115, 4);
RT_INTERFACE!{interface ISmartCardPinPolicy(ISmartCardPinPolicyVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardPinPolicy] {
    fn get_MinLength(&self, out: *mut u32) -> HRESULT,
    fn put_MinLength(&self, value: u32) -> HRESULT,
    fn get_MaxLength(&self, out: *mut u32) -> HRESULT,
    fn put_MaxLength(&self, value: u32) -> HRESULT,
    fn get_UppercaseLetters(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_UppercaseLetters(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn get_LowercaseLetters(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_LowercaseLetters(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn get_Digits(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_Digits(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn get_SpecialCharacters(&self, out: *mut SmartCardPinCharacterPolicyOption) -> HRESULT,
    fn put_SpecialCharacters(&self, value: SmartCardPinCharacterPolicyOption) -> HRESULT
}}
impl ComPtr<ISmartCardPinPolicy> {
    #[inline] pub fn get_min_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_min_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_MinLength)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_max_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_max_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_MaxLength)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_uppercase_letters(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UppercaseLetters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_uppercase_letters(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_UppercaseLetters)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_lowercase_letters(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_LowercaseLetters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_lowercase_letters(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_LowercaseLetters)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_digits(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Digits)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_digits(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Digits)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_special_characters(&self) -> Result<SmartCardPinCharacterPolicyOption> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SpecialCharacters)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_special_characters(&self, value: SmartCardPinCharacterPolicyOption) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SpecialCharacters)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardPinPolicy: ISmartCardPinPolicy}
impl RtActivatable<IActivationFactory> for SmartCardPinPolicy {}
DEFINE_CLSID!(SmartCardPinPolicy(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,80,105,110,80,111,108,105,99,121,0]) [CLSID_SmartCardPinPolicy]);
DEFINE_IID!(IID_ISmartCardPinResetDeferral, 415845036, 30725, 16388, 133, 228, 187, 239, 172, 143, 104, 132);
RT_INTERFACE!{interface ISmartCardPinResetDeferral(ISmartCardPinResetDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardPinResetDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ComPtr<ISmartCardPinResetDeferral> {
    #[inline] pub fn complete(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Complete)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardPinResetDeferral: ISmartCardPinResetDeferral}
DEFINE_IID!(IID_SmartCardPinResetHandler, 328031808, 62396, 19036, 180, 29, 75, 78, 246, 132, 226, 55);
RT_DELEGATE!{delegate SmartCardPinResetHandler(SmartCardPinResetHandlerVtbl, SmartCardPinResetHandlerImpl) [IID_SmartCardPinResetHandler] {
    fn Invoke(&self, sender: *mut SmartCardProvisioning, request: *mut SmartCardPinResetRequest) -> HRESULT
}}
impl ComPtr<SmartCardPinResetHandler> {
    #[inline] pub fn invoke(&self, sender: &ComPtr<SmartCardProvisioning>, request: &ComPtr<SmartCardPinResetRequest>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Invoke)(self.deref() as *const _ as *mut _, sender.deref() as *const _ as *mut _, request.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardPinResetRequest, 318651469, 24505, 20110, 159, 246, 97, 244, 117, 18, 79, 239);
RT_INTERFACE!{interface ISmartCardPinResetRequest(ISmartCardPinResetRequestVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardPinResetRequest] {
    #[cfg(feature="windows-storage")] fn get_Challenge(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_Deadline(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut SmartCardPinResetDeferral) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetResponse(&self, response: *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<ISmartCardPinResetRequest> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_challenge(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Challenge)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_deadline(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Deadline)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_deferral(&self) -> Result<Option<ComPtr<SmartCardPinResetDeferral>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeferral)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_response(&self, response: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetResponse)(self.deref() as *const _ as *mut _, response.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardPinResetRequest: ISmartCardPinResetRequest}
DEFINE_IID!(IID_ISmartCardProvisioning, 435088829, 8107, 18300, 183, 18, 26, 44, 90, 241, 253, 110);
RT_INTERFACE!{interface ISmartCardProvisioning(ISmartCardProvisioningVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioning] {
    fn get_SmartCard(&self, out: *mut *mut SmartCard) -> HRESULT,
    fn GetIdAsync(&self, out: *mut *mut foundation::IAsyncOperation<Guid>) -> HRESULT,
    fn GetNameAsync(&self, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetChallengeContextAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardChallengeContext>) -> HRESULT,
    fn RequestPinChangeAsync(&self, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestPinResetAsync(&self, handler: *mut SmartCardPinResetHandler, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ISmartCardProvisioning> {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<ComPtr<SmartCard>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SmartCard)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_id_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<Guid>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetIdAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetNameAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_challenge_context_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardChallengeContext>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetChallengeContextAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_change_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestPinChangeAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_pin_reset_async(&self, handler: &ComPtr<SmartCardPinResetHandler>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestPinResetAsync)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardProvisioning: ISmartCardProvisioning}
impl RtActivatable<ISmartCardProvisioningStatics> for SmartCardProvisioning {}
impl RtActivatable<ISmartCardProvisioningStatics2> for SmartCardProvisioning {}
impl SmartCardProvisioning {
    #[inline] pub fn from_smart_card_async(card: &ComPtr<SmartCard>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().from_smart_card_async(card)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async(friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().request_virtual_smart_card_creation_async(friendlyName, administrativeKey, pinPolicy)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async_with_card_id(friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>, cardId: Guid) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().request_virtual_smart_card_creation_async_with_card_id(friendlyName, administrativeKey, pinPolicy, cardId)
    }
    #[inline] pub fn request_virtual_smart_card_deletion_async(card: &ComPtr<SmartCard>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics>>::get_activation_factory().request_virtual_smart_card_deletion_async(card)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async(friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics2>>::get_activation_factory().request_attested_virtual_smart_card_creation_async(friendlyName, administrativeKey, pinPolicy)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async_with_card_id(friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>, cardId: Guid) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> {
        <Self as RtActivatable<ISmartCardProvisioningStatics2>>::get_activation_factory().request_attested_virtual_smart_card_creation_async_with_card_id(friendlyName, administrativeKey, pinPolicy, cardId)
    }
}
DEFINE_CLSID!(SmartCardProvisioning(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,80,114,111,118,105,115,105,111,110,105,110,103,0]) [CLSID_SmartCardProvisioning]);
DEFINE_IID!(IID_ISmartCardProvisioning2, 285026539, 16249, 19302, 155, 124, 17, 193, 73, 183, 208, 188);
RT_INTERFACE!{interface ISmartCardProvisioning2(ISmartCardProvisioning2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioning2] {
    fn GetAuthorityKeyContainerNameAsync(&self, out: *mut *mut foundation::IAsyncOperation<HString>) -> HRESULT
}}
impl ComPtr<ISmartCardProvisioning2> {
    #[inline] pub fn get_authority_key_container_name_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<HString>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetAuthorityKeyContainerNameAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardProvisioningStatics, 327690312, 3347, 20080, 151, 53, 81, 218, 236, 165, 37, 79);
RT_INTERFACE!{static interface ISmartCardProvisioningStatics(ISmartCardProvisioningStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioningStatics] {
    fn FromSmartCardAsync(&self, card: *mut SmartCard, out: *mut *mut foundation::IAsyncOperation<SmartCardProvisioning>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn RequestVirtualSmartCardCreationAsync(&self, friendlyName: HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, out: *mut *mut foundation::IAsyncOperation<SmartCardProvisioning>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn RequestVirtualSmartCardCreationAsyncWithCardId(&self, friendlyName: HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, cardId: Guid, out: *mut *mut foundation::IAsyncOperation<SmartCardProvisioning>) -> HRESULT,
    fn RequestVirtualSmartCardDeletionAsync(&self, card: *mut SmartCard, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ISmartCardProvisioningStatics> {
    #[inline] pub fn from_smart_card_async(&self, card: &ComPtr<SmartCard>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromSmartCardAsync)(self.deref() as *const _ as *mut _, card.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async(&self, friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestVirtualSmartCardCreationAsync)(self.deref() as *const _ as *mut _, friendlyName.get(), administrativeKey.deref() as *const _ as *mut _, pinPolicy.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_virtual_smart_card_creation_async_with_card_id(&self, friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>, cardId: Guid) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestVirtualSmartCardCreationAsyncWithCardId)(self.deref() as *const _ as *mut _, friendlyName.get(), administrativeKey.deref() as *const _ as *mut _, pinPolicy.deref() as *const _ as *mut _, cardId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_virtual_smart_card_deletion_async(&self, card: &ComPtr<SmartCard>) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestVirtualSmartCardDeletionAsync)(self.deref() as *const _ as *mut _, card.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardProvisioningStatics2, 877119144, 51616, 19414, 181, 13, 37, 31, 78, 141, 58, 98);
RT_INTERFACE!{static interface ISmartCardProvisioningStatics2(ISmartCardProvisioningStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardProvisioningStatics2] {
    #[cfg(feature="windows-storage")] fn RequestAttestedVirtualSmartCardCreationAsync(&self, friendlyName: HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, out: *mut *mut foundation::IAsyncOperation<SmartCardProvisioning>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn RequestAttestedVirtualSmartCardCreationAsyncWithCardId(&self, friendlyName: HSTRING, administrativeKey: *mut super::super::storage::streams::IBuffer, pinPolicy: *mut SmartCardPinPolicy, cardId: Guid, out: *mut *mut foundation::IAsyncOperation<SmartCardProvisioning>) -> HRESULT
}}
impl ComPtr<ISmartCardProvisioningStatics2> {
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async(&self, friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAttestedVirtualSmartCardCreationAsync)(self.deref() as *const _ as *mut _, friendlyName.get(), administrativeKey.deref() as *const _ as *mut _, pinPolicy.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn request_attested_virtual_smart_card_creation_async_with_card_id(&self, friendlyName: &HStringArg, administrativeKey: &ComPtr<super::super::storage::streams::IBuffer>, pinPolicy: &ComPtr<SmartCardPinPolicy>, cardId: Guid) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardProvisioning>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAttestedVirtualSmartCardCreationAsyncWithCardId)(self.deref() as *const _ as *mut _, friendlyName.get(), administrativeKey.deref() as *const _ as *mut _, pinPolicy.deref() as *const _ as *mut _, cardId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardReader, 276083936, 21698, 19952, 129, 122, 20, 193, 67, 120, 240, 108);
RT_INTERFACE!{interface ISmartCardReader(ISmartCardReaderVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardReader] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut SmartCardReaderKind) -> HRESULT,
    fn GetStatusAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmartCardReaderStatus>) -> HRESULT,
    fn FindAllCardsAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCard>>) -> HRESULT,
    fn add_CardAdded(&self, handler: *mut foundation::TypedEventHandler<SmartCardReader, CardAddedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CardAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_CardRemoved(&self, handler: *mut foundation::TypedEventHandler<SmartCardReader, CardRemovedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CardRemoved(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ISmartCardReader> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Name)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_kind(&self) -> Result<SmartCardReaderKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Kind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_status_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardReaderStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetStatusAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn find_all_cards_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SmartCard>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllCardsAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_card_added(&self, handler: &ComPtr<foundation::TypedEventHandler<SmartCardReader, CardAddedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CardAdded)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_card_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CardAdded)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_card_removed(&self, handler: &ComPtr<foundation::TypedEventHandler<SmartCardReader, CardRemovedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_CardRemoved)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_card_removed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_CardRemoved)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardReader: ISmartCardReader}
impl RtActivatable<ISmartCardReaderStatics> for SmartCardReader {}
impl SmartCardReader {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISmartCardReaderStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_with_kind(kind: SmartCardReaderKind) -> Result<HString> {
        <Self as RtActivatable<ISmartCardReaderStatics>>::get_activation_factory().get_device_selector_with_kind(kind)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardReader>>> {
        <Self as RtActivatable<ISmartCardReaderStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(SmartCardReader(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,97,114,116,67,97,114,100,115,46,83,109,97,114,116,67,97,114,100,82,101,97,100,101,114,0]) [CLSID_SmartCardReader]);
RT_ENUM! { enum SmartCardReaderKind: i32 {
    Any = 0, Generic = 1, Tpm = 2, Nfc = 3, Uicc = 4, EmbeddedSE = 5,
}}
DEFINE_IID!(IID_ISmartCardReaderStatics, 272368865, 41418, 18674, 162, 129, 91, 111, 102, 154, 241, 7);
RT_INTERFACE!{static interface ISmartCardReaderStatics(ISmartCardReaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardReaderStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorWithKind(&self, kind: SmartCardReaderKind, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmartCardReader>) -> HRESULT
}}
impl ComPtr<ISmartCardReaderStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_with_kind(&self, kind: SmartCardReaderKind) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorWithKind)(self.deref() as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmartCardReader>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardReaderStatus: i32 {
    Disconnected = 0, Ready = 1, Exclusive = 2,
}}
RT_ENUM! { enum SmartCardStatus: i32 {
    Disconnected = 0, Ready = 1, Shared = 2, Exclusive = 3, Unresponsive = 4,
}}
DEFINE_IID!(IID_ISmartCardTriggerDetails, 1604055326, 14831, 20267, 180, 79, 10, 145, 85, 177, 119, 188);
RT_INTERFACE!{interface ISmartCardTriggerDetails(ISmartCardTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerDetails] {
    fn get_TriggerType(&self, out: *mut SmartCardTriggerType) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_SourceAppletId(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_TriggerData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<ISmartCardTriggerDetails> {
    #[inline] pub fn get_trigger_type(&self) -> Result<SmartCardTriggerType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TriggerType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_source_applet_id(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SourceAppletId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_trigger_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TriggerData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmartCardTriggerDetails: ISmartCardTriggerDetails}
DEFINE_IID!(IID_ISmartCardTriggerDetails2, 692438377, 35189, 19025, 158, 26, 95, 138, 118, 238, 81, 175);
RT_INTERFACE!{interface ISmartCardTriggerDetails2(ISmartCardTriggerDetails2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerDetails2] {
    fn get_Emulator(&self, out: *mut *mut SmartCardEmulator) -> HRESULT,
    fn TryLaunchCurrentAppAsync(&self, arguments: HSTRING, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryLaunchCurrentAppWithBehaviorAsync(&self, arguments: HSTRING, behavior: SmartCardLaunchBehavior, out: *mut *mut foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl ComPtr<ISmartCardTriggerDetails2> {
    #[inline] pub fn get_emulator(&self) -> Result<Option<ComPtr<SmartCardEmulator>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Emulator)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_launch_current_app_async(&self, arguments: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryLaunchCurrentAppAsync)(self.deref() as *const _ as *mut _, arguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn try_launch_current_app_with_behavior_async(&self, arguments: &HStringArg, behavior: SmartCardLaunchBehavior) -> Result<ComPtr<foundation::IAsyncOperation<bool>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).TryLaunchCurrentAppWithBehaviorAsync)(self.deref() as *const _ as *mut _, arguments.get(), behavior, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmartCardTriggerDetails3, 3017982589, 6342, 19368, 131, 118, 239, 3, 212, 145, 38, 102);
RT_INTERFACE!{interface ISmartCardTriggerDetails3(ISmartCardTriggerDetails3Vtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerDetails3] {
    fn get_SmartCard(&self, out: *mut *mut SmartCard) -> HRESULT
}}
impl ComPtr<ISmartCardTriggerDetails3> {
    #[inline] pub fn get_smart_card(&self) -> Result<Option<ComPtr<SmartCard>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SmartCard)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmartCardTriggerType: i32 {
    EmulatorTransaction = 0, EmulatorNearFieldEntry = 1, EmulatorNearFieldExit = 2, EmulatorHostApplicationActivated = 3, EmulatorAppletIdGroupRegistrationChanged = 4, ReaderCardAdded = 5,
}}
RT_ENUM! { enum SmartCardUnlockPromptingBehavior: i32 {
    AllowUnlockPrompt = 0, RequireUnlockPrompt = 1, PreventUnlockPrompt = 2,
}}
} // Windows.Devices.SmartCards
pub mod sms { // Windows.Devices.Sms
use crate::prelude::*;
RT_ENUM! { enum CellularClass: i32 {
    None = 0, Gsm = 1, Cdma = 2,
}}
RT_CLASS!{class DeleteSmsMessageOperation: foundation::IAsyncAction}
RT_CLASS!{class DeleteSmsMessagesOperation: foundation::IAsyncAction}
RT_CLASS!{class GetSmsDeviceOperation: foundation::IAsyncOperation<SmsDevice>}
RT_CLASS!{class GetSmsMessageOperation: foundation::IAsyncOperation<ISmsMessage>}
RT_CLASS!{class GetSmsMessagesOperation: foundation::IAsyncOperationWithProgress<foundation::collections::IVectorView<ISmsMessage>, i32>}
RT_CLASS!{class SendSmsMessageOperation: foundation::IAsyncAction}
DEFINE_IID!(IID_ISmsAppMessage, 3904603284, 54176, 18954, 134, 215, 41, 16, 51, 168, 207, 84);
RT_INTERFACE!{interface ISmsAppMessage(ISmsAppMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsAppMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_CallbackNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CallbackNumber(&self, value: HSTRING) -> HRESULT,
    fn get_IsDeliveryNotificationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDeliveryNotificationEnabled(&self, value: bool) -> HRESULT,
    fn get_RetryAttemptCount(&self, out: *mut i32) -> HRESULT,
    fn put_RetryAttemptCount(&self, value: i32) -> HRESULT,
    fn get_Encoding(&self, out: *mut SmsEncoding) -> HRESULT,
    fn put_Encoding(&self, value: SmsEncoding) -> HRESULT,
    fn get_PortNumber(&self, out: *mut i32) -> HRESULT,
    fn put_PortNumber(&self, value: i32) -> HRESULT,
    fn get_TeleserviceId(&self, out: *mut i32) -> HRESULT,
    fn put_TeleserviceId(&self, value: i32) -> HRESULT,
    fn get_ProtocolId(&self, out: *mut i32) -> HRESULT,
    fn put_ProtocolId(&self, value: i32) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_BinaryBody(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_BinaryBody(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<ISmsAppMessage> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_to(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_To)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_From)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Body)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Body)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_callback_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CallbackNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_callback_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CallbackNumber)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_delivery_notification_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDeliveryNotificationEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_delivery_notification_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDeliveryNotificationEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_retry_attempt_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RetryAttemptCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_retry_attempt_count(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RetryAttemptCount)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding(&self) -> Result<SmsEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Encoding)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding(&self, value: SmsEncoding) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Encoding)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_port_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PortNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_port_number(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PortNumber)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_teleservice_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TeleserviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_teleservice_id(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_TeleserviceId)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtocolId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_protocol_id(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ProtocolId)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_binary_body(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BinaryBody)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_binary_body(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_BinaryBody)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsAppMessage: ISmsAppMessage}
impl RtActivatable<IActivationFactory> for SmsAppMessage {}
DEFINE_CLSID!(SmsAppMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,65,112,112,77,101,115,115,97,103,101,0]) [CLSID_SmsAppMessage]);
DEFINE_IID!(IID_ISmsBinaryMessage, 1542776851, 15187, 19566, 182, 26, 216, 106, 99, 117, 86, 80);
RT_INTERFACE!{interface ISmsBinaryMessage(ISmsBinaryMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsBinaryMessage] {
    fn get_Format(&self, out: *mut SmsDataFormat) -> HRESULT,
    fn put_Format(&self, value: SmsDataFormat) -> HRESULT,
    fn GetData(&self, outSize: *mut u32, out: *mut *mut u8) -> HRESULT,
    fn SetData(&self, valueSize: u32, value: *mut u8) -> HRESULT
}}
impl ComPtr<ISmsBinaryMessage> {
    #[inline] pub fn get_format(&self) -> Result<SmsDataFormat> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Format)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_format(&self, value: SmsDataFormat) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Format)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data(&self) -> Result<ComArray<u8>> { unsafe { 
        let mut outSize = 0; let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetData)(self.deref() as *const _ as *mut _, &mut outSize, &mut out);
        if hr == S_OK { Ok(ComArray::from_raw(outSize, out)) } else { err(hr) }
    }}
    #[inline] pub fn set_data(&self, value: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).SetData)(self.deref() as *const _ as *mut _, value.len() as u32, value.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsBinaryMessage: ISmsBinaryMessage}
impl RtActivatable<IActivationFactory> for SmsBinaryMessage {}
DEFINE_CLSID!(SmsBinaryMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,66,105,110,97,114,121,77,101,115,115,97,103,101,0]) [CLSID_SmsBinaryMessage]);
DEFINE_IID!(IID_ISmsBroadcastMessage, 1974385649, 58551, 18548, 160, 156, 41, 86, 229, 146, 249, 87);
RT_INTERFACE!{interface ISmsBroadcastMessage(ISmsBroadcastMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsBroadcastMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Channel(&self, out: *mut i32) -> HRESULT,
    fn get_GeographicalScope(&self, out: *mut SmsGeographicalScope) -> HRESULT,
    fn get_MessageCode(&self, out: *mut i32) -> HRESULT,
    fn get_UpdateNumber(&self, out: *mut i32) -> HRESULT,
    fn get_BroadcastType(&self, out: *mut SmsBroadcastType) -> HRESULT,
    fn get_IsEmergencyAlert(&self, out: *mut bool) -> HRESULT,
    fn get_IsUserPopupRequested(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<ISmsBroadcastMessage> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Body)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_channel(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Channel)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_geographical_scope(&self) -> Result<SmsGeographicalScope> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GeographicalScope)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_update_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_UpdateNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_type(&self) -> Result<SmsBroadcastType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BroadcastType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_emergency_alert(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEmergencyAlert)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_user_popup_requested(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsUserPopupRequested)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsBroadcastMessage: ISmsBroadcastMessage}
RT_ENUM! { enum SmsBroadcastType: i32 {
    Other = 0, CmasPresidential = 1, CmasExtreme = 2, CmasSevere = 3, CmasAmber = 4, CmasTest = 5, EUAlert1 = 6, EUAlert2 = 7, EUAlert3 = 8, EUAlertAmber = 9, EUAlertInfo = 10, EtwsEarthquake = 11, EtwsTsunami = 12, EtwsTsunamiAndEarthquake = 13, LatAlertLocal = 14,
}}
RT_ENUM! { enum SmsDataFormat: i32 {
    Unknown = 0, CdmaSubmit = 1, GsmSubmit = 2, CdmaDeliver = 3, GsmDeliver = 4,
}}
DEFINE_IID!(IID_ISmsDevice, 152539629, 34603, 20204, 156, 114, 171, 17, 98, 123, 52, 236);
RT_INTERFACE!{interface ISmsDevice(ISmsDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDevice] {
    fn SendMessageAsync(&self, message: *mut ISmsMessage, out: *mut *mut SendSmsMessageOperation) -> HRESULT,
    fn CalculateLength(&self, message: *mut SmsTextMessage, out: *mut SmsEncodedLength) -> HRESULT,
    fn get_AccountPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_MessageStore(&self, out: *mut *mut SmsDeviceMessageStore) -> HRESULT,
    fn get_DeviceStatus(&self, out: *mut SmsDeviceStatus) -> HRESULT,
    fn add_SmsMessageReceived(&self, eventHandler: *mut SmsMessageReceivedEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SmsMessageReceived(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn add_SmsDeviceStatusChanged(&self, eventHandler: *mut SmsDeviceStatusChangedEventHandler, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SmsDeviceStatusChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ISmsDevice> {
    #[inline] pub fn send_message_async(&self, message: &ComPtr<ISmsMessage>) -> Result<ComPtr<SendSmsMessageOperation>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendMessageAsync)(self.deref() as *const _ as *mut _, message.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn calculate_length(&self, message: &ComPtr<SmsTextMessage>) -> Result<SmsEncodedLength> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).CalculateLength)(self.deref() as *const _ as *mut _, message.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_account_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AccountPhoneNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CellularClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_store(&self) -> Result<Option<ComPtr<SmsDeviceMessageStore>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MessageStore)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_status(&self) -> Result<SmsDeviceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DeviceStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_sms_message_received(&self, eventHandler: &ComPtr<SmsMessageReceivedEventHandler>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SmsMessageReceived)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sms_message_received(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SmsMessageReceived)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_sms_device_status_changed(&self, eventHandler: &ComPtr<SmsDeviceStatusChangedEventHandler>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SmsDeviceStatusChanged)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_sms_device_status_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SmsDeviceStatusChanged)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsDevice: ISmsDevice}
impl RtActivatable<ISmsDeviceStatics> for SmsDevice {}
impl RtActivatable<ISmsDeviceStatics2> for SmsDevice {}
impl SmsDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISmsDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmsDevice>>> {
        <Self as RtActivatable<ISmsDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<SmsDevice>>> {
        <Self as RtActivatable<ISmsDeviceStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn from_network_account_id_async(networkAccountId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmsDevice>>> {
        <Self as RtActivatable<ISmsDeviceStatics2>>::get_activation_factory().from_network_account_id_async(networkAccountId)
    }
}
DEFINE_CLSID!(SmsDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,68,101,118,105,99,101,0]) [CLSID_SmsDevice]);
DEFINE_IID!(IID_ISmsDevice2, 3179961363, 58658, 18123, 184, 213, 158, 173, 48, 251, 108, 71);
RT_INTERFACE!{interface ISmsDevice2(ISmsDevice2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsDevice2] {
    fn get_SmscAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SmscAddress(&self, value: HSTRING) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParentDeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AccountPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_DeviceStatus(&self, out: *mut SmsDeviceStatus) -> HRESULT,
    fn CalculateLength(&self, message: *mut ISmsMessageBase, out: *mut SmsEncodedLength) -> HRESULT,
    fn SendMessageAndGetResultAsync(&self, message: *mut ISmsMessageBase, out: *mut *mut foundation::IAsyncOperation<SmsSendMessageResult>) -> HRESULT,
    fn add_DeviceStatusChanged(&self, eventHandler: *mut foundation::TypedEventHandler<SmsDevice2, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeviceStatusChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ISmsDevice2> {
    #[inline] pub fn get_smsc_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SmscAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_smsc_address(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SmscAddress)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_parent_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ParentDeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_account_phone_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AccountPhoneNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CellularClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_status(&self) -> Result<SmsDeviceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DeviceStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn calculate_length(&self, message: &ComPtr<ISmsMessageBase>) -> Result<SmsEncodedLength> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).CalculateLength)(self.deref() as *const _ as *mut _, message.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn send_message_and_get_result_async(&self, message: &ComPtr<ISmsMessageBase>) -> Result<ComPtr<foundation::IAsyncOperation<SmsSendMessageResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendMessageAndGetResultAsync)(self.deref() as *const _ as *mut _, message.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_device_status_changed(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<SmsDevice2, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DeviceStatusChanged)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_device_status_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DeviceStatusChanged)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsDevice2: ISmsDevice2}
impl RtActivatable<ISmsDevice2Statics> for SmsDevice2 {}
impl SmsDevice2 {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id(deviceId: &HStringArg) -> Result<Option<ComPtr<SmsDevice2>>> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().from_id(deviceId)
    }
    #[inline] pub fn get_default() -> Result<Option<ComPtr<SmsDevice2>>> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().get_default()
    }
    #[inline] pub fn from_parent_id(parentDeviceId: &HStringArg) -> Result<Option<ComPtr<SmsDevice2>>> {
        <Self as RtActivatable<ISmsDevice2Statics>>::get_activation_factory().from_parent_id(parentDeviceId)
    }
}
DEFINE_CLSID!(SmsDevice2(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,68,101,118,105,99,101,50,0]) [CLSID_SmsDevice2]);
DEFINE_IID!(IID_ISmsDevice2Statics, 1707574053, 4145, 18718, 143, 182, 239, 153, 145, 175, 227, 99);
RT_INTERFACE!{static interface ISmsDevice2Statics(ISmsDevice2StaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDevice2Statics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromId(&self, deviceId: HSTRING, out: *mut *mut SmsDevice2) -> HRESULT,
    fn GetDefault(&self, out: *mut *mut SmsDevice2) -> HRESULT,
    fn FromParentId(&self, parentDeviceId: HSTRING, out: *mut *mut SmsDevice2) -> HRESULT
}}
impl ComPtr<ISmsDevice2Statics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id(&self, deviceId: &HStringArg) -> Result<Option<ComPtr<SmsDevice2>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromId)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default(&self) -> Result<Option<ComPtr<SmsDevice2>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefault)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_parent_id(&self, parentDeviceId: &HStringArg) -> Result<Option<ComPtr<SmsDevice2>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromParentId)(self.deref() as *const _ as *mut _, parentDeviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsDeviceMessageStore, 2559177299, 61832, 17447, 141, 84, 206, 12, 36, 35, 197, 193);
RT_INTERFACE!{interface ISmsDeviceMessageStore(ISmsDeviceMessageStoreVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDeviceMessageStore] {
    fn DeleteMessageAsync(&self, messageId: u32, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn DeleteMessagesAsync(&self, messageFilter: SmsMessageFilter, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn GetMessageAsync(&self, messageId: u32, out: *mut *mut foundation::IAsyncOperation<ISmsMessage>) -> HRESULT,
    fn GetMessagesAsync(&self, messageFilter: SmsMessageFilter, out: *mut *mut foundation::IAsyncOperationWithProgress<foundation::collections::IVectorView<ISmsMessage>, i32>) -> HRESULT,
    fn get_MaxMessages(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ISmsDeviceMessageStore> {
    #[inline] pub fn delete_message_async(&self, messageId: u32) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DeleteMessageAsync)(self.deref() as *const _ as *mut _, messageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn delete_messages_async(&self, messageFilter: SmsMessageFilter) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).DeleteMessagesAsync)(self.deref() as *const _ as *mut _, messageFilter, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_async(&self, messageId: u32) -> Result<ComPtr<foundation::IAsyncOperation<ISmsMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetMessageAsync)(self.deref() as *const _ as *mut _, messageId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_messages_async(&self, messageFilter: SmsMessageFilter) -> Result<ComPtr<foundation::IAsyncOperationWithProgress<foundation::collections::IVectorView<ISmsMessage>, i32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetMessagesAsync)(self.deref() as *const _ as *mut _, messageFilter, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_max_messages(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxMessages)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsDeviceMessageStore: ISmsDeviceMessageStore}
DEFINE_IID!(IID_ISmsDeviceStatics, 4169992170, 55317, 19921, 162, 52, 69, 32, 206, 70, 4, 164);
RT_INTERFACE!{static interface ISmsDeviceStatics(ISmsDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmsDevice>) -> HRESULT,
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<SmsDevice>) -> HRESULT
}}
impl ComPtr<ISmsDeviceStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmsDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SmsDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsDeviceStatics2, 748756103, 2163, 19631, 138, 125, 189, 71, 30, 133, 134, 209);
RT_INTERFACE!{static interface ISmsDeviceStatics2(ISmsDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsDeviceStatics2] {
    fn FromNetworkAccountIdAsync(&self, networkAccountId: HSTRING, out: *mut *mut foundation::IAsyncOperation<SmsDevice>) -> HRESULT
}}
impl ComPtr<ISmsDeviceStatics2> {
    #[inline] pub fn from_network_account_id_async(&self, networkAccountId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<SmsDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromNetworkAccountIdAsync)(self.deref() as *const _ as *mut _, networkAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsDeviceStatus: i32 {
    Off = 0, Ready = 1, SimNotInserted = 2, BadSim = 3, DeviceFailure = 4, SubscriptionNotActivated = 5, DeviceLocked = 6, DeviceBlocked = 7,
}}
DEFINE_IID!(IID_SmsDeviceStatusChangedEventHandler, 2552959330, 15831, 17944, 175, 137, 12, 39, 45, 93, 6, 216);
RT_DELEGATE!{delegate SmsDeviceStatusChangedEventHandler(SmsDeviceStatusChangedEventHandlerVtbl, SmsDeviceStatusChangedEventHandlerImpl) [IID_SmsDeviceStatusChangedEventHandler] {
    fn Invoke(&self, sender: *mut SmsDevice) -> HRESULT
}}
impl ComPtr<SmsDeviceStatusChangedEventHandler> {
    #[inline] pub fn invoke(&self, sender: &ComPtr<SmsDevice>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Invoke)(self.deref() as *const _ as *mut _, sender.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_STRUCT! { struct SmsEncodedLength {
    SegmentCount: u32, CharacterCountLastSegment: u32, CharactersPerSegment: u32, ByteCountLastSegment: u32, BytesPerSegment: u32,
}}
RT_ENUM! { enum SmsEncoding: i32 {
    Unknown = 0, Optimal = 1, SevenBitAscii = 2, Unicode = 3, GsmSevenBit = 4, EightBit = 5, Latin = 6, Korean = 7, IA5 = 8, ShiftJis = 9, LatinHebrew = 10,
}}
RT_ENUM! { enum SmsFilterActionType: i32 {
    AcceptImmediately = 0, Drop = 1, Peek = 2, Accept = 3,
}}
DEFINE_IID!(IID_ISmsFilterRule, 1088630702, 45129, 20412, 175, 233, 226, 166, 16, 239, 245, 92);
RT_INTERFACE!{interface ISmsFilterRule(ISmsFilterRuleVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRule] {
    fn get_MessageType(&self, out: *mut SmsMessageType) -> HRESULT,
    fn get_ImsiPrefixes(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn get_DeviceIds(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn get_SenderNumbers(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn get_TextMessagePrefixes(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn get_PortNumbers(&self, out: *mut *mut foundation::collections::IVector<i32>) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn put_CellularClass(&self, value: CellularClass) -> HRESULT,
    fn get_ProtocolIds(&self, out: *mut *mut foundation::collections::IVector<i32>) -> HRESULT,
    fn get_TeleserviceIds(&self, out: *mut *mut foundation::collections::IVector<i32>) -> HRESULT,
    fn get_WapApplicationIds(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn get_WapContentTypes(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    fn get_BroadcastTypes(&self, out: *mut *mut foundation::collections::IVector<SmsBroadcastType>) -> HRESULT,
    fn get_BroadcastChannels(&self, out: *mut *mut foundation::collections::IVector<i32>) -> HRESULT
}}
impl ComPtr<ISmsFilterRule> {
    #[inline] pub fn get_message_type(&self) -> Result<SmsMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_imsi_prefixes(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ImsiPrefixes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_sender_numbers(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SenderNumbers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_text_message_prefixes(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TextMessagePrefixes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_port_numbers(&self) -> Result<Option<ComPtr<foundation::collections::IVector<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PortNumbers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CellularClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_cellular_class(&self, value: CellularClass) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CellularClass)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVector<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_teleservice_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVector<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TeleserviceIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wap_application_ids(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_WapApplicationIds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wap_content_types(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_WapContentTypes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_types(&self) -> Result<Option<ComPtr<foundation::collections::IVector<SmsBroadcastType>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BroadcastTypes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_channels(&self) -> Result<Option<ComPtr<foundation::collections::IVector<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BroadcastChannels)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsFilterRule: ISmsFilterRule}
impl RtActivatable<ISmsFilterRuleFactory> for SmsFilterRule {}
impl SmsFilterRule {
    #[inline] pub fn create_filter_rule(messageType: SmsMessageType) -> Result<ComPtr<SmsFilterRule>> {
        <Self as RtActivatable<ISmsFilterRuleFactory>>::get_activation_factory().create_filter_rule(messageType)
    }
}
DEFINE_CLSID!(SmsFilterRule(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,70,105,108,116,101,114,82,117,108,101,0]) [CLSID_SmsFilterRule]);
DEFINE_IID!(IID_ISmsFilterRuleFactory, 12805384, 25238, 20265, 154, 173, 137, 32, 206, 186, 60, 232);
RT_INTERFACE!{static interface ISmsFilterRuleFactory(ISmsFilterRuleFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRuleFactory] {
    fn CreateFilterRule(&self, messageType: SmsMessageType, out: *mut *mut SmsFilterRule) -> HRESULT
}}
impl ComPtr<ISmsFilterRuleFactory> {
    #[inline] pub fn create_filter_rule(&self, messageType: SmsMessageType) -> Result<ComPtr<SmsFilterRule>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFilterRule)(self.deref() as *const _ as *mut _, messageType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsFilterRules, 1313336059, 31181, 18561, 152, 148, 85, 164, 19, 91, 35, 250);
RT_INTERFACE!{interface ISmsFilterRules(ISmsFilterRulesVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRules] {
    fn get_ActionType(&self, out: *mut SmsFilterActionType) -> HRESULT,
    fn get_Rules(&self, out: *mut *mut foundation::collections::IVector<SmsFilterRule>) -> HRESULT
}}
impl ComPtr<ISmsFilterRules> {
    #[inline] pub fn get_action_type(&self) -> Result<SmsFilterActionType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ActionType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_rules(&self) -> Result<Option<ComPtr<foundation::collections::IVector<SmsFilterRule>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Rules)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsFilterRules: ISmsFilterRules}
impl RtActivatable<ISmsFilterRulesFactory> for SmsFilterRules {}
impl SmsFilterRules {
    #[inline] pub fn create_filter_rules(actionType: SmsFilterActionType) -> Result<ComPtr<SmsFilterRules>> {
        <Self as RtActivatable<ISmsFilterRulesFactory>>::get_activation_factory().create_filter_rules(actionType)
    }
}
DEFINE_CLSID!(SmsFilterRules(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,70,105,108,116,101,114,82,117,108,101,115,0]) [CLSID_SmsFilterRules]);
DEFINE_IID!(IID_ISmsFilterRulesFactory, 2694391021, 28206, 17712, 159, 222, 70, 93, 2, 238, 208, 14);
RT_INTERFACE!{static interface ISmsFilterRulesFactory(ISmsFilterRulesFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmsFilterRulesFactory] {
    fn CreateFilterRules(&self, actionType: SmsFilterActionType, out: *mut *mut SmsFilterRules) -> HRESULT
}}
impl ComPtr<ISmsFilterRulesFactory> {
    #[inline] pub fn create_filter_rules(&self, actionType: SmsFilterActionType) -> Result<ComPtr<SmsFilterRules>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFilterRules)(self.deref() as *const _ as *mut _, actionType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsGeographicalScope: i32 {
    None = 0, CellWithImmediateDisplay = 1, LocationArea = 2, Plmn = 3, Cell = 4,
}}
DEFINE_IID!(IID_ISmsMessage, 3980156456, 27012, 19207, 129, 29, 141, 89, 6, 237, 60, 234);
RT_INTERFACE!{interface ISmsMessage(ISmsMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessage] {
    fn get_Id(&self, out: *mut u32) -> HRESULT,
    fn get_MessageClass(&self, out: *mut SmsMessageClass) -> HRESULT
}}
impl ComPtr<ISmsMessage> {
    #[inline] pub fn get_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_class(&self) -> Result<SmsMessageClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsMessageBase, 753991216, 65104, 20422, 170, 136, 76, 207, 226, 122, 41, 234);
RT_INTERFACE!{interface ISmsMessageBase(ISmsMessageBaseVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageBase] {
    fn get_MessageType(&self, out: *mut SmsMessageType) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_MessageClass(&self, out: *mut SmsMessageClass) -> HRESULT,
    fn get_SimIccId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ComPtr<ISmsMessageBase> {
    #[inline] pub fn get_message_type(&self) -> Result<SmsMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CellularClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_class(&self) -> Result<SmsMessageClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_sim_icc_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SimIccId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsMessageClass: i32 {
    None = 0, Class0 = 1, Class1 = 2, Class2 = 3, Class3 = 4,
}}
RT_ENUM! { enum SmsMessageFilter: i32 {
    All = 0, Unread = 1, Read = 2, Sent = 3, Draft = 4,
}}
DEFINE_IID!(IID_ISmsMessageReceivedEventArgs, 149424792, 47333, 16833, 163, 216, 211, 171, 250, 226, 38, 117);
RT_INTERFACE!{interface ISmsMessageReceivedEventArgs(ISmsMessageReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedEventArgs] {
    fn get_TextMessage(&self, out: *mut *mut SmsTextMessage) -> HRESULT,
    fn get_BinaryMessage(&self, out: *mut *mut SmsBinaryMessage) -> HRESULT
}}
impl ComPtr<ISmsMessageReceivedEventArgs> {
    #[inline] pub fn get_text_message(&self) -> Result<Option<ComPtr<SmsTextMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TextMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_binary_message(&self) -> Result<Option<ComPtr<SmsBinaryMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BinaryMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageReceivedEventArgs: ISmsMessageReceivedEventArgs}
DEFINE_IID!(IID_SmsMessageReceivedEventHandler, 192599049, 60461, 18382, 162, 83, 115, 43, 238, 235, 202, 205);
RT_DELEGATE!{delegate SmsMessageReceivedEventHandler(SmsMessageReceivedEventHandlerVtbl, SmsMessageReceivedEventHandlerImpl) [IID_SmsMessageReceivedEventHandler] {
    fn Invoke(&self, sender: *mut SmsDevice, e: *mut SmsMessageReceivedEventArgs) -> HRESULT
}}
impl ComPtr<SmsMessageReceivedEventHandler> {
    #[inline] pub fn invoke(&self, sender: &ComPtr<SmsDevice>, e: &ComPtr<SmsMessageReceivedEventArgs>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Invoke)(self.deref() as *const _ as *mut _, sender.deref() as *const _ as *mut _, e.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsMessageReceivedTriggerDetails, 735038420, 9815, 16680, 173, 95, 227, 135, 113, 50, 189, 177);
RT_INTERFACE!{interface ISmsMessageReceivedTriggerDetails(ISmsMessageReceivedTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedTriggerDetails] {
    fn get_MessageType(&self, out: *mut SmsMessageType) -> HRESULT,
    fn get_TextMessage(&self, out: *mut *mut SmsTextMessage2) -> HRESULT,
    fn get_WapMessage(&self, out: *mut *mut SmsWapMessage) -> HRESULT,
    fn get_AppMessage(&self, out: *mut *mut SmsAppMessage) -> HRESULT,
    fn get_BroadcastMessage(&self, out: *mut *mut SmsBroadcastMessage) -> HRESULT,
    fn get_VoicemailMessage(&self, out: *mut *mut SmsVoicemailMessage) -> HRESULT,
    fn get_StatusMessage(&self, out: *mut *mut SmsStatusMessage) -> HRESULT,
    fn Drop(&self) -> HRESULT,
    fn Accept(&self) -> HRESULT
}}
impl ComPtr<ISmsMessageReceivedTriggerDetails> {
    #[inline] pub fn get_message_type(&self) -> Result<SmsMessageType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_text_message(&self) -> Result<Option<ComPtr<SmsTextMessage2>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_TextMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_wap_message(&self) -> Result<Option<ComPtr<SmsWapMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_WapMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_app_message(&self) -> Result<Option<ComPtr<SmsAppMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AppMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_broadcast_message(&self) -> Result<Option<ComPtr<SmsBroadcastMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BroadcastMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_voicemail_message(&self) -> Result<Option<ComPtr<SmsVoicemailMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VoicemailMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status_message(&self) -> Result<Option<ComPtr<SmsStatusMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_StatusMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn drop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Drop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn accept(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Accept)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageReceivedTriggerDetails: ISmsMessageReceivedTriggerDetails}
DEFINE_IID!(IID_ISmsMessageRegistration, 387993662, 62287, 17515, 131, 179, 15, 241, 153, 35, 180, 9);
RT_INTERFACE!{interface ISmsMessageRegistration(ISmsMessageRegistrationVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageRegistration] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn Unregister(&self) -> HRESULT,
    fn add_MessageReceived(&self, eventHandler: *mut foundation::TypedEventHandler<SmsMessageRegistration, SmsMessageReceivedTriggerDetails>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageReceived(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<ISmsMessageRegistration> {
    #[inline] pub fn get_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Id)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn unregister(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Unregister)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_message_received(&self, eventHandler: &ComPtr<foundation::TypedEventHandler<SmsMessageRegistration, SmsMessageReceivedTriggerDetails>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_MessageReceived)(self.deref() as *const _ as *mut _, eventHandler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_message_received(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_MessageReceived)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsMessageRegistration: ISmsMessageRegistration}
impl RtActivatable<ISmsMessageRegistrationStatics> for SmsMessageRegistration {}
impl SmsMessageRegistration {
    #[inline] pub fn get_all_registrations() -> Result<Option<ComPtr<foundation::collections::IVectorView<SmsMessageRegistration>>>> {
        <Self as RtActivatable<ISmsMessageRegistrationStatics>>::get_activation_factory().get_all_registrations()
    }
    #[inline] pub fn register(id: &HStringArg, filterRules: &ComPtr<SmsFilterRules>) -> Result<Option<ComPtr<SmsMessageRegistration>>> {
        <Self as RtActivatable<ISmsMessageRegistrationStatics>>::get_activation_factory().register(id, filterRules)
    }
}
DEFINE_CLSID!(SmsMessageRegistration(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,77,101,115,115,97,103,101,82,101,103,105,115,116,114,97,116,105,111,110,0]) [CLSID_SmsMessageRegistration]);
DEFINE_IID!(IID_ISmsMessageRegistrationStatics, 1671451748, 10392, 18296, 160, 60, 111, 153, 73, 7, 214, 58);
RT_INTERFACE!{static interface ISmsMessageRegistrationStatics(ISmsMessageRegistrationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageRegistrationStatics] {
    fn get_AllRegistrations(&self, out: *mut *mut foundation::collections::IVectorView<SmsMessageRegistration>) -> HRESULT,
    fn Register(&self, id: HSTRING, filterRules: *mut SmsFilterRules, out: *mut *mut SmsMessageRegistration) -> HRESULT
}}
impl ComPtr<ISmsMessageRegistrationStatics> {
    #[inline] pub fn get_all_registrations(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<SmsMessageRegistration>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AllRegistrations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn register(&self, id: &HStringArg, filterRules: &ComPtr<SmsFilterRules>) -> Result<Option<ComPtr<SmsMessageRegistration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Register)(self.deref() as *const _ as *mut _, id.get(), filterRules.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SmsMessageType: i32 {
    Binary = 0, Text = 1, Wap = 2, App = 3, Broadcast = 4, Voicemail = 5, Status = 6,
}}
RT_ENUM! { enum SmsModemErrorCode: i32 {
    Other = 0, MessagingNetworkError = 1, SmsOperationNotSupportedByDevice = 2, SmsServiceNotSupportedByNetwork = 3, DeviceFailure = 4, MessageNotEncodedProperly = 5, MessageTooLarge = 6, DeviceNotReady = 7, NetworkNotReady = 8, InvalidSmscAddress = 9, NetworkFailure = 10, FixedDialingNumberRestricted = 11,
}}
DEFINE_IID!(IID_ISmsReceivedEventDetails, 1538592533, 58477, 19586, 132, 125, 90, 3, 4, 193, 213, 61);
RT_INTERFACE!{interface ISmsReceivedEventDetails(ISmsReceivedEventDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsReceivedEventDetails] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MessageIndex(&self, out: *mut u32) -> HRESULT
}}
impl ComPtr<ISmsReceivedEventDetails> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageIndex)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsReceivedEventDetails: ISmsReceivedEventDetails}
DEFINE_IID!(IID_ISmsReceivedEventDetails2, 1088445574, 42932, 18289, 154, 231, 11, 95, 251, 18, 192, 58);
RT_INTERFACE!{interface ISmsReceivedEventDetails2(ISmsReceivedEventDetails2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsReceivedEventDetails2] {
    fn get_MessageClass(&self, out: *mut SmsMessageClass) -> HRESULT,
    fn get_BinaryMessage(&self, out: *mut *mut SmsBinaryMessage) -> HRESULT
}}
impl ComPtr<ISmsReceivedEventDetails2> {
    #[inline] pub fn get_message_class(&self) -> Result<SmsMessageClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_binary_message(&self) -> Result<Option<ComPtr<SmsBinaryMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BinaryMessage)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsSendMessageResult, 3675495154, 30921, 20459, 150, 34, 69, 35, 40, 8, 141, 98);
RT_INTERFACE!{interface ISmsSendMessageResult(ISmsSendMessageResultVtbl): IInspectable(IInspectableVtbl) [IID_ISmsSendMessageResult] {
    fn get_IsSuccessful(&self, out: *mut bool) -> HRESULT,
    fn get_MessageReferenceNumbers(&self, out: *mut *mut foundation::collections::IVectorView<i32>) -> HRESULT,
    fn get_CellularClass(&self, out: *mut CellularClass) -> HRESULT,
    fn get_ModemErrorCode(&self, out: *mut SmsModemErrorCode) -> HRESULT,
    fn get_IsErrorTransient(&self, out: *mut bool) -> HRESULT,
    fn get_NetworkCauseCode(&self, out: *mut i32) -> HRESULT,
    fn get_TransportFailureCause(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<ISmsSendMessageResult> {
    #[inline] pub fn get_is_successful(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsSuccessful)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reference_numbers(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MessageReferenceNumbers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_cellular_class(&self) -> Result<CellularClass> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CellularClass)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_modem_error_code(&self) -> Result<SmsModemErrorCode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ModemErrorCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_error_transient(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsErrorTransient)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_cause_code(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NetworkCauseCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_transport_failure_cause(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TransportFailureCause)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsSendMessageResult: ISmsSendMessageResult}
DEFINE_IID!(IID_ISmsStatusMessage, 3872555842, 46859, 18039, 147, 121, 201, 120, 63, 223, 248, 244);
RT_INTERFACE!{interface ISmsStatusMessage(ISmsStatusMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsStatusMessage] {
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Status(&self, out: *mut i32) -> HRESULT,
    fn get_MessageReferenceNumber(&self, out: *mut i32) -> HRESULT,
    fn get_ServiceCenterTimestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_DischargeTime(&self, out: *mut foundation::DateTime) -> HRESULT
}}
impl ComPtr<ISmsStatusMessage> {
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_From)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Body)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_message_reference_number(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MessageReferenceNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_center_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceCenterTimestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_discharge_time(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DischargeTime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsStatusMessage: ISmsStatusMessage}
DEFINE_IID!(IID_ISmsTextMessage, 3592196172, 42133, 18559, 154, 111, 151, 21, 72, 197, 188, 159);
RT_INTERFACE!{interface ISmsTextMessage(ISmsTextMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsTextMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_PartReferenceId(&self, out: *mut u32) -> HRESULT,
    fn get_PartNumber(&self, out: *mut u32) -> HRESULT,
    fn get_PartCount(&self, out: *mut u32) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn put_From(&self, value: HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_Encoding(&self, out: *mut SmsEncoding) -> HRESULT,
    fn put_Encoding(&self, value: SmsEncoding) -> HRESULT,
    fn ToBinaryMessages(&self, format: SmsDataFormat, out: *mut *mut foundation::collections::IVectorView<ISmsBinaryMessage>) -> HRESULT
}}
impl ComPtr<ISmsTextMessage> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_part_reference_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PartReferenceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_part_number(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PartNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_part_count(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PartCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_to(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_To)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_From)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_from(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_From)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Body)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Body)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding(&self) -> Result<SmsEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Encoding)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding(&self, value: SmsEncoding) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Encoding)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn to_binary_messages(&self, format: SmsDataFormat) -> Result<Option<ComPtr<foundation::collections::IVectorView<ISmsBinaryMessage>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ToBinaryMessages)(self.deref() as *const _ as *mut _, format, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsTextMessage: ISmsTextMessage}
impl RtActivatable<ISmsTextMessageStatics> for SmsTextMessage {}
impl RtActivatable<IActivationFactory> for SmsTextMessage {}
impl SmsTextMessage {
    #[inline] pub fn from_binary_message(binaryMessage: &ComPtr<SmsBinaryMessage>) -> Result<Option<ComPtr<SmsTextMessage>>> {
        <Self as RtActivatable<ISmsTextMessageStatics>>::get_activation_factory().from_binary_message(binaryMessage)
    }
    #[inline] pub fn from_binary_data(format: SmsDataFormat, value: &[u8]) -> Result<Option<ComPtr<SmsTextMessage>>> {
        <Self as RtActivatable<ISmsTextMessageStatics>>::get_activation_factory().from_binary_data(format, value)
    }
}
DEFINE_CLSID!(SmsTextMessage(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,84,101,120,116,77,101,115,115,97,103,101,0]) [CLSID_SmsTextMessage]);
DEFINE_IID!(IID_ISmsTextMessage2, 580966547, 17749, 18261, 181, 161, 231, 253, 132, 149, 95, 141);
RT_INTERFACE!{interface ISmsTextMessage2(ISmsTextMessage2Vtbl): IInspectable(IInspectableVtbl) [IID_ISmsTextMessage2] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn put_To(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_Encoding(&self, out: *mut SmsEncoding) -> HRESULT,
    fn put_Encoding(&self, value: SmsEncoding) -> HRESULT,
    fn get_CallbackNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CallbackNumber(&self, value: HSTRING) -> HRESULT,
    fn get_IsDeliveryNotificationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsDeliveryNotificationEnabled(&self, value: bool) -> HRESULT,
    fn get_RetryAttemptCount(&self, out: *mut i32) -> HRESULT,
    fn put_RetryAttemptCount(&self, value: i32) -> HRESULT,
    fn get_TeleserviceId(&self, out: *mut i32) -> HRESULT,
    fn get_ProtocolId(&self, out: *mut i32) -> HRESULT
}}
impl ComPtr<ISmsTextMessage2> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_to(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_To)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_From)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Body)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_body(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Body)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_encoding(&self) -> Result<SmsEncoding> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Encoding)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_encoding(&self, value: SmsEncoding) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Encoding)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_callback_number(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CallbackNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_callback_number(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CallbackNumber)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_delivery_notification_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsDeliveryNotificationEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_delivery_notification_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsDeliveryNotificationEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_retry_attempt_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RetryAttemptCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_retry_attempt_count(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RetryAttemptCount)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_teleservice_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_TeleserviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_id(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtocolId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsTextMessage2: ISmsTextMessage2}
impl RtActivatable<IActivationFactory> for SmsTextMessage2 {}
DEFINE_CLSID!(SmsTextMessage2(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,109,115,46,83,109,115,84,101,120,116,77,101,115,115,97,103,101,50,0]) [CLSID_SmsTextMessage2]);
DEFINE_IID!(IID_ISmsTextMessageStatics, 2137572845, 15564, 18339, 140, 85, 56, 13, 59, 1, 8, 146);
RT_INTERFACE!{static interface ISmsTextMessageStatics(ISmsTextMessageStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISmsTextMessageStatics] {
    fn FromBinaryMessage(&self, binaryMessage: *mut SmsBinaryMessage, out: *mut *mut SmsTextMessage) -> HRESULT,
    fn FromBinaryData(&self, format: SmsDataFormat, valueSize: u32, value: *mut u8, out: *mut *mut SmsTextMessage) -> HRESULT
}}
impl ComPtr<ISmsTextMessageStatics> {
    #[inline] pub fn from_binary_message(&self, binaryMessage: &ComPtr<SmsBinaryMessage>) -> Result<Option<ComPtr<SmsTextMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromBinaryMessage)(self.deref() as *const _ as *mut _, binaryMessage.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_binary_data(&self, format: SmsDataFormat, value: &[u8]) -> Result<Option<ComPtr<SmsTextMessage>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromBinaryData)(self.deref() as *const _ as *mut _, format, value.len() as u32, value.as_ptr() as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISmsVoicemailMessage, 656056486, 38321, 17663, 188, 184, 184, 253, 215, 224, 139, 195);
RT_INTERFACE!{interface ISmsVoicemailMessage(ISmsVoicemailMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsVoicemailMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MessageCount(&self, out: *mut *mut foundation::IReference<i32>) -> HRESULT
}}
impl ComPtr<ISmsVoicemailMessage> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_body(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Body)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_message_count(&self) -> Result<Option<ComPtr<foundation::IReference<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_MessageCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsVoicemailMessage: ISmsVoicemailMessage}
DEFINE_IID!(IID_ISmsWapMessage, 3448993603, 31317, 19771, 144, 33, 242, 46, 2, 45, 9, 197);
RT_INTERFACE!{interface ISmsWapMessage(ISmsWapMessageVtbl): IInspectable(IInspectableVtbl) [IID_ISmsWapMessage] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_To(&self, out: *mut HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ApplicationId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentType(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_BinaryBody(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_Headers(&self, out: *mut *mut foundation::collections::IMap<HString, HString>) -> HRESULT
}}
impl ComPtr<ISmsWapMessage> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_to(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_To)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_from(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_From)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_application_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ApplicationId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_content_type(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ContentType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_binary_body(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BinaryBody)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_headers(&self) -> Result<Option<ComPtr<foundation::collections::IMap<HString, HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Headers)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SmsWapMessage: ISmsWapMessage}
} // Windows.Devices.Sms
pub mod spi { // Windows.Devices.Spi
use crate::prelude::*;
DEFINE_IID!(IID_ISpiBusInfo, 2569618506, 21746, 18630, 185, 82, 156, 50, 252, 2, 198, 105);
RT_INTERFACE!{interface ISpiBusInfo(ISpiBusInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISpiBusInfo] {
    fn get_ChipSelectLineCount(&self, out: *mut i32) -> HRESULT,
    fn get_MinClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn get_MaxClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn get_SupportedDataBitLengths(&self, out: *mut *mut foundation::collections::IVectorView<i32>) -> HRESULT
}}
impl ComPtr<ISpiBusInfo> {
    #[inline] pub fn get_chip_select_line_count(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChipSelectLineCount)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_min_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MinClockFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxClockFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_data_bit_lengths(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<i32>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedDataBitLengths)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiBusInfo: ISpiBusInfo}
DEFINE_IID!(IID_ISpiConnectionSettings, 1384358783, 63797, 19359, 167, 167, 58, 120, 144, 175, 165, 206);
RT_INTERFACE!{interface ISpiConnectionSettings(ISpiConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ISpiConnectionSettings] {
    fn get_ChipSelectLine(&self, out: *mut i32) -> HRESULT,
    fn put_ChipSelectLine(&self, value: i32) -> HRESULT,
    fn get_Mode(&self, out: *mut SpiMode) -> HRESULT,
    fn put_Mode(&self, value: SpiMode) -> HRESULT,
    fn get_DataBitLength(&self, out: *mut i32) -> HRESULT,
    fn put_DataBitLength(&self, value: i32) -> HRESULT,
    fn get_ClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn put_ClockFrequency(&self, value: i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut SpiSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: SpiSharingMode) -> HRESULT
}}
impl ComPtr<ISpiConnectionSettings> {
    #[inline] pub fn get_chip_select_line(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChipSelectLine)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_chip_select_line(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ChipSelectLine)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<SpiMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Mode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: SpiMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Mode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_bit_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataBitLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_bit_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DataBitLength)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClockFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_clock_frequency(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ClockFrequency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<SpiSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: SpiSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SharingMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiConnectionSettings: ISpiConnectionSettings}
impl RtActivatable<ISpiConnectionSettingsFactory> for SpiConnectionSettings {}
impl SpiConnectionSettings {
    #[inline] pub fn create(chipSelectLine: i32) -> Result<ComPtr<SpiConnectionSettings>> {
        <Self as RtActivatable<ISpiConnectionSettingsFactory>>::get_activation_factory().create(chipSelectLine)
    }
}
DEFINE_CLSID!(SpiConnectionSettings(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_SpiConnectionSettings]);
DEFINE_IID!(IID_ISpiConnectionSettingsFactory, 4288219166, 4292, 17591, 159, 234, 167, 72, 181, 164, 111, 49);
RT_INTERFACE!{static interface ISpiConnectionSettingsFactory(ISpiConnectionSettingsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISpiConnectionSettingsFactory] {
    fn Create(&self, chipSelectLine: i32, out: *mut *mut SpiConnectionSettings) -> HRESULT
}}
impl ComPtr<ISpiConnectionSettingsFactory> {
    #[inline] pub fn create(&self, chipSelectLine: i32) -> Result<ComPtr<SpiConnectionSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, chipSelectLine, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiController, 2832451625, 39061, 16729, 169, 52, 135, 65, 241, 238, 109, 39);
RT_INTERFACE!{interface ISpiController(ISpiControllerVtbl): IInspectable(IInspectableVtbl) [IID_ISpiController] {
    fn GetDevice(&self, settings: *mut SpiConnectionSettings, out: *mut *mut SpiDevice) -> HRESULT
}}
impl ComPtr<ISpiController> {
    #[inline] pub fn get_device(&self, settings: &ComPtr<SpiConnectionSettings>) -> Result<Option<ComPtr<SpiDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDevice)(self.deref() as *const _ as *mut _, settings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiController: ISpiController}
impl RtActivatable<ISpiControllerStatics> for SpiController {}
impl SpiController {
    #[inline] pub fn get_default_async() -> Result<ComPtr<foundation::IAsyncOperation<SpiController>>> {
        <Self as RtActivatable<ISpiControllerStatics>>::get_activation_factory().get_default_async()
    }
    #[inline] pub fn get_controllers_async(provider: &ComPtr<provider::ISpiProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SpiController>>>> {
        <Self as RtActivatable<ISpiControllerStatics>>::get_activation_factory().get_controllers_async(provider)
    }
}
DEFINE_CLSID!(SpiController(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,67,111,110,116,114,111,108,108,101,114,0]) [CLSID_SpiController]);
DEFINE_IID!(IID_ISpiControllerStatics, 223488482, 5003, 20040, 185, 100, 79, 47, 121, 185, 197, 162);
RT_INTERFACE!{static interface ISpiControllerStatics(ISpiControllerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpiControllerStatics] {
    fn GetDefaultAsync(&self, out: *mut *mut foundation::IAsyncOperation<SpiController>) -> HRESULT,
    fn GetControllersAsync(&self, provider: *mut provider::ISpiProvider, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<SpiController>>) -> HRESULT
}}
impl ComPtr<ISpiControllerStatics> {
    #[inline] pub fn get_default_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<SpiController>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDefaultAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_controllers_async(&self, provider: &ComPtr<provider::ISpiProvider>) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<SpiController>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, provider.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiDevice, 97858925, 4534, 19769, 132, 213, 149, 223, 180, 201, 242, 206);
RT_INTERFACE!{interface ISpiDevice(ISpiDeviceVtbl): IInspectable(IInspectableVtbl) [IID_ISpiDevice] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionSettings(&self, out: *mut *mut SpiConnectionSettings) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn TransferSequential(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn TransferFullDuplex(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT
}}
impl ComPtr<ISpiDevice> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_settings(&self) -> Result<Option<ComPtr<SpiConnectionSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionSettings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Write)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_sequential(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).TransferSequential)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_full_duplex(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).TransferFullDuplex)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class SpiDevice: ISpiDevice}
impl RtActivatable<ISpiDeviceStatics> for SpiDevice {}
impl SpiDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn get_device_selector_from_friendly_name(friendlyName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().get_device_selector_from_friendly_name(friendlyName)
    }
    #[inline] pub fn get_bus_info(busId: &HStringArg) -> Result<Option<ComPtr<SpiBusInfo>>> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().get_bus_info(busId)
    }
    #[inline] pub fn from_id_async(busId: &HStringArg, settings: &ComPtr<SpiConnectionSettings>) -> Result<ComPtr<foundation::IAsyncOperation<SpiDevice>>> {
        <Self as RtActivatable<ISpiDeviceStatics>>::get_activation_factory().from_id_async(busId, settings)
    }
}
DEFINE_CLSID!(SpiDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,83,112,105,68,101,118,105,99,101,0]) [CLSID_SpiDevice]);
DEFINE_IID!(IID_ISpiDeviceStatics, 2725832025, 22304, 19775, 189, 147, 86, 245, 255, 90, 88, 121);
RT_INTERFACE!{static interface ISpiDeviceStatics(ISpiDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISpiDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorFromFriendlyName(&self, friendlyName: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn GetBusInfo(&self, busId: HSTRING, out: *mut *mut SpiBusInfo) -> HRESULT,
    fn FromIdAsync(&self, busId: HSTRING, settings: *mut SpiConnectionSettings, out: *mut *mut foundation::IAsyncOperation<SpiDevice>) -> HRESULT
}}
impl ComPtr<ISpiDeviceStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_from_friendly_name(&self, friendlyName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorFromFriendlyName)(self.deref() as *const _ as *mut _, friendlyName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bus_info(&self, busId: &HStringArg) -> Result<Option<ComPtr<SpiBusInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetBusInfo)(self.deref() as *const _ as *mut _, busId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, busId: &HStringArg, settings: &ComPtr<SpiConnectionSettings>) -> Result<ComPtr<foundation::IAsyncOperation<SpiDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, busId.get(), settings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum SpiMode: i32 {
    Mode0 = 0, Mode1 = 1, Mode2 = 2, Mode3 = 3,
}}
RT_ENUM! { enum SpiSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
pub mod provider { // Windows.Devices.Spi.Provider
use crate::prelude::*;
DEFINE_IID!(IID_IProviderSpiConnectionSettings, 4127409488, 42306, 20160, 150, 1, 164, 221, 104, 248, 105, 123);
RT_INTERFACE!{interface IProviderSpiConnectionSettings(IProviderSpiConnectionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_IProviderSpiConnectionSettings] {
    fn get_ChipSelectLine(&self, out: *mut i32) -> HRESULT,
    fn put_ChipSelectLine(&self, value: i32) -> HRESULT,
    fn get_Mode(&self, out: *mut ProviderSpiMode) -> HRESULT,
    fn put_Mode(&self, value: ProviderSpiMode) -> HRESULT,
    fn get_DataBitLength(&self, out: *mut i32) -> HRESULT,
    fn put_DataBitLength(&self, value: i32) -> HRESULT,
    fn get_ClockFrequency(&self, out: *mut i32) -> HRESULT,
    fn put_ClockFrequency(&self, value: i32) -> HRESULT,
    fn get_SharingMode(&self, out: *mut ProviderSpiSharingMode) -> HRESULT,
    fn put_SharingMode(&self, value: ProviderSpiSharingMode) -> HRESULT
}}
impl ComPtr<IProviderSpiConnectionSettings> {
    #[inline] pub fn get_chip_select_line(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChipSelectLine)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_chip_select_line(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ChipSelectLine)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_mode(&self) -> Result<ProviderSpiMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Mode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_mode(&self, value: ProviderSpiMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Mode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_data_bit_length(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DataBitLength)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_data_bit_length(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DataBitLength)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_clock_frequency(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClockFrequency)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_clock_frequency(&self, value: i32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ClockFrequency)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_sharing_mode(&self) -> Result<ProviderSpiSharingMode> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SharingMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_sharing_mode(&self, value: ProviderSpiSharingMode) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SharingMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class ProviderSpiConnectionSettings: IProviderSpiConnectionSettings}
impl RtActivatable<IProviderSpiConnectionSettingsFactory> for ProviderSpiConnectionSettings {}
impl ProviderSpiConnectionSettings {
    #[inline] pub fn create(chipSelectLine: i32) -> Result<ComPtr<ProviderSpiConnectionSettings>> {
        <Self as RtActivatable<IProviderSpiConnectionSettingsFactory>>::get_activation_factory().create(chipSelectLine)
    }
}
DEFINE_CLSID!(ProviderSpiConnectionSettings(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,83,112,105,46,80,114,111,118,105,100,101,114,46,80,114,111,118,105,100,101,114,83,112,105,67,111,110,110,101,99,116,105,111,110,83,101,116,116,105,110,103,115,0]) [CLSID_ProviderSpiConnectionSettings]);
DEFINE_IID!(IID_IProviderSpiConnectionSettingsFactory, 1715825498, 3193, 17379, 159, 60, 229, 151, 128, 172, 24, 250);
RT_INTERFACE!{static interface IProviderSpiConnectionSettingsFactory(IProviderSpiConnectionSettingsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProviderSpiConnectionSettingsFactory] {
    fn Create(&self, chipSelectLine: i32, out: *mut *mut ProviderSpiConnectionSettings) -> HRESULT
}}
impl ComPtr<IProviderSpiConnectionSettingsFactory> {
    #[inline] pub fn create(&self, chipSelectLine: i32) -> Result<ComPtr<ProviderSpiConnectionSettings>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Create)(self.deref() as *const _ as *mut _, chipSelectLine, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum ProviderSpiMode: i32 {
    Mode0 = 0, Mode1 = 1, Mode2 = 2, Mode3 = 3,
}}
RT_ENUM! { enum ProviderSpiSharingMode: i32 {
    Exclusive = 0, Shared = 1,
}}
DEFINE_IID!(IID_ISpiControllerProvider, 3244844292, 718, 16934, 163, 133, 79, 17, 251, 4, 180, 27);
RT_INTERFACE!{interface ISpiControllerProvider(ISpiControllerProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpiControllerProvider] {
    fn GetDeviceProvider(&self, settings: *mut ProviderSpiConnectionSettings, out: *mut *mut ISpiDeviceProvider) -> HRESULT
}}
impl ComPtr<ISpiControllerProvider> {
    #[inline] pub fn get_device_provider(&self, settings: &ComPtr<ProviderSpiConnectionSettings>) -> Result<Option<ComPtr<ISpiDeviceProvider>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceProvider)(self.deref() as *const _ as *mut _, settings.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiDeviceProvider, 219952195, 12363, 16476, 180, 247, 245, 171, 16, 116, 70, 30);
RT_INTERFACE!{interface ISpiDeviceProvider(ISpiDeviceProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpiDeviceProvider] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConnectionSettings(&self, out: *mut *mut ProviderSpiConnectionSettings) -> HRESULT,
    fn Write(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn Read(&self, bufferSize: u32, buffer: *mut u8) -> HRESULT,
    fn TransferSequential(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT,
    fn TransferFullDuplex(&self, writeBufferSize: u32, writeBuffer: *mut u8, readBufferSize: u32, readBuffer: *mut u8) -> HRESULT
}}
impl ComPtr<ISpiDeviceProvider> {
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_connection_settings(&self) -> Result<Option<ComPtr<ProviderSpiConnectionSettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConnectionSettings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn write(&self, buffer: &[u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Write)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn read(&self, buffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Read)(self.deref() as *const _ as *mut _, buffer.len() as u32, buffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_sequential(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).TransferSequential)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn transfer_full_duplex(&self, writeBuffer: &[u8], readBuffer: &mut [u8]) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).TransferFullDuplex)(self.deref() as *const _ as *mut _, writeBuffer.len() as u32, writeBuffer.as_ptr() as *mut _, readBuffer.len() as u32, readBuffer.as_mut_ptr() as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_ISpiProvider, 2528403938, 30676, 18638, 170, 160, 117, 113, 90, 131, 98, 207);
RT_INTERFACE!{interface ISpiProvider(ISpiProviderVtbl): IInspectable(IInspectableVtbl) [IID_ISpiProvider] {
    fn GetControllersAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<ISpiControllerProvider>>) -> HRESULT
}}
impl ComPtr<ISpiProvider> {
    #[inline] pub fn get_controllers_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<ISpiControllerProvider>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetControllersAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
} // Windows.Devices.Spi.Provider
} // Windows.Devices.Spi
pub mod usb { // Windows.Devices.Usb
use crate::prelude::*;
DEFINE_IID!(IID_IUsbBulkInEndpointDescriptor, 1013860422, 1743, 17065, 157, 194, 151, 28, 27, 20, 182, 227);
RT_INTERFACE!{interface IUsbBulkInEndpointDescriptor(IUsbBulkInEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkInEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Pipe(&self, out: *mut *mut UsbBulkInPipe) -> HRESULT
}}
impl ComPtr<IUsbBulkInEndpointDescriptor> {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPacketSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EndpointNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<ComPtr<UsbBulkInPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Pipe)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkInEndpointDescriptor: IUsbBulkInEndpointDescriptor}
DEFINE_IID!(IID_IUsbBulkInPipe, 4028443963, 17736, 19792, 179, 38, 216, 44, 218, 190, 18, 32);
RT_INTERFACE!{interface IUsbBulkInPipe(IUsbBulkInPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkInPipe] {
    fn get_MaxTransferSizeBytes(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointDescriptor(&self, out: *mut *mut UsbBulkInEndpointDescriptor) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn put_ReadOptions(&self, value: UsbReadOptions) -> HRESULT,
    fn get_ReadOptions(&self, out: *mut UsbReadOptions) -> HRESULT,
    fn FlushBuffer(&self) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_InputStream(&self, out: *mut *mut super::super::storage::streams::IInputStream) -> HRESULT
}}
impl ComPtr<IUsbBulkInPipe> {
    #[inline] pub fn get_max_transfer_size_bytes(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxTransferSizeBytes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbBulkInEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClearStallAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_read_options(&self, value: UsbReadOptions) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ReadOptions)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_read_options(&self) -> Result<UsbReadOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ReadOptions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn flush_buffer(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).FlushBuffer)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_input_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IInputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkInPipe: IUsbBulkInPipe}
DEFINE_IID!(IID_IUsbBulkOutEndpointDescriptor, 673219706, 65518, 20320, 155, 225, 149, 108, 172, 62, 203, 101);
RT_INTERFACE!{interface IUsbBulkOutEndpointDescriptor(IUsbBulkOutEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkOutEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Pipe(&self, out: *mut *mut UsbBulkOutPipe) -> HRESULT
}}
impl ComPtr<IUsbBulkOutEndpointDescriptor> {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPacketSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EndpointNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<ComPtr<UsbBulkOutPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Pipe)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkOutEndpointDescriptor: IUsbBulkOutEndpointDescriptor}
DEFINE_IID!(IID_IUsbBulkOutPipe, 2833903214, 277, 17834, 139, 33, 55, 178, 37, 188, 206, 231);
RT_INTERFACE!{interface IUsbBulkOutPipe(IUsbBulkOutPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbBulkOutPipe] {
    fn get_EndpointDescriptor(&self, out: *mut *mut UsbBulkOutEndpointDescriptor) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn put_WriteOptions(&self, value: UsbWriteOptions) -> HRESULT,
    fn get_WriteOptions(&self, out: *mut UsbWriteOptions) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut *mut super::super::storage::streams::IOutputStream) -> HRESULT
}}
impl ComPtr<IUsbBulkOutPipe> {
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbBulkOutEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClearStallAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_write_options(&self, value: UsbWriteOptions) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_WriteOptions)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_options(&self) -> Result<UsbWriteOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteOptions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IOutputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbBulkOutPipe: IUsbBulkOutPipe}
DEFINE_IID!(IID_IUsbConfiguration, 1746367529, 13993, 18135, 184, 115, 252, 104, 146, 81, 236, 48);
RT_INTERFACE!{interface IUsbConfiguration(IUsbConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IUsbConfiguration] {
    fn get_UsbInterfaces(&self, out: *mut *mut foundation::collections::IVectorView<UsbInterface>) -> HRESULT,
    fn get_ConfigurationDescriptor(&self, out: *mut *mut UsbConfigurationDescriptor) -> HRESULT,
    fn get_Descriptors(&self, out: *mut *mut foundation::collections::IVectorView<UsbDescriptor>) -> HRESULT
}}
impl ComPtr<IUsbConfiguration> {
    #[inline] pub fn get_usb_interfaces(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbInterface>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_UsbInterfaces)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration_descriptor(&self) -> Result<Option<ComPtr<UsbConfigurationDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ConfigurationDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbConfiguration: IUsbConfiguration}
DEFINE_IID!(IID_IUsbConfigurationDescriptor, 4061621650, 46146, 16506, 130, 7, 125, 100, 108, 3, 133, 243);
RT_INTERFACE!{interface IUsbConfigurationDescriptor(IUsbConfigurationDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbConfigurationDescriptor] {
    fn get_ConfigurationValue(&self, out: *mut u8) -> HRESULT,
    fn get_MaxPowerMilliamps(&self, out: *mut u32) -> HRESULT,
    fn get_SelfPowered(&self, out: *mut bool) -> HRESULT,
    fn get_RemoteWakeup(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IUsbConfigurationDescriptor> {
    #[inline] pub fn get_configuration_value(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConfigurationValue)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_power_milliamps(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPowerMilliamps)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_self_powered(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SelfPowered)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_remote_wakeup(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_RemoteWakeup)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbConfigurationDescriptor: IUsbConfigurationDescriptor}
impl RtActivatable<IUsbConfigurationDescriptorStatics> for UsbConfigurationDescriptor {}
impl UsbConfigurationDescriptor {
    #[inline] pub fn try_parse(descriptor: &ComPtr<UsbDescriptor>) -> Result<(Option<ComPtr<UsbConfigurationDescriptor>>, bool)> {
        <Self as RtActivatable<IUsbConfigurationDescriptorStatics>>::get_activation_factory().try_parse(descriptor)
    }
    #[inline] pub fn parse(descriptor: &ComPtr<UsbDescriptor>) -> Result<Option<ComPtr<UsbConfigurationDescriptor>>> {
        <Self as RtActivatable<IUsbConfigurationDescriptorStatics>>::get_activation_factory().parse(descriptor)
    }
}
DEFINE_CLSID!(UsbConfigurationDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,67,111,110,102,105,103,117,114,97,116,105,111,110,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_UsbConfigurationDescriptor]);
DEFINE_IID!(IID_IUsbConfigurationDescriptorStatics, 1112337811, 59200, 16545, 146, 189, 218, 18, 14, 160, 73, 20);
RT_INTERFACE!{static interface IUsbConfigurationDescriptorStatics(IUsbConfigurationDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbConfigurationDescriptorStatics] {
    fn TryParse(&self, descriptor: *mut UsbDescriptor, parsed: *mut *mut UsbConfigurationDescriptor, out: *mut bool) -> HRESULT,
    fn Parse(&self, descriptor: *mut UsbDescriptor, out: *mut *mut UsbConfigurationDescriptor) -> HRESULT
}}
impl ComPtr<IUsbConfigurationDescriptorStatics> {
    #[inline] pub fn try_parse(&self, descriptor: &ComPtr<UsbDescriptor>) -> Result<(Option<ComPtr<UsbConfigurationDescriptor>>, bool)> { unsafe { 
        let mut parsed = null_mut(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryParse)(self.deref() as *const _ as *mut _, descriptor.deref() as *const _ as *mut _, &mut parsed, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap_optional(parsed), out)) } else { err(hr) }
    }}
    #[inline] pub fn parse(&self, descriptor: &ComPtr<UsbDescriptor>) -> Result<Option<ComPtr<UsbConfigurationDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Parse)(self.deref() as *const _ as *mut _, descriptor.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UsbControlRecipient: i32 {
    Device = 0, SpecifiedInterface = 1, Endpoint = 2, Other = 3, DefaultInterface = 4,
}}
DEFINE_IID!(IID_IUsbControlRequestType, 2392090022, 55101, 18142, 148, 190, 170, 231, 240, 124, 15, 92);
RT_INTERFACE!{interface IUsbControlRequestType(IUsbControlRequestTypeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbControlRequestType] {
    fn get_Direction(&self, out: *mut UsbTransferDirection) -> HRESULT,
    fn put_Direction(&self, value: UsbTransferDirection) -> HRESULT,
    fn get_ControlTransferType(&self, out: *mut UsbControlTransferType) -> HRESULT,
    fn put_ControlTransferType(&self, value: UsbControlTransferType) -> HRESULT,
    fn get_Recipient(&self, out: *mut UsbControlRecipient) -> HRESULT,
    fn put_Recipient(&self, value: UsbControlRecipient) -> HRESULT,
    fn get_AsByte(&self, out: *mut u8) -> HRESULT,
    fn put_AsByte(&self, value: u8) -> HRESULT
}}
impl ComPtr<IUsbControlRequestType> {
    #[inline] pub fn get_direction(&self) -> Result<UsbTransferDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Direction)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_direction(&self, value: UsbTransferDirection) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Direction)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_control_transfer_type(&self) -> Result<UsbControlTransferType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ControlTransferType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_control_transfer_type(&self, value: UsbControlTransferType) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ControlTransferType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_recipient(&self) -> Result<UsbControlRecipient> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Recipient)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_recipient(&self, value: UsbControlRecipient) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Recipient)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_as_byte(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AsByte)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_as_byte(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AsByte)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbControlRequestType: IUsbControlRequestType}
impl RtActivatable<IActivationFactory> for UsbControlRequestType {}
DEFINE_CLSID!(UsbControlRequestType(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,67,111,110,116,114,111,108,82,101,113,117,101,115,116,84,121,112,101,0]) [CLSID_UsbControlRequestType]);
RT_ENUM! { enum UsbControlTransferType: i32 {
    Standard = 0, Class = 1, Vendor = 2,
}}
DEFINE_IID!(IID_IUsbDescriptor, 176812566, 24477, 18548, 137, 4, 218, 154, 211, 245, 82, 143);
RT_INTERFACE!{interface IUsbDescriptor(IUsbDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDescriptor] {
    fn get_Length(&self, out: *mut u8) -> HRESULT,
    fn get_DescriptorType(&self, out: *mut u8) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ReadDescriptorBuffer(&self, buffer: *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IUsbDescriptor> {
    #[inline] pub fn get_length(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Length)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptor_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_DescriptorType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn read_descriptor_buffer(&self, buffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).ReadDescriptorBuffer)(self.deref() as *const _ as *mut _, buffer.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDescriptor: IUsbDescriptor}
DEFINE_IID!(IID_IUsbDevice, 1380563346, 50262, 17621, 173, 94, 36, 245, 160, 137, 246, 59);
RT_INTERFACE!{interface IUsbDevice(IUsbDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDevice] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendControlOutTransferAsync(&self, setupPacket: *mut UsbSetupPacket, buffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<u32>) -> HRESULT,
    fn SendControlOutTransferAsyncNoBuffer(&self, setupPacket: *mut UsbSetupPacket, out: *mut *mut foundation::IAsyncOperation<u32>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendControlInTransferAsync(&self, setupPacket: *mut UsbSetupPacket, buffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn SendControlInTransferAsyncNoBuffer(&self, setupPacket: *mut UsbSetupPacket, out: *mut *mut foundation::IAsyncOperation<super::super::storage::streams::IBuffer>) -> HRESULT,
    fn get_DefaultInterface(&self, out: *mut *mut UsbInterface) -> HRESULT,
    fn get_DeviceDescriptor(&self, out: *mut *mut UsbDeviceDescriptor) -> HRESULT,
    fn get_Configuration(&self, out: *mut *mut UsbConfiguration) -> HRESULT
}}
impl ComPtr<IUsbDevice> {
    #[cfg(feature="windows-storage")] #[inline] pub fn send_control_out_transfer_async(&self, setupPacket: &ComPtr<UsbSetupPacket>, buffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendControlOutTransferAsync)(self.deref() as *const _ as *mut _, setupPacket.deref() as *const _ as *mut _, buffer.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn send_control_out_transfer_async_no_buffer(&self, setupPacket: &ComPtr<UsbSetupPacket>) -> Result<ComPtr<foundation::IAsyncOperation<u32>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendControlOutTransferAsyncNoBuffer)(self.deref() as *const _ as *mut _, setupPacket.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_control_in_transfer_async(&self, setupPacket: &ComPtr<UsbSetupPacket>, buffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendControlInTransferAsync)(self.deref() as *const _ as *mut _, setupPacket.deref() as *const _ as *mut _, buffer.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn send_control_in_transfer_async_no_buffer(&self, setupPacket: &ComPtr<UsbSetupPacket>) -> Result<ComPtr<foundation::IAsyncOperation<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SendControlInTransferAsyncNoBuffer)(self.deref() as *const _ as *mut _, setupPacket.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_default_interface(&self) -> Result<Option<ComPtr<UsbInterface>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DefaultInterface)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_descriptor(&self) -> Result<Option<ComPtr<UsbDeviceDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_configuration(&self) -> Result<Option<ComPtr<UsbConfiguration>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Configuration)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDevice: IUsbDevice}
impl RtActivatable<IUsbDeviceStatics> for UsbDevice {}
impl UsbDevice {
    #[inline] pub fn get_device_selector(vendorId: u32, productId: u32, winUsbInterfaceClass: Guid) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_selector(vendorId, productId, winUsbInterfaceClass)
    }
    #[inline] pub fn get_device_selector_guid_only(winUsbInterfaceClass: Guid) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_selector_guid_only(winUsbInterfaceClass)
    }
    #[inline] pub fn get_device_selector_vid_pid_only(vendorId: u32, productId: u32) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_selector_vid_pid_only(vendorId, productId)
    }
    #[inline] pub fn get_device_class_selector(usbClass: &ComPtr<UsbDeviceClass>) -> Result<HString> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().get_device_class_selector(usbClass)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<UsbDevice>>> {
        <Self as RtActivatable<IUsbDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(UsbDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,0]) [CLSID_UsbDevice]);
DEFINE_IID!(IID_IUsbDeviceClass, 85541625, 33886, 18411, 177, 42, 56, 242, 246, 23, 175, 231);
RT_INTERFACE!{interface IUsbDeviceClass(IUsbDeviceClassVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClass] {
    fn get_ClassCode(&self, out: *mut u8) -> HRESULT,
    fn put_ClassCode(&self, value: u8) -> HRESULT,
    fn get_SubclassCode(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT,
    fn put_SubclassCode(&self, value: *mut foundation::IReference<u8>) -> HRESULT,
    fn get_ProtocolCode(&self, out: *mut *mut foundation::IReference<u8>) -> HRESULT,
    fn put_ProtocolCode(&self, value: *mut foundation::IReference<u8>) -> HRESULT
}}
impl ComPtr<IUsbDeviceClass> {
    #[inline] pub fn get_class_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClassCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_class_code(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ClassCode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_subclass_code(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SubclassCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_subclass_code(&self, value: &ComPtr<foundation::IReference<u8>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SubclassCode)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_code(&self) -> Result<Option<ComPtr<foundation::IReference<u8>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProtocolCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_protocol_code(&self, value: &ComPtr<foundation::IReference<u8>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ProtocolCode)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDeviceClass: IUsbDeviceClass}
impl RtActivatable<IActivationFactory> for UsbDeviceClass {}
DEFINE_CLSID!(UsbDeviceClass(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,67,108,97,115,115,0]) [CLSID_UsbDeviceClass]);
DEFINE_IID!(IID_IUsbDeviceClasses, 1752143197, 39826, 19248, 151, 129, 194, 44, 85, 172, 53, 203);
RT_INTERFACE!{interface IUsbDeviceClasses(IUsbDeviceClassesVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClasses] {
    
}}
RT_CLASS!{class UsbDeviceClasses: IUsbDeviceClasses}
impl RtActivatable<IUsbDeviceClassesStatics> for UsbDeviceClasses {}
impl UsbDeviceClasses {
    #[inline] pub fn get_cdc_control() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_cdc_control()
    }
    #[inline] pub fn get_physical() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_physical()
    }
    #[inline] pub fn get_personal_healthcare() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_personal_healthcare()
    }
    #[inline] pub fn get_active_sync() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_active_sync()
    }
    #[inline] pub fn get_palm_sync() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_palm_sync()
    }
    #[inline] pub fn get_device_firmware_update() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_device_firmware_update()
    }
    #[inline] pub fn get_irda() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_irda()
    }
    #[inline] pub fn get_measurement() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_measurement()
    }
    #[inline] pub fn get_vendor_specific() -> Result<Option<ComPtr<UsbDeviceClass>>> {
        <Self as RtActivatable<IUsbDeviceClassesStatics>>::get_activation_factory().get_vendor_specific()
    }
}
DEFINE_CLSID!(UsbDeviceClasses(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,68,101,118,105,99,101,67,108,97,115,115,101,115,0]) [CLSID_UsbDeviceClasses]);
DEFINE_IID!(IID_IUsbDeviceClassesStatics, 2987066663, 50560, 17817, 161, 101, 152, 27, 79, 208, 50, 48);
RT_INTERFACE!{static interface IUsbDeviceClassesStatics(IUsbDeviceClassesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceClassesStatics] {
    fn get_CdcControl(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_Physical(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_PersonalHealthcare(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_ActiveSync(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_PalmSync(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_DeviceFirmwareUpdate(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_Irda(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_Measurement(&self, out: *mut *mut UsbDeviceClass) -> HRESULT,
    fn get_VendorSpecific(&self, out: *mut *mut UsbDeviceClass) -> HRESULT
}}
impl ComPtr<IUsbDeviceClassesStatics> {
    #[inline] pub fn get_cdc_control(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_CdcControl)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_physical(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Physical)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_personal_healthcare(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PersonalHealthcare)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_active_sync(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ActiveSync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_palm_sync(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PalmSync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_firmware_update(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceFirmwareUpdate)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_irda(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Irda)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_measurement(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Measurement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_vendor_specific(&self) -> Result<Option<ComPtr<UsbDeviceClass>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_VendorSpecific)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUsbDeviceDescriptor, 524866038, 47767, 17186, 185, 44, 181, 177, 137, 33, 101, 136);
RT_INTERFACE!{interface IUsbDeviceDescriptor(IUsbDeviceDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceDescriptor] {
    fn get_BcdUsb(&self, out: *mut u32) -> HRESULT,
    fn get_MaxPacketSize0(&self, out: *mut u8) -> HRESULT,
    fn get_VendorId(&self, out: *mut u32) -> HRESULT,
    fn get_ProductId(&self, out: *mut u32) -> HRESULT,
    fn get_BcdDeviceRevision(&self, out: *mut u32) -> HRESULT,
    fn get_NumberOfConfigurations(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IUsbDeviceDescriptor> {
    #[inline] pub fn get_bcd_usb(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BcdUsb)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_max_packet_size0(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPacketSize0)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_vendor_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_VendorId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_product_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProductId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_bcd_device_revision(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BcdDeviceRevision)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_number_of_configurations(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NumberOfConfigurations)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbDeviceDescriptor: IUsbDeviceDescriptor}
DEFINE_IID!(IID_IUsbDeviceStatics, 107709858, 2487, 17478, 133, 2, 111, 230, 220, 170, 115, 9);
RT_INTERFACE!{static interface IUsbDeviceStatics(IUsbDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbDeviceStatics] {
    fn GetDeviceSelector(&self, vendorId: u32, productId: u32, winUsbInterfaceClass: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorGuidOnly(&self, winUsbInterfaceClass: Guid, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceSelectorVidPidOnly(&self, vendorId: u32, productId: u32, out: *mut HSTRING) -> HRESULT,
    fn GetDeviceClassSelector(&self, usbClass: *mut UsbDeviceClass, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<UsbDevice>) -> HRESULT
}}
impl ComPtr<IUsbDeviceStatics> {
    #[inline] pub fn get_device_selector(&self, vendorId: u32, productId: u32, winUsbInterfaceClass: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, vendorId, productId, winUsbInterfaceClass, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_guid_only(&self, winUsbInterfaceClass: Guid) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorGuidOnly)(self.deref() as *const _ as *mut _, winUsbInterfaceClass, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector_vid_pid_only(&self, vendorId: u32, productId: u32) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelectorVidPidOnly)(self.deref() as *const _ as *mut _, vendorId, productId, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_class_selector(&self, usbClass: &ComPtr<UsbDeviceClass>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceClassSelector)(self.deref() as *const _ as *mut _, usbClass.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<UsbDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUsbEndpointDescriptor, 1799906009, 36343, 19264, 172, 131, 87, 143, 19, 159, 5, 117);
RT_INTERFACE!{interface IUsbEndpointDescriptor(IUsbEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbEndpointDescriptor] {
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Direction(&self, out: *mut UsbTransferDirection) -> HRESULT,
    fn get_EndpointType(&self, out: *mut UsbEndpointType) -> HRESULT,
    fn get_AsBulkInEndpointDescriptor(&self, out: *mut *mut UsbBulkInEndpointDescriptor) -> HRESULT,
    fn get_AsInterruptInEndpointDescriptor(&self, out: *mut *mut UsbInterruptInEndpointDescriptor) -> HRESULT,
    fn get_AsBulkOutEndpointDescriptor(&self, out: *mut *mut UsbBulkOutEndpointDescriptor) -> HRESULT,
    fn get_AsInterruptOutEndpointDescriptor(&self, out: *mut *mut UsbInterruptOutEndpointDescriptor) -> HRESULT
}}
impl ComPtr<IUsbEndpointDescriptor> {
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EndpointNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_direction(&self) -> Result<UsbTransferDirection> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Direction)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_type(&self) -> Result<UsbEndpointType> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EndpointType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_as_bulk_in_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbBulkInEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AsBulkInEndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_as_interrupt_in_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbInterruptInEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AsInterruptInEndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_as_bulk_out_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbBulkOutEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AsBulkOutEndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_as_interrupt_out_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbInterruptOutEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AsInterruptOutEndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbEndpointDescriptor: IUsbEndpointDescriptor}
impl RtActivatable<IUsbEndpointDescriptorStatics> for UsbEndpointDescriptor {}
impl UsbEndpointDescriptor {
    #[inline] pub fn try_parse(descriptor: &ComPtr<UsbDescriptor>) -> Result<(Option<ComPtr<UsbEndpointDescriptor>>, bool)> {
        <Self as RtActivatable<IUsbEndpointDescriptorStatics>>::get_activation_factory().try_parse(descriptor)
    }
    #[inline] pub fn parse(descriptor: &ComPtr<UsbDescriptor>) -> Result<Option<ComPtr<UsbEndpointDescriptor>>> {
        <Self as RtActivatable<IUsbEndpointDescriptorStatics>>::get_activation_factory().parse(descriptor)
    }
}
DEFINE_CLSID!(UsbEndpointDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,69,110,100,112,111,105,110,116,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_UsbEndpointDescriptor]);
DEFINE_IID!(IID_IUsbEndpointDescriptorStatics, 3364925953, 39530, 18782, 168, 44, 41, 91, 158, 112, 129, 6);
RT_INTERFACE!{static interface IUsbEndpointDescriptorStatics(IUsbEndpointDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbEndpointDescriptorStatics] {
    fn TryParse(&self, descriptor: *mut UsbDescriptor, parsed: *mut *mut UsbEndpointDescriptor, out: *mut bool) -> HRESULT,
    fn Parse(&self, descriptor: *mut UsbDescriptor, out: *mut *mut UsbEndpointDescriptor) -> HRESULT
}}
impl ComPtr<IUsbEndpointDescriptorStatics> {
    #[inline] pub fn try_parse(&self, descriptor: &ComPtr<UsbDescriptor>) -> Result<(Option<ComPtr<UsbEndpointDescriptor>>, bool)> { unsafe { 
        let mut parsed = null_mut(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryParse)(self.deref() as *const _ as *mut _, descriptor.deref() as *const _ as *mut _, &mut parsed, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap_optional(parsed), out)) } else { err(hr) }
    }}
    #[inline] pub fn parse(&self, descriptor: &ComPtr<UsbDescriptor>) -> Result<Option<ComPtr<UsbEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Parse)(self.deref() as *const _ as *mut _, descriptor.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UsbEndpointType: i32 {
    Control = 0, Isochronous = 1, Bulk = 2, Interrupt = 3,
}}
DEFINE_IID!(IID_IUsbInterface, 2687642517, 32583, 18603, 167, 39, 103, 140, 37, 190, 33, 18);
RT_INTERFACE!{interface IUsbInterface(IUsbInterfaceVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterface] {
    fn get_BulkInPipes(&self, out: *mut *mut foundation::collections::IVectorView<UsbBulkInPipe>) -> HRESULT,
    fn get_InterruptInPipes(&self, out: *mut *mut foundation::collections::IVectorView<UsbInterruptInPipe>) -> HRESULT,
    fn get_BulkOutPipes(&self, out: *mut *mut foundation::collections::IVectorView<UsbBulkOutPipe>) -> HRESULT,
    fn get_InterruptOutPipes(&self, out: *mut *mut foundation::collections::IVectorView<UsbInterruptOutPipe>) -> HRESULT,
    fn get_InterfaceSettings(&self, out: *mut *mut foundation::collections::IVectorView<UsbInterfaceSetting>) -> HRESULT,
    fn get_InterfaceNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Descriptors(&self, out: *mut *mut foundation::collections::IVectorView<UsbDescriptor>) -> HRESULT
}}
impl ComPtr<IUsbInterface> {
    #[inline] pub fn get_bulk_in_pipes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbBulkInPipe>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BulkInPipes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_in_pipes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbInterruptInPipe>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterruptInPipes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bulk_out_pipes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbBulkOutPipe>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BulkOutPipes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_out_pipes(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbInterruptOutPipe>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterruptOutPipes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_settings(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbInterfaceSetting>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterfaceSettings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InterfaceNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterface: IUsbInterface}
DEFINE_IID!(IID_IUsbInterfaceDescriptor, 429289671, 47086, 20368, 140, 213, 148, 162, 226, 87, 89, 138);
RT_INTERFACE!{interface IUsbInterfaceDescriptor(IUsbInterfaceDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceDescriptor] {
    fn get_ClassCode(&self, out: *mut u8) -> HRESULT,
    fn get_SubclassCode(&self, out: *mut u8) -> HRESULT,
    fn get_ProtocolCode(&self, out: *mut u8) -> HRESULT,
    fn get_AlternateSettingNumber(&self, out: *mut u8) -> HRESULT,
    fn get_InterfaceNumber(&self, out: *mut u8) -> HRESULT
}}
impl ComPtr<IUsbInterfaceDescriptor> {
    #[inline] pub fn get_class_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ClassCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_subclass_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SubclassCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol_code(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ProtocolCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_alternate_setting_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AlternateSettingNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_InterfaceNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterfaceDescriptor: IUsbInterfaceDescriptor}
impl RtActivatable<IUsbInterfaceDescriptorStatics> for UsbInterfaceDescriptor {}
impl UsbInterfaceDescriptor {
    #[inline] pub fn try_parse(descriptor: &ComPtr<UsbDescriptor>) -> Result<(Option<ComPtr<UsbInterfaceDescriptor>>, bool)> {
        <Self as RtActivatable<IUsbInterfaceDescriptorStatics>>::get_activation_factory().try_parse(descriptor)
    }
    #[inline] pub fn parse(descriptor: &ComPtr<UsbDescriptor>) -> Result<Option<ComPtr<UsbInterfaceDescriptor>>> {
        <Self as RtActivatable<IUsbInterfaceDescriptorStatics>>::get_activation_factory().parse(descriptor)
    }
}
DEFINE_CLSID!(UsbInterfaceDescriptor(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,73,110,116,101,114,102,97,99,101,68,101,115,99,114,105,112,116,111,114,0]) [CLSID_UsbInterfaceDescriptor]);
DEFINE_IID!(IID_IUsbInterfaceDescriptorStatics, 3813318645, 30678, 18614, 176, 190, 22, 198, 66, 35, 22, 254);
RT_INTERFACE!{static interface IUsbInterfaceDescriptorStatics(IUsbInterfaceDescriptorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceDescriptorStatics] {
    fn TryParse(&self, descriptor: *mut UsbDescriptor, parsed: *mut *mut UsbInterfaceDescriptor, out: *mut bool) -> HRESULT,
    fn Parse(&self, descriptor: *mut UsbDescriptor, out: *mut *mut UsbInterfaceDescriptor) -> HRESULT
}}
impl ComPtr<IUsbInterfaceDescriptorStatics> {
    #[inline] pub fn try_parse(&self, descriptor: &ComPtr<UsbDescriptor>) -> Result<(Option<ComPtr<UsbInterfaceDescriptor>>, bool)> { unsafe { 
        let mut parsed = null_mut(); let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).TryParse)(self.deref() as *const _ as *mut _, descriptor.deref() as *const _ as *mut _, &mut parsed, &mut out);
        if hr == S_OK { Ok((ComPtr::wrap_optional(parsed), out)) } else { err(hr) }
    }}
    #[inline] pub fn parse(&self, descriptor: &ComPtr<UsbDescriptor>) -> Result<Option<ComPtr<UsbInterfaceDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).Parse)(self.deref() as *const _ as *mut _, descriptor.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IUsbInterfaceSetting, 405257127, 36263, 19191, 143, 76, 127, 48, 50, 231, 129, 245);
RT_INTERFACE!{interface IUsbInterfaceSetting(IUsbInterfaceSettingVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterfaceSetting] {
    fn get_BulkInEndpoints(&self, out: *mut *mut foundation::collections::IVectorView<UsbBulkInEndpointDescriptor>) -> HRESULT,
    fn get_InterruptInEndpoints(&self, out: *mut *mut foundation::collections::IVectorView<UsbInterruptInEndpointDescriptor>) -> HRESULT,
    fn get_BulkOutEndpoints(&self, out: *mut *mut foundation::collections::IVectorView<UsbBulkOutEndpointDescriptor>) -> HRESULT,
    fn get_InterruptOutEndpoints(&self, out: *mut *mut foundation::collections::IVectorView<UsbInterruptOutEndpointDescriptor>) -> HRESULT,
    fn get_Selected(&self, out: *mut bool) -> HRESULT,
    fn SelectSettingAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn get_InterfaceDescriptor(&self, out: *mut *mut UsbInterfaceDescriptor) -> HRESULT,
    fn get_Descriptors(&self, out: *mut *mut foundation::collections::IVectorView<UsbDescriptor>) -> HRESULT
}}
impl ComPtr<IUsbInterfaceSetting> {
    #[inline] pub fn get_bulk_in_endpoints(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbBulkInEndpointDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BulkInEndpoints)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_in_endpoints(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbInterruptInEndpointDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterruptInEndpoints)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bulk_out_endpoints(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbBulkOutEndpointDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_BulkOutEndpoints)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interrupt_out_endpoints(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbInterruptOutEndpointDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterruptOutEndpoints)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_selected(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Selected)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn select_setting_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).SelectSettingAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_interface_descriptor(&self) -> Result<Option<ComPtr<UsbInterfaceDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterfaceDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_descriptors(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<UsbDescriptor>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Descriptors)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterfaceSetting: IUsbInterfaceSetting}
DEFINE_IID!(IID_IUsbInterruptInEndpointDescriptor, 3226634599, 51473, 19514, 134, 178, 65, 156, 45, 168, 144, 57);
RT_INTERFACE!{interface IUsbInterruptInEndpointDescriptor(IUsbInterruptInEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Interval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Pipe(&self, out: *mut *mut UsbInterruptInPipe) -> HRESULT
}}
impl ComPtr<IUsbInterruptInEndpointDescriptor> {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPacketSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EndpointNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Interval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<ComPtr<UsbInterruptInPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Pipe)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptInEndpointDescriptor: IUsbInterruptInEndpointDescriptor}
DEFINE_IID!(IID_IUsbInterruptInEventArgs, 3081781394, 5144, 18742, 130, 9, 41, 156, 245, 96, 85, 131);
RT_INTERFACE!{interface IUsbInterruptInEventArgs(IUsbInterruptInEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInEventArgs] {
    #[cfg(feature="windows-storage")] fn get_InterruptData(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IUsbInterruptInEventArgs> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_interrupt_data(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InterruptData)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptInEventArgs: IUsbInterruptInEventArgs}
DEFINE_IID!(IID_IUsbInterruptInPipe, 4194332950, 34007, 18631, 138, 63, 76, 11, 35, 95, 46, 166);
RT_INTERFACE!{interface IUsbInterruptInPipe(IUsbInterruptInPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptInPipe] {
    fn get_EndpointDescriptor(&self, out: *mut *mut UsbInterruptInEndpointDescriptor) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn add_DataReceived(&self, handler: *mut foundation::TypedEventHandler<UsbInterruptInPipe, UsbInterruptInEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataReceived(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IUsbInterruptInPipe> {
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbInterruptInEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClearStallAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_data_received(&self, handler: &ComPtr<foundation::TypedEventHandler<UsbInterruptInPipe, UsbInterruptInEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_DataReceived)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_data_received(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_DataReceived)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptInPipe: IUsbInterruptInPipe}
DEFINE_IID!(IID_IUsbInterruptOutEndpointDescriptor, 3433033089, 4298, 17715, 149, 45, 158, 39, 131, 65, 232, 15);
RT_INTERFACE!{interface IUsbInterruptOutEndpointDescriptor(IUsbInterruptOutEndpointDescriptorVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptOutEndpointDescriptor] {
    fn get_MaxPacketSize(&self, out: *mut u32) -> HRESULT,
    fn get_EndpointNumber(&self, out: *mut u8) -> HRESULT,
    fn get_Interval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Pipe(&self, out: *mut *mut UsbInterruptOutPipe) -> HRESULT
}}
impl ComPtr<IUsbInterruptOutEndpointDescriptor> {
    #[inline] pub fn get_max_packet_size(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_MaxPacketSize)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_endpoint_number(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_EndpointNumber)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Interval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_pipe(&self) -> Result<Option<ComPtr<UsbInterruptOutPipe>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Pipe)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptOutEndpointDescriptor: IUsbInterruptOutEndpointDescriptor}
DEFINE_IID!(IID_IUsbInterruptOutPipe, 3917793449, 43769, 18896, 185, 108, 246, 97, 171, 74, 127, 149);
RT_INTERFACE!{interface IUsbInterruptOutPipe(IUsbInterruptOutPipeVtbl): IInspectable(IInspectableVtbl) [IID_IUsbInterruptOutPipe] {
    fn get_EndpointDescriptor(&self, out: *mut *mut UsbInterruptOutEndpointDescriptor) -> HRESULT,
    fn ClearStallAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn put_WriteOptions(&self, value: UsbWriteOptions) -> HRESULT,
    fn get_WriteOptions(&self, out: *mut UsbWriteOptions) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_OutputStream(&self, out: *mut *mut super::super::storage::streams::IOutputStream) -> HRESULT
}}
impl ComPtr<IUsbInterruptOutPipe> {
    #[inline] pub fn get_endpoint_descriptor(&self) -> Result<Option<ComPtr<UsbInterruptOutEndpointDescriptor>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EndpointDescriptor)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn clear_stall_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ClearStallAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_write_options(&self, value: UsbWriteOptions) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_WriteOptions)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_write_options(&self) -> Result<UsbWriteOptions> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_WriteOptions)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_output_stream(&self) -> Result<Option<ComPtr<super::super::storage::streams::IOutputStream>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_OutputStream)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbInterruptOutPipe: IUsbInterruptOutPipe}
RT_ENUM! { enum UsbReadOptions: u32 {
    None = 0, AutoClearStall = 1, OverrideAutomaticBufferManagement = 2, IgnoreShortPacket = 4, AllowPartialReads = 8,
}}
DEFINE_IID!(IID_IUsbSetupPacket, 273391922, 51087, 19537, 182, 84, 228, 157, 2, 242, 203, 3);
RT_INTERFACE!{interface IUsbSetupPacket(IUsbSetupPacketVtbl): IInspectable(IInspectableVtbl) [IID_IUsbSetupPacket] {
    fn get_RequestType(&self, out: *mut *mut UsbControlRequestType) -> HRESULT,
    fn put_RequestType(&self, value: *mut UsbControlRequestType) -> HRESULT,
    fn get_Request(&self, out: *mut u8) -> HRESULT,
    fn put_Request(&self, value: u8) -> HRESULT,
    fn get_Value(&self, out: *mut u32) -> HRESULT,
    fn put_Value(&self, value: u32) -> HRESULT,
    fn get_Index(&self, out: *mut u32) -> HRESULT,
    fn put_Index(&self, value: u32) -> HRESULT,
    fn get_Length(&self, out: *mut u32) -> HRESULT,
    fn put_Length(&self, value: u32) -> HRESULT
}}
impl ComPtr<IUsbSetupPacket> {
    #[inline] pub fn get_request_type(&self) -> Result<Option<ComPtr<UsbControlRequestType>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RequestType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_request_type(&self, value: &ComPtr<UsbControlRequestType>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_RequestType)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_request(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Request)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_request(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Request)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_value(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_value(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Value)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_index(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Index)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_index(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Index)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_length(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Length)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_length(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Length)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class UsbSetupPacket: IUsbSetupPacket}
impl RtActivatable<IUsbSetupPacketFactory> for UsbSetupPacket {}
impl RtActivatable<IActivationFactory> for UsbSetupPacket {}
impl UsbSetupPacket {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_with_eight_byte_buffer(eightByteBuffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<UsbSetupPacket>> {
        <Self as RtActivatable<IUsbSetupPacketFactory>>::get_activation_factory().create_with_eight_byte_buffer(eightByteBuffer)
    }
}
DEFINE_CLSID!(UsbSetupPacket(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,85,115,98,46,85,115,98,83,101,116,117,112,80,97,99,107,101,116,0]) [CLSID_UsbSetupPacket]);
DEFINE_IID!(IID_IUsbSetupPacketFactory, 3374677328, 6958, 19009, 162, 167, 51, 143, 12, 239, 60, 20);
RT_INTERFACE!{static interface IUsbSetupPacketFactory(IUsbSetupPacketFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUsbSetupPacketFactory] {
    #[cfg(feature="windows-storage")] fn CreateWithEightByteBuffer(&self, eightByteBuffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut UsbSetupPacket) -> HRESULT
}}
impl ComPtr<IUsbSetupPacketFactory> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_with_eight_byte_buffer(&self, eightByteBuffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<ComPtr<UsbSetupPacket>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWithEightByteBuffer)(self.deref() as *const _ as *mut _, eightByteBuffer.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum UsbTransferDirection: i32 {
    Out = 0, In = 1,
}}
RT_ENUM! { enum UsbWriteOptions: u32 {
    None = 0, AutoClearStall = 1, ShortPacketTerminate = 2,
}}
} // Windows.Devices.Usb
pub mod wifi { // Windows.Devices.WiFi
use crate::prelude::*;
RT_ENUM! { enum WiFiAccessStatus: i32 {
    Unspecified = 0, Allowed = 1, DeniedByUser = 2, DeniedBySystem = 3,
}}
DEFINE_IID!(IID_IWiFiAdapter, 2797921315, 15733, 17316, 185, 222, 17, 226, 107, 114, 217, 176);
RT_INTERFACE!{interface IWiFiAdapter(IWiFiAdapterVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAdapter] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_NetworkAdapter(&self, out: *mut *mut super::super::networking::connectivity::NetworkAdapter) -> HRESULT,
    fn ScanAsync(&self, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn get_NetworkReport(&self, out: *mut *mut WiFiNetworkReport) -> HRESULT,
    fn add_AvailableNetworksChanged(&self, args: *mut foundation::TypedEventHandler<WiFiAdapter, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AvailableNetworksChanged(&self, eventCookie: foundation::EventRegistrationToken) -> HRESULT,
    fn ConnectAsync(&self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, out: *mut *mut foundation::IAsyncOperation<WiFiConnectionResult>) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-security")] fn ConnectWithPasswordCredentialAsync(&self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: *mut super::super::security::credentials::PasswordCredential, out: *mut *mut foundation::IAsyncOperation<WiFiConnectionResult>) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-security")] fn ConnectWithPasswordCredentialAndSsidAsync(&self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: *mut super::super::security::credentials::PasswordCredential, ssid: HSTRING, out: *mut *mut foundation::IAsyncOperation<WiFiConnectionResult>) -> HRESULT,
    fn Disconnect(&self) -> HRESULT
}}
impl ComPtr<IWiFiAdapter> {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_network_adapter(&self) -> Result<Option<ComPtr<super::super::networking::connectivity::NetworkAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_NetworkAdapter)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn scan_async(&self) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ScanAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_network_report(&self) -> Result<Option<ComPtr<WiFiNetworkReport>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_NetworkReport)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_available_networks_changed(&self, args: &ComPtr<foundation::TypedEventHandler<WiFiAdapter, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AvailableNetworksChanged)(self.deref() as *const _ as *mut _, args.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_available_networks_changed(&self, eventCookie: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AvailableNetworksChanged)(self.deref() as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn connect_async(&self, availableNetwork: &ComPtr<WiFiAvailableNetwork>, reconnectionKind: WiFiReconnectionKind) -> Result<ComPtr<foundation::IAsyncOperation<WiFiConnectionResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectAsync)(self.deref() as *const _ as *mut _, availableNetwork.deref() as *const _ as *mut _, reconnectionKind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn connect_with_password_credential_async(&self, availableNetwork: &ComPtr<WiFiAvailableNetwork>, reconnectionKind: WiFiReconnectionKind, passwordCredential: &ComPtr<super::super::security::credentials::PasswordCredential>) -> Result<ComPtr<foundation::IAsyncOperation<WiFiConnectionResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectWithPasswordCredentialAsync)(self.deref() as *const _ as *mut _, availableNetwork.deref() as *const _ as *mut _, reconnectionKind, passwordCredential.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn connect_with_password_credential_and_ssid_async(&self, availableNetwork: &ComPtr<WiFiAvailableNetwork>, reconnectionKind: WiFiReconnectionKind, passwordCredential: &ComPtr<super::super::security::credentials::PasswordCredential>, ssid: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiConnectionResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectWithPasswordCredentialAndSsidAsync)(self.deref() as *const _ as *mut _, availableNetwork.deref() as *const _ as *mut _, reconnectionKind, passwordCredential.deref() as *const _ as *mut _, ssid.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn disconnect(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Disconnect)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiAdapter: IWiFiAdapter}
impl RtActivatable<IWiFiAdapterStatics> for WiFiAdapter {}
impl WiFiAdapter {
    #[inline] pub fn find_all_adapters_async() -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<WiFiAdapter>>>> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().find_all_adapters_async()
    }
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiAdapter>>> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn request_access_async() -> Result<ComPtr<foundation::IAsyncOperation<WiFiAccessStatus>>> {
        <Self as RtActivatable<IWiFiAdapterStatics>>::get_activation_factory().request_access_async()
    }
}
DEFINE_CLSID!(WiFiAdapter(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,46,87,105,70,105,65,100,97,112,116,101,114,0]) [CLSID_WiFiAdapter]);
DEFINE_IID!(IID_IWiFiAdapter2, 1539592221, 33252, 17725, 148, 48, 31, 202, 251, 173, 214, 182);
RT_INTERFACE!{interface IWiFiAdapter2(IWiFiAdapter2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAdapter2] {
    fn GetWpsConfigurationAsync(&self, availableNetwork: *mut WiFiAvailableNetwork, out: *mut *mut foundation::IAsyncOperation<WiFiWpsConfigurationResult>) -> HRESULT,
    #[cfg(feature="windows-security")] fn ConnectWithPasswordCredentialAndSsidAndConnectionMethodAsync(&self, availableNetwork: *mut WiFiAvailableNetwork, reconnectionKind: WiFiReconnectionKind, passwordCredential: *mut super::super::security::credentials::PasswordCredential, ssid: HSTRING, connectionMethod: WiFiConnectionMethod, out: *mut *mut foundation::IAsyncOperation<WiFiConnectionResult>) -> HRESULT
}}
impl ComPtr<IWiFiAdapter2> {
    #[inline] pub fn get_wps_configuration_async(&self, availableNetwork: &ComPtr<WiFiAvailableNetwork>) -> Result<ComPtr<foundation::IAsyncOperation<WiFiWpsConfigurationResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetWpsConfigurationAsync)(self.deref() as *const _ as *mut _, availableNetwork.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn connect_with_password_credential_and_ssid_and_connection_method_async(&self, availableNetwork: &ComPtr<WiFiAvailableNetwork>, reconnectionKind: WiFiReconnectionKind, passwordCredential: &ComPtr<super::super::security::credentials::PasswordCredential>, ssid: &HStringArg, connectionMethod: WiFiConnectionMethod) -> Result<ComPtr<foundation::IAsyncOperation<WiFiConnectionResult>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectWithPasswordCredentialAndSsidAndConnectionMethodAsync)(self.deref() as *const _ as *mut _, availableNetwork.deref() as *const _ as *mut _, reconnectionKind, passwordCredential.deref() as *const _ as *mut _, ssid.get(), connectionMethod, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiAdapterStatics, 3659922909, 53836, 17379, 170, 189, 196, 101, 159, 115, 15, 153);
RT_INTERFACE!{static interface IWiFiAdapterStatics(IWiFiAdapterStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAdapterStatics] {
    fn FindAllAdaptersAsync(&self, out: *mut *mut foundation::IAsyncOperation<foundation::collections::IVectorView<WiFiAdapter>>) -> HRESULT,
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<WiFiAdapter>) -> HRESULT,
    fn RequestAccessAsync(&self, out: *mut *mut foundation::IAsyncOperation<WiFiAccessStatus>) -> HRESULT
}}
impl ComPtr<IWiFiAdapterStatics> {
    #[inline] pub fn find_all_adapters_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<foundation::collections::IVectorView<WiFiAdapter>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FindAllAdaptersAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiAdapter>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn request_access_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<WiFiAccessStatus>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).RequestAccessAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiAvailableNetwork, 652829254, 6206, 18180, 152, 38, 113, 180, 162, 240, 246, 104);
RT_INTERFACE!{interface IWiFiAvailableNetwork(IWiFiAvailableNetworkVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiAvailableNetwork] {
    fn get_Uptime(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_Ssid(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Bssid(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ChannelCenterFrequencyInKilohertz(&self, out: *mut i32) -> HRESULT,
    fn get_NetworkRssiInDecibelMilliwatts(&self, out: *mut f64) -> HRESULT,
    fn get_SignalBars(&self, out: *mut u8) -> HRESULT,
    fn get_NetworkKind(&self, out: *mut WiFiNetworkKind) -> HRESULT,
    fn get_PhyKind(&self, out: *mut WiFiPhyKind) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_SecuritySettings(&self, out: *mut *mut super::super::networking::connectivity::NetworkSecuritySettings) -> HRESULT,
    fn get_BeaconInterval(&self, out: *mut foundation::TimeSpan) -> HRESULT,
    fn get_IsWiFiDirect(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IWiFiAvailableNetwork> {
    #[inline] pub fn get_uptime(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Uptime)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_ssid(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Ssid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_bssid(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Bssid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_channel_center_frequency_in_kilohertz(&self) -> Result<i32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ChannelCenterFrequencyInKilohertz)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_rssi_in_decibel_milliwatts(&self) -> Result<f64> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NetworkRssiInDecibelMilliwatts)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_signal_bars(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SignalBars)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_network_kind(&self) -> Result<WiFiNetworkKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_NetworkKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_phy_kind(&self) -> Result<WiFiPhyKind> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PhyKind)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_security_settings(&self) -> Result<Option<ComPtr<super::super::networking::connectivity::NetworkSecuritySettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SecuritySettings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_beacon_interval(&self) -> Result<foundation::TimeSpan> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_BeaconInterval)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_wi_fi_direct(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsWiFiDirect)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiAvailableNetwork: IWiFiAvailableNetwork}
RT_ENUM! { enum WiFiConnectionMethod: i32 {
    Default = 0, WpsPin = 1, WpsPushButton = 2,
}}
DEFINE_IID!(IID_IWiFiConnectionResult, 339468249, 50045, 16574, 165, 200, 133, 123, 206, 133, 169, 49);
RT_INTERFACE!{interface IWiFiConnectionResult(IWiFiConnectionResultVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiConnectionResult] {
    fn get_ConnectionStatus(&self, out: *mut WiFiConnectionStatus) -> HRESULT
}}
impl ComPtr<IWiFiConnectionResult> {
    #[inline] pub fn get_connection_status(&self) -> Result<WiFiConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConnectionStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiConnectionResult: IWiFiConnectionResult}
RT_ENUM! { enum WiFiConnectionStatus: i32 {
    UnspecifiedFailure = 0, Success = 1, AccessRevoked = 2, InvalidCredential = 3, NetworkNotAvailable = 4, Timeout = 5, UnsupportedAuthenticationProtocol = 6,
}}
RT_ENUM! { enum WiFiNetworkKind: i32 {
    Any = 0, Infrastructure = 1, Adhoc = 2,
}}
DEFINE_IID!(IID_IWiFiNetworkReport, 2502221522, 22801, 17502, 129, 148, 190, 79, 26, 112, 72, 149);
RT_INTERFACE!{interface IWiFiNetworkReport(IWiFiNetworkReportVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiNetworkReport] {
    fn get_Timestamp(&self, out: *mut foundation::DateTime) -> HRESULT,
    fn get_AvailableNetworks(&self, out: *mut *mut foundation::collections::IVectorView<WiFiAvailableNetwork>) -> HRESULT
}}
impl ComPtr<IWiFiNetworkReport> {
    #[inline] pub fn get_timestamp(&self) -> Result<foundation::DateTime> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Timestamp)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_available_networks(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<WiFiAvailableNetwork>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_AvailableNetworks)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiNetworkReport: IWiFiNetworkReport}
RT_ENUM! { enum WiFiPhyKind: i32 {
    Unknown = 0, Fhss = 1, Dsss = 2, IRBaseband = 3, Ofdm = 4, Hrdsss = 5, Erp = 6, HT = 7, Vht = 8, Dmg = 9, HE = 10,
}}
RT_ENUM! { enum WiFiReconnectionKind: i32 {
    Automatic = 0, Manual = 1,
}}
DEFINE_IID!(IID_IWiFiWpsConfigurationResult, 1739888753, 6126, 17105, 177, 79, 90, 17, 241, 34, 111, 181);
RT_INTERFACE!{interface IWiFiWpsConfigurationResult(IWiFiWpsConfigurationResultVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiWpsConfigurationResult] {
    fn get_Status(&self, out: *mut WiFiWpsConfigurationStatus) -> HRESULT,
    fn get_SupportedWpsKinds(&self, out: *mut *mut foundation::collections::IVectorView<WiFiWpsKind>) -> HRESULT
}}
impl ComPtr<IWiFiWpsConfigurationResult> {
    #[inline] pub fn get_status(&self) -> Result<WiFiWpsConfigurationStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_wps_kinds(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<WiFiWpsKind>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedWpsKinds)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiWpsConfigurationResult: IWiFiWpsConfigurationResult}
RT_ENUM! { enum WiFiWpsConfigurationStatus: i32 {
    UnspecifiedFailure = 0, Success = 1, Timeout = 2,
}}
RT_ENUM! { enum WiFiWpsKind: i32 {
    Unknown = 0, Pin = 1, PushButton = 2, Nfc = 3, Ethernet = 4, Usb = 5,
}}
} // Windows.Devices.WiFi
pub mod wifidirect { // Windows.Devices.WiFiDirect
use crate::prelude::*;
DEFINE_IID!(IID_IWiFiDirectAdvertisement, 2874219053, 10758, 18849, 165, 132, 97, 67, 92, 121, 5, 166);
RT_INTERFACE!{interface IWiFiDirectAdvertisement(IWiFiDirectAdvertisementVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisement] {
    fn get_InformationElements(&self, out: *mut *mut foundation::collections::IVector<WiFiDirectInformationElement>) -> HRESULT,
    fn put_InformationElements(&self, value: *mut foundation::collections::IVector<WiFiDirectInformationElement>) -> HRESULT,
    fn get_ListenStateDiscoverability(&self, out: *mut WiFiDirectAdvertisementListenStateDiscoverability) -> HRESULT,
    fn put_ListenStateDiscoverability(&self, value: WiFiDirectAdvertisementListenStateDiscoverability) -> HRESULT,
    fn get_IsAutonomousGroupOwnerEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsAutonomousGroupOwnerEnabled(&self, value: bool) -> HRESULT,
    fn get_LegacySettings(&self, out: *mut *mut WiFiDirectLegacySettings) -> HRESULT
}}
impl ComPtr<IWiFiDirectAdvertisement> {
    #[inline] pub fn get_information_elements(&self) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectInformationElement>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_InformationElements)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_information_elements(&self, value: &ComPtr<foundation::collections::IVector<WiFiDirectInformationElement>>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_InformationElements)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_listen_state_discoverability(&self) -> Result<WiFiDirectAdvertisementListenStateDiscoverability> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ListenStateDiscoverability)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_listen_state_discoverability(&self, value: WiFiDirectAdvertisementListenStateDiscoverability) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ListenStateDiscoverability)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_is_autonomous_group_owner_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsAutonomousGroupOwnerEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_autonomous_group_owner_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsAutonomousGroupOwnerEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_legacy_settings(&self) -> Result<Option<ComPtr<WiFiDirectLegacySettings>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_LegacySettings)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectAdvertisement: IWiFiDirectAdvertisement}
DEFINE_IID!(IID_IWiFiDirectAdvertisement2, 3076106822, 55318, 18715, 145, 122, 180, 13, 125, 196, 3, 162);
RT_INTERFACE!{interface IWiFiDirectAdvertisement2(IWiFiDirectAdvertisement2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisement2] {
    fn get_SupportedConfigurationMethods(&self, out: *mut *mut foundation::collections::IVector<WiFiDirectConfigurationMethod>) -> HRESULT
}}
impl ComPtr<IWiFiDirectAdvertisement2> {
    #[inline] pub fn get_supported_configuration_methods(&self) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectConfigurationMethod>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedConfigurationMethods)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WiFiDirectAdvertisementListenStateDiscoverability: i32 {
    None = 0, Normal = 1, Intensive = 2,
}}
DEFINE_IID!(IID_IWiFiDirectAdvertisementPublisher, 3009031450, 39711, 17881, 146, 90, 105, 77, 102, 223, 104, 239);
RT_INTERFACE!{interface IWiFiDirectAdvertisementPublisher(IWiFiDirectAdvertisementPublisherVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisementPublisher] {
    fn get_Advertisement(&self, out: *mut *mut WiFiDirectAdvertisement) -> HRESULT,
    fn get_Status(&self, out: *mut WiFiDirectAdvertisementPublisherStatus) -> HRESULT,
    fn add_StatusChanged(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectAdvertisementPublisher, WiFiDirectAdvertisementPublisherStatusChangedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IWiFiDirectAdvertisementPublisher> {
    #[inline] pub fn get_advertisement(&self) -> Result<Option<ComPtr<WiFiDirectAdvertisement>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Advertisement)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<WiFiDirectAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectAdvertisementPublisher, WiFiDirectAdvertisementPublisherStatusChangedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_StatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_StatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectAdvertisementPublisher: IWiFiDirectAdvertisementPublisher}
impl RtActivatable<IActivationFactory> for WiFiDirectAdvertisementPublisher {}
DEFINE_CLSID!(WiFiDirectAdvertisementPublisher(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,65,100,118,101,114,116,105,115,101,109,101,110,116,80,117,98,108,105,115,104,101,114,0]) [CLSID_WiFiDirectAdvertisementPublisher]);
RT_ENUM! { enum WiFiDirectAdvertisementPublisherStatus: i32 {
    Created = 0, Started = 1, Stopped = 2, Aborted = 3,
}}
DEFINE_IID!(IID_IWiFiDirectAdvertisementPublisherStatusChangedEventArgs, 2868766012, 21633, 18150, 144, 221, 50, 17, 101, 24, 241, 146);
RT_INTERFACE!{interface IWiFiDirectAdvertisementPublisherStatusChangedEventArgs(IWiFiDirectAdvertisementPublisherStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectAdvertisementPublisherStatusChangedEventArgs] {
    fn get_Status(&self, out: *mut WiFiDirectAdvertisementPublisherStatus) -> HRESULT,
    fn get_Error(&self, out: *mut WiFiDirectError) -> HRESULT
}}
impl ComPtr<IWiFiDirectAdvertisementPublisherStatusChangedEventArgs> {
    #[inline] pub fn get_status(&self) -> Result<WiFiDirectAdvertisementPublisherStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error(&self) -> Result<WiFiDirectError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Error)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectAdvertisementPublisherStatusChangedEventArgs: IWiFiDirectAdvertisementPublisherStatusChangedEventArgs}
RT_ENUM! { enum WiFiDirectConfigurationMethod: i32 {
    ProvidePin = 0, DisplayPin = 1, PushButton = 2,
}}
DEFINE_IID!(IID_IWiFiDirectConnectionListener, 1771838221, 36115, 20201, 185, 236, 156, 114, 248, 37, 31, 125);
RT_INTERFACE!{interface IWiFiDirectConnectionListener(IWiFiDirectConnectionListenerVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionListener] {
    fn add_ConnectionRequested(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectConnectionListener, WiFiDirectConnectionRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IWiFiDirectConnectionListener> {
    #[inline] pub fn add_connection_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectConnectionListener, WiFiDirectConnectionRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ConnectionRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ConnectionRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionListener: IWiFiDirectConnectionListener}
impl RtActivatable<IActivationFactory> for WiFiDirectConnectionListener {}
DEFINE_CLSID!(WiFiDirectConnectionListener(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,67,111,110,110,101,99,116,105,111,110,76,105,115,116,101,110,101,114,0]) [CLSID_WiFiDirectConnectionListener]);
DEFINE_IID!(IID_IWiFiDirectConnectionParameters, 3001373701, 22274, 19222, 160, 44, 187, 205, 33, 239, 96, 152);
RT_INTERFACE!{interface IWiFiDirectConnectionParameters(IWiFiDirectConnectionParametersVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParameters] {
    fn get_GroupOwnerIntent(&self, out: *mut i16) -> HRESULT,
    fn put_GroupOwnerIntent(&self, value: i16) -> HRESULT
}}
impl ComPtr<IWiFiDirectConnectionParameters> {
    #[inline] pub fn get_group_owner_intent(&self) -> Result<i16> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_GroupOwnerIntent)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_group_owner_intent(&self, value: i16) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_GroupOwnerIntent)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionParameters: IWiFiDirectConnectionParameters}
impl RtActivatable<IWiFiDirectConnectionParametersStatics> for WiFiDirectConnectionParameters {}
impl RtActivatable<IActivationFactory> for WiFiDirectConnectionParameters {}
impl WiFiDirectConnectionParameters {
    #[inline] pub fn get_device_pairing_kinds(configurationMethod: WiFiDirectConfigurationMethod) -> Result<super::enumeration::DevicePairingKinds> {
        <Self as RtActivatable<IWiFiDirectConnectionParametersStatics>>::get_activation_factory().get_device_pairing_kinds(configurationMethod)
    }
}
DEFINE_CLSID!(WiFiDirectConnectionParameters(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,67,111,110,110,101,99,116,105,111,110,80,97,114,97,109,101,116,101,114,115,0]) [CLSID_WiFiDirectConnectionParameters]);
DEFINE_IID!(IID_IWiFiDirectConnectionParameters2, 2872774590, 43650, 17588, 136, 200, 227, 5, 107, 137, 128, 29);
RT_INTERFACE!{interface IWiFiDirectConnectionParameters2(IWiFiDirectConnectionParameters2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParameters2] {
    fn get_PreferenceOrderedConfigurationMethods(&self, out: *mut *mut foundation::collections::IVector<WiFiDirectConfigurationMethod>) -> HRESULT,
    fn get_PreferredPairingProcedure(&self, out: *mut WiFiDirectPairingProcedure) -> HRESULT,
    fn put_PreferredPairingProcedure(&self, value: WiFiDirectPairingProcedure) -> HRESULT
}}
impl ComPtr<IWiFiDirectConnectionParameters2> {
    #[inline] pub fn get_preference_ordered_configuration_methods(&self) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectConfigurationMethod>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PreferenceOrderedConfigurationMethods)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_preferred_pairing_procedure(&self) -> Result<WiFiDirectPairingProcedure> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PreferredPairingProcedure)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_preferred_pairing_procedure(&self, value: WiFiDirectPairingProcedure) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PreferredPairingProcedure)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectConnectionParametersStatics, 1502278803, 30274, 17775, 185, 216, 232, 169, 235, 31, 64, 26);
RT_INTERFACE!{static interface IWiFiDirectConnectionParametersStatics(IWiFiDirectConnectionParametersStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionParametersStatics] {
    fn GetDevicePairingKinds(&self, configurationMethod: WiFiDirectConfigurationMethod, out: *mut super::enumeration::DevicePairingKinds) -> HRESULT
}}
impl ComPtr<IWiFiDirectConnectionParametersStatics> {
    #[inline] pub fn get_device_pairing_kinds(&self, configurationMethod: WiFiDirectConfigurationMethod) -> Result<super::enumeration::DevicePairingKinds> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).GetDevicePairingKinds)(self.deref() as *const _ as *mut _, configurationMethod, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectConnectionRequest, 2394527237, 37199, 18883, 166, 20, 209, 141, 197, 177, 155, 67);
RT_INTERFACE!{interface IWiFiDirectConnectionRequest(IWiFiDirectConnectionRequestVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionRequest] {
    fn get_DeviceInformation(&self, out: *mut *mut super::enumeration::DeviceInformation) -> HRESULT
}}
impl ComPtr<IWiFiDirectConnectionRequest> {
    #[inline] pub fn get_device_information(&self) -> Result<Option<ComPtr<super::enumeration::DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionRequest: IWiFiDirectConnectionRequest}
DEFINE_IID!(IID_IWiFiDirectConnectionRequestedEventArgs, 4187824318, 54157, 18511, 130, 21, 231, 182, 90, 191, 36, 76);
RT_INTERFACE!{interface IWiFiDirectConnectionRequestedEventArgs(IWiFiDirectConnectionRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectConnectionRequestedEventArgs] {
    fn GetConnectionRequest(&self, out: *mut *mut WiFiDirectConnectionRequest) -> HRESULT
}}
impl ComPtr<IWiFiDirectConnectionRequestedEventArgs> {
    #[inline] pub fn get_connection_request(&self) -> Result<Option<ComPtr<WiFiDirectConnectionRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetConnectionRequest)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectConnectionRequestedEventArgs: IWiFiDirectConnectionRequestedEventArgs}
RT_ENUM! { enum WiFiDirectConnectionStatus: i32 {
    Disconnected = 0, Connected = 1,
}}
DEFINE_IID!(IID_IWiFiDirectDevice, 1927195304, 29419, 19886, 138, 40, 133, 19, 53, 93, 39, 119);
RT_INTERFACE!{interface IWiFiDirectDevice(IWiFiDirectDeviceVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDevice] {
    fn get_ConnectionStatus(&self, out: *mut WiFiDirectConnectionStatus) -> HRESULT,
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn add_ConnectionStatusChanged(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectDevice, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ConnectionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-networking")] fn GetConnectionEndpointPairs(&self, out: *mut *mut foundation::collections::IVectorView<super::super::networking::EndpointPair>) -> HRESULT
}}
impl ComPtr<IWiFiDirectDevice> {
    #[inline] pub fn get_connection_status(&self) -> Result<WiFiDirectConnectionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ConnectionStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_device_id(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_connection_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectDevice, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_ConnectionStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_connection_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_ConnectionStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_connection_endpoint_pairs(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<super::super::networking::EndpointPair>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetConnectionEndpointPairs)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectDevice: IWiFiDirectDevice}
impl RtActivatable<IWiFiDirectDeviceStatics> for WiFiDirectDevice {}
impl RtActivatable<IWiFiDirectDeviceStatics2> for WiFiDirectDevice {}
impl WiFiDirectDevice {
    #[inline] pub fn get_device_selector() -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics>>::get_activation_factory().get_device_selector()
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectDevice>>> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
    #[inline] pub fn get_device_selector2(type_: WiFiDirectDeviceSelectorType) -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics2>>::get_activation_factory().get_device_selector(type_)
    }
    #[inline] pub fn from_id_async2(deviceId: &HStringArg, connectionParameters: &ComPtr<WiFiDirectConnectionParameters>) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectDevice>>> {
        <Self as RtActivatable<IWiFiDirectDeviceStatics2>>::get_activation_factory().from_id_async(deviceId, connectionParameters)
    }
}
DEFINE_CLSID!(WiFiDirectDevice(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,68,101,118,105,99,101,0]) [CLSID_WiFiDirectDevice]);
RT_ENUM! { enum WiFiDirectDeviceSelectorType: i32 {
    DeviceInterface = 0, AssociationEndpoint = 1,
}}
DEFINE_IID!(IID_IWiFiDirectDeviceStatics, 3899438460, 15020, 18513, 167, 146, 72, 42, 175, 147, 27, 4);
RT_INTERFACE!{static interface IWiFiDirectDeviceStatics(IWiFiDirectDeviceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDeviceStatics] {
    fn GetDeviceSelector(&self, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<WiFiDirectDevice>) -> HRESULT
}}
impl ComPtr<IWiFiDirectDeviceStatics> {
    #[inline] pub fn get_device_selector(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectDeviceStatics2, 445988425, 45315, 17278, 146, 38, 171, 103, 151, 19, 66, 249);
RT_INTERFACE!{static interface IWiFiDirectDeviceStatics2(IWiFiDirectDeviceStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectDeviceStatics2] {
    fn GetDeviceSelector(&self, type_: WiFiDirectDeviceSelectorType, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, connectionParameters: *mut WiFiDirectConnectionParameters, out: *mut *mut foundation::IAsyncOperation<WiFiDirectDevice>) -> HRESULT
}}
impl ComPtr<IWiFiDirectDeviceStatics2> {
    #[inline] pub fn get_device_selector(&self, type_: WiFiDirectDeviceSelectorType) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetDeviceSelector)(self.deref() as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg, connectionParameters: &ComPtr<WiFiDirectConnectionParameters>) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectDevice>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), connectionParameters.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WiFiDirectError: i32 {
    Success = 0, RadioNotAvailable = 1, ResourceInUse = 2,
}}
DEFINE_IID!(IID_IWiFiDirectInformationElement, 2952491734, 30395, 18814, 172, 139, 220, 114, 131, 139, 195, 9);
RT_INTERFACE!{interface IWiFiDirectInformationElement(IWiFiDirectInformationElementVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectInformationElement] {
    #[cfg(feature="windows-storage")] fn get_Oui(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Oui(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT,
    fn get_OuiType(&self, out: *mut u8) -> HRESULT,
    fn put_OuiType(&self, value: u8) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Value(&self, out: *mut *mut super::super::storage::streams::IBuffer) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Value(&self, value: *mut super::super::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IWiFiDirectInformationElement> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_oui(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Oui)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_oui(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Oui)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_oui_type(&self) -> Result<u8> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_OuiType)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_oui_type(&self, value: u8) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_OuiType)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_value(&self) -> Result<Option<ComPtr<super::super::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Value)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_value(&self, value: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Value)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectInformationElement: IWiFiDirectInformationElement}
impl RtActivatable<IWiFiDirectInformationElementStatics> for WiFiDirectInformationElement {}
impl RtActivatable<IActivationFactory> for WiFiDirectInformationElement {}
impl WiFiDirectInformationElement {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_buffer(buffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectInformationElement>>>> {
        <Self as RtActivatable<IWiFiDirectInformationElementStatics>>::get_activation_factory().create_from_buffer(buffer)
    }
    #[inline] pub fn create_from_device_information(deviceInformation: &ComPtr<super::enumeration::DeviceInformation>) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectInformationElement>>>> {
        <Self as RtActivatable<IWiFiDirectInformationElementStatics>>::get_activation_factory().create_from_device_information(deviceInformation)
    }
}
DEFINE_CLSID!(WiFiDirectInformationElement(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,87,105,70,105,68,105,114,101,99,116,73,110,102,111,114,109,97,116,105,111,110,69,108,101,109,101,110,116,0]) [CLSID_WiFiDirectInformationElement]);
DEFINE_IID!(IID_IWiFiDirectInformationElementStatics, 3687853846, 4517, 20064, 140, 170, 52, 119, 33, 72, 55, 138);
RT_INTERFACE!{static interface IWiFiDirectInformationElementStatics(IWiFiDirectInformationElementStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectInformationElementStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn CreateFromBuffer(&self, buffer: *mut super::super::storage::streams::IBuffer, out: *mut *mut foundation::collections::IVector<WiFiDirectInformationElement>) -> HRESULT,
    fn CreateFromDeviceInformation(&self, deviceInformation: *mut super::enumeration::DeviceInformation, out: *mut *mut foundation::collections::IVector<WiFiDirectInformationElement>) -> HRESULT
}}
impl ComPtr<IWiFiDirectInformationElementStatics> {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_buffer(&self, buffer: &ComPtr<super::super::storage::streams::IBuffer>) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectInformationElement>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromBuffer)(self.deref() as *const _ as *mut _, buffer.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn create_from_device_information(&self, deviceInformation: &ComPtr<super::enumeration::DeviceInformation>) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectInformationElement>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateFromDeviceInformation)(self.deref() as *const _ as *mut _, deviceInformation.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectLegacySettings, 2790251450, 62205, 17767, 169, 27, 245, 194, 245, 50, 16, 87);
RT_INTERFACE!{interface IWiFiDirectLegacySettings(IWiFiDirectLegacySettingsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectLegacySettings] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_Ssid(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Ssid(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-security")] fn get_Passphrase(&self, out: *mut *mut super::super::security::credentials::PasswordCredential) -> HRESULT,
    #[cfg(feature="windows-security")] fn put_Passphrase(&self, value: *mut super::super::security::credentials::PasswordCredential) -> HRESULT
}}
impl ComPtr<IWiFiDirectLegacySettings> {
    #[inline] pub fn get_is_enabled(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsEnabled)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_is_enabled(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_IsEnabled)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_ssid(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Ssid)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn set_ssid(&self, value: &HStringArg) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Ssid)(self.deref() as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn get_passphrase(&self) -> Result<Option<ComPtr<super::super::security::credentials::PasswordCredential>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Passphrase)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-security")] #[inline] pub fn set_passphrase(&self, value: &ComPtr<super::super::security::credentials::PasswordCredential>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_Passphrase)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectLegacySettings: IWiFiDirectLegacySettings}
RT_ENUM! { enum WiFiDirectPairingProcedure: i32 {
    GroupOwnerNegotiation = 0, Invitation = 1,
}}
pub mod services { // Windows.Devices.WiFiDirect.Services
use crate::prelude::*;
DEFINE_IID!(IID_IWiFiDirectService, 1353366456, 24433, 17900, 132, 241, 161, 228, 252, 120, 121, 163);
RT_INTERFACE!{interface IWiFiDirectService(IWiFiDirectServiceVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectService] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_RemoteServiceInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_SupportedConfigurationMethods(&self, out: *mut *mut foundation::collections::IVectorView<WiFiDirectServiceConfigurationMethod>) -> HRESULT,
    fn get_PreferGroupOwnerMode(&self, out: *mut bool) -> HRESULT,
    fn put_PreferGroupOwnerMode(&self, value: bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SessionInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SessionInfo(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_ServiceError(&self, out: *mut WiFiDirectServiceError) -> HRESULT,
    fn add_SessionDeferred(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectService, WiFiDirectServiceSessionDeferredEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionDeferred(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn GetProvisioningInfoAsync(&self, selectedConfigurationMethod: WiFiDirectServiceConfigurationMethod, out: *mut *mut foundation::IAsyncOperation<WiFiDirectServiceProvisioningInfo>) -> HRESULT,
    fn ConnectAsync(&self, out: *mut *mut foundation::IAsyncOperation<WiFiDirectServiceSession>) -> HRESULT,
    fn ConnectAsyncWithPin(&self, pin: HSTRING, out: *mut *mut foundation::IAsyncOperation<WiFiDirectServiceSession>) -> HRESULT
}}
impl ComPtr<IWiFiDirectService> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_remote_service_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_RemoteServiceInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_supported_configuration_methods(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<WiFiDirectServiceConfigurationMethod>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SupportedConfigurationMethods)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_prefer_group_owner_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PreferGroupOwnerMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_prefer_group_owner_mode(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PreferGroupOwnerMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_session_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SessionInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_session_info(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_SessionInfo)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_service_error(&self) -> Result<WiFiDirectServiceError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_session_deferred(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectService, WiFiDirectServiceSessionDeferredEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SessionDeferred)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_deferred(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SessionDeferred)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_provisioning_info_async(&self, selectedConfigurationMethod: WiFiDirectServiceConfigurationMethod) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectServiceProvisioningInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetProvisioningInfoAsync)(self.deref() as *const _ as *mut _, selectedConfigurationMethod, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_async(&self) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectServiceSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectAsync)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_async_with_pin(&self, pin: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectServiceSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectAsyncWithPin)(self.deref() as *const _ as *mut _, pin.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectService: IWiFiDirectService}
impl RtActivatable<IWiFiDirectServiceStatics> for WiFiDirectService {}
impl WiFiDirectService {
    #[inline] pub fn get_selector(serviceName: &HStringArg) -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectServiceStatics>>::get_activation_factory().get_selector(serviceName)
    }
    #[cfg(feature="windows-storage")] #[inline] pub fn get_selector_with_filter(serviceName: &HStringArg, serviceInfoFilter: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<HString> {
        <Self as RtActivatable<IWiFiDirectServiceStatics>>::get_activation_factory().get_selector_with_filter(serviceName, serviceInfoFilter)
    }
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectService>>> {
        <Self as RtActivatable<IWiFiDirectServiceStatics>>::get_activation_factory().from_id_async(deviceId)
    }
}
DEFINE_CLSID!(WiFiDirectService(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,83,101,114,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,83,101,114,118,105,99,101,0]) [CLSID_WiFiDirectService]);
RT_ENUM! { enum WiFiDirectServiceAdvertisementStatus: i32 {
    Created = 0, Started = 1, Stopped = 2, Aborted = 3,
}}
DEFINE_IID!(IID_IWiFiDirectServiceAdvertiser, 2762612449, 40335, 20303, 147, 238, 125, 222, 162, 227, 127, 70);
RT_INTERFACE!{interface IWiFiDirectServiceAdvertiser(IWiFiDirectServiceAdvertiserVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAdvertiser] {
    fn get_ServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceNamePrefixes(&self, out: *mut *mut foundation::collections::IVector<HString>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_ServiceInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_ServiceInfo(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_AutoAcceptSession(&self, out: *mut bool) -> HRESULT,
    fn put_AutoAcceptSession(&self, value: bool) -> HRESULT,
    fn get_PreferGroupOwnerMode(&self, out: *mut bool) -> HRESULT,
    fn put_PreferGroupOwnerMode(&self, value: bool) -> HRESULT,
    fn get_PreferredConfigurationMethods(&self, out: *mut *mut foundation::collections::IVector<WiFiDirectServiceConfigurationMethod>) -> HRESULT,
    fn get_ServiceStatus(&self, out: *mut WiFiDirectServiceStatus) -> HRESULT,
    fn put_ServiceStatus(&self, value: WiFiDirectServiceStatus) -> HRESULT,
    fn get_CustomServiceStatusCode(&self, out: *mut u32) -> HRESULT,
    fn put_CustomServiceStatusCode(&self, value: u32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DeferredSessionInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_DeferredSessionInfo(&self, value: *mut crate::windows::storage::streams::IBuffer) -> HRESULT,
    fn get_AdvertisementStatus(&self, out: *mut WiFiDirectServiceAdvertisementStatus) -> HRESULT,
    fn get_ServiceError(&self, out: *mut WiFiDirectServiceError) -> HRESULT,
    fn add_SessionRequested(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceSessionRequestedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionRequested(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AutoAcceptSessionConnected(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AutoAcceptSessionConnected(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn add_AdvertisementStatusChanged(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AdvertisementStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    fn ConnectAsync(&self, deviceInfo: *mut super::super::enumeration::DeviceInformation, out: *mut *mut foundation::IAsyncOperation<WiFiDirectServiceSession>) -> HRESULT,
    fn ConnectAsyncWithPin(&self, deviceInfo: *mut super::super::enumeration::DeviceInformation, pin: HSTRING, out: *mut *mut foundation::IAsyncOperation<WiFiDirectServiceSession>) -> HRESULT,
    fn Start(&self) -> HRESULT,
    fn Stop(&self) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceAdvertiser> {
    #[inline] pub fn get_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_name_prefixes(&self) -> Result<Option<ComPtr<foundation::collections::IVector<HString>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceNamePrefixes)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_service_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_service_info(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ServiceInfo)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_auto_accept_session(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AutoAcceptSession)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_auto_accept_session(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_AutoAcceptSession)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_prefer_group_owner_mode(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_PreferGroupOwnerMode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_prefer_group_owner_mode(&self, value: bool) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_PreferGroupOwnerMode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_preferred_configuration_methods(&self) -> Result<Option<ComPtr<foundation::collections::IVector<WiFiDirectServiceConfigurationMethod>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_PreferredConfigurationMethods)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_service_status(&self) -> Result<WiFiDirectServiceStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_service_status(&self, value: WiFiDirectServiceStatus) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_ServiceStatus)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_custom_service_status_code(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_CustomServiceStatusCode)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn set_custom_service_status_code(&self, value: u32) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_CustomServiceStatusCode)(self.deref() as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_deferred_session_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeferredSessionInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn set_deferred_session_info(&self, value: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).put_DeferredSessionInfo)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_status(&self) -> Result<WiFiDirectServiceAdvertisementStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdvertisementStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_error(&self) -> Result<WiFiDirectServiceError> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ServiceError)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn add_session_requested(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceSessionRequestedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SessionRequested)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_requested(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SessionRequested)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_auto_accept_session_connected(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, WiFiDirectServiceAutoAcceptSessionConnectedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AutoAcceptSessionConnected)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_auto_accept_session_connected(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AutoAcceptSessionConnected)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn add_advertisement_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectServiceAdvertiser, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_AdvertisementStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_advertisement_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_AdvertisementStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn connect_async(&self, deviceInfo: &ComPtr<super::super::enumeration::DeviceInformation>) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectServiceSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectAsync)(self.deref() as *const _ as *mut _, deviceInfo.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn connect_async_with_pin(&self, deviceInfo: &ComPtr<super::super::enumeration::DeviceInformation>, pin: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectServiceSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).ConnectAsyncWithPin)(self.deref() as *const _ as *mut _, deviceInfo.deref() as *const _ as *mut _, pin.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn start(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Start)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[inline] pub fn stop(&self) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).Stop)(self.deref() as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceAdvertiser: IWiFiDirectServiceAdvertiser}
impl RtActivatable<IWiFiDirectServiceAdvertiserFactory> for WiFiDirectServiceAdvertiser {}
impl WiFiDirectServiceAdvertiser {
    #[inline] pub fn create_wi_fi_direct_service_advertiser(serviceName: &HStringArg) -> Result<ComPtr<WiFiDirectServiceAdvertiser>> {
        <Self as RtActivatable<IWiFiDirectServiceAdvertiserFactory>>::get_activation_factory().create_wi_fi_direct_service_advertiser(serviceName)
    }
}
DEFINE_CLSID!(WiFiDirectServiceAdvertiser(&[87,105,110,100,111,119,115,46,68,101,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,46,83,101,114,118,105,99,101,115,46,87,105,70,105,68,105,114,101,99,116,83,101,114,118,105,99,101,65,100,118,101,114,116,105,115,101,114,0]) [CLSID_WiFiDirectServiceAdvertiser]);
DEFINE_IID!(IID_IWiFiDirectServiceAdvertiserFactory, 822520845, 46150, 20243, 159, 154, 138, 233, 37, 254, 186, 43);
RT_INTERFACE!{static interface IWiFiDirectServiceAdvertiserFactory(IWiFiDirectServiceAdvertiserFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAdvertiserFactory] {
    fn CreateWiFiDirectServiceAdvertiser(&self, serviceName: HSTRING, out: *mut *mut WiFiDirectServiceAdvertiser) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceAdvertiserFactory> {
    #[inline] pub fn create_wi_fi_direct_service_advertiser(&self, serviceName: &HStringArg) -> Result<ComPtr<WiFiDirectServiceAdvertiser>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).CreateWiFiDirectServiceAdvertiser)(self.deref() as *const _ as *mut _, serviceName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
DEFINE_IID!(IID_IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs, 3705266206, 33759, 17381, 143, 67, 203, 232, 71, 158, 132, 235);
RT_INTERFACE!{interface IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs(IWiFiDirectServiceAutoAcceptSessionConnectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs] {
    fn get_Session(&self, out: *mut *mut WiFiDirectServiceSession) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_SessionInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs> {
    #[inline] pub fn get_session(&self) -> Result<Option<ComPtr<WiFiDirectServiceSession>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_Session)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_session_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SessionInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceAutoAcceptSessionConnectedEventArgs: IWiFiDirectServiceAutoAcceptSessionConnectedEventArgs}
RT_ENUM! { enum WiFiDirectServiceConfigurationMethod: i32 {
    Default = 0, PinDisplay = 1, PinEntry = 2,
}}
RT_ENUM! { enum WiFiDirectServiceError: i32 {
    Success = 0, RadioNotAvailable = 1, ResourceInUse = 2, UnsupportedHardware = 3, NoHardware = 4,
}}
RT_ENUM! { enum WiFiDirectServiceIPProtocol: i32 {
    Tcp = 6, Udp = 17,
}}
DEFINE_IID!(IID_IWiFiDirectServiceProvisioningInfo, 2346417406, 38873, 17826, 142, 153, 219, 80, 145, 15, 182, 166);
RT_INTERFACE!{interface IWiFiDirectServiceProvisioningInfo(IWiFiDirectServiceProvisioningInfoVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceProvisioningInfo] {
    fn get_SelectedConfigurationMethod(&self, out: *mut WiFiDirectServiceConfigurationMethod) -> HRESULT,
    fn get_IsGroupFormationNeeded(&self, out: *mut bool) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceProvisioningInfo> {
    #[inline] pub fn get_selected_configuration_method(&self) -> Result<WiFiDirectServiceConfigurationMethod> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SelectedConfigurationMethod)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_is_group_formation_needed(&self) -> Result<bool> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_IsGroupFormationNeeded)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceProvisioningInfo: IWiFiDirectServiceProvisioningInfo}
DEFINE_IID!(IID_IWiFiDirectServiceRemotePortAddedEventArgs, 3570318017, 16339, 20238, 183, 189, 120, 41, 6, 244, 68, 17);
RT_INTERFACE!{interface IWiFiDirectServiceRemotePortAddedEventArgs(IWiFiDirectServiceRemotePortAddedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceRemotePortAddedEventArgs] {
    #[cfg(not(feature="windows-networking"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-networking")] fn get_EndpointPairs(&self, out: *mut *mut foundation::collections::IVectorView<crate::windows::networking::EndpointPair>) -> HRESULT,
    fn get_Protocol(&self, out: *mut WiFiDirectServiceIPProtocol) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceRemotePortAddedEventArgs> {
    #[cfg(feature="windows-networking")] #[inline] pub fn get_endpoint_pairs(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<crate::windows::networking::EndpointPair>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_EndpointPairs)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_protocol(&self) -> Result<WiFiDirectServiceIPProtocol> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Protocol)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceRemotePortAddedEventArgs: IWiFiDirectServiceRemotePortAddedEventArgs}
DEFINE_IID!(IID_IWiFiDirectServiceSession, 2165580131, 58406, 18379, 134, 64, 225, 179, 88, 139, 242, 111);
RT_INTERFACE!{interface IWiFiDirectServiceSession(IWiFiDirectServiceSessionVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSession] {
    fn get_ServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Status(&self, out: *mut WiFiDirectServiceSessionStatus) -> HRESULT,
    fn get_ErrorStatus(&self, out: *mut WiFiDirectServiceSessionErrorStatus) -> HRESULT,
    fn get_SessionId(&self, out: *mut u32) -> HRESULT,
    fn get_AdvertisementId(&self, out: *mut u32) -> HRESULT,
    fn get_ServiceAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SessionAddress(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-networking")] fn GetConnectionEndpointPairs(&self, out: *mut *mut foundation::collections::IVectorView<crate::windows::networking::EndpointPair>) -> HRESULT,
    fn add_SessionStatusChanged(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectServiceSession, IInspectable>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SessionStatusChanged(&self, token: foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-networking")] fn AddStreamSocketListenerAsync(&self, value: *mut crate::windows::networking::sockets::StreamSocketListener, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    #[cfg(not(feature="windows-networking"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-networking")] fn AddDatagramSocketAsync(&self, value: *mut crate::windows::networking::sockets::DatagramSocket, out: *mut *mut foundation::IAsyncAction) -> HRESULT,
    fn add_RemotePortAdded(&self, handler: *mut foundation::TypedEventHandler<WiFiDirectServiceSession, WiFiDirectServiceRemotePortAddedEventArgs>, out: *mut foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RemotePortAdded(&self, token: foundation::EventRegistrationToken) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceSession> {
    #[inline] pub fn get_service_name(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceName)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_status(&self) -> Result<WiFiDirectServiceSessionStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_Status)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_error_status(&self) -> Result<WiFiDirectServiceSessionErrorStatus> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_ErrorStatus)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_session_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_SessionId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_advertisement_id(&self) -> Result<u32> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).get_AdvertisementId)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn get_service_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ServiceAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_session_address(&self) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SessionAddress)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn get_connection_endpoint_pairs(&self) -> Result<Option<ComPtr<foundation::collections::IVectorView<crate::windows::networking::EndpointPair>>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetConnectionEndpointPairs)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_session_status_changed(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectServiceSession, IInspectable>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_SessionStatusChanged)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_session_status_changed(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_SessionStatusChanged)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn add_stream_socket_listener_async(&self, value: &ComPtr<crate::windows::networking::sockets::StreamSocketListener>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AddStreamSocketListenerAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-networking")] #[inline] pub fn add_datagram_socket_async(&self, value: &ComPtr<crate::windows::networking::sockets::DatagramSocket>) -> Result<ComPtr<foundation::IAsyncAction>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).AddDatagramSocketAsync)(self.deref() as *const _ as *mut _, value.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn add_remote_port_added(&self, handler: &ComPtr<foundation::TypedEventHandler<WiFiDirectServiceSession, WiFiDirectServiceRemotePortAddedEventArgs>>) -> Result<foundation::EventRegistrationToken> { unsafe { 
        let mut out = zeroed();
        let hr = ((*self.deref().lpVtbl).add_RemotePortAdded)(self.deref() as *const _ as *mut _, handler.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }}
    #[inline] pub fn remove_remote_port_added(&self, token: foundation::EventRegistrationToken) -> Result<()> { unsafe { 
        let hr = ((*self.deref().lpVtbl).remove_RemotePortAdded)(self.deref() as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSession: IWiFiDirectServiceSession}
DEFINE_IID!(IID_IWiFiDirectServiceSessionDeferredEventArgs, 2382109055, 4609, 20255, 182, 244, 93, 241, 183, 185, 251, 46);
RT_INTERFACE!{interface IWiFiDirectServiceSessionDeferredEventArgs(IWiFiDirectServiceSessionDeferredEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionDeferredEventArgs] {
    #[cfg(feature="windows-storage")] fn get_DeferredSessionInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceSessionDeferredEventArgs> {
    #[cfg(feature="windows-storage")] #[inline] pub fn get_deferred_session_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeferredSessionInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSessionDeferredEventArgs: IWiFiDirectServiceSessionDeferredEventArgs}
RT_ENUM! { enum WiFiDirectServiceSessionErrorStatus: i32 {
    Ok = 0, Disassociated = 1, LocalClose = 2, RemoteClose = 3, SystemFailure = 4, NoResponseFromRemote = 5,
}}
DEFINE_IID!(IID_IWiFiDirectServiceSessionRequest, 2699197579, 20683, 19032, 155, 207, 228, 114, 185, 159, 186, 4);
RT_INTERFACE!{interface IWiFiDirectServiceSessionRequest(IWiFiDirectServiceSessionRequestVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionRequest] {
    fn get_DeviceInformation(&self, out: *mut *mut super::super::enumeration::DeviceInformation) -> HRESULT,
    fn get_ProvisioningInfo(&self, out: *mut *mut WiFiDirectServiceProvisioningInfo) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_SessionInfo(&self, out: *mut *mut crate::windows::storage::streams::IBuffer) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceSessionRequest> {
    #[inline] pub fn get_device_information(&self) -> Result<Option<ComPtr<super::super::enumeration::DeviceInformation>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_DeviceInformation)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[inline] pub fn get_provisioning_info(&self) -> Result<Option<ComPtr<WiFiDirectServiceProvisioningInfo>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_ProvisioningInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_session_info(&self) -> Result<Option<ComPtr<crate::windows::storage::streams::IBuffer>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).get_SessionInfo)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSessionRequest: IWiFiDirectServiceSessionRequest}
DEFINE_IID!(IID_IWiFiDirectServiceSessionRequestedEventArgs, 1958595601, 21462, 18841, 180, 248, 108, 142, 204, 23, 113, 231);
RT_INTERFACE!{interface IWiFiDirectServiceSessionRequestedEventArgs(IWiFiDirectServiceSessionRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceSessionRequestedEventArgs] {
    fn GetSessionRequest(&self, out: *mut *mut WiFiDirectServiceSessionRequest) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceSessionRequestedEventArgs> {
    #[inline] pub fn get_session_request(&self) -> Result<Option<ComPtr<WiFiDirectServiceSessionRequest>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSessionRequest)(self.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap_optional(out)) } else { err(hr) }
    }}
}
RT_CLASS!{class WiFiDirectServiceSessionRequestedEventArgs: IWiFiDirectServiceSessionRequestedEventArgs}
RT_ENUM! { enum WiFiDirectServiceSessionStatus: i32 {
    Closed = 0, Initiated = 1, Requested = 2, Open = 3,
}}
DEFINE_IID!(IID_IWiFiDirectServiceStatics, 2108948549, 64884, 18056, 183, 37, 93, 206, 134, 172, 242, 51);
RT_INTERFACE!{static interface IWiFiDirectServiceStatics(IWiFiDirectServiceStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWiFiDirectServiceStatics] {
    fn GetSelector(&self, serviceName: HSTRING, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetSelectorWithFilter(&self, serviceName: HSTRING, serviceInfoFilter: *mut crate::windows::storage::streams::IBuffer, out: *mut HSTRING) -> HRESULT,
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut foundation::IAsyncOperation<WiFiDirectService>) -> HRESULT
}}
impl ComPtr<IWiFiDirectServiceStatics> {
    #[inline] pub fn get_selector(&self, serviceName: &HStringArg) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSelector)(self.deref() as *const _ as *mut _, serviceName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_selector_with_filter(&self, serviceName: &HStringArg, serviceInfoFilter: &ComPtr<crate::windows::storage::streams::IBuffer>) -> Result<HString> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).GetSelectorWithFilter)(self.deref() as *const _ as *mut _, serviceName.get(), serviceInfoFilter.deref() as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }}
    #[inline] pub fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<foundation::IAsyncOperation<WiFiDirectService>>> { unsafe { 
        let mut out = null_mut();
        let hr = ((*self.deref().lpVtbl).FromIdAsync)(self.deref() as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }}
}
RT_ENUM! { enum WiFiDirectServiceStatus: i32 {
    Available = 0, Busy = 1, Custom = 2,
}}
} // Windows.Devices.WiFiDirect.Services
} // Windows.Devices.WiFiDirect
