use ::prelude::*;
DEFINE_IID!(IID_IAppDisplayInfo, 451612931, 58580, 16810, 164, 246, 196, 162, 118, 231, 158, 172);
RT_INTERFACE!{interface IAppDisplayInfo(IAppDisplayInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAppDisplayInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetLogo(&self, size: super::foundation::Size, out: *mut *mut super::storage::streams::RandomAccessStreamReference) -> HRESULT
}}
impl IAppDisplayInfo {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_logo(&self, size: super::foundation::Size) -> Result<ComPtr<super::storage::streams::RandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetLogo)(self as *const _ as *mut _, size, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppDisplayInfo: IAppDisplayInfo}
DEFINE_IID!(IID_IAppInfo, 3481229747, 27145, 19944, 166, 192, 87, 146, 213, 104, 128, 209);
RT_INTERFACE!{interface IAppInfo(IAppInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAppInfo] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppUserModelId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayInfo(&self, out: *mut *mut AppDisplayInfo) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppInfo {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_user_model_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppUserModelId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_info(&self) -> Result<ComPtr<AppDisplayInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppInfo: IAppInfo}
RT_CLASS!{static class DesignMode}
impl RtActivatable<IDesignModeStatics> for DesignMode {}
impl RtActivatable<IDesignModeStatics2> for DesignMode {}
impl DesignMode {
    #[inline] pub fn get_design_mode_enabled() -> Result<bool> { unsafe {
        <Self as RtActivatable<IDesignModeStatics>>::get_activation_factory().get_design_mode_enabled()
    }}
    #[inline] pub fn get_design_mode2_enabled() -> Result<bool> { unsafe {
        <Self as RtActivatable<IDesignModeStatics2>>::get_activation_factory().get_design_mode2_enabled()
    }}
}
DEFINE_CLSID!(DesignMode: "Windows.ApplicationModel.DesignMode");
DEFINE_IID!(IID_IDesignModeStatics, 741905356, 63514, 20090, 184, 87, 118, 168, 8, 135, 225, 133);
RT_INTERFACE!{static interface IDesignModeStatics(IDesignModeStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDesignModeStatics] {
    fn get_DesignModeEnabled(&self, out: *mut bool) -> HRESULT
}}
impl IDesignModeStatics {
    #[inline] pub unsafe fn get_design_mode_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesignModeEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDesignModeStatics2, 2161082679, 45156, 18520, 190, 200, 62, 186, 34, 53, 117, 53);
RT_INTERFACE!{static interface IDesignModeStatics2(IDesignModeStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDesignModeStatics2] {
    fn get_DesignMode2Enabled(&self, out: *mut bool) -> HRESULT
}}
impl IDesignModeStatics2 {
    #[inline] pub unsafe fn get_design_mode2_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesignMode2Enabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEnteredBackgroundEventArgs, 4146257090, 38951, 16445, 170, 237, 236, 202, 154, 193, 115, 152);
RT_INTERFACE!{interface IEnteredBackgroundEventArgs(IEnteredBackgroundEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEnteredBackgroundEventArgs] {
    fn GetDeferral(&self, out: *mut *mut super::foundation::Deferral) -> HRESULT
}}
impl IEnteredBackgroundEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EnteredBackgroundEventArgs: IEnteredBackgroundEventArgs}
RT_CLASS!{static class FullTrustProcessLauncher}
impl RtActivatable<IFullTrustProcessLauncherStatics> for FullTrustProcessLauncher {}
impl FullTrustProcessLauncher {
    #[inline] pub fn launch_full_trust_process_for_current_app_async() -> Result<ComPtr<super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_current_app_async()
    }}
    #[inline] pub fn launch_full_trust_process_for_current_app_with_parameters_async(parameterGroupId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_current_app_with_parameters_async(parameterGroupId)
    }}
    #[inline] pub fn launch_full_trust_process_for_app_async(fullTrustPackageRelativeAppId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_app_async(fullTrustPackageRelativeAppId)
    }}
    #[inline] pub fn launch_full_trust_process_for_app_with_parameters_async(fullTrustPackageRelativeAppId: &HStringArg, parameterGroupId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IFullTrustProcessLauncherStatics>>::get_activation_factory().launch_full_trust_process_for_app_with_parameters_async(fullTrustPackageRelativeAppId, parameterGroupId)
    }}
}
DEFINE_CLSID!(FullTrustProcessLauncher: "Windows.ApplicationModel.FullTrustProcessLauncher");
DEFINE_IID!(IID_IFullTrustProcessLauncherStatics, 3615785855, 4352, 15467, 164, 85, 246, 38, 44, 195, 49, 182);
RT_INTERFACE!{static interface IFullTrustProcessLauncherStatics(IFullTrustProcessLauncherStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IFullTrustProcessLauncherStatics] {
    fn LaunchFullTrustProcessForCurrentAppAsync(&self, out: *mut *mut super::foundation::IAsyncAction) -> HRESULT,
    fn LaunchFullTrustProcessForCurrentAppWithParametersAsync(&self, parameterGroupId: HSTRING, out: *mut *mut super::foundation::IAsyncAction) -> HRESULT,
    fn LaunchFullTrustProcessForAppAsync(&self, fullTrustPackageRelativeAppId: HSTRING, out: *mut *mut super::foundation::IAsyncAction) -> HRESULT,
    fn LaunchFullTrustProcessForAppWithParametersAsync(&self, fullTrustPackageRelativeAppId: HSTRING, parameterGroupId: HSTRING, out: *mut *mut super::foundation::IAsyncAction) -> HRESULT
}}
impl IFullTrustProcessLauncherStatics {
    #[inline] pub unsafe fn launch_full_trust_process_for_current_app_async(&self) -> Result<ComPtr<super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LaunchFullTrustProcessForCurrentAppAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch_full_trust_process_for_current_app_with_parameters_async(&self, parameterGroupId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LaunchFullTrustProcessForCurrentAppWithParametersAsync)(self as *const _ as *mut _, parameterGroupId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch_full_trust_process_for_app_async(&self, fullTrustPackageRelativeAppId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LaunchFullTrustProcessForAppAsync)(self as *const _ as *mut _, fullTrustPackageRelativeAppId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch_full_trust_process_for_app_with_parameters_async(&self, fullTrustPackageRelativeAppId: &HStringArg, parameterGroupId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LaunchFullTrustProcessForAppWithParametersAsync)(self as *const _ as *mut _, fullTrustPackageRelativeAppId.get(), parameterGroupId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILeavingBackgroundEventArgs, 969338010, 44654, 18169, 160, 122, 207, 194, 63, 136, 115, 62);
RT_INTERFACE!{interface ILeavingBackgroundEventArgs(ILeavingBackgroundEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILeavingBackgroundEventArgs] {
    fn GetDeferral(&self, out: *mut *mut super::foundation::Deferral) -> HRESULT
}}
impl ILeavingBackgroundEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LeavingBackgroundEventArgs: ILeavingBackgroundEventArgs}
DEFINE_IID!(IID_IPackage, 373061935, 48501, 16700, 191, 35, 177, 254, 123, 149, 216, 37);
RT_INTERFACE!{interface IPackage(IPackageVtbl): IInspectable(IInspectableVtbl) [IID_IPackage] {
    fn get_Id(&self, out: *mut *mut PackageId) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_InstalledLocation(&self, out: *mut *mut super::storage::StorageFolder) -> HRESULT,
    fn get_IsFramework(&self, out: *mut bool) -> HRESULT,
    fn get_Dependencies(&self, out: *mut *mut super::foundation::collections::IVectorView<Package>) -> HRESULT
}}
impl IPackage {
    #[inline] pub unsafe fn get_id(&self) -> Result<ComPtr<PackageId>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_installed_location(&self) -> Result<ComPtr<super::storage::StorageFolder>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstalledLocation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_framework(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFramework)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dependencies(&self) -> Result<ComPtr<super::foundation::collections::IVectorView<Package>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dependencies)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Package: IPackage}
impl RtActivatable<IPackageStatics> for Package {}
impl Package {
    #[inline] pub fn get_current() -> Result<ComPtr<Package>> { unsafe {
        <Self as RtActivatable<IPackageStatics>>::get_activation_factory().get_current()
    }}
}
DEFINE_CLSID!(Package: "Windows.ApplicationModel.Package");
DEFINE_IID!(IID_IPackage2, 2791387062, 30344, 19150, 149, 251, 53, 149, 56, 231, 170, 1);
RT_INTERFACE!{interface IPackage2(IPackage2Vtbl): IInspectable(IInspectableVtbl) [IID_IPackage2] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PublisherDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Logo(&self, out: *mut *mut super::foundation::Uri) -> HRESULT,
    fn get_IsResourcePackage(&self, out: *mut bool) -> HRESULT,
    fn get_IsBundle(&self, out: *mut bool) -> HRESULT,
    fn get_IsDevelopmentMode(&self, out: *mut bool) -> HRESULT
}}
impl IPackage2 {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_publisher_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PublisherDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_logo(&self) -> Result<ComPtr<super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_resource_package(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsResourcePackage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_bundle(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsBundle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_development_mode(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDevelopmentMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackage3, 1601407841, 63594, 18711, 147, 209, 241, 238, 157, 59, 53, 217);
RT_INTERFACE!{interface IPackage3(IPackage3Vtbl): IInspectable(IInspectableVtbl) [IID_IPackage3] {
    fn get_Status(&self, out: *mut *mut PackageStatus) -> HRESULT,
    fn get_InstalledDate(&self, out: *mut super::foundation::DateTime) -> HRESULT,
    fn GetAppListEntriesAsync(&self, out: *mut *mut super::foundation::IAsyncOperation<super::foundation::collections::IVectorView<core::AppListEntry>>) -> HRESULT
}}
impl IPackage3 {
    #[inline] pub unsafe fn get_status(&self) -> Result<ComPtr<PackageStatus>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_installed_date(&self) -> Result<super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstalledDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_list_entries_async(&self) -> Result<ComPtr<super::foundation::IAsyncOperation<super::foundation::collections::IVectorView<core::AppListEntry>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppListEntriesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackage4, 1705955758, 47451, 17676, 136, 43, 98, 85, 24, 127, 57, 126);
RT_INTERFACE!{interface IPackage4(IPackage4Vtbl): IInspectable(IInspectableVtbl) [IID_IPackage4] {
    fn get_SignatureKind(&self, out: *mut PackageSignatureKind) -> HRESULT,
    fn get_IsOptional(&self, out: *mut bool) -> HRESULT,
    fn VerifyContentIntegrityAsync(&self, out: *mut *mut super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IPackage4 {
    #[inline] pub unsafe fn get_signature_kind(&self) -> Result<PackageSignatureKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SignatureKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_optional(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOptional)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn verify_content_integrity_async(&self) -> Result<ComPtr<super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).VerifyContentIntegrityAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackage5, 243543508, 55724, 17901, 154, 30, 116, 206, 5, 107, 38, 53);
RT_INTERFACE!{interface IPackage5(IPackage5Vtbl): IInspectable(IInspectableVtbl) [IID_IPackage5] {
    fn GetContentGroupsAsync(&self, out: *mut *mut super::foundation::IAsyncOperation<super::foundation::collections::IVector<PackageContentGroup>>) -> HRESULT,
    fn GetContentGroupAsync(&self, name: HSTRING, out: *mut *mut super::foundation::IAsyncOperation<PackageContentGroup>) -> HRESULT,
    fn StageContentGroupsAsync(&self, names: *mut super::foundation::collections::IIterable<HString>, out: *mut *mut super::foundation::IAsyncOperation<super::foundation::collections::IVector<PackageContentGroup>>) -> HRESULT,
    fn StageContentGroupsWithPriorityAsync(&self, names: *mut super::foundation::collections::IIterable<HString>, moveToHeadOfQueue: bool, out: *mut *mut super::foundation::IAsyncOperation<super::foundation::collections::IVector<PackageContentGroup>>) -> HRESULT,
    fn SetInUseAsync(&self, inUse: bool, out: *mut *mut super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IPackage5 {
    #[inline] pub unsafe fn get_content_groups_async(&self) -> Result<ComPtr<super::foundation::IAsyncOperation<super::foundation::collections::IVector<PackageContentGroup>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContentGroupsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_group_async(&self, name: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncOperation<PackageContentGroup>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContentGroupAsync)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn stage_content_groups_async(&self, names: &super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::foundation::IAsyncOperation<super::foundation::collections::IVector<PackageContentGroup>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StageContentGroupsAsync)(self as *const _ as *mut _, names as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn stage_content_groups_with_priority_async(&self, names: &super::foundation::collections::IIterable<HString>, moveToHeadOfQueue: bool) -> Result<ComPtr<super::foundation::IAsyncOperation<super::foundation::collections::IVector<PackageContentGroup>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StageContentGroupsWithPriorityAsync)(self as *const _ as *mut _, names as *const _ as *mut _, moveToHeadOfQueue, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_in_use_async(&self, inUse: bool) -> Result<ComPtr<super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetInUseAsync)(self as *const _ as *mut _, inUse, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageCatalog, 587872081, 40419, 17477, 190, 116, 145, 251, 50, 90, 190, 254);
RT_INTERFACE!{interface IPackageCatalog(IPackageCatalogVtbl): IInspectable(IInspectableVtbl) [IID_IPackageCatalog] {
    fn add_PackageStaging(&self, handler: *mut super::foundation::TypedEventHandler<PackageCatalog, PackageStagingEventArgs>, out: *mut super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageStaging(&self, token: super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageInstalling(&self, handler: *mut super::foundation::TypedEventHandler<PackageCatalog, PackageInstallingEventArgs>, out: *mut super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageInstalling(&self, token: super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUpdating(&self, handler: *mut super::foundation::TypedEventHandler<PackageCatalog, PackageUpdatingEventArgs>, out: *mut super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUpdating(&self, token: super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUninstalling(&self, handler: *mut super::foundation::TypedEventHandler<PackageCatalog, PackageUninstallingEventArgs>, out: *mut super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUninstalling(&self, token: super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageStatusChanged(&self, handler: *mut super::foundation::TypedEventHandler<PackageCatalog, PackageStatusChangedEventArgs>, out: *mut super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageStatusChanged(&self, token: super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IPackageCatalog {
    #[inline] pub unsafe fn add_package_staging(&self, handler: &super::foundation::TypedEventHandler<PackageCatalog, PackageStagingEventArgs>) -> Result<super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageStaging)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_staging(&self, token: super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageStaging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_installing(&self, handler: &super::foundation::TypedEventHandler<PackageCatalog, PackageInstallingEventArgs>) -> Result<super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageInstalling)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_installing(&self, token: super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageInstalling)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_updating(&self, handler: &super::foundation::TypedEventHandler<PackageCatalog, PackageUpdatingEventArgs>) -> Result<super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageUpdating)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_updating(&self, token: super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageUpdating)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_uninstalling(&self, handler: &super::foundation::TypedEventHandler<PackageCatalog, PackageUninstallingEventArgs>) -> Result<super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageUninstalling)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_uninstalling(&self, token: super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageUninstalling)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_status_changed(&self, handler: &super::foundation::TypedEventHandler<PackageCatalog, PackageStatusChangedEventArgs>) -> Result<super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_status_changed(&self, token: super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PackageCatalog: IPackageCatalog}
impl RtActivatable<IPackageCatalogStatics> for PackageCatalog {}
impl PackageCatalog {
    #[inline] pub fn open_for_current_package() -> Result<ComPtr<PackageCatalog>> { unsafe {
        <Self as RtActivatable<IPackageCatalogStatics>>::get_activation_factory().open_for_current_package()
    }}
    #[inline] pub fn open_for_current_user() -> Result<ComPtr<PackageCatalog>> { unsafe {
        <Self as RtActivatable<IPackageCatalogStatics>>::get_activation_factory().open_for_current_user()
    }}
}
DEFINE_CLSID!(PackageCatalog: "Windows.ApplicationModel.PackageCatalog");
DEFINE_IID!(IID_IPackageCatalog2, 2527464502, 36855, 17220, 182, 191, 238, 100, 194, 32, 126, 210);
RT_INTERFACE!{interface IPackageCatalog2(IPackageCatalog2Vtbl): IInspectable(IInspectableVtbl) [IID_IPackageCatalog2] {
    fn add_PackageContentGroupStaging(&self, handler: *mut super::foundation::TypedEventHandler<PackageCatalog, PackageContentGroupStagingEventArgs>, out: *mut super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageContentGroupStaging(&self, token: super::foundation::EventRegistrationToken) -> HRESULT,
    fn AddOptionalPackageAsync(&self, optionalPackageFamilyName: HSTRING, out: *mut *mut super::foundation::IAsyncOperation<PackageCatalogAddOptionalPackageResult>) -> HRESULT
}}
impl IPackageCatalog2 {
    #[inline] pub unsafe fn add_package_content_group_staging(&self, handler: &super::foundation::TypedEventHandler<PackageCatalog, PackageContentGroupStagingEventArgs>) -> Result<super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageContentGroupStaging)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_content_group_staging(&self, token: super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageContentGroupStaging)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_optional_package_async(&self, optionalPackageFamilyName: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncOperation<PackageCatalogAddOptionalPackageResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AddOptionalPackageAsync)(self as *const _ as *mut _, optionalPackageFamilyName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageCatalog3, 2531089544, 34871, 17401, 144, 21, 3, 52, 52, 186, 20, 243);
RT_INTERFACE!{interface IPackageCatalog3(IPackageCatalog3Vtbl): IInspectable(IInspectableVtbl) [IID_IPackageCatalog3] {
    fn RemoveOptionalPackagesAsync(&self, optionalPackageFamilyNames: *mut super::foundation::collections::IIterable<HString>, out: *mut *mut super::foundation::IAsyncOperation<PackageCatalogRemoveOptionalPackagesResult>) -> HRESULT
}}
impl IPackageCatalog3 {
    #[inline] pub unsafe fn remove_optional_packages_async(&self, optionalPackageFamilyNames: &super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::foundation::IAsyncOperation<PackageCatalogRemoveOptionalPackagesResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RemoveOptionalPackagesAsync)(self as *const _ as *mut _, optionalPackageFamilyNames as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageCatalogAddOptionalPackageResult, 1005653204, 46303, 18355, 169, 99, 226, 250, 131, 47, 125, 211);
RT_INTERFACE!{interface IPackageCatalogAddOptionalPackageResult(IPackageCatalogAddOptionalPackageResultVtbl): IInspectable(IInspectableVtbl) [IID_IPackageCatalogAddOptionalPackageResult] {
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut super::foundation::HResult) -> HRESULT
}}
impl IPackageCatalogAddOptionalPackageResult {
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extended_error(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendedError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageCatalogAddOptionalPackageResult: IPackageCatalogAddOptionalPackageResult}
DEFINE_IID!(IID_IPackageCatalogRemoveOptionalPackagesResult, 701692283, 55668, 20068, 147, 89, 34, 202, 223, 215, 152, 40);
RT_INTERFACE!{interface IPackageCatalogRemoveOptionalPackagesResult(IPackageCatalogRemoveOptionalPackagesResultVtbl): IInspectable(IInspectableVtbl) [IID_IPackageCatalogRemoveOptionalPackagesResult] {
    fn get_PackagesRemoved(&self, out: *mut *mut super::foundation::collections::IVectorView<Package>) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut super::foundation::HResult) -> HRESULT
}}
impl IPackageCatalogRemoveOptionalPackagesResult {
    #[inline] pub unsafe fn get_packages_removed(&self) -> Result<ComPtr<super::foundation::collections::IVectorView<Package>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackagesRemoved)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extended_error(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendedError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageCatalogRemoveOptionalPackagesResult: IPackageCatalogRemoveOptionalPackagesResult}
DEFINE_IID!(IID_IPackageCatalogStatics, 2710345366, 58971, 17972, 186, 33, 94, 99, 235, 114, 68, 167);
RT_INTERFACE!{static interface IPackageCatalogStatics(IPackageCatalogStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageCatalogStatics] {
    fn OpenForCurrentPackage(&self, out: *mut *mut PackageCatalog) -> HRESULT,
    fn OpenForCurrentUser(&self, out: *mut *mut PackageCatalog) -> HRESULT
}}
impl IPackageCatalogStatics {
    #[inline] pub unsafe fn open_for_current_package(&self) -> Result<ComPtr<PackageCatalog>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OpenForCurrentPackage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn open_for_current_user(&self) -> Result<ComPtr<PackageCatalog>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OpenForCurrentUser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageContentGroup, 2405591389, 4618, 18328, 181, 225, 88, 0, 221, 168, 242, 225);
RT_INTERFACE!{interface IPackageContentGroup(IPackageContentGroupVtbl): IInspectable(IInspectableVtbl) [IID_IPackageContentGroup] {
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_State(&self, out: *mut PackageContentGroupState) -> HRESULT,
    fn get_IsRequired(&self, out: *mut bool) -> HRESULT
}}
impl IPackageContentGroup {
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_state(&self) -> Result<PackageContentGroupState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_required(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRequired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageContentGroup: IPackageContentGroup}
impl RtActivatable<IPackageContentGroupStatics> for PackageContentGroup {}
impl PackageContentGroup {
    #[inline] pub fn get_required_group_name() -> Result<HString> { unsafe {
        <Self as RtActivatable<IPackageContentGroupStatics>>::get_activation_factory().get_required_group_name()
    }}
}
DEFINE_CLSID!(PackageContentGroup: "Windows.ApplicationModel.PackageContentGroup");
DEFINE_IID!(IID_IPackageContentGroupStagingEventArgs, 1031520894, 28455, 17516, 152, 110, 212, 115, 61, 77, 145, 19);
RT_INTERFACE!{interface IPackageContentGroupStagingEventArgs(IPackageContentGroupStagingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageContentGroupStagingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut super::foundation::HResult) -> HRESULT,
    fn get_ContentGroupName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsContentGroupRequired(&self, out: *mut bool) -> HRESULT
}}
impl IPackageContentGroupStagingEventArgs {
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_complete(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComplete)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_error_code(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_group_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentGroupName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_content_group_required(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContentGroupRequired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageContentGroupStagingEventArgs: IPackageContentGroupStagingEventArgs}
RT_ENUM! { enum PackageContentGroupState: i32 {
    NotStaged (PackageContentGroupState_NotStaged) = 0, Queued (PackageContentGroupState_Queued) = 1, Staging (PackageContentGroupState_Staging) = 2, Staged (PackageContentGroupState_Staged) = 3,
}}
DEFINE_IID!(IID_IPackageContentGroupStatics, 1894675993, 24338, 19346, 185, 234, 108, 202, 218, 19, 188, 117);
RT_INTERFACE!{static interface IPackageContentGroupStatics(IPackageContentGroupStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageContentGroupStatics] {
    fn get_RequiredGroupName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPackageContentGroupStatics {
    #[inline] pub unsafe fn get_required_group_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RequiredGroupName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageId, 450586206, 14279, 18320, 153, 128, 221, 122, 231, 78, 139, 178);
RT_INTERFACE!{interface IPackageId(IPackageIdVtbl): IInspectable(IInspectableVtbl) [IID_IPackageId] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Version(&self, out: *mut PackageVersion) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-system")] fn get_Architecture(&self, out: *mut super::system::ProcessorArchitecture) -> HRESULT,
    fn get_ResourceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Publisher(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PublisherId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPackageId {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_version(&self) -> Result<PackageVersion> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Version)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_architecture(&self) -> Result<super::system::ProcessorArchitecture> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Architecture)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_resource_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ResourceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_publisher(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Publisher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_publisher_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PublisherId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FullName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PackageId: IPackageId}
DEFINE_IID!(IID_IPackageIdWithMetadata, 1079474812, 3230, 17469, 144, 116, 133, 95, 92, 224, 160, 141);
RT_INTERFACE!{interface IPackageIdWithMetadata(IPackageIdWithMetadataVtbl): IInspectable(IInspectableVtbl) [IID_IPackageIdWithMetadata] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Author(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPackageIdWithMetadata {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_author(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Author)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageInstallingEventArgs, 2540969655, 43898, 16410, 139, 97, 235, 14, 127, 175, 242, 55);
RT_INTERFACE!{interface IPackageInstallingEventArgs(IPackageInstallingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageInstallingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut super::foundation::HResult) -> HRESULT
}}
impl IPackageInstallingEventArgs {
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_complete(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComplete)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_error_code(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageInstallingEventArgs: IPackageInstallingEventArgs}
RT_ENUM! { enum PackageSignatureKind: i32 {
    None (PackageSignatureKind_None) = 0, Developer (PackageSignatureKind_Developer) = 1, Enterprise (PackageSignatureKind_Enterprise) = 2, Store (PackageSignatureKind_Store) = 3, System (PackageSignatureKind_System) = 4,
}}
DEFINE_IID!(IID_IPackageStagingEventArgs, 272721965, 21730, 20305, 184, 40, 158, 247, 4, 108, 33, 15);
RT_INTERFACE!{interface IPackageStagingEventArgs(IPackageStagingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageStagingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut super::foundation::HResult) -> HRESULT
}}
impl IPackageStagingEventArgs {
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_complete(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComplete)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_error_code(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageStagingEventArgs: IPackageStagingEventArgs}
DEFINE_IID!(IID_IPackageStatics, 1314081759, 10592, 18552, 151, 164, 150, 36, 222, 183, 47, 45);
RT_INTERFACE!{static interface IPackageStatics(IPackageStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageStatics] {
    fn get_Current(&self, out: *mut *mut Package) -> HRESULT
}}
impl IPackageStatics {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageStatus, 1608994673, 41829, 19465, 160, 45, 4, 109, 82, 94, 161, 218);
RT_INTERFACE!{interface IPackageStatus(IPackageStatusVtbl): IInspectable(IInspectableVtbl) [IID_IPackageStatus] {
    fn VerifyIsOK(&self, out: *mut bool) -> HRESULT,
    fn get_NotAvailable(&self, out: *mut bool) -> HRESULT,
    fn get_PackageOffline(&self, out: *mut bool) -> HRESULT,
    fn get_DataOffline(&self, out: *mut bool) -> HRESULT,
    fn get_Disabled(&self, out: *mut bool) -> HRESULT,
    fn get_NeedsRemediation(&self, out: *mut bool) -> HRESULT,
    fn get_LicenseIssue(&self, out: *mut bool) -> HRESULT,
    fn get_Modified(&self, out: *mut bool) -> HRESULT,
    fn get_Tampered(&self, out: *mut bool) -> HRESULT,
    fn get_DependencyIssue(&self, out: *mut bool) -> HRESULT,
    fn get_Servicing(&self, out: *mut bool) -> HRESULT,
    fn get_DeploymentInProgress(&self, out: *mut bool) -> HRESULT
}}
impl IPackageStatus {
    #[inline] pub unsafe fn verify_is_ok(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).VerifyIsOK)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_not_available(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NotAvailable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package_offline(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PackageOffline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_offline(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DataOffline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_disabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Disabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_needs_remediation(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NeedsRemediation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_license_issue(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LicenseIssue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_modified(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Modified)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tampered(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Tampered)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dependency_issue(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DependencyIssue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_servicing(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Servicing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deployment_in_progress(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DeploymentInProgress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageStatus: IPackageStatus}
DEFINE_IID!(IID_IPackageStatus2, 4096326291, 31830, 18530, 172, 250, 171, 174, 220, 192, 105, 77);
RT_INTERFACE!{interface IPackageStatus2(IPackageStatus2Vtbl): IInspectable(IInspectableVtbl) [IID_IPackageStatus2] {
    fn get_IsPartiallyStaged(&self, out: *mut bool) -> HRESULT
}}
impl IPackageStatus2 {
    #[inline] pub unsafe fn get_is_partially_staged(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPartiallyStaged)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPackageStatusChangedEventArgs, 1132294477, 48512, 19056, 188, 80, 246, 231, 150, 80, 149, 117);
RT_INTERFACE!{interface IPackageStatusChangedEventArgs(IPackageStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageStatusChangedEventArgs] {
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT
}}
impl IPackageStatusChangedEventArgs {
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PackageStatusChangedEventArgs: IPackageStatusChangedEventArgs}
DEFINE_IID!(IID_IPackageUninstallingEventArgs, 1145285202, 43810, 17613, 130, 187, 78, 201, 184, 39, 54, 122);
RT_INTERFACE!{interface IPackageUninstallingEventArgs(IPackageUninstallingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageUninstallingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_Package(&self, out: *mut *mut Package) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut super::foundation::HResult) -> HRESULT
}}
impl IPackageUninstallingEventArgs {
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_complete(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComplete)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_error_code(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageUninstallingEventArgs: IPackageUninstallingEventArgs}
DEFINE_IID!(IID_IPackageUpdatingEventArgs, 3447407144, 64884, 17470, 177, 20, 35, 230, 119, 176, 232, 111);
RT_INTERFACE!{interface IPackageUpdatingEventArgs(IPackageUpdatingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPackageUpdatingEventArgs] {
    fn get_ActivityId(&self, out: *mut Guid) -> HRESULT,
    fn get_SourcePackage(&self, out: *mut *mut Package) -> HRESULT,
    fn get_TargetPackage(&self, out: *mut *mut Package) -> HRESULT,
    fn get_Progress(&self, out: *mut f64) -> HRESULT,
    fn get_IsComplete(&self, out: *mut bool) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut super::foundation::HResult) -> HRESULT
}}
impl IPackageUpdatingEventArgs {
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePackage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_package(&self) -> Result<ComPtr<Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetPackage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_complete(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComplete)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_error_code(&self) -> Result<super::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PackageUpdatingEventArgs: IPackageUpdatingEventArgs}
RT_STRUCT! { struct PackageVersion {
    Major: u16, Minor: u16, Build: u16, Revision: u16,
}}
DEFINE_IID!(IID_IPackageWithMetadata, 2509543296, 7657, 16626, 180, 82, 13, 233, 241, 145, 0, 18);
RT_INTERFACE!{interface IPackageWithMetadata(IPackageWithMetadataVtbl): IInspectable(IInspectableVtbl) [IID_IPackageWithMetadata] {
    fn get_InstallDate(&self, out: *mut super::foundation::DateTime) -> HRESULT,
    fn GetThumbnailToken(&self, out: *mut HSTRING) -> HRESULT,
    fn Launch(&self, parameters: HSTRING) -> HRESULT
}}
impl IPackageWithMetadata {
    #[inline] pub unsafe fn get_install_date(&self) -> Result<super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstallDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumbnail_token(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetThumbnailToken)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch(&self, parameters: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).Launch)(self as *const _ as *mut _, parameters.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStartupTask, 4150010824, 46578, 20332, 136, 221, 54, 203, 29, 89, 157, 23);
RT_INTERFACE!{interface IStartupTask(IStartupTaskVtbl): IInspectable(IInspectableVtbl) [IID_IStartupTask] {
    fn RequestEnableAsync(&self, out: *mut *mut super::foundation::IAsyncOperation<StartupTaskState>) -> HRESULT,
    fn Disable(&self) -> HRESULT,
    fn get_State(&self, out: *mut StartupTaskState) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStartupTask {
    #[inline] pub unsafe fn request_enable_async(&self) -> Result<ComPtr<super::foundation::IAsyncOperation<StartupTaskState>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestEnableAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn disable(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Disable)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_state(&self) -> Result<StartupTaskState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StartupTask: IStartupTask}
impl RtActivatable<IStartupTaskStatics> for StartupTask {}
impl StartupTask {
    #[inline] pub fn get_for_current_package_async() -> Result<ComPtr<super::foundation::IAsyncOperation<super::foundation::collections::IVectorView<StartupTask>>>> { unsafe {
        <Self as RtActivatable<IStartupTaskStatics>>::get_activation_factory().get_for_current_package_async()
    }}
    #[inline] pub fn get_async(taskId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncOperation<StartupTask>>> { unsafe {
        <Self as RtActivatable<IStartupTaskStatics>>::get_activation_factory().get_async(taskId)
    }}
}
DEFINE_CLSID!(StartupTask: "Windows.ApplicationModel.StartupTask");
RT_ENUM! { enum StartupTaskState: i32 {
    Disabled (StartupTaskState_Disabled) = 0, DisabledByUser (StartupTaskState_DisabledByUser) = 1, Enabled (StartupTaskState_Enabled) = 2, DisabledByPolicy (StartupTaskState_DisabledByPolicy) = 3,
}}
DEFINE_IID!(IID_IStartupTaskStatics, 3998965949, 41288, 16807, 178, 110, 232, 184, 138, 30, 98, 248);
RT_INTERFACE!{static interface IStartupTaskStatics(IStartupTaskStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStartupTaskStatics] {
    fn GetForCurrentPackageAsync(&self, out: *mut *mut super::foundation::IAsyncOperation<super::foundation::collections::IVectorView<StartupTask>>) -> HRESULT,
    fn GetAsync(&self, taskId: HSTRING, out: *mut *mut super::foundation::IAsyncOperation<StartupTask>) -> HRESULT
}}
impl IStartupTaskStatics {
    #[inline] pub unsafe fn get_for_current_package_async(&self) -> Result<ComPtr<super::foundation::IAsyncOperation<super::foundation::collections::IVectorView<StartupTask>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentPackageAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_async(&self, taskId: &HStringArg) -> Result<ComPtr<super::foundation::IAsyncOperation<StartupTask>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAsync)(self as *const _ as *mut _, taskId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISuspendingDeferral, 1494484233, 35785, 20148, 182, 54, 218, 189, 196, 244, 111, 102);
RT_INTERFACE!{interface ISuspendingDeferral(ISuspendingDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ISuspendingDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISuspendingDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SuspendingDeferral: ISuspendingDeferral}
DEFINE_IID!(IID_ISuspendingEventArgs, 2516982789, 11706, 19720, 176, 189, 43, 48, 161, 49, 198, 170);
RT_INTERFACE!{interface ISuspendingEventArgs(ISuspendingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISuspendingEventArgs] {
    fn get_SuspendingOperation(&self, out: *mut *mut SuspendingOperation) -> HRESULT
}}
impl ISuspendingEventArgs {
    #[inline] pub unsafe fn get_suspending_operation(&self) -> Result<ComPtr<SuspendingOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SuspendingOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SuspendingEventArgs: ISuspendingEventArgs}
DEFINE_IID!(IID_ISuspendingOperation, 2644822593, 8417, 20123, 159, 101, 169, 244, 53, 52, 12, 58);
RT_INTERFACE!{interface ISuspendingOperation(ISuspendingOperationVtbl): IInspectable(IInspectableVtbl) [IID_ISuspendingOperation] {
    fn GetDeferral(&self, out: *mut *mut SuspendingDeferral) -> HRESULT,
    fn get_Deadline(&self, out: *mut super::foundation::DateTime) -> HRESULT
}}
impl ISuspendingOperation {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<SuspendingDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deadline(&self) -> Result<super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Deadline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SuspendingOperation: ISuspendingOperation}
pub mod calls { // Windows.ApplicationModel.Calls
use ::prelude::*;
DEFINE_IID!(IID_ICallAnswerEventArgs, 4252538391, 11735, 19596, 178, 189, 149, 209, 122, 91, 183, 51);
RT_INTERFACE!{interface ICallAnswerEventArgs(ICallAnswerEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICallAnswerEventArgs] {
    fn get_AcceptedMedia(&self, out: *mut VoipPhoneCallMedia) -> HRESULT
}}
impl ICallAnswerEventArgs {
    #[inline] pub unsafe fn get_accepted_media(&self) -> Result<VoipPhoneCallMedia> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AcceptedMedia)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CallAnswerEventArgs: ICallAnswerEventArgs}
DEFINE_IID!(IID_ICallRejectEventArgs, 3662150359, 5076, 19858, 161, 194, 183, 120, 17, 238, 55, 236);
RT_INTERFACE!{interface ICallRejectEventArgs(ICallRejectEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICallRejectEventArgs] {
    fn get_RejectReason(&self, out: *mut VoipPhoneCallRejectReason) -> HRESULT
}}
impl ICallRejectEventArgs {
    #[inline] pub unsafe fn get_reject_reason(&self) -> Result<VoipPhoneCallRejectReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RejectReason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CallRejectEventArgs: ICallRejectEventArgs}
DEFINE_IID!(IID_ICallStateChangeEventArgs, 3937547422, 26357, 18425, 159, 181, 69, 156, 81, 152, 199, 32);
RT_INTERFACE!{interface ICallStateChangeEventArgs(ICallStateChangeEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICallStateChangeEventArgs] {
    fn get_State(&self, out: *mut VoipPhoneCallState) -> HRESULT
}}
impl ICallStateChangeEventArgs {
    #[inline] pub unsafe fn get_state(&self) -> Result<VoipPhoneCallState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CallStateChangeEventArgs: ICallStateChangeEventArgs}
DEFINE_IID!(IID_ILockScreenCallEndCallDeferral, 769125645, 39149, 16449, 150, 50, 80, 255, 129, 43, 119, 63);
RT_INTERFACE!{interface ILockScreenCallEndCallDeferral(ILockScreenCallEndCallDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenCallEndCallDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ILockScreenCallEndCallDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenCallEndCallDeferral: ILockScreenCallEndCallDeferral}
DEFINE_IID!(IID_ILockScreenCallEndRequestedEventArgs, 2173739875, 28455, 18153, 174, 182, 192, 174, 131, 228, 125, 199);
RT_INTERFACE!{interface ILockScreenCallEndRequestedEventArgs(ILockScreenCallEndRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenCallEndRequestedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut LockScreenCallEndCallDeferral) -> HRESULT,
    fn get_Deadline(&self, out: *mut super::super::foundation::DateTime) -> HRESULT
}}
impl ILockScreenCallEndRequestedEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<LockScreenCallEndCallDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deadline(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Deadline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenCallEndRequestedEventArgs: ILockScreenCallEndRequestedEventArgs}
DEFINE_IID!(IID_ILockScreenCallUI, 3315006861, 29641, 18964, 176, 33, 236, 28, 80, 163, 183, 39);
RT_INTERFACE!{interface ILockScreenCallUI(ILockScreenCallUIVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenCallUI] {
    fn Dismiss(&self) -> HRESULT,
    fn add_EndRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<LockScreenCallUI, LockScreenCallEndRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EndRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closed(&self, handler: *mut super::super::foundation::TypedEventHandler<LockScreenCallUI, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closed(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_CallTitle(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CallTitle(&self, value: HSTRING) -> HRESULT
}}
impl ILockScreenCallUI {
    #[inline] pub unsafe fn dismiss(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Dismiss)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_end_requested(&self, handler: &super::super::foundation::TypedEventHandler<LockScreenCallUI, LockScreenCallEndRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EndRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_end_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_EndRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closed(&self, handler: &super::super::foundation::TypedEventHandler<LockScreenCallUI, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_call_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallTitle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_call_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CallTitle)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenCallUI: ILockScreenCallUI}
DEFINE_IID!(IID_IMuteChangeEventArgs, 2240143705, 3137, 17196, 129, 77, 197, 241, 253, 245, 48, 190);
RT_INTERFACE!{interface IMuteChangeEventArgs(IMuteChangeEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IMuteChangeEventArgs] {
    fn get_Muted(&self, out: *mut bool) -> HRESULT
}}
impl IMuteChangeEventArgs {
    #[inline] pub unsafe fn get_muted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Muted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class MuteChangeEventArgs: IMuteChangeEventArgs}
DEFINE_IID!(IID_IPhoneCallHistoryEntry, 4205895977, 12964, 19333, 131, 209, 249, 13, 140, 35, 168, 87);
RT_INTERFACE!{interface IPhoneCallHistoryEntry(IPhoneCallHistoryEntryVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryEntry] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut *mut PhoneCallHistoryEntryAddress) -> HRESULT,
    fn put_Address(&self, value: *mut PhoneCallHistoryEntryAddress) -> HRESULT,
    fn get_Duration(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> HRESULT,
    fn put_Duration(&self, value: *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> HRESULT,
    fn get_IsCallerIdBlocked(&self, out: *mut bool) -> HRESULT,
    fn put_IsCallerIdBlocked(&self, value: bool) -> HRESULT,
    fn get_IsEmergency(&self, out: *mut bool) -> HRESULT,
    fn put_IsEmergency(&self, value: bool) -> HRESULT,
    fn get_IsIncoming(&self, out: *mut bool) -> HRESULT,
    fn put_IsIncoming(&self, value: bool) -> HRESULT,
    fn get_IsMissed(&self, out: *mut bool) -> HRESULT,
    fn put_IsMissed(&self, value: bool) -> HRESULT,
    fn get_IsRinging(&self, out: *mut bool) -> HRESULT,
    fn put_IsRinging(&self, value: bool) -> HRESULT,
    fn get_IsSeen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeen(&self, value: bool) -> HRESULT,
    fn get_IsSuppressed(&self, out: *mut bool) -> HRESULT,
    fn put_IsSuppressed(&self, value: bool) -> HRESULT,
    fn get_IsVoicemail(&self, out: *mut bool) -> HRESULT,
    fn put_IsVoicemail(&self, value: bool) -> HRESULT,
    fn get_Media(&self, out: *mut PhoneCallHistoryEntryMedia) -> HRESULT,
    fn put_Media(&self, value: PhoneCallHistoryEntryMedia) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut PhoneCallHistoryEntryOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: PhoneCallHistoryEntryOtherAppReadAccess) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SourceId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SourceId(&self, value: HSTRING) -> HRESULT,
    fn get_SourceIdKind(&self, out: *mut PhoneCallHistorySourceIdKind) -> HRESULT,
    fn put_SourceIdKind(&self, value: PhoneCallHistorySourceIdKind) -> HRESULT,
    fn get_StartTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: super::super::foundation::DateTime) -> HRESULT
}}
impl IPhoneCallHistoryEntry {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_address(&self) -> Result<ComPtr<PhoneCallHistoryEntryAddress>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Address)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_address(&self, value: &PhoneCallHistoryEntryAddress) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Address)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::TimeSpan>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_duration(&self, value: &super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Duration)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_caller_id_blocked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCallerIdBlocked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_caller_id_blocked(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCallerIdBlocked)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_emergency(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEmergency)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_emergency(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsEmergency)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_incoming(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIncoming)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_incoming(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsIncoming)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_missed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMissed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_missed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsMissed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_ringing(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRinging)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_ringing(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRinging)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seen(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSeen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_seen(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSeen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_suppressed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSuppressed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_suppressed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSuppressed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_voicemail(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVoicemail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_voicemail(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsVoicemail)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_media(&self) -> Result<PhoneCallHistoryEntryMedia> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Media)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_media(&self, value: PhoneCallHistoryEntryMedia) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Media)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_read_access(&self) -> Result<PhoneCallHistoryEntryOtherAppReadAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppReadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_read_access(&self, value: PhoneCallHistoryEntryOtherAppReadAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppReadAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SourceId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_id_kind(&self) -> Result<PhoneCallHistorySourceIdKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SourceIdKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_source_id_kind(&self, value: PhoneCallHistorySourceIdKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SourceIdKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallHistoryEntry: IPhoneCallHistoryEntry}
impl RtActivatable<IActivationFactory> for PhoneCallHistoryEntry {}
DEFINE_CLSID!(PhoneCallHistoryEntry: "Windows.ApplicationModel.Calls.PhoneCallHistoryEntry");
DEFINE_IID!(IID_IPhoneCallHistoryEntryAddress, 821123546, 14677, 16450, 132, 230, 102, 238, 191, 130, 230, 127);
RT_INTERFACE!{interface IPhoneCallHistoryEntryAddress(IPhoneCallHistoryEntryAddressVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryEntryAddress] {
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactId(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_RawAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RawAddress(&self, value: HSTRING) -> HRESULT,
    fn get_RawAddressKind(&self, out: *mut PhoneCallHistoryEntryRawAddressKind) -> HRESULT,
    fn put_RawAddressKind(&self, value: PhoneCallHistoryEntryRawAddressKind) -> HRESULT
}}
impl IPhoneCallHistoryEntryAddress {
    #[inline] pub unsafe fn get_contact_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contact_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContactId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_raw_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RawAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_raw_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RawAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_raw_address_kind(&self) -> Result<PhoneCallHistoryEntryRawAddressKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RawAddressKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_raw_address_kind(&self, value: PhoneCallHistoryEntryRawAddressKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RawAddressKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallHistoryEntryAddress: IPhoneCallHistoryEntryAddress}
impl RtActivatable<IPhoneCallHistoryEntryAddressFactory> for PhoneCallHistoryEntryAddress {}
impl RtActivatable<IActivationFactory> for PhoneCallHistoryEntryAddress {}
impl PhoneCallHistoryEntryAddress {
    #[inline] pub fn create(rawAddress: &HStringArg, rawAddressKind: PhoneCallHistoryEntryRawAddressKind) -> Result<ComPtr<PhoneCallHistoryEntryAddress>> { unsafe {
        <Self as RtActivatable<IPhoneCallHistoryEntryAddressFactory>>::get_activation_factory().create(rawAddress, rawAddressKind)
    }}
}
DEFINE_CLSID!(PhoneCallHistoryEntryAddress: "Windows.ApplicationModel.Calls.PhoneCallHistoryEntryAddress");
DEFINE_IID!(IID_IPhoneCallHistoryEntryAddressFactory, 4212108730, 51184, 19382, 159, 107, 186, 93, 115, 32, 154, 202);
RT_INTERFACE!{static interface IPhoneCallHistoryEntryAddressFactory(IPhoneCallHistoryEntryAddressFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryEntryAddressFactory] {
    fn Create(&self, rawAddress: HSTRING, rawAddressKind: PhoneCallHistoryEntryRawAddressKind, out: *mut *mut PhoneCallHistoryEntryAddress) -> HRESULT
}}
impl IPhoneCallHistoryEntryAddressFactory {
    #[inline] pub unsafe fn create(&self, rawAddress: &HStringArg, rawAddressKind: PhoneCallHistoryEntryRawAddressKind) -> Result<ComPtr<PhoneCallHistoryEntryAddress>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, rawAddress.get(), rawAddressKind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PhoneCallHistoryEntryMedia: i32 {
    Audio (PhoneCallHistoryEntryMedia_Audio) = 0, Video (PhoneCallHistoryEntryMedia_Video) = 1,
}}
RT_ENUM! { enum PhoneCallHistoryEntryOtherAppReadAccess: i32 {
    Full (PhoneCallHistoryEntryOtherAppReadAccess_Full) = 0, SystemOnly (PhoneCallHistoryEntryOtherAppReadAccess_SystemOnly) = 1,
}}
RT_ENUM! { enum PhoneCallHistoryEntryQueryDesiredMedia: u32 {
    None (PhoneCallHistoryEntryQueryDesiredMedia_None) = 0, Audio (PhoneCallHistoryEntryQueryDesiredMedia_Audio) = 1, Video (PhoneCallHistoryEntryQueryDesiredMedia_Video) = 2, All (PhoneCallHistoryEntryQueryDesiredMedia_All) = 4294967295,
}}
DEFINE_IID!(IID_IPhoneCallHistoryEntryQueryOptions, 2623529308, 35821, 16586, 176, 110, 196, 202, 142, 174, 92, 135);
RT_INTERFACE!{interface IPhoneCallHistoryEntryQueryOptions(IPhoneCallHistoryEntryQueryOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryEntryQueryOptions] {
    fn get_DesiredMedia(&self, out: *mut PhoneCallHistoryEntryQueryDesiredMedia) -> HRESULT,
    fn put_DesiredMedia(&self, value: PhoneCallHistoryEntryQueryDesiredMedia) -> HRESULT,
    fn get_SourceIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IPhoneCallHistoryEntryQueryOptions {
    #[inline] pub unsafe fn get_desired_media(&self) -> Result<PhoneCallHistoryEntryQueryDesiredMedia> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredMedia)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_media(&self, value: PhoneCallHistoryEntryQueryDesiredMedia) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredMedia)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallHistoryEntryQueryOptions: IPhoneCallHistoryEntryQueryOptions}
impl RtActivatable<IActivationFactory> for PhoneCallHistoryEntryQueryOptions {}
DEFINE_CLSID!(PhoneCallHistoryEntryQueryOptions: "Windows.ApplicationModel.Calls.PhoneCallHistoryEntryQueryOptions");
RT_ENUM! { enum PhoneCallHistoryEntryRawAddressKind: i32 {
    PhoneNumber (PhoneCallHistoryEntryRawAddressKind_PhoneNumber) = 0, Custom (PhoneCallHistoryEntryRawAddressKind_Custom) = 1,
}}
DEFINE_IID!(IID_IPhoneCallHistoryEntryReader, 1642915006, 36230, 18335, 132, 4, 169, 132, 105, 32, 254, 230);
RT_INTERFACE!{interface IPhoneCallHistoryEntryReader(IPhoneCallHistoryEntryReaderVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryEntryReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PhoneCallHistoryEntry>>) -> HRESULT
}}
impl IPhoneCallHistoryEntryReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<PhoneCallHistoryEntry>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallHistoryEntryReader: IPhoneCallHistoryEntryReader}
RT_CLASS!{static class PhoneCallHistoryManager}
impl RtActivatable<IPhoneCallHistoryManagerStatics> for PhoneCallHistoryManager {}
impl RtActivatable<IPhoneCallHistoryManagerStatics2> for PhoneCallHistoryManager {}
impl PhoneCallHistoryManager {
    #[inline] pub fn request_store_async(accessType: PhoneCallHistoryStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PhoneCallHistoryStore>>> { unsafe {
        <Self as RtActivatable<IPhoneCallHistoryManagerStatics>>::get_activation_factory().request_store_async(accessType)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<PhoneCallHistoryManagerForUser>> { unsafe {
        <Self as RtActivatable<IPhoneCallHistoryManagerStatics2>>::get_activation_factory().get_for_user(user)
    }}
}
DEFINE_CLSID!(PhoneCallHistoryManager: "Windows.ApplicationModel.Calls.PhoneCallHistoryManager");
DEFINE_IID!(IID_IPhoneCallHistoryManagerForUser, 3643131171, 62815, 17235, 157, 180, 2, 5, 165, 38, 90, 85);
RT_INTERFACE!{interface IPhoneCallHistoryManagerForUser(IPhoneCallHistoryManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryManagerForUser] {
    fn RequestStoreAsync(&self, accessType: PhoneCallHistoryStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<PhoneCallHistoryStore>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IPhoneCallHistoryManagerForUser {
    #[inline] pub unsafe fn request_store_async(&self, accessType: PhoneCallHistoryStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PhoneCallHistoryStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallHistoryManagerForUser: IPhoneCallHistoryManagerForUser}
DEFINE_IID!(IID_IPhoneCallHistoryManagerStatics, 4121352761, 45855, 20293, 172, 142, 27, 8, 137, 60, 27, 80);
RT_INTERFACE!{static interface IPhoneCallHistoryManagerStatics(IPhoneCallHistoryManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryManagerStatics] {
    fn RequestStoreAsync(&self, accessType: PhoneCallHistoryStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<PhoneCallHistoryStore>) -> HRESULT
}}
impl IPhoneCallHistoryManagerStatics {
    #[inline] pub unsafe fn request_store_async(&self, accessType: PhoneCallHistoryStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PhoneCallHistoryStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPhoneCallHistoryManagerStatics2, 4023678192, 41691, 16776, 158, 146, 188, 60, 250, 104, 19, 207);
RT_INTERFACE!{static interface IPhoneCallHistoryManagerStatics2(IPhoneCallHistoryManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryManagerStatics2] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut PhoneCallHistoryManagerForUser) -> HRESULT
}}
impl IPhoneCallHistoryManagerStatics2 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<PhoneCallHistoryManagerForUser>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PhoneCallHistorySourceIdKind: i32 {
    CellularPhoneLineId (PhoneCallHistorySourceIdKind_CellularPhoneLineId) = 0, PackageFamilyName (PhoneCallHistorySourceIdKind_PackageFamilyName) = 1,
}}
DEFINE_IID!(IID_IPhoneCallHistoryStore, 797998520, 46094, 16939, 133, 69, 203, 25, 16, 166, 28, 82);
RT_INTERFACE!{interface IPhoneCallHistoryStore(IPhoneCallHistoryStoreVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallHistoryStore] {
    fn GetEntryAsync(&self, callHistoryEntryId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PhoneCallHistoryEntry>) -> HRESULT,
    fn GetEntryReader(&self, out: *mut *mut PhoneCallHistoryEntryReader) -> HRESULT,
    fn GetEntryReaderWithOptions(&self, queryOptions: *mut PhoneCallHistoryEntryQueryOptions, out: *mut *mut PhoneCallHistoryEntryReader) -> HRESULT,
    fn SaveEntryAsync(&self, callHistoryEntry: *mut PhoneCallHistoryEntry, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteEntryAsync(&self, callHistoryEntry: *mut PhoneCallHistoryEntry, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteEntriesAsync(&self, callHistoryEntries: *mut super::super::foundation::collections::IIterable<PhoneCallHistoryEntry>, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkEntryAsSeenAsync(&self, callHistoryEntry: *mut PhoneCallHistoryEntry, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkEntriesAsSeenAsync(&self, callHistoryEntries: *mut super::super::foundation::collections::IIterable<PhoneCallHistoryEntry>, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetUnseenCountAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> HRESULT,
    fn MarkAllAsSeenAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetSourcesUnseenCountAsync(&self, sourceIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<u32>) -> HRESULT,
    fn MarkSourcesAsSeenAsync(&self, sourceIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IPhoneCallHistoryStore {
    #[inline] pub unsafe fn get_entry_async(&self, callHistoryEntryId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PhoneCallHistoryEntry>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEntryAsync)(self as *const _ as *mut _, callHistoryEntryId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_entry_reader(&self) -> Result<ComPtr<PhoneCallHistoryEntryReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEntryReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_entry_reader_with_options(&self, queryOptions: &PhoneCallHistoryEntryQueryOptions) -> Result<ComPtr<PhoneCallHistoryEntryReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEntryReaderWithOptions)(self as *const _ as *mut _, queryOptions as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_entry_async(&self, callHistoryEntry: &PhoneCallHistoryEntry) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveEntryAsync)(self as *const _ as *mut _, callHistoryEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_entry_async(&self, callHistoryEntry: &PhoneCallHistoryEntry) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteEntryAsync)(self as *const _ as *mut _, callHistoryEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_entries_async(&self, callHistoryEntries: &super::super::foundation::collections::IIterable<PhoneCallHistoryEntry>) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteEntriesAsync)(self as *const _ as *mut _, callHistoryEntries as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_entry_as_seen_async(&self, callHistoryEntry: &PhoneCallHistoryEntry) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkEntryAsSeenAsync)(self as *const _ as *mut _, callHistoryEntry as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_entries_as_seen_async(&self, callHistoryEntries: &super::super::foundation::collections::IIterable<PhoneCallHistoryEntry>) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkEntriesAsSeenAsync)(self as *const _ as *mut _, callHistoryEntries as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unseen_count_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUnseenCountAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_all_as_seen_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkAllAsSeenAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sources_unseen_count_async(&self, sourceIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSourcesUnseenCountAsync)(self as *const _ as *mut _, sourceIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_sources_as_seen_async(&self, sourceIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkSourcesAsSeenAsync)(self as *const _ as *mut _, sourceIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallHistoryStore: IPhoneCallHistoryStore}
RT_ENUM! { enum PhoneCallHistoryStoreAccessType: i32 {
    AppEntriesReadWrite (PhoneCallHistoryStoreAccessType_AppEntriesReadWrite) = 0, AllEntriesLimitedReadWrite (PhoneCallHistoryStoreAccessType_AllEntriesLimitedReadWrite) = 1, AllEntriesReadWrite (PhoneCallHistoryStoreAccessType_AllEntriesReadWrite) = 2,
}}
DEFINE_IID!(IID_IVoipCallCoordinator, 1326549967, 59631, 17460, 156, 95, 168, 216, 147, 250, 254, 121);
RT_INTERFACE!{interface IVoipCallCoordinator(IVoipCallCoordinatorVtbl): IInspectable(IInspectableVtbl) [IID_IVoipCallCoordinator] {
    fn ReserveCallResourcesAsync(&self, taskEntryPoint: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<VoipPhoneCallResourceReservationStatus>) -> HRESULT,
    fn add_MuteStateChanged(&self, muteChangeHandler: *mut super::super::foundation::TypedEventHandler<VoipCallCoordinator, MuteChangeEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MuteStateChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn RequestNewIncomingCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, contactImage: *mut super::super::foundation::Uri, serviceName: HSTRING, brandingImage: *mut super::super::foundation::Uri, callDetails: HSTRING, ringtone: *mut super::super::foundation::Uri, media: VoipPhoneCallMedia, ringTimeout: super::super::foundation::TimeSpan, out: *mut *mut VoipPhoneCall) -> HRESULT,
    fn RequestNewOutgoingCall(&self, context: HSTRING, contactName: HSTRING, serviceName: HSTRING, media: VoipPhoneCallMedia, out: *mut *mut VoipPhoneCall) -> HRESULT,
    fn NotifyMuted(&self) -> HRESULT,
    fn NotifyUnmuted(&self) -> HRESULT,
    fn RequestOutgoingUpgradeToVideoCall(&self, callUpgradeGuid: Guid, context: HSTRING, contactName: HSTRING, serviceName: HSTRING, out: *mut *mut VoipPhoneCall) -> HRESULT,
    fn RequestIncomingUpgradeToVideoCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, contactImage: *mut super::super::foundation::Uri, serviceName: HSTRING, brandingImage: *mut super::super::foundation::Uri, callDetails: HSTRING, ringtone: *mut super::super::foundation::Uri, ringTimeout: super::super::foundation::TimeSpan, out: *mut *mut VoipPhoneCall) -> HRESULT,
    fn TerminateCellularCall(&self, callUpgradeGuid: Guid) -> HRESULT,
    fn CancelUpgrade(&self, callUpgradeGuid: Guid) -> HRESULT
}}
impl IVoipCallCoordinator {
    #[inline] pub unsafe fn reserve_call_resources_async(&self, taskEntryPoint: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<VoipPhoneCallResourceReservationStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReserveCallResourcesAsync)(self as *const _ as *mut _, taskEntryPoint.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_mute_state_changed(&self, muteChangeHandler: &super::super::foundation::TypedEventHandler<VoipCallCoordinator, MuteChangeEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MuteStateChanged)(self as *const _ as *mut _, muteChangeHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_mute_state_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MuteStateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_new_incoming_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, contactImage: &super::super::foundation::Uri, serviceName: &HStringArg, brandingImage: &super::super::foundation::Uri, callDetails: &HStringArg, ringtone: &super::super::foundation::Uri, media: VoipPhoneCallMedia, ringTimeout: super::super::foundation::TimeSpan) -> Result<ComPtr<VoipPhoneCall>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestNewIncomingCall)(self as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), contactImage as *const _ as *mut _, serviceName.get(), brandingImage as *const _ as *mut _, callDetails.get(), ringtone as *const _ as *mut _, media, ringTimeout, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_new_outgoing_call(&self, context: &HStringArg, contactName: &HStringArg, serviceName: &HStringArg, media: VoipPhoneCallMedia) -> Result<ComPtr<VoipPhoneCall>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestNewOutgoingCall)(self as *const _ as *mut _, context.get(), contactName.get(), serviceName.get(), media, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_muted(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyMuted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_unmuted(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyUnmuted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_outgoing_upgrade_to_video_call(&self, callUpgradeGuid: Guid, context: &HStringArg, contactName: &HStringArg, serviceName: &HStringArg) -> Result<ComPtr<VoipPhoneCall>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestOutgoingUpgradeToVideoCall)(self as *const _ as *mut _, callUpgradeGuid, context.get(), contactName.get(), serviceName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_incoming_upgrade_to_video_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, contactImage: &super::super::foundation::Uri, serviceName: &HStringArg, brandingImage: &super::super::foundation::Uri, callDetails: &HStringArg, ringtone: &super::super::foundation::Uri, ringTimeout: super::super::foundation::TimeSpan) -> Result<ComPtr<VoipPhoneCall>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestIncomingUpgradeToVideoCall)(self as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), contactImage as *const _ as *mut _, serviceName.get(), brandingImage as *const _ as *mut _, callDetails.get(), ringtone as *const _ as *mut _, ringTimeout, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn terminate_cellular_call(&self, callUpgradeGuid: Guid) -> Result<()> {
        let hr = ((*self.lpVtbl).TerminateCellularCall)(self as *const _ as *mut _, callUpgradeGuid);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel_upgrade(&self, callUpgradeGuid: Guid) -> Result<()> {
        let hr = ((*self.lpVtbl).CancelUpgrade)(self as *const _ as *mut _, callUpgradeGuid);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VoipCallCoordinator: IVoipCallCoordinator}
impl RtActivatable<IVoipCallCoordinatorStatics> for VoipCallCoordinator {}
impl VoipCallCoordinator {
    #[inline] pub fn get_default() -> Result<ComPtr<VoipCallCoordinator>> { unsafe {
        <Self as RtActivatable<IVoipCallCoordinatorStatics>>::get_activation_factory().get_default()
    }}
}
DEFINE_CLSID!(VoipCallCoordinator: "Windows.ApplicationModel.Calls.VoipCallCoordinator");
DEFINE_IID!(IID_IVoipCallCoordinator2, 3199511027, 50948, 16948, 137, 206, 232, 140, 192, 210, 143, 190);
RT_INTERFACE!{interface IVoipCallCoordinator2(IVoipCallCoordinator2Vtbl): IInspectable(IInspectableVtbl) [IID_IVoipCallCoordinator2] {
    fn SetupNewAcceptedCall(&self, context: HSTRING, contactName: HSTRING, contactNumber: HSTRING, serviceName: HSTRING, media: VoipPhoneCallMedia, out: *mut *mut VoipPhoneCall) -> HRESULT
}}
impl IVoipCallCoordinator2 {
    #[inline] pub unsafe fn setup_new_accepted_call(&self, context: &HStringArg, contactName: &HStringArg, contactNumber: &HStringArg, serviceName: &HStringArg, media: VoipPhoneCallMedia) -> Result<ComPtr<VoipPhoneCall>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetupNewAcceptedCall)(self as *const _ as *mut _, context.get(), contactName.get(), contactNumber.get(), serviceName.get(), media, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVoipCallCoordinatorStatics, 2136809259, 57418, 19728, 179, 26, 165, 92, 146, 44, 194, 251);
RT_INTERFACE!{static interface IVoipCallCoordinatorStatics(IVoipCallCoordinatorStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVoipCallCoordinatorStatics] {
    fn GetDefault(&self, out: *mut *mut VoipCallCoordinator) -> HRESULT
}}
impl IVoipCallCoordinatorStatics {
    #[inline] pub unsafe fn get_default(&self) -> Result<ComPtr<VoipCallCoordinator>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVoipPhoneCall, 1827795354, 30612, 19034, 140, 104, 174, 135, 148, 122, 105, 144);
RT_INTERFACE!{interface IVoipPhoneCall(IVoipPhoneCallVtbl): IInspectable(IInspectableVtbl) [IID_IVoipPhoneCall] {
    fn add_EndRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EndRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_HoldRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HoldRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResumeRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResumeRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_AnswerRequested(&self, acceptHandler: *mut super::super::foundation::TypedEventHandler<VoipPhoneCall, CallAnswerEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AnswerRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_RejectRequested(&self, rejectHandler: *mut super::super::foundation::TypedEventHandler<VoipPhoneCall, CallRejectEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RejectRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn NotifyCallHeld(&self) -> HRESULT,
    fn NotifyCallActive(&self) -> HRESULT,
    fn NotifyCallEnded(&self) -> HRESULT,
    fn get_ContactName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactName(&self, value: HSTRING) -> HRESULT,
    fn get_StartTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_CallMedia(&self, out: *mut VoipPhoneCallMedia) -> HRESULT,
    fn put_CallMedia(&self, value: VoipPhoneCallMedia) -> HRESULT,
    fn NotifyCallReady(&self) -> HRESULT
}}
impl IVoipPhoneCall {
    #[inline] pub unsafe fn add_end_requested(&self, handler: &super::super::foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EndRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_end_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_EndRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_hold_requested(&self, handler: &super::super::foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HoldRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_hold_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_HoldRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_resume_requested(&self, handler: &super::super::foundation::TypedEventHandler<VoipPhoneCall, CallStateChangeEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ResumeRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_resume_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ResumeRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_answer_requested(&self, acceptHandler: &super::super::foundation::TypedEventHandler<VoipPhoneCall, CallAnswerEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AnswerRequested)(self as *const _ as *mut _, acceptHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_answer_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AnswerRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_reject_requested(&self, rejectHandler: &super::super::foundation::TypedEventHandler<VoipPhoneCall, CallRejectEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RejectRequested)(self as *const _ as *mut _, rejectHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_reject_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_RejectRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_call_held(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyCallHeld)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_call_active(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyCallActive)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_call_ended(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyCallEnded)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contact_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContactName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_call_media(&self) -> Result<VoipPhoneCallMedia> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CallMedia)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_call_media(&self, value: VoipPhoneCallMedia) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CallMedia)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_call_ready(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyCallReady)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VoipPhoneCall: IVoipPhoneCall}
DEFINE_IID!(IID_IVoipPhoneCall2, 1947944673, 9311, 16883, 147, 153, 49, 65, 210, 91, 82, 227);
RT_INTERFACE!{interface IVoipPhoneCall2(IVoipPhoneCall2Vtbl): IInspectable(IInspectableVtbl) [IID_IVoipPhoneCall2] {
    fn TryShowAppUI(&self) -> HRESULT
}}
impl IVoipPhoneCall2 {
    #[inline] pub unsafe fn try_show_app_ui(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).TryShowAppUI)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum VoipPhoneCallMedia: u32 {
    None (VoipPhoneCallMedia_None) = 0, Audio (VoipPhoneCallMedia_Audio) = 1, Video (VoipPhoneCallMedia_Video) = 2,
}}
RT_ENUM! { enum VoipPhoneCallRejectReason: i32 {
    UserIgnored (VoipPhoneCallRejectReason_UserIgnored) = 0, TimedOut (VoipPhoneCallRejectReason_TimedOut) = 1, OtherIncomingCall (VoipPhoneCallRejectReason_OtherIncomingCall) = 2, EmergencyCallExists (VoipPhoneCallRejectReason_EmergencyCallExists) = 3, InvalidCallState (VoipPhoneCallRejectReason_InvalidCallState) = 4,
}}
RT_ENUM! { enum VoipPhoneCallResourceReservationStatus: i32 {
    Success (VoipPhoneCallResourceReservationStatus_Success) = 0, ResourcesNotAvailable (VoipPhoneCallResourceReservationStatus_ResourcesNotAvailable) = 1,
}}
RT_ENUM! { enum VoipPhoneCallState: i32 {
    Ended (VoipPhoneCallState_Ended) = 0, Held (VoipPhoneCallState_Held) = 1, Active (VoipPhoneCallState_Active) = 2, Incoming (VoipPhoneCallState_Incoming) = 3, Outgoing (VoipPhoneCallState_Outgoing) = 4,
}}
pub mod background { // Windows.ApplicationModel.Calls.Background
use ::prelude::*;
RT_ENUM! { enum PhoneCallBlockedReason: i32 {
    InCallBlockingList (PhoneCallBlockedReason_InCallBlockingList) = 0, PrivateNumber (PhoneCallBlockedReason_PrivateNumber) = 1, UnknownNumber (PhoneCallBlockedReason_UnknownNumber) = 2,
}}
DEFINE_IID!(IID_IPhoneCallBlockedTriggerDetails, 2762379426, 58561, 17023, 134, 78, 228, 112, 71, 125, 219, 103);
RT_INTERFACE!{interface IPhoneCallBlockedTriggerDetails(IPhoneCallBlockedTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallBlockedTriggerDetails] {
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LineId(&self, out: *mut Guid) -> HRESULT,
    fn get_CallBlockedReason(&self, out: *mut PhoneCallBlockedReason) -> HRESULT
}}
impl IPhoneCallBlockedTriggerDetails {
    #[inline] pub unsafe fn get_phone_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_line_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_call_blocked_reason(&self) -> Result<PhoneCallBlockedReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CallBlockedReason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallBlockedTriggerDetails: IPhoneCallBlockedTriggerDetails}
DEFINE_IID!(IID_IPhoneCallOriginDataRequestTriggerDetails, 1855675199, 50507, 20098, 76, 201, 227, 41, 164, 24, 69, 146);
RT_INTERFACE!{interface IPhoneCallOriginDataRequestTriggerDetails(IPhoneCallOriginDataRequestTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneCallOriginDataRequestTriggerDetails] {
    fn get_RequestId(&self, out: *mut Guid) -> HRESULT,
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPhoneCallOriginDataRequestTriggerDetails {
    #[inline] pub unsafe fn get_request_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phone_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneCallOriginDataRequestTriggerDetails: IPhoneCallOriginDataRequestTriggerDetails}
DEFINE_IID!(IID_IPhoneLineChangedTriggerDetails, 3335725543, 53533, 16600, 178, 183, 228, 10, 1, 214, 98, 73);
RT_INTERFACE!{interface IPhoneLineChangedTriggerDetails(IPhoneLineChangedTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneLineChangedTriggerDetails] {
    fn get_LineId(&self, out: *mut Guid) -> HRESULT,
    fn get_ChangeType(&self, out: *mut PhoneLineChangeKind) -> HRESULT,
    fn HasLinePropertyChanged(&self, lineProperty: PhoneLineProperties, out: *mut bool) -> HRESULT
}}
impl IPhoneLineChangedTriggerDetails {
    #[inline] pub unsafe fn get_line_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_type(&self) -> Result<PhoneLineChangeKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn has_line_property_changed(&self, lineProperty: PhoneLineProperties) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HasLinePropertyChanged)(self as *const _ as *mut _, lineProperty, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneLineChangedTriggerDetails: IPhoneLineChangedTriggerDetails}
RT_ENUM! { enum PhoneLineChangeKind: i32 {
    Added (PhoneLineChangeKind_Added) = 0, Removed (PhoneLineChangeKind_Removed) = 1, PropertiesChanged (PhoneLineChangeKind_PropertiesChanged) = 2,
}}
RT_ENUM! { enum PhoneLineProperties: u32 {
    None (PhoneLineProperties_None) = 0, BrandingOptions (PhoneLineProperties_BrandingOptions) = 1, CanDial (PhoneLineProperties_CanDial) = 2, CellularDetails (PhoneLineProperties_CellularDetails) = 4, DisplayColor (PhoneLineProperties_DisplayColor) = 8, DisplayName (PhoneLineProperties_DisplayName) = 16, NetworkName (PhoneLineProperties_NetworkName) = 32, NetworkState (PhoneLineProperties_NetworkState) = 64, Transport (PhoneLineProperties_Transport) = 128, Voicemail (PhoneLineProperties_Voicemail) = 256,
}}
DEFINE_IID!(IID_IPhoneNewVoicemailMessageTriggerDetails, 329826331, 47153, 18643, 139, 169, 141, 34, 166, 88, 13, 207);
RT_INTERFACE!{interface IPhoneNewVoicemailMessageTriggerDetails(IPhoneNewVoicemailMessageTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneNewVoicemailMessageTriggerDetails] {
    fn get_LineId(&self, out: *mut Guid) -> HRESULT,
    fn get_VoicemailCount(&self, out: *mut i32) -> HRESULT,
    fn get_OperatorMessage(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPhoneNewVoicemailMessageTriggerDetails {
    #[inline] pub unsafe fn get_line_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LineId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_voicemail_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VoicemailCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_operator_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OperatorMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneNewVoicemailMessageTriggerDetails: IPhoneNewVoicemailMessageTriggerDetails}
RT_ENUM! { enum PhoneTriggerType: i32 {
    NewVoicemailMessage (PhoneTriggerType_NewVoicemailMessage) = 0, CallHistoryChanged (PhoneTriggerType_CallHistoryChanged) = 1, LineChanged (PhoneTriggerType_LineChanged) = 2, AirplaneModeDisabledForEmergencyCall (PhoneTriggerType_AirplaneModeDisabledForEmergencyCall) = 3, CallOriginDataRequest (PhoneTriggerType_CallOriginDataRequest) = 4, CallBlocked (PhoneTriggerType_CallBlocked) = 5,
}}
} // Windows.ApplicationModel.Calls.Background
} // Windows.ApplicationModel.Calls
pub mod socialinfo { // Windows.ApplicationModel.SocialInfo
use ::prelude::*;
DEFINE_IID!(IID_ISocialFeedChildItem, 191535194, 54685, 16574, 152, 12, 72, 138, 42, 179, 10, 131);
RT_INTERFACE!{interface ISocialFeedChildItem(ISocialFeedChildItemVtbl): IInspectable(IInspectableVtbl) [IID_ISocialFeedChildItem] {
    fn get_Author(&self, out: *mut *mut SocialUserInfo) -> HRESULT,
    fn get_PrimaryContent(&self, out: *mut *mut SocialFeedContent) -> HRESULT,
    fn get_SecondaryContent(&self, out: *mut *mut SocialFeedContent) -> HRESULT,
    fn get_Timestamp(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_TargetUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_Thumbnails(&self, out: *mut *mut super::super::foundation::collections::IVector<SocialItemThumbnail>) -> HRESULT,
    fn get_SharedItem(&self, out: *mut *mut SocialFeedSharedItem) -> HRESULT,
    fn put_SharedItem(&self, value: *mut SocialFeedSharedItem) -> HRESULT
}}
impl ISocialFeedChildItem {
    #[inline] pub unsafe fn get_author(&self) -> Result<ComPtr<SocialUserInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Author)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_content(&self) -> Result<ComPtr<SocialFeedContent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_content(&self) -> Result<ComPtr<SocialFeedContent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_timestamp(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_timestamp(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Timestamp)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumbnails(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<SocialItemThumbnail>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shared_item(&self) -> Result<ComPtr<SocialFeedSharedItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SharedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_shared_item(&self, value: &SocialFeedSharedItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SharedItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SocialFeedChildItem: ISocialFeedChildItem}
impl RtActivatable<IActivationFactory> for SocialFeedChildItem {}
DEFINE_CLSID!(SocialFeedChildItem: "Windows.ApplicationModel.SocialInfo.SocialFeedChildItem");
DEFINE_IID!(IID_ISocialFeedContent, 2721375273, 15929, 18765, 163, 124, 244, 98, 162, 73, 69, 20);
RT_INTERFACE!{interface ISocialFeedContent(ISocialFeedContentVtbl): IInspectable(IInspectableVtbl) [IID_ISocialFeedContent] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Message(&self, value: HSTRING) -> HRESULT,
    fn get_TargetUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT
}}
impl ISocialFeedContent {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Message)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SocialFeedContent: ISocialFeedContent}
DEFINE_IID!(IID_ISocialFeedItem, 1326682795, 8050, 19763, 182, 149, 222, 62, 29, 182, 3, 23);
RT_INTERFACE!{interface ISocialFeedItem(ISocialFeedItemVtbl): IInspectable(IInspectableVtbl) [IID_ISocialFeedItem] {
    fn get_Author(&self, out: *mut *mut SocialUserInfo) -> HRESULT,
    fn get_PrimaryContent(&self, out: *mut *mut SocialFeedContent) -> HRESULT,
    fn get_SecondaryContent(&self, out: *mut *mut SocialFeedContent) -> HRESULT,
    fn get_Timestamp(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_TargetUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_Thumbnails(&self, out: *mut *mut super::super::foundation::collections::IVector<SocialItemThumbnail>) -> HRESULT,
    fn get_SharedItem(&self, out: *mut *mut SocialFeedSharedItem) -> HRESULT,
    fn put_SharedItem(&self, value: *mut SocialFeedSharedItem) -> HRESULT,
    fn get_BadgeStyle(&self, out: *mut SocialItemBadgeStyle) -> HRESULT,
    fn put_BadgeStyle(&self, value: SocialItemBadgeStyle) -> HRESULT,
    fn get_BadgeCountValue(&self, out: *mut i32) -> HRESULT,
    fn put_BadgeCountValue(&self, value: i32) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_ChildItem(&self, out: *mut *mut SocialFeedChildItem) -> HRESULT,
    fn put_ChildItem(&self, value: *mut SocialFeedChildItem) -> HRESULT,
    fn get_Style(&self, out: *mut SocialFeedItemStyle) -> HRESULT,
    fn put_Style(&self, value: SocialFeedItemStyle) -> HRESULT
}}
impl ISocialFeedItem {
    #[inline] pub unsafe fn get_author(&self) -> Result<ComPtr<SocialUserInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Author)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_primary_content(&self) -> Result<ComPtr<SocialFeedContent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PrimaryContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_secondary_content(&self) -> Result<ComPtr<SocialFeedContent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SecondaryContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_timestamp(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_timestamp(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Timestamp)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumbnails(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<SocialItemThumbnail>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shared_item(&self) -> Result<ComPtr<SocialFeedSharedItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SharedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_shared_item(&self, value: &SocialFeedSharedItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SharedItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_badge_style(&self) -> Result<SocialItemBadgeStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BadgeStyle)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_badge_style(&self, value: SocialItemBadgeStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BadgeStyle)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_badge_count_value(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BadgeCountValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_badge_count_value(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BadgeCountValue)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_child_item(&self) -> Result<ComPtr<SocialFeedChildItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChildItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_child_item(&self, value: &SocialFeedChildItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ChildItem)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_style(&self) -> Result<SocialFeedItemStyle> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Style)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_style(&self, value: SocialFeedItemStyle) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Style)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SocialFeedItem: ISocialFeedItem}
impl RtActivatable<IActivationFactory> for SocialFeedItem {}
DEFINE_CLSID!(SocialFeedItem: "Windows.ApplicationModel.SocialInfo.SocialFeedItem");
RT_ENUM! { enum SocialFeedItemStyle: i32 {
    Default (SocialFeedItemStyle_Default) = 0, Photo (SocialFeedItemStyle_Photo) = 1,
}}
RT_ENUM! { enum SocialFeedKind: i32 {
    HomeFeed (SocialFeedKind_HomeFeed) = 0, ContactFeed (SocialFeedKind_ContactFeed) = 1, Dashboard (SocialFeedKind_Dashboard) = 2,
}}
DEFINE_IID!(IID_ISocialFeedSharedItem, 2080087616, 42666, 17831, 159, 246, 84, 196, 33, 5, 221, 31);
RT_INTERFACE!{interface ISocialFeedSharedItem(ISocialFeedSharedItemVtbl): IInspectable(IInspectableVtbl) [IID_ISocialFeedSharedItem] {
    fn get_OriginalSource(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_OriginalSource(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_Content(&self, out: *mut *mut SocialFeedContent) -> HRESULT,
    fn get_Timestamp(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_TargetUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn put_Thumbnail(&self, value: *mut SocialItemThumbnail) -> HRESULT,
    fn get_Thumbnail(&self, out: *mut *mut SocialItemThumbnail) -> HRESULT
}}
impl ISocialFeedSharedItem {
    #[inline] pub unsafe fn get_original_source(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginalSource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_original_source(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OriginalSource)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<SocialFeedContent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_timestamp(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_timestamp(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Timestamp)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_thumbnail(&self, value: &SocialItemThumbnail) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Thumbnail)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<SocialItemThumbnail>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SocialFeedSharedItem: ISocialFeedSharedItem}
impl RtActivatable<IActivationFactory> for SocialFeedSharedItem {}
DEFINE_CLSID!(SocialFeedSharedItem: "Windows.ApplicationModel.SocialInfo.SocialFeedSharedItem");
RT_ENUM! { enum SocialFeedUpdateMode: i32 {
    Append (SocialFeedUpdateMode_Append) = 0, Replace (SocialFeedUpdateMode_Replace) = 1,
}}
RT_ENUM! { enum SocialItemBadgeStyle: i32 {
    Hidden (SocialItemBadgeStyle_Hidden) = 0, Visible (SocialItemBadgeStyle_Visible) = 1, VisibleWithCount (SocialItemBadgeStyle_VisibleWithCount) = 2,
}}
DEFINE_IID!(IID_ISocialItemThumbnail, 1556054810, 16136, 18815, 145, 127, 87, 224, 157, 132, 177, 65);
RT_INTERFACE!{interface ISocialItemThumbnail(ISocialItemThumbnailVtbl): IInspectable(IInspectableVtbl) [IID_ISocialItemThumbnail] {
    fn get_TargetUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_ImageUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_ImageUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-graphics")] fn get_BitmapSize(&self, out: *mut super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-graphics")] fn put_BitmapSize(&self, value: super::super::graphics::imaging::BitmapSize) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetImageAsync(&self, image: *mut super::super::storage::streams::IInputStream, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl ISocialItemThumbnail {
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_image_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImageUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_image_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ImageUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn get_bitmap_size(&self) -> Result<super::super::graphics::imaging::BitmapSize> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BitmapSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_bitmap_size(&self, value: super::super::graphics::imaging::BitmapSize) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BitmapSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_image_async(&self, image: &super::super::storage::streams::IInputStream) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetImageAsync)(self as *const _ as *mut _, image as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SocialItemThumbnail: ISocialItemThumbnail}
impl RtActivatable<IActivationFactory> for SocialItemThumbnail {}
DEFINE_CLSID!(SocialItemThumbnail: "Windows.ApplicationModel.SocialInfo.SocialItemThumbnail");
DEFINE_IID!(IID_ISocialUserInfo, 2656967633, 37072, 19997, 149, 84, 132, 77, 70, 96, 127, 97);
RT_INTERFACE!{interface ISocialUserInfo(ISocialUserInfoVtbl): IInspectable(IInspectableVtbl) [IID_ISocialUserInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_UserName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UserName(&self, value: HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_TargetUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT
}}
impl ISocialUserInfo {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_user_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UserName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SocialUserInfo: ISocialUserInfo}
pub mod provider { // Windows.ApplicationModel.SocialInfo.Provider
use ::prelude::*;
DEFINE_IID!(IID_ISocialDashboardItemUpdater, 1021222345, 18432, 18125, 134, 155, 25, 115, 236, 104, 91, 222);
RT_INTERFACE!{interface ISocialDashboardItemUpdater(ISocialDashboardItemUpdaterVtbl): IInspectable(IInspectableVtbl) [IID_ISocialDashboardItemUpdater] {
    fn get_OwnerRemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Content(&self, out: *mut *mut super::SocialFeedContent) -> HRESULT,
    fn get_Timestamp(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_Timestamp(&self, value: ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn put_Thumbnail(&self, value: *mut super::SocialItemThumbnail) -> HRESULT,
    fn get_Thumbnail(&self, out: *mut *mut super::SocialItemThumbnail) -> HRESULT,
    fn CommitAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn get_TargetUri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_TargetUri(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT
}}
impl ISocialDashboardItemUpdater {
    #[inline] pub unsafe fn get_owner_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OwnerRemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<super::SocialFeedContent>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_timestamp(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Timestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_timestamp(&self, value: ::rt::gen::windows::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Timestamp)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_thumbnail(&self, value: &super::SocialItemThumbnail) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Thumbnail)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<super::SocialItemThumbnail>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn commit_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CommitAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_target_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TargetUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_target_uri(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TargetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SocialDashboardItemUpdater: ISocialDashboardItemUpdater}
DEFINE_IID!(IID_ISocialFeedUpdater, 2047609511, 60809, 19413, 168, 217, 21, 244, 217, 134, 28, 16);
RT_INTERFACE!{interface ISocialFeedUpdater(ISocialFeedUpdaterVtbl): IInspectable(IInspectableVtbl) [IID_ISocialFeedUpdater] {
    fn get_OwnerRemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut super::SocialFeedKind) -> HRESULT,
    fn get_Items(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::SocialFeedItem>) -> HRESULT,
    fn CommitAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl ISocialFeedUpdater {
    #[inline] pub unsafe fn get_owner_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OwnerRemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<super::SocialFeedKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::SocialFeedItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Items)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn commit_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CommitAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SocialFeedUpdater: ISocialFeedUpdater}
RT_CLASS!{static class SocialInfoProviderManager}
impl RtActivatable<ISocialInfoProviderManagerStatics> for SocialInfoProviderManager {}
impl SocialInfoProviderManager {
    #[inline] pub fn create_social_feed_updater_async(kind: super::SocialFeedKind, mode: super::SocialFeedUpdateMode, ownerRemoteId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<SocialFeedUpdater>>> { unsafe {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().create_social_feed_updater_async(kind, mode, ownerRemoteId)
    }}
    #[inline] pub fn create_dashboard_item_updater_async(ownerRemoteId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<SocialDashboardItemUpdater>>> { unsafe {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().create_dashboard_item_updater_async(ownerRemoteId)
    }}
    #[inline] pub fn update_badge_count_value(itemRemoteId: &HStringArg, newCount: i32) -> Result<()> { unsafe {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().update_badge_count_value(itemRemoteId, newCount)
    }}
    #[inline] pub fn report_new_content_available(contactRemoteId: &HStringArg, kind: super::SocialFeedKind) -> Result<()> { unsafe {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().report_new_content_available(contactRemoteId, kind)
    }}
    #[inline] pub fn provision_async() -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> { unsafe {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().provision_async()
    }}
    #[inline] pub fn deprovision_async() -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<ISocialInfoProviderManagerStatics>>::get_activation_factory().deprovision_async()
    }}
}
DEFINE_CLSID!(SocialInfoProviderManager: "Windows.ApplicationModel.SocialInfo.Provider.SocialInfoProviderManager");
DEFINE_IID!(IID_ISocialInfoProviderManagerStatics, 461956395, 30599, 18646, 170, 18, 216, 232, 244, 122, 184, 90);
RT_INTERFACE!{static interface ISocialInfoProviderManagerStatics(ISocialInfoProviderManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISocialInfoProviderManagerStatics] {
    fn CreateSocialFeedUpdaterAsync(&self, kind: super::SocialFeedKind, mode: super::SocialFeedUpdateMode, ownerRemoteId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<SocialFeedUpdater>) -> HRESULT,
    fn CreateDashboardItemUpdaterAsync(&self, ownerRemoteId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<SocialDashboardItemUpdater>) -> HRESULT,
    fn UpdateBadgeCountValue(&self, itemRemoteId: HSTRING, newCount: i32) -> HRESULT,
    fn ReportNewContentAvailable(&self, contactRemoteId: HSTRING, kind: super::SocialFeedKind) -> HRESULT,
    fn ProvisionAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn DeprovisionAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl ISocialInfoProviderManagerStatics {
    #[inline] pub unsafe fn create_social_feed_updater_async(&self, kind: super::SocialFeedKind, mode: super::SocialFeedUpdateMode, ownerRemoteId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<SocialFeedUpdater>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSocialFeedUpdaterAsync)(self as *const _ as *mut _, kind, mode, ownerRemoteId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_dashboard_item_updater_async(&self, ownerRemoteId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<SocialDashboardItemUpdater>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDashboardItemUpdaterAsync)(self as *const _ as *mut _, ownerRemoteId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_badge_count_value(&self, itemRemoteId: &HStringArg, newCount: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).UpdateBadgeCountValue)(self as *const _ as *mut _, itemRemoteId.get(), newCount);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_new_content_available(&self, contactRemoteId: &HStringArg, kind: super::SocialFeedKind) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportNewContentAvailable)(self as *const _ as *mut _, contactRemoteId.get(), kind);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn provision_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ProvisionAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn deprovision_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeprovisionAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.SocialInfo.Provider
} // Windows.ApplicationModel.SocialInfo
pub mod search { // Windows.ApplicationModel.Search
use ::prelude::*;
DEFINE_IID!(IID_ILocalContentSuggestionSettings, 4004425826, 29757, 17774, 132, 163, 35, 240, 111, 45, 21, 215);
RT_INTERFACE!{interface ILocalContentSuggestionSettings(ILocalContentSuggestionSettingsVtbl): IInspectable(IInspectableVtbl) [IID_ILocalContentSuggestionSettings] {
    fn put_Enabled(&self, value: bool) -> HRESULT,
    fn get_Enabled(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Locations(&self, out: *mut *mut super::super::foundation::collections::IVector<super::super::storage::StorageFolder>) -> HRESULT,
    fn put_AqsFilter(&self, value: HSTRING) -> HRESULT,
    fn get_AqsFilter(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PropertiesToMatch(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl ILocalContentSuggestionSettings {
    #[inline] pub unsafe fn set_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Enabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Enabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_locations(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<super::super::storage::StorageFolder>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Locations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_aqs_filter(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AqsFilter)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aqs_filter(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AqsFilter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_properties_to_match(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PropertiesToMatch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LocalContentSuggestionSettings: ILocalContentSuggestionSettings}
impl RtActivatable<IActivationFactory> for LocalContentSuggestionSettings {}
DEFINE_CLSID!(LocalContentSuggestionSettings: "Windows.ApplicationModel.Search.LocalContentSuggestionSettings");
DEFINE_IID!(IID_ISearchPane, 4255968312, 14080, 19827, 145, 161, 47, 153, 134, 116, 35, 138);
RT_INTERFACE!{interface ISearchPane(ISearchPaneVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPane] {
    fn put_SearchHistoryEnabled(&self, value: bool) -> HRESULT,
    fn get_SearchHistoryEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SearchHistoryContext(&self, value: HSTRING) -> HRESULT,
    fn get_SearchHistoryContext(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PlaceholderText(&self, value: HSTRING) -> HRESULT,
    fn get_PlaceholderText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Visible(&self, out: *mut bool) -> HRESULT,
    fn add_VisibilityChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<SearchPane, SearchPaneVisibilityChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VisibilityChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_QueryChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<SearchPane, SearchPaneQueryChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QueryChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SuggestionsRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<SearchPane, SearchPaneSuggestionsRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SuggestionsRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_QuerySubmitted(&self, handler: *mut super::super::foundation::TypedEventHandler<SearchPane, SearchPaneQuerySubmittedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_QuerySubmitted(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResultSuggestionChosen(&self, handler: *mut super::super::foundation::TypedEventHandler<SearchPane, SearchPaneResultSuggestionChosenEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResultSuggestionChosen(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn SetLocalContentSuggestionSettings(&self, settings: *mut LocalContentSuggestionSettings) -> HRESULT,
    fn ShowOverloadDefault(&self) -> HRESULT,
    fn ShowOverloadWithQuery(&self, query: HSTRING) -> HRESULT,
    fn put_ShowOnKeyboardInput(&self, value: bool) -> HRESULT,
    fn get_ShowOnKeyboardInput(&self, out: *mut bool) -> HRESULT,
    fn TrySetQueryText(&self, query: HSTRING, out: *mut bool) -> HRESULT
}}
impl ISearchPane {
    #[inline] pub unsafe fn set_search_history_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchHistoryEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_history_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SearchHistoryEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_history_context(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchHistoryContext)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_history_context(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchHistoryContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_placeholder_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PlaceholderText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_placeholder_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PlaceholderText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_visibility_changed(&self, handler: &super::super::foundation::TypedEventHandler<SearchPane, SearchPaneVisibilityChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VisibilityChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_visibility_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_VisibilityChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_query_changed(&self, handler: &super::super::foundation::TypedEventHandler<SearchPane, SearchPaneQueryChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_QueryChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_query_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_QueryChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_suggestions_requested(&self, handler: &super::super::foundation::TypedEventHandler<SearchPane, SearchPaneSuggestionsRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SuggestionsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_suggestions_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SuggestionsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_query_submitted(&self, handler: &super::super::foundation::TypedEventHandler<SearchPane, SearchPaneQuerySubmittedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_QuerySubmitted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_query_submitted(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_QuerySubmitted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_result_suggestion_chosen(&self, handler: &super::super::foundation::TypedEventHandler<SearchPane, SearchPaneResultSuggestionChosenEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ResultSuggestionChosen)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_result_suggestion_chosen(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ResultSuggestionChosen)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_local_content_suggestion_settings(&self, settings: &LocalContentSuggestionSettings) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLocalContentSuggestionSettings)(self as *const _ as *mut _, settings as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_overload_default(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowOverloadDefault)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_overload_with_query(&self, query: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowOverloadWithQuery)(self as *const _ as *mut _, query.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_show_on_keyboard_input(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShowOnKeyboardInput)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_show_on_keyboard_input(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowOnKeyboardInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_set_query_text(&self, query: &HStringArg) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySetQueryText)(self as *const _ as *mut _, query.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPane: ISearchPane}
impl RtActivatable<ISearchPaneStatics> for SearchPane {}
impl RtActivatable<ISearchPaneStaticsWithHideThisApplication> for SearchPane {}
impl SearchPane {
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<SearchPane>> { unsafe {
        <Self as RtActivatable<ISearchPaneStatics>>::get_activation_factory().get_for_current_view()
    }}
    #[inline] pub fn hide_this_application() -> Result<()> { unsafe {
        <Self as RtActivatable<ISearchPaneStaticsWithHideThisApplication>>::get_activation_factory().hide_this_application()
    }}
}
DEFINE_CLSID!(SearchPane: "Windows.ApplicationModel.Search.SearchPane");
DEFINE_IID!(IID_ISearchPaneQueryChangedEventArgs, 1007046633, 9041, 16968, 165, 41, 113, 16, 244, 100, 167, 133);
RT_INTERFACE!{interface ISearchPaneQueryChangedEventArgs(ISearchPaneQueryChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneQueryChangedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LinguisticDetails(&self, out: *mut *mut SearchPaneQueryLinguisticDetails) -> HRESULT
}}
impl ISearchPaneQueryChangedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<SearchPaneQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneQueryChangedEventArgs: ISearchPaneQueryChangedEventArgs}
DEFINE_IID!(IID_ISearchPaneQueryLinguisticDetails, 2197505550, 2368, 19309, 184, 208, 100, 43, 48, 152, 158, 21);
RT_INTERFACE!{interface ISearchPaneQueryLinguisticDetails(ISearchPaneQueryLinguisticDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneQueryLinguisticDetails] {
    fn get_QueryTextAlternatives(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_QueryTextCompositionStart(&self, out: *mut u32) -> HRESULT,
    fn get_QueryTextCompositionLength(&self, out: *mut u32) -> HRESULT
}}
impl ISearchPaneQueryLinguisticDetails {
    #[inline] pub unsafe fn get_query_text_alternatives(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryTextAlternatives)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text_composition_start(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_QueryTextCompositionStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text_composition_length(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_QueryTextCompositionLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneQueryLinguisticDetails: ISearchPaneQueryLinguisticDetails}
DEFINE_IID!(IID_ISearchPaneQuerySubmittedEventArgs, 339453180, 59845, 18230, 145, 178, 232, 235, 156, 184, 131, 86);
RT_INTERFACE!{interface ISearchPaneQuerySubmittedEventArgs(ISearchPaneQuerySubmittedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneQuerySubmittedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchPaneQuerySubmittedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneQuerySubmittedEventArgs: ISearchPaneQuerySubmittedEventArgs}
DEFINE_IID!(IID_ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails, 1175229157, 19506, 17720, 164, 212, 182, 180, 64, 13, 20, 15);
RT_INTERFACE!{interface ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails(ISearchPaneQuerySubmittedEventArgsWithLinguisticDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails] {
    fn get_LinguisticDetails(&self, out: *mut *mut SearchPaneQueryLinguisticDetails) -> HRESULT
}}
impl ISearchPaneQuerySubmittedEventArgsWithLinguisticDetails {
    #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<SearchPaneQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchPaneResultSuggestionChosenEventArgs, 3358682304, 44754, 16864, 188, 224, 194, 108, 167, 79, 133, 236);
RT_INTERFACE!{interface ISearchPaneResultSuggestionChosenEventArgs(ISearchPaneResultSuggestionChosenEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneResultSuggestionChosenEventArgs] {
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchPaneResultSuggestionChosenEventArgs {
    #[inline] pub unsafe fn get_tag(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneResultSuggestionChosenEventArgs: ISearchPaneResultSuggestionChosenEventArgs}
DEFINE_IID!(IID_ISearchPaneStatics, 2507320817, 36637, 18463, 161, 91, 198, 22, 85, 241, 106, 14);
RT_INTERFACE!{static interface ISearchPaneStatics(ISearchPaneStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneStatics] {
    fn GetForCurrentView(&self, out: *mut *mut SearchPane) -> HRESULT
}}
impl ISearchPaneStatics {
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<SearchPane>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchPaneStaticsWithHideThisApplication, 7546928, 20721, 19715, 153, 172, 198, 100, 76, 142, 216, 181);
RT_INTERFACE!{static interface ISearchPaneStaticsWithHideThisApplication(ISearchPaneStaticsWithHideThisApplicationVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneStaticsWithHideThisApplication] {
    fn HideThisApplication(&self) -> HRESULT
}}
impl ISearchPaneStaticsWithHideThisApplication {
    #[inline] pub unsafe fn hide_this_application(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).HideThisApplication)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchPaneSuggestionsRequest, 2175863580, 58721, 16531, 155, 77, 42, 212, 130, 121, 74, 83);
RT_INTERFACE!{interface ISearchPaneSuggestionsRequest(ISearchPaneSuggestionsRequestVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneSuggestionsRequest] {
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn get_SearchSuggestionCollection(&self, out: *mut *mut SearchSuggestionCollection) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut SearchPaneSuggestionsRequestDeferral) -> HRESULT
}}
impl ISearchPaneSuggestionsRequest {
    #[inline] pub unsafe fn get_is_canceled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_suggestion_collection(&self) -> Result<ComPtr<SearchSuggestionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchSuggestionCollection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<SearchPaneSuggestionsRequestDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneSuggestionsRequest: ISearchPaneSuggestionsRequest}
DEFINE_IID!(IID_ISearchPaneSuggestionsRequestDeferral, 2697988599, 34632, 20194, 173, 68, 175, 166, 190, 153, 124, 81);
RT_INTERFACE!{interface ISearchPaneSuggestionsRequestDeferral(ISearchPaneSuggestionsRequestDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneSuggestionsRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISearchPaneSuggestionsRequestDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneSuggestionsRequestDeferral: ISearchPaneSuggestionsRequestDeferral}
DEFINE_IID!(IID_ISearchPaneSuggestionsRequestedEventArgs, 3365636655, 44118, 17504, 141, 47, 128, 2, 59, 236, 79, 197);
RT_INTERFACE!{interface ISearchPaneSuggestionsRequestedEventArgs(ISearchPaneSuggestionsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneSuggestionsRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut SearchPaneSuggestionsRequest) -> HRESULT
}}
impl ISearchPaneSuggestionsRequestedEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<SearchPaneSuggestionsRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneSuggestionsRequestedEventArgs: ISearchPaneSuggestionsRequestedEventArgs}
DEFINE_IID!(IID_ISearchPaneVisibilityChangedEventArgs, 1011691590, 44107, 18930, 151, 214, 2, 14, 97, 130, 203, 156);
RT_INTERFACE!{interface ISearchPaneVisibilityChangedEventArgs(ISearchPaneVisibilityChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchPaneVisibilityChangedEventArgs] {
    fn get_Visible(&self, out: *mut bool) -> HRESULT
}}
impl ISearchPaneVisibilityChangedEventArgs {
    #[inline] pub unsafe fn get_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Visible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SearchPaneVisibilityChangedEventArgs: ISearchPaneVisibilityChangedEventArgs}
DEFINE_IID!(IID_ISearchQueryLinguisticDetails, 1184964699, 27081, 18245, 183, 47, 168, 164, 252, 143, 36, 174);
RT_INTERFACE!{interface ISearchQueryLinguisticDetails(ISearchQueryLinguisticDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchQueryLinguisticDetails] {
    fn get_QueryTextAlternatives(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_QueryTextCompositionStart(&self, out: *mut u32) -> HRESULT,
    fn get_QueryTextCompositionLength(&self, out: *mut u32) -> HRESULT
}}
impl ISearchQueryLinguisticDetails {
    #[inline] pub unsafe fn get_query_text_alternatives(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryTextAlternatives)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text_composition_start(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_QueryTextCompositionStart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_query_text_composition_length(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_QueryTextCompositionLength)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SearchQueryLinguisticDetails: ISearchQueryLinguisticDetails}
impl RtActivatable<ISearchQueryLinguisticDetailsFactory> for SearchQueryLinguisticDetails {}
impl SearchQueryLinguisticDetails {
    #[inline] pub fn create_instance(queryTextAlternatives: &super::super::foundation::collections::IIterable<HString>, queryTextCompositionStart: u32, queryTextCompositionLength: u32) -> Result<ComPtr<SearchQueryLinguisticDetails>> { unsafe {
        <Self as RtActivatable<ISearchQueryLinguisticDetailsFactory>>::get_activation_factory().create_instance(queryTextAlternatives, queryTextCompositionStart, queryTextCompositionLength)
    }}
}
DEFINE_CLSID!(SearchQueryLinguisticDetails: "Windows.ApplicationModel.Search.SearchQueryLinguisticDetails");
DEFINE_IID!(IID_ISearchQueryLinguisticDetailsFactory, 3402023864, 15460, 19965, 173, 159, 71, 158, 77, 64, 101, 164);
RT_INTERFACE!{static interface ISearchQueryLinguisticDetailsFactory(ISearchQueryLinguisticDetailsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISearchQueryLinguisticDetailsFactory] {
    fn CreateInstance(&self, queryTextAlternatives: *mut super::super::foundation::collections::IIterable<HString>, queryTextCompositionStart: u32, queryTextCompositionLength: u32, out: *mut *mut SearchQueryLinguisticDetails) -> HRESULT
}}
impl ISearchQueryLinguisticDetailsFactory {
    #[inline] pub unsafe fn create_instance(&self, queryTextAlternatives: &super::super::foundation::collections::IIterable<HString>, queryTextCompositionStart: u32, queryTextCompositionLength: u32) -> Result<ComPtr<SearchQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstance)(self as *const _ as *mut _, queryTextAlternatives as *const _ as *mut _, queryTextCompositionStart, queryTextCompositionLength, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISearchSuggestionCollection, 842697291, 64490, 17478, 171, 188, 61, 167, 145, 95, 221, 58);
RT_INTERFACE!{interface ISearchSuggestionCollection(ISearchSuggestionCollectionVtbl): IInspectable(IInspectableVtbl) [IID_ISearchSuggestionCollection] {
    fn get_Size(&self, out: *mut u32) -> HRESULT,
    fn AppendQuerySuggestion(&self, text: HSTRING) -> HRESULT,
    fn AppendQuerySuggestions(&self, suggestions: *mut super::super::foundation::collections::IIterable<HString>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn AppendResultSuggestion(&self, text: HSTRING, detailText: HSTRING, tag: HSTRING, image: *mut super::super::storage::streams::IRandomAccessStreamReference, imageAlternateText: HSTRING) -> HRESULT,
    fn AppendSearchSeparator(&self, label: HSTRING) -> HRESULT
}}
impl ISearchSuggestionCollection {
    #[inline] pub unsafe fn get_size(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Size)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn append_query_suggestion(&self, text: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).AppendQuerySuggestion)(self as *const _ as *mut _, text.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn append_query_suggestions(&self, suggestions: &super::super::foundation::collections::IIterable<HString>) -> Result<()> {
        let hr = ((*self.lpVtbl).AppendQuerySuggestions)(self as *const _ as *mut _, suggestions as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn append_result_suggestion(&self, text: &HStringArg, detailText: &HStringArg, tag: &HStringArg, image: &super::super::storage::streams::IRandomAccessStreamReference, imageAlternateText: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).AppendResultSuggestion)(self as *const _ as *mut _, text.get(), detailText.get(), tag.get(), image as *const _ as *mut _, imageAlternateText.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn append_search_separator(&self, label: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).AppendSearchSeparator)(self as *const _ as *mut _, label.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SearchSuggestionCollection: ISearchSuggestionCollection}
DEFINE_IID!(IID_ISearchSuggestionsRequest, 1313744551, 17637, 16441, 144, 153, 96, 0, 234, 209, 240, 198);
RT_INTERFACE!{interface ISearchSuggestionsRequest(ISearchSuggestionsRequestVtbl): IInspectable(IInspectableVtbl) [IID_ISearchSuggestionsRequest] {
    fn get_IsCanceled(&self, out: *mut bool) -> HRESULT,
    fn get_SearchSuggestionCollection(&self, out: *mut *mut SearchSuggestionCollection) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut SearchSuggestionsRequestDeferral) -> HRESULT
}}
impl ISearchSuggestionsRequest {
    #[inline] pub unsafe fn get_is_canceled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_suggestion_collection(&self) -> Result<ComPtr<SearchSuggestionCollection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchSuggestionCollection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<SearchSuggestionsRequestDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchSuggestionsRequest: ISearchSuggestionsRequest}
DEFINE_IID!(IID_ISearchSuggestionsRequestDeferral, 3071645865, 49253, 17773, 168, 69, 30, 204, 236, 93, 194, 139);
RT_INTERFACE!{interface ISearchSuggestionsRequestDeferral(ISearchSuggestionsRequestDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ISearchSuggestionsRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ISearchSuggestionsRequestDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SearchSuggestionsRequestDeferral: ISearchSuggestionsRequestDeferral}
pub mod core { // Windows.ApplicationModel.Search.Core
use ::prelude::*;
DEFINE_IID!(IID_IRequestingFocusOnKeyboardInputEventArgs, 2702794535, 45479, 16802, 135, 157, 106, 104, 104, 126, 89, 133);
RT_INTERFACE!{interface IRequestingFocusOnKeyboardInputEventArgs(IRequestingFocusOnKeyboardInputEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRequestingFocusOnKeyboardInputEventArgs] {
    
}}
RT_CLASS!{class RequestingFocusOnKeyboardInputEventArgs: IRequestingFocusOnKeyboardInputEventArgs}
DEFINE_IID!(IID_ISearchSuggestion, 1532318896, 5415, 17275, 149, 197, 141, 24, 210, 184, 175, 85);
RT_INTERFACE!{interface ISearchSuggestion(ISearchSuggestionVtbl): IInspectable(IInspectableVtbl) [IID_ISearchSuggestion] {
    fn get_Kind(&self, out: *mut SearchSuggestionKind) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DetailText(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_ImageAlternateText(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchSuggestion {
    #[inline] pub unsafe fn get_kind(&self) -> Result<SearchSuggestionKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tag(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_detail_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DetailText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_image(&self) -> Result<ComPtr<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Image)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_image_alternate_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImageAlternateText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchSuggestion: ISearchSuggestion}
RT_ENUM! { enum SearchSuggestionKind: i32 {
    Query (SearchSuggestionKind_Query) = 0, Result (SearchSuggestionKind_Result) = 1, Separator (SearchSuggestionKind_Separator) = 2,
}}
DEFINE_IID!(IID_ISearchSuggestionManager, 1057771681, 52125, 18811, 181, 0, 60, 4, 172, 149, 154, 210);
RT_INTERFACE!{interface ISearchSuggestionManager(ISearchSuggestionManagerVtbl): IInspectable(IInspectableVtbl) [IID_ISearchSuggestionManager] {
    fn get_SearchHistoryEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_SearchHistoryEnabled(&self, value: bool) -> HRESULT,
    fn get_SearchHistoryContext(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SearchHistoryContext(&self, value: HSTRING) -> HRESULT,
    fn SetLocalContentSuggestionSettings(&self, settings: *mut super::LocalContentSuggestionSettings) -> HRESULT,
    fn SetQuery(&self, queryText: HSTRING) -> HRESULT,
    fn SetQueryWithLanguage(&self, queryText: HSTRING, language: HSTRING) -> HRESULT,
    fn SetQueryWithSearchQueryLinguisticDetails(&self, queryText: HSTRING, language: HSTRING, linguisticDetails: *mut super::SearchQueryLinguisticDetails) -> HRESULT,
    fn get_Suggestions(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableVector<SearchSuggestion>) -> HRESULT,
    fn AddToHistory(&self, queryText: HSTRING) -> HRESULT,
    fn AddToHistoryWithLanguage(&self, queryText: HSTRING, language: HSTRING) -> HRESULT,
    fn ClearHistory(&self) -> HRESULT,
    fn add_SuggestionsRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchSuggestionManager, SearchSuggestionsRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SuggestionsRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_RequestingFocusOnKeyboardInput(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<SearchSuggestionManager, RequestingFocusOnKeyboardInputEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RequestingFocusOnKeyboardInput(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl ISearchSuggestionManager {
    #[inline] pub unsafe fn get_search_history_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SearchHistoryEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_history_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchHistoryEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_history_context(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchHistoryContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_history_context(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchHistoryContext)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_local_content_suggestion_settings(&self, settings: &super::LocalContentSuggestionSettings) -> Result<()> {
        let hr = ((*self.lpVtbl).SetLocalContentSuggestionSettings)(self as *const _ as *mut _, settings as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_query(&self, queryText: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetQuery)(self as *const _ as *mut _, queryText.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_query_with_language(&self, queryText: &HStringArg, language: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetQueryWithLanguage)(self as *const _ as *mut _, queryText.get(), language.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_query_with_search_query_linguistic_details(&self, queryText: &HStringArg, language: &HStringArg, linguisticDetails: &super::SearchQueryLinguisticDetails) -> Result<()> {
        let hr = ((*self.lpVtbl).SetQueryWithSearchQueryLinguisticDetails)(self as *const _ as *mut _, queryText.get(), language.get(), linguisticDetails as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_suggestions(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableVector<SearchSuggestion>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Suggestions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_to_history(&self, queryText: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).AddToHistory)(self as *const _ as *mut _, queryText.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_to_history_with_language(&self, queryText: &HStringArg, language: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).AddToHistoryWithLanguage)(self as *const _ as *mut _, queryText.get(), language.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear_history(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ClearHistory)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_suggestions_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<SearchSuggestionManager, SearchSuggestionsRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SuggestionsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_suggestions_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SuggestionsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_requesting_focus_on_keyboard_input(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<SearchSuggestionManager, RequestingFocusOnKeyboardInputEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RequestingFocusOnKeyboardInput)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_requesting_focus_on_keyboard_input(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_RequestingFocusOnKeyboardInput)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SearchSuggestionManager: ISearchSuggestionManager}
impl RtActivatable<IActivationFactory> for SearchSuggestionManager {}
DEFINE_CLSID!(SearchSuggestionManager: "Windows.ApplicationModel.Search.Core.SearchSuggestionManager");
DEFINE_IID!(IID_ISearchSuggestionsRequestedEventArgs, 1876236773, 40574, 19124, 139, 227, 199, 107, 27, 212, 52, 74);
RT_INTERFACE!{interface ISearchSuggestionsRequestedEventArgs(ISearchSuggestionsRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchSuggestionsRequestedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LinguisticDetails(&self, out: *mut *mut super::SearchQueryLinguisticDetails) -> HRESULT,
    fn get_Request(&self, out: *mut *mut super::SearchSuggestionsRequest) -> HRESULT
}}
impl ISearchSuggestionsRequestedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<super::SearchQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<super::SearchSuggestionsRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchSuggestionsRequestedEventArgs: ISearchSuggestionsRequestedEventArgs}
} // Windows.ApplicationModel.Search.Core
} // Windows.ApplicationModel.Search
pub mod background { // Windows.ApplicationModel.Background
use ::prelude::*;
DEFINE_IID!(IID_IActivitySensorTrigger, 3504161602, 58235, 18467, 165, 254, 107, 49, 223, 239, 222, 176);
RT_INTERFACE!{interface IActivitySensorTrigger(IActivitySensorTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorTrigger] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_SubscribedActivities(&self, out: *mut *mut super::super::foundation::collections::IVector<super::super::devices::sensors::ActivityType>) -> HRESULT,
    fn get_ReportInterval(&self, out: *mut u32) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_SupportedActivities(&self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::devices::sensors::ActivityType>) -> HRESULT,
    fn get_MinimumReportInterval(&self, out: *mut u32) -> HRESULT
}}
impl IActivitySensorTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_subscribed_activities(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<super::super::devices::sensors::ActivityType>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SubscribedActivities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_report_interval(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ReportInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_supported_activities(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<super::super::devices::sensors::ActivityType>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedActivities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_minimum_report_interval(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinimumReportInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ActivitySensorTrigger: IActivitySensorTrigger}
impl RtActivatable<IActivitySensorTriggerFactory> for ActivitySensorTrigger {}
impl ActivitySensorTrigger {
    #[inline] pub fn create(reportIntervalInMilliseconds: u32) -> Result<ComPtr<ActivitySensorTrigger>> { unsafe {
        <Self as RtActivatable<IActivitySensorTriggerFactory>>::get_activation_factory().create(reportIntervalInMilliseconds)
    }}
}
DEFINE_CLSID!(ActivitySensorTrigger: "Windows.ApplicationModel.Background.ActivitySensorTrigger");
DEFINE_IID!(IID_IActivitySensorTriggerFactory, 2804322755, 14391, 17655, 131, 27, 1, 50, 204, 135, 43, 195);
RT_INTERFACE!{static interface IActivitySensorTriggerFactory(IActivitySensorTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IActivitySensorTriggerFactory] {
    fn Create(&self, reportIntervalInMilliseconds: u32, out: *mut *mut ActivitySensorTrigger) -> HRESULT
}}
impl IActivitySensorTriggerFactory {
    #[inline] pub unsafe fn create(&self, reportIntervalInMilliseconds: u32) -> Result<ComPtr<ActivitySensorTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, reportIntervalInMilliseconds, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AlarmAccessStatus: i32 {
    Unspecified (AlarmAccessStatus_Unspecified) = 0, AllowedWithWakeupCapability (AlarmAccessStatus_AllowedWithWakeupCapability) = 1, AllowedWithoutWakeupCapability (AlarmAccessStatus_AllowedWithoutWakeupCapability) = 2, Denied (AlarmAccessStatus_Denied) = 3,
}}
RT_CLASS!{static class AlarmApplicationManager}
impl RtActivatable<IAlarmApplicationManagerStatics> for AlarmApplicationManager {}
impl AlarmApplicationManager {
    #[inline] pub fn request_access_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<AlarmAccessStatus>>> { unsafe {
        <Self as RtActivatable<IAlarmApplicationManagerStatics>>::get_activation_factory().request_access_async()
    }}
    #[inline] pub fn get_access_status() -> Result<AlarmAccessStatus> { unsafe {
        <Self as RtActivatable<IAlarmApplicationManagerStatics>>::get_activation_factory().get_access_status()
    }}
}
DEFINE_CLSID!(AlarmApplicationManager: "Windows.ApplicationModel.Background.AlarmApplicationManager");
DEFINE_IID!(IID_IAlarmApplicationManagerStatics, 3389258299, 52454, 19938, 176, 155, 150, 40, 189, 51, 187, 190);
RT_INTERFACE!{static interface IAlarmApplicationManagerStatics(IAlarmApplicationManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAlarmApplicationManagerStatics] {
    fn RequestAccessAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<AlarmAccessStatus>) -> HRESULT,
    fn GetAccessStatus(&self, out: *mut AlarmAccessStatus) -> HRESULT
}}
impl IAlarmApplicationManagerStatics {
    #[inline] pub unsafe fn request_access_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AlarmAccessStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAccessAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_status(&self) -> Result<AlarmAccessStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAccessStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBroadcastTrigger, 1960113302, 36151, 17644, 148, 129, 42, 11, 152, 84, 235, 72);
RT_INTERFACE!{interface IAppBroadcastTrigger(IAppBroadcastTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IAppBroadcastTrigger] {
    fn put_ProviderInfo(&self, value: *mut AppBroadcastTriggerProviderInfo) -> HRESULT,
    fn get_ProviderInfo(&self, out: *mut *mut AppBroadcastTriggerProviderInfo) -> HRESULT
}}
impl IAppBroadcastTrigger {
    #[inline] pub unsafe fn set_provider_info(&self, value: &AppBroadcastTriggerProviderInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ProviderInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_provider_info(&self) -> Result<ComPtr<AppBroadcastTriggerProviderInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProviderInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppBroadcastTrigger: IAppBroadcastTrigger}
impl RtActivatable<IAppBroadcastTriggerFactory> for AppBroadcastTrigger {}
impl AppBroadcastTrigger {
    #[inline] pub fn create_app_broadcast_trigger(providerKey: &HStringArg) -> Result<ComPtr<AppBroadcastTrigger>> { unsafe {
        <Self as RtActivatable<IAppBroadcastTriggerFactory>>::get_activation_factory().create_app_broadcast_trigger(providerKey)
    }}
}
DEFINE_CLSID!(AppBroadcastTrigger: "Windows.ApplicationModel.Background.AppBroadcastTrigger");
DEFINE_IID!(IID_IAppBroadcastTriggerFactory, 671850308, 8948, 17944, 160, 46, 231, 228, 17, 235, 114, 56);
RT_INTERFACE!{static interface IAppBroadcastTriggerFactory(IAppBroadcastTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IAppBroadcastTriggerFactory] {
    fn CreateAppBroadcastTrigger(&self, providerKey: HSTRING, out: *mut *mut AppBroadcastTrigger) -> HRESULT
}}
impl IAppBroadcastTriggerFactory {
    #[inline] pub unsafe fn create_app_broadcast_trigger(&self, providerKey: &HStringArg) -> Result<ComPtr<AppBroadcastTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAppBroadcastTrigger)(self as *const _ as *mut _, providerKey.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppBroadcastTriggerProviderInfo, 4061738285, 40424, 17440, 156, 226, 94, 255, 143, 23, 55, 107);
RT_INTERFACE!{interface IAppBroadcastTriggerProviderInfo(IAppBroadcastTriggerProviderInfoVtbl): IInspectable(IInspectableVtbl) [IID_IAppBroadcastTriggerProviderInfo] {
    fn put_DisplayNameResource(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayNameResource(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LogoResource(&self, value: HSTRING) -> HRESULT,
    fn get_LogoResource(&self, out: *mut HSTRING) -> HRESULT,
    fn put_VideoKeyFrameInterval(&self, value: super::super::foundation::TimeSpan) -> HRESULT,
    fn get_VideoKeyFrameInterval(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn put_MaxVideoBitrate(&self, value: u32) -> HRESULT,
    fn get_MaxVideoBitrate(&self, out: *mut u32) -> HRESULT,
    fn put_MaxVideoWidth(&self, value: u32) -> HRESULT,
    fn get_MaxVideoWidth(&self, out: *mut u32) -> HRESULT,
    fn put_MaxVideoHeight(&self, value: u32) -> HRESULT,
    fn get_MaxVideoHeight(&self, out: *mut u32) -> HRESULT
}}
impl IAppBroadcastTriggerProviderInfo {
    #[inline] pub unsafe fn set_display_name_resource(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayNameResource)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name_resource(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayNameResource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_logo_resource(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LogoResource)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_logo_resource(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LogoResource)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_video_key_frame_interval(&self, value: super::super::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_VideoKeyFrameInterval)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_video_key_frame_interval(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_VideoKeyFrameInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_video_bitrate(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxVideoBitrate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_video_bitrate(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxVideoBitrate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_video_width(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxVideoWidth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_video_width(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxVideoWidth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_video_height(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxVideoHeight)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_video_height(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxVideoHeight)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppBroadcastTriggerProviderInfo: IAppBroadcastTriggerProviderInfo}
DEFINE_IID!(IID_IApplicationTrigger, 189171248, 38260, 18732, 158, 147, 26, 58, 230, 51, 95, 233);
RT_INTERFACE!{interface IApplicationTrigger(IApplicationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationTrigger] {
    fn RequestAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ApplicationTriggerResult>) -> HRESULT,
    fn RequestAsyncWithArguments(&self, arguments: *mut super::super::foundation::collections::ValueSet, out: *mut *mut super::super::foundation::IAsyncOperation<ApplicationTriggerResult>) -> HRESULT
}}
impl IApplicationTrigger {
    #[inline] pub unsafe fn request_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ApplicationTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_async_with_arguments(&self, arguments: &super::super::foundation::collections::ValueSet) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ApplicationTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsyncWithArguments)(self as *const _ as *mut _, arguments as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ApplicationTrigger: IApplicationTrigger}
impl RtActivatable<IActivationFactory> for ApplicationTrigger {}
DEFINE_CLSID!(ApplicationTrigger: "Windows.ApplicationModel.Background.ApplicationTrigger");
DEFINE_IID!(IID_IApplicationTriggerDetails, 2547804850, 8729, 19102, 156, 94, 65, 208, 71, 247, 110, 130);
RT_INTERFACE!{interface IApplicationTriggerDetails(IApplicationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationTriggerDetails] {
    fn get_Arguments(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT
}}
impl IApplicationTriggerDetails {
    #[inline] pub unsafe fn get_arguments(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ApplicationTriggerDetails: IApplicationTriggerDetails}
RT_ENUM! { enum ApplicationTriggerResult: i32 {
    Allowed (ApplicationTriggerResult_Allowed) = 0, CurrentlyRunning (ApplicationTriggerResult_CurrentlyRunning) = 1, DisabledByPolicy (ApplicationTriggerResult_DisabledByPolicy) = 2, UnknownError (ApplicationTriggerResult_UnknownError) = 3,
}}
DEFINE_IID!(IID_IAppointmentStoreNotificationTrigger, 1691616268, 49665, 17069, 170, 42, 226, 27, 163, 66, 91, 109);
RT_INTERFACE!{interface IAppointmentStoreNotificationTrigger(IAppointmentStoreNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreNotificationTrigger] {
    
}}
RT_CLASS!{class AppointmentStoreNotificationTrigger: IAppointmentStoreNotificationTrigger}
impl RtActivatable<IActivationFactory> for AppointmentStoreNotificationTrigger {}
DEFINE_CLSID!(AppointmentStoreNotificationTrigger: "Windows.ApplicationModel.Background.AppointmentStoreNotificationTrigger");
RT_ENUM! { enum BackgroundAccessStatus: i32 {
    Unspecified (BackgroundAccessStatus_Unspecified) = 0, AllowedWithAlwaysOnRealTimeConnectivity (BackgroundAccessStatus_AllowedWithAlwaysOnRealTimeConnectivity) = 1, AllowedMayUseActiveRealTimeConnectivity (BackgroundAccessStatus_AllowedMayUseActiveRealTimeConnectivity) = 2, Denied (BackgroundAccessStatus_Denied) = 3, AlwaysAllowed (BackgroundAccessStatus_AlwaysAllowed) = 4, AllowedSubjectToSystemPolicy (BackgroundAccessStatus_AllowedSubjectToSystemPolicy) = 5, DeniedBySystemPolicy (BackgroundAccessStatus_DeniedBySystemPolicy) = 6, DeniedByUser (BackgroundAccessStatus_DeniedByUser) = 7,
}}
DEFINE_IID!(IID_IBackgroundCondition, 2923995630, 35153, 16394, 131, 2, 156, 156, 154, 42, 58, 59);
RT_INTERFACE!{interface IBackgroundCondition(IBackgroundConditionVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundCondition] {
    
}}
RT_CLASS!{static class BackgroundExecutionManager}
impl RtActivatable<IBackgroundExecutionManagerStatics> for BackgroundExecutionManager {}
impl BackgroundExecutionManager {
    #[inline] pub fn request_access_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<BackgroundAccessStatus>>> { unsafe {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().request_access_async()
    }}
    #[inline] pub fn request_access_for_application_async(applicationId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<BackgroundAccessStatus>>> { unsafe {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().request_access_for_application_async(applicationId)
    }}
    #[inline] pub fn remove_access() -> Result<()> { unsafe {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().remove_access()
    }}
    #[inline] pub fn remove_access_for_application(applicationId: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().remove_access_for_application(applicationId)
    }}
    #[inline] pub fn get_access_status() -> Result<BackgroundAccessStatus> { unsafe {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().get_access_status()
    }}
    #[inline] pub fn get_access_status_for_application(applicationId: &HStringArg) -> Result<BackgroundAccessStatus> { unsafe {
        <Self as RtActivatable<IBackgroundExecutionManagerStatics>>::get_activation_factory().get_access_status_for_application(applicationId)
    }}
}
DEFINE_CLSID!(BackgroundExecutionManager: "Windows.ApplicationModel.Background.BackgroundExecutionManager");
DEFINE_IID!(IID_IBackgroundExecutionManagerStatics, 3894864472, 26281, 19777, 131, 212, 180, 193, 140, 135, 184, 70);
RT_INTERFACE!{static interface IBackgroundExecutionManagerStatics(IBackgroundExecutionManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundExecutionManagerStatics] {
    fn RequestAccessAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<BackgroundAccessStatus>) -> HRESULT,
    fn RequestAccessForApplicationAsync(&self, applicationId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<BackgroundAccessStatus>) -> HRESULT,
    fn RemoveAccess(&self) -> HRESULT,
    fn RemoveAccessForApplication(&self, applicationId: HSTRING) -> HRESULT,
    fn GetAccessStatus(&self, out: *mut BackgroundAccessStatus) -> HRESULT,
    fn GetAccessStatusForApplication(&self, applicationId: HSTRING, out: *mut BackgroundAccessStatus) -> HRESULT
}}
impl IBackgroundExecutionManagerStatics {
    #[inline] pub unsafe fn request_access_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<BackgroundAccessStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAccessAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_access_for_application_async(&self, applicationId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<BackgroundAccessStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAccessForApplicationAsync)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveAccess)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_access_for_application(&self, applicationId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveAccessForApplication)(self as *const _ as *mut _, applicationId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_status(&self) -> Result<BackgroundAccessStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAccessStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_access_status_for_application(&self, applicationId: &HStringArg) -> Result<BackgroundAccessStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAccessStatusForApplication)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTask, 2098451764, 64786, 17358, 140, 34, 234, 31, 241, 60, 6, 223);
RT_INTERFACE!{interface IBackgroundTask(IBackgroundTaskVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTask] {
    fn Run(&self, taskInstance: *mut IBackgroundTaskInstance) -> HRESULT
}}
impl IBackgroundTask {
    #[inline] pub unsafe fn run(&self, taskInstance: &IBackgroundTaskInstance) -> Result<()> {
        let hr = ((*self.lpVtbl).Run)(self as *const _ as *mut _, taskInstance as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskBuilder, 55661838, 15972, 17778, 169, 58, 132, 7, 90, 55, 201, 23);
RT_INTERFACE!{interface IBackgroundTaskBuilder(IBackgroundTaskBuilderVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskBuilder] {
    fn put_TaskEntryPoint(&self, value: HSTRING) -> HRESULT,
    fn get_TaskEntryPoint(&self, out: *mut HSTRING) -> HRESULT,
    fn SetTrigger(&self, trigger: *mut IBackgroundTrigger) -> HRESULT,
    fn AddCondition(&self, condition: *mut IBackgroundCondition) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn Register(&self, out: *mut *mut BackgroundTaskRegistration) -> HRESULT
}}
impl IBackgroundTaskBuilder {
    #[inline] pub unsafe fn set_task_entry_point(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TaskEntryPoint)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_entry_point(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskEntryPoint)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_trigger(&self, trigger: &IBackgroundTrigger) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTrigger)(self as *const _ as *mut _, trigger as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_condition(&self, condition: &IBackgroundCondition) -> Result<()> {
        let hr = ((*self.lpVtbl).AddCondition)(self as *const _ as *mut _, condition as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn register(&self) -> Result<ComPtr<BackgroundTaskRegistration>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Register)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundTaskBuilder: IBackgroundTaskBuilder}
impl RtActivatable<IActivationFactory> for BackgroundTaskBuilder {}
DEFINE_CLSID!(BackgroundTaskBuilder: "Windows.ApplicationModel.Background.BackgroundTaskBuilder");
DEFINE_IID!(IID_IBackgroundTaskBuilder2, 1793576881, 4175, 16493, 141, 182, 132, 74, 87, 15, 66, 187);
RT_INTERFACE!{interface IBackgroundTaskBuilder2(IBackgroundTaskBuilder2Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskBuilder2] {
    fn put_CancelOnConditionLoss(&self, value: bool) -> HRESULT,
    fn get_CancelOnConditionLoss(&self, out: *mut bool) -> HRESULT
}}
impl IBackgroundTaskBuilder2 {
    #[inline] pub unsafe fn set_cancel_on_condition_loss(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CancelOnConditionLoss)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cancel_on_condition_loss(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CancelOnConditionLoss)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskBuilder3, 684150602, 35753, 19465, 162, 79, 25, 104, 62, 44, 146, 76);
RT_INTERFACE!{interface IBackgroundTaskBuilder3(IBackgroundTaskBuilder3Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskBuilder3] {
    fn put_IsNetworkRequested(&self, value: bool) -> HRESULT,
    fn get_IsNetworkRequested(&self, out: *mut bool) -> HRESULT
}}
impl IBackgroundTaskBuilder3 {
    #[inline] pub unsafe fn set_is_network_requested(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsNetworkRequested)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_network_requested(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsNetworkRequested)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskBuilder4, 1196811554, 52130, 20021, 189, 22, 166, 218, 127, 28, 25, 170);
RT_INTERFACE!{interface IBackgroundTaskBuilder4(IBackgroundTaskBuilder4Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskBuilder4] {
    fn get_TaskGroup(&self, out: *mut *mut BackgroundTaskRegistrationGroup) -> HRESULT,
    fn put_TaskGroup(&self, value: *mut BackgroundTaskRegistrationGroup) -> HRESULT
}}
impl IBackgroundTaskBuilder4 {
    #[inline] pub unsafe fn get_task_group(&self) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskGroup)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_task_group(&self, value: &BackgroundTaskRegistrationGroup) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TaskGroup)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_BackgroundTaskCanceledEventHandler, 2797910720, 20984, 19543, 172, 63, 21, 109, 209, 104, 12, 79);
RT_DELEGATE!{delegate BackgroundTaskCanceledEventHandler(BackgroundTaskCanceledEventHandlerVtbl, BackgroundTaskCanceledEventHandlerImpl) [IID_BackgroundTaskCanceledEventHandler] {
    fn Invoke(&self, sender: *mut IBackgroundTaskInstance, reason: BackgroundTaskCancellationReason) -> HRESULT
}}
impl BackgroundTaskCanceledEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &IBackgroundTaskInstance, reason: BackgroundTaskCancellationReason) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, reason);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum BackgroundTaskCancellationReason: i32 {
    Abort (BackgroundTaskCancellationReason_Abort) = 0, Terminating (BackgroundTaskCancellationReason_Terminating) = 1, LoggingOff (BackgroundTaskCancellationReason_LoggingOff) = 2, ServicingUpdate (BackgroundTaskCancellationReason_ServicingUpdate) = 3, IdleTask (BackgroundTaskCancellationReason_IdleTask) = 4, Uninstall (BackgroundTaskCancellationReason_Uninstall) = 5, ConditionLoss (BackgroundTaskCancellationReason_ConditionLoss) = 6, SystemPolicy (BackgroundTaskCancellationReason_SystemPolicy) = 7, QuietHoursEntered (BackgroundTaskCancellationReason_QuietHoursEntered) = 8, ExecutionTimeExceeded (BackgroundTaskCancellationReason_ExecutionTimeExceeded) = 9, ResourceRevocation (BackgroundTaskCancellationReason_ResourceRevocation) = 10, EnergySaver (BackgroundTaskCancellationReason_EnergySaver) = 11,
}}
DEFINE_IID!(IID_IBackgroundTaskCompletedEventArgs, 1448945103, 61961, 18676, 153, 103, 43, 24, 79, 123, 251, 240);
RT_INTERFACE!{interface IBackgroundTaskCompletedEventArgs(IBackgroundTaskCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskCompletedEventArgs] {
    fn get_InstanceId(&self, out: *mut Guid) -> HRESULT,
    fn CheckResult(&self) -> HRESULT
}}
impl IBackgroundTaskCompletedEventArgs {
    #[inline] pub unsafe fn get_instance_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstanceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn check_result(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).CheckResult)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundTaskCompletedEventArgs: IBackgroundTaskCompletedEventArgs}
DEFINE_IID!(IID_BackgroundTaskCompletedEventHandler, 1530456361, 41094, 18087, 166, 120, 67, 145, 53, 130, 43, 207);
RT_DELEGATE!{delegate BackgroundTaskCompletedEventHandler(BackgroundTaskCompletedEventHandlerVtbl, BackgroundTaskCompletedEventHandlerImpl) [IID_BackgroundTaskCompletedEventHandler] {
    fn Invoke(&self, sender: *mut BackgroundTaskRegistration, args: *mut BackgroundTaskCompletedEventArgs) -> HRESULT
}}
impl BackgroundTaskCompletedEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &BackgroundTaskRegistration, args: &BackgroundTaskCompletedEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskDeferral, 2479625581, 44839, 19923, 132, 110, 36, 238, 64, 202, 221, 37);
RT_INTERFACE!{interface IBackgroundTaskDeferral(IBackgroundTaskDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IBackgroundTaskDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundTaskDeferral: IBackgroundTaskDeferral}
DEFINE_IID!(IID_IBackgroundTaskInstance, 2254166650, 8664, 17779, 143, 50, 146, 138, 27, 6, 65, 246);
RT_INTERFACE!{interface IBackgroundTaskInstance(IBackgroundTaskInstanceVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskInstance] {
    fn get_InstanceId(&self, out: *mut Guid) -> HRESULT,
    fn get_Task(&self, out: *mut *mut BackgroundTaskRegistration) -> HRESULT,
    fn get_Progress(&self, out: *mut u32) -> HRESULT,
    fn put_Progress(&self, value: u32) -> HRESULT,
    fn get_TriggerDetails(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn add_Canceled(&self, cancelHandler: *mut BackgroundTaskCanceledEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Canceled(&self, cookie: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_SuspendedCount(&self, out: *mut u32) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut BackgroundTaskDeferral) -> HRESULT
}}
impl IBackgroundTaskInstance {
    #[inline] pub unsafe fn get_instance_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstanceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task(&self) -> Result<ComPtr<BackgroundTaskRegistration>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Task)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_progress(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Progress)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_trigger_details(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TriggerDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_canceled(&self, cancelHandler: &BackgroundTaskCanceledEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Canceled)(self as *const _ as *mut _, cancelHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_canceled(&self, cookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Canceled)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_suspended_count(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SuspendedCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<BackgroundTaskDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskInstance2, 1333592438, 3190, 20404, 137, 109, 93, 225, 134, 65, 34, 246);
RT_INTERFACE!{interface IBackgroundTaskInstance2(IBackgroundTaskInstance2Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskInstance2] {
    fn GetThrottleCount(&self, counter: BackgroundTaskThrottleCounter, out: *mut u32) -> HRESULT
}}
impl IBackgroundTaskInstance2 {
    #[inline] pub unsafe fn get_throttle_count(&self, counter: BackgroundTaskThrottleCounter) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetThrottleCount)(self as *const _ as *mut _, counter, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskInstance4, 2133455420, 43524, 19208, 151, 176, 6, 216, 116, 205, 171, 245);
RT_INTERFACE!{interface IBackgroundTaskInstance4(IBackgroundTaskInstance4Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskInstance4] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IBackgroundTaskInstance4 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskProgressEventArgs, 4212418732, 33586, 19722, 149, 50, 3, 234, 230, 132, 218, 49);
RT_INTERFACE!{interface IBackgroundTaskProgressEventArgs(IBackgroundTaskProgressEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskProgressEventArgs] {
    fn get_InstanceId(&self, out: *mut Guid) -> HRESULT,
    fn get_Progress(&self, out: *mut u32) -> HRESULT
}}
impl IBackgroundTaskProgressEventArgs {
    #[inline] pub unsafe fn get_instance_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstanceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_progress(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Progress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundTaskProgressEventArgs: IBackgroundTaskProgressEventArgs}
DEFINE_IID!(IID_BackgroundTaskProgressEventHandler, 1189111868, 35464, 19609, 128, 76, 118, 137, 127, 98, 119, 166);
RT_DELEGATE!{delegate BackgroundTaskProgressEventHandler(BackgroundTaskProgressEventHandlerVtbl, BackgroundTaskProgressEventHandlerImpl) [IID_BackgroundTaskProgressEventHandler] {
    fn Invoke(&self, sender: *mut BackgroundTaskRegistration, args: *mut BackgroundTaskProgressEventArgs) -> HRESULT
}}
impl BackgroundTaskProgressEventHandler {
    #[inline] pub unsafe fn invoke(&self, sender: &BackgroundTaskRegistration, args: &BackgroundTaskProgressEventArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, sender as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskRegistration, 275074242, 41582, 17343, 140, 18, 31, 180, 13, 191, 191, 160);
RT_INTERFACE!{interface IBackgroundTaskRegistration(IBackgroundTaskRegistrationVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistration] {
    fn get_TaskId(&self, out: *mut Guid) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn add_Progress(&self, handler: *mut BackgroundTaskProgressEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Progress(&self, cookie: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Completed(&self, handler: *mut BackgroundTaskCompletedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, cookie: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn Unregister(&self, cancelTask: bool) -> HRESULT
}}
impl IBackgroundTaskRegistration {
    #[inline] pub unsafe fn get_task_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TaskId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_progress(&self, handler: &BackgroundTaskProgressEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Progress)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_progress(&self, cookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Progress)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_completed(&self, handler: &BackgroundTaskCompletedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_completed(&self, cookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn unregister(&self, cancelTask: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).Unregister)(self as *const _ as *mut _, cancelTask);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundTaskRegistration: IBackgroundTaskRegistration}
impl RtActivatable<IBackgroundTaskRegistrationStatics> for BackgroundTaskRegistration {}
impl RtActivatable<IBackgroundTaskRegistrationStatics2> for BackgroundTaskRegistration {}
impl BackgroundTaskRegistration {
    #[inline] pub fn get_all_tasks() -> Result<ComPtr<super::super::foundation::collections::IMapView<Guid, IBackgroundTaskRegistration>>> { unsafe {
        <Self as RtActivatable<IBackgroundTaskRegistrationStatics>>::get_activation_factory().get_all_tasks()
    }}
    #[inline] pub fn get_all_task_groups() -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, BackgroundTaskRegistrationGroup>>> { unsafe {
        <Self as RtActivatable<IBackgroundTaskRegistrationStatics2>>::get_activation_factory().get_all_task_groups()
    }}
    #[inline] pub fn get_task_group(groupId: &HStringArg) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> { unsafe {
        <Self as RtActivatable<IBackgroundTaskRegistrationStatics2>>::get_activation_factory().get_task_group(groupId)
    }}
}
DEFINE_CLSID!(BackgroundTaskRegistration: "Windows.ApplicationModel.Background.BackgroundTaskRegistration");
DEFINE_IID!(IID_IBackgroundTaskRegistration2, 1631110915, 48006, 16658, 175, 195, 127, 147, 155, 22, 110, 59);
RT_INTERFACE!{interface IBackgroundTaskRegistration2(IBackgroundTaskRegistration2Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistration2] {
    fn get_Trigger(&self, out: *mut *mut IBackgroundTrigger) -> HRESULT
}}
impl IBackgroundTaskRegistration2 {
    #[inline] pub unsafe fn get_trigger(&self) -> Result<ComPtr<IBackgroundTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Trigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskRegistration3, 4264788373, 37923, 19851, 131, 13, 177, 221, 44, 123, 173, 213);
RT_INTERFACE!{interface IBackgroundTaskRegistration3(IBackgroundTaskRegistration3Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistration3] {
    fn get_TaskGroup(&self, out: *mut *mut BackgroundTaskRegistrationGroup) -> HRESULT
}}
impl IBackgroundTaskRegistration3 {
    #[inline] pub unsafe fn get_task_group(&self) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskGroup)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskRegistrationGroup, 716280218, 34587, 16743, 138, 118, 5, 92, 214, 123, 91, 35);
RT_INTERFACE!{interface IBackgroundTaskRegistrationGroup(IBackgroundTaskRegistrationGroupVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistrationGroup] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn add_BackgroundActivated(&self, handler: *mut super::super::foundation::TypedEventHandler<BackgroundTaskRegistrationGroup, super::activation::BackgroundActivatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackgroundActivated(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_AllTasks(&self, out: *mut *mut super::super::foundation::collections::IMapView<Guid, BackgroundTaskRegistration>) -> HRESULT
}}
impl IBackgroundTaskRegistrationGroup {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_background_activated(&self, handler: &super::super::foundation::TypedEventHandler<BackgroundTaskRegistrationGroup, super::activation::BackgroundActivatedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BackgroundActivated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_background_activated(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BackgroundActivated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_all_tasks(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<Guid, BackgroundTaskRegistration>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllTasks)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundTaskRegistrationGroup: IBackgroundTaskRegistrationGroup}
impl RtActivatable<IBackgroundTaskRegistrationGroupFactory> for BackgroundTaskRegistrationGroup {}
impl BackgroundTaskRegistrationGroup {
    #[inline] pub fn create(id: &HStringArg) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> { unsafe {
        <Self as RtActivatable<IBackgroundTaskRegistrationGroupFactory>>::get_activation_factory().create(id)
    }}
    #[inline] pub fn create_with_name(id: &HStringArg, name: &HStringArg) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> { unsafe {
        <Self as RtActivatable<IBackgroundTaskRegistrationGroupFactory>>::get_activation_factory().create_with_name(id, name)
    }}
}
DEFINE_CLSID!(BackgroundTaskRegistrationGroup: "Windows.ApplicationModel.Background.BackgroundTaskRegistrationGroup");
DEFINE_IID!(IID_IBackgroundTaskRegistrationGroupFactory, 2212047721, 17615, 17969, 151, 64, 3, 199, 216, 116, 27, 197);
RT_INTERFACE!{static interface IBackgroundTaskRegistrationGroupFactory(IBackgroundTaskRegistrationGroupFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistrationGroupFactory] {
    fn Create(&self, id: HSTRING, out: *mut *mut BackgroundTaskRegistrationGroup) -> HRESULT,
    fn CreateWithName(&self, id: HSTRING, name: HSTRING, out: *mut *mut BackgroundTaskRegistrationGroup) -> HRESULT
}}
impl IBackgroundTaskRegistrationGroupFactory {
    #[inline] pub unsafe fn create(&self, id: &HStringArg) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_name(&self, id: &HStringArg, name: &HStringArg) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithName)(self as *const _ as *mut _, id.get(), name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskRegistrationStatics, 1280585577, 45056, 17082, 160, 147, 106, 86, 60, 101, 227, 248);
RT_INTERFACE!{static interface IBackgroundTaskRegistrationStatics(IBackgroundTaskRegistrationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistrationStatics] {
    fn get_AllTasks(&self, out: *mut *mut super::super::foundation::collections::IMapView<Guid, IBackgroundTaskRegistration>) -> HRESULT
}}
impl IBackgroundTaskRegistrationStatics {
    #[inline] pub unsafe fn get_all_tasks(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<Guid, IBackgroundTaskRegistration>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllTasks)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IBackgroundTaskRegistrationStatics2, 390817566, 45581, 20393, 173, 154, 233, 58, 214, 199, 30, 1);
RT_INTERFACE!{static interface IBackgroundTaskRegistrationStatics2(IBackgroundTaskRegistrationStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTaskRegistrationStatics2] {
    fn get_AllTaskGroups(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, BackgroundTaskRegistrationGroup>) -> HRESULT,
    fn GetTaskGroup(&self, groupId: HSTRING, out: *mut *mut BackgroundTaskRegistrationGroup) -> HRESULT
}}
impl IBackgroundTaskRegistrationStatics2 {
    #[inline] pub unsafe fn get_all_task_groups(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, BackgroundTaskRegistrationGroup>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllTaskGroups)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_group(&self, groupId: &HStringArg) -> Result<ComPtr<BackgroundTaskRegistrationGroup>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTaskGroup)(self as *const _ as *mut _, groupId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum BackgroundTaskThrottleCounter: i32 {
    All (BackgroundTaskThrottleCounter_All) = 0, Cpu (BackgroundTaskThrottleCounter_Cpu) = 1, Network (BackgroundTaskThrottleCounter_Network) = 2,
}}
DEFINE_IID!(IID_IBackgroundTrigger, 2226364504, 24615, 19335, 151, 144, 189, 243, 247, 87, 219, 215);
RT_INTERFACE!{interface IBackgroundTrigger(IBackgroundTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundTrigger] {
    
}}
RT_CLASS!{static class BackgroundWorkCost}
impl RtActivatable<IBackgroundWorkCostStatics> for BackgroundWorkCost {}
impl BackgroundWorkCost {
    #[inline] pub fn get_current_background_work_cost() -> Result<BackgroundWorkCostValue> { unsafe {
        <Self as RtActivatable<IBackgroundWorkCostStatics>>::get_activation_factory().get_current_background_work_cost()
    }}
}
DEFINE_CLSID!(BackgroundWorkCost: "Windows.ApplicationModel.Background.BackgroundWorkCost");
DEFINE_IID!(IID_IBackgroundWorkCostStatics, 3342902882, 49936, 19330, 179, 227, 59, 207, 185, 228, 199, 125);
RT_INTERFACE!{static interface IBackgroundWorkCostStatics(IBackgroundWorkCostStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundWorkCostStatics] {
    fn get_CurrentBackgroundWorkCost(&self, out: *mut BackgroundWorkCostValue) -> HRESULT
}}
impl IBackgroundWorkCostStatics {
    #[inline] pub unsafe fn get_current_background_work_cost(&self) -> Result<BackgroundWorkCostValue> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentBackgroundWorkCost)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum BackgroundWorkCostValue: i32 {
    Low (BackgroundWorkCostValue_Low) = 0, Medium (BackgroundWorkCostValue_Medium) = 1, High (BackgroundWorkCostValue_High) = 2,
}}
DEFINE_IID!(IID_IBluetoothLEAdvertisementPublisherTrigger, 2872976914, 9683, 18606, 135, 36, 216, 24, 119, 174, 97, 41);
RT_INTERFACE!{interface IBluetoothLEAdvertisementPublisherTrigger(IBluetoothLEAdvertisementPublisherTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementPublisherTrigger] {
    #[cfg(feature="windows-devices")] fn get_Advertisement(&self, out: *mut *mut super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisement) -> HRESULT
}}
impl IBluetoothLEAdvertisementPublisherTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_advertisement(&self) -> Result<ComPtr<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisement>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Advertisement)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BluetoothLEAdvertisementPublisherTrigger: IBluetoothLEAdvertisementPublisherTrigger}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementPublisherTrigger {}
DEFINE_CLSID!(BluetoothLEAdvertisementPublisherTrigger: "Windows.ApplicationModel.Background.BluetoothLEAdvertisementPublisherTrigger");
DEFINE_IID!(IID_IBluetoothLEAdvertisementWatcherTrigger, 447420441, 48353, 18667, 168, 39, 89, 251, 124, 238, 82, 166);
RT_INTERFACE!{interface IBluetoothLEAdvertisementWatcherTrigger(IBluetoothLEAdvertisementWatcherTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IBluetoothLEAdvertisementWatcherTrigger] {
    fn get_MinSamplingInterval(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn get_MaxSamplingInterval(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn get_MinOutOfRangeTimeout(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn get_MaxOutOfRangeTimeout(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_SignalStrengthFilter(&self, out: *mut *mut super::super::devices::bluetooth::BluetoothSignalStrengthFilter) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_SignalStrengthFilter(&self, value: *mut super::super::devices::bluetooth::BluetoothSignalStrengthFilter) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_AdvertisementFilter(&self, out: *mut *mut super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_AdvertisementFilter(&self, value: *mut super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter) -> HRESULT
}}
impl IBluetoothLEAdvertisementWatcherTrigger {
    #[inline] pub unsafe fn get_min_sampling_interval(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinSamplingInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_sampling_interval(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxSamplingInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_min_out_of_range_timeout(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MinOutOfRangeTimeout)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_out_of_range_timeout(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxOutOfRangeTimeout)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_signal_strength_filter(&self) -> Result<ComPtr<super::super::devices::bluetooth::BluetoothSignalStrengthFilter>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SignalStrengthFilter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_signal_strength_filter(&self, value: &super::super::devices::bluetooth::BluetoothSignalStrengthFilter) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SignalStrengthFilter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_advertisement_filter(&self) -> Result<ComPtr<super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AdvertisementFilter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_advertisement_filter(&self, value: &super::super::devices::bluetooth::advertisement::BluetoothLEAdvertisementFilter) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AdvertisementFilter)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class BluetoothLEAdvertisementWatcherTrigger: IBluetoothLEAdvertisementWatcherTrigger}
impl RtActivatable<IActivationFactory> for BluetoothLEAdvertisementWatcherTrigger {}
DEFINE_CLSID!(BluetoothLEAdvertisementWatcherTrigger: "Windows.ApplicationModel.Background.BluetoothLEAdvertisementWatcherTrigger");
DEFINE_IID!(IID_ICachedFileUpdaterTrigger, 3793530603, 13042, 19761, 181, 83, 185, 224, 27, 222, 55, 224);
RT_INTERFACE!{interface ICachedFileUpdaterTrigger(ICachedFileUpdaterTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ICachedFileUpdaterTrigger] {
    
}}
RT_CLASS!{class CachedFileUpdaterTrigger: ICachedFileUpdaterTrigger}
impl RtActivatable<IActivationFactory> for CachedFileUpdaterTrigger {}
DEFINE_CLSID!(CachedFileUpdaterTrigger: "Windows.ApplicationModel.Background.CachedFileUpdaterTrigger");
DEFINE_IID!(IID_ICachedFileUpdaterTriggerDetails, 1904446483, 4884, 18356, 149, 151, 220, 126, 36, 140, 23, 204);
RT_INTERFACE!{interface ICachedFileUpdaterTriggerDetails(ICachedFileUpdaterTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ICachedFileUpdaterTriggerDetails] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_UpdateTarget(&self, out: *mut super::super::storage::provider::CachedFileTarget) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_UpdateRequest(&self, out: *mut *mut super::super::storage::provider::FileUpdateRequest) -> HRESULT,
    fn get_CanRequestUserInput(&self, out: *mut bool) -> HRESULT
}}
impl ICachedFileUpdaterTriggerDetails {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_update_target(&self) -> Result<super::super::storage::provider::CachedFileTarget> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UpdateTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_update_request(&self) -> Result<ComPtr<super::super::storage::provider::FileUpdateRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UpdateRequest)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_request_user_input(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanRequestUserInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CachedFileUpdaterTriggerDetails: ICachedFileUpdaterTriggerDetails}
DEFINE_IID!(IID_IChatMessageNotificationTrigger, 1362838463, 7488, 23645, 120, 245, 201, 35, 254, 227, 115, 158);
RT_INTERFACE!{interface IChatMessageNotificationTrigger(IChatMessageNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageNotificationTrigger] {
    
}}
RT_CLASS!{class ChatMessageNotificationTrigger: IChatMessageNotificationTrigger}
impl RtActivatable<IActivationFactory> for ChatMessageNotificationTrigger {}
DEFINE_CLSID!(ChatMessageNotificationTrigger: "Windows.ApplicationModel.Background.ChatMessageNotificationTrigger");
DEFINE_IID!(IID_IChatMessageReceivedNotificationTrigger, 1050899982, 47861, 16503, 136, 233, 6, 12, 246, 240, 198, 213);
RT_INTERFACE!{interface IChatMessageReceivedNotificationTrigger(IChatMessageReceivedNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageReceivedNotificationTrigger] {
    
}}
RT_CLASS!{class ChatMessageReceivedNotificationTrigger: IChatMessageReceivedNotificationTrigger}
impl RtActivatable<IActivationFactory> for ChatMessageReceivedNotificationTrigger {}
DEFINE_CLSID!(ChatMessageReceivedNotificationTrigger: "Windows.ApplicationModel.Background.ChatMessageReceivedNotificationTrigger");
DEFINE_IID!(IID_IContactStoreNotificationTrigger, 3358802331, 18181, 17777, 154, 22, 6, 185, 151, 191, 156, 150);
RT_INTERFACE!{interface IContactStoreNotificationTrigger(IContactStoreNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IContactStoreNotificationTrigger] {
    
}}
RT_CLASS!{class ContactStoreNotificationTrigger: IContactStoreNotificationTrigger}
impl RtActivatable<IActivationFactory> for ContactStoreNotificationTrigger {}
DEFINE_CLSID!(ContactStoreNotificationTrigger: "Windows.ApplicationModel.Background.ContactStoreNotificationTrigger");
DEFINE_IID!(IID_IContentPrefetchTrigger, 1896228846, 1274, 17419, 128, 192, 23, 50, 2, 25, 158, 93);
RT_INTERFACE!{interface IContentPrefetchTrigger(IContentPrefetchTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IContentPrefetchTrigger] {
    fn get_WaitInterval(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT
}}
impl IContentPrefetchTrigger {
    #[inline] pub unsafe fn get_wait_interval(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WaitInterval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ContentPrefetchTrigger: IContentPrefetchTrigger}
impl RtActivatable<IContentPrefetchTriggerFactory> for ContentPrefetchTrigger {}
impl RtActivatable<IActivationFactory> for ContentPrefetchTrigger {}
impl ContentPrefetchTrigger {
    #[inline] pub fn create(waitInterval: super::super::foundation::TimeSpan) -> Result<ComPtr<ContentPrefetchTrigger>> { unsafe {
        <Self as RtActivatable<IContentPrefetchTriggerFactory>>::get_activation_factory().create(waitInterval)
    }}
}
DEFINE_CLSID!(ContentPrefetchTrigger: "Windows.ApplicationModel.Background.ContentPrefetchTrigger");
DEFINE_IID!(IID_IContentPrefetchTriggerFactory, 3261349594, 35331, 16542, 184, 196, 136, 129, 76, 40, 204, 182);
RT_INTERFACE!{static interface IContentPrefetchTriggerFactory(IContentPrefetchTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContentPrefetchTriggerFactory] {
    fn Create(&self, waitInterval: super::super::foundation::TimeSpan, out: *mut *mut ContentPrefetchTrigger) -> HRESULT
}}
impl IContentPrefetchTriggerFactory {
    #[inline] pub unsafe fn create(&self, waitInterval: super::super::foundation::TimeSpan) -> Result<ComPtr<ContentPrefetchTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, waitInterval, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDeviceConnectionChangeTrigger, 2424790628, 15581, 20219, 171, 28, 91, 59, 106, 96, 206, 52);
RT_INTERFACE!{interface IDeviceConnectionChangeTrigger(IDeviceConnectionChangeTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceConnectionChangeTrigger] {
    fn get_DeviceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CanMaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn get_MaintainConnection(&self, out: *mut bool) -> HRESULT,
    fn put_MaintainConnection(&self, value: bool) -> HRESULT
}}
impl IDeviceConnectionChangeTrigger {
    #[inline] pub unsafe fn get_device_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_maintain_connection(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanMaintainConnection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_maintain_connection(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaintainConnection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_maintain_connection(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaintainConnection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DeviceConnectionChangeTrigger: IDeviceConnectionChangeTrigger}
impl RtActivatable<IDeviceConnectionChangeTriggerStatics> for DeviceConnectionChangeTrigger {}
impl DeviceConnectionChangeTrigger {
    #[inline] pub fn from_id_async(deviceId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<DeviceConnectionChangeTrigger>>> { unsafe {
        <Self as RtActivatable<IDeviceConnectionChangeTriggerStatics>>::get_activation_factory().from_id_async(deviceId)
    }}
}
DEFINE_CLSID!(DeviceConnectionChangeTrigger: "Windows.ApplicationModel.Background.DeviceConnectionChangeTrigger");
DEFINE_IID!(IID_IDeviceConnectionChangeTriggerStatics, 3286901866, 20221, 17560, 170, 96, 164, 228, 227, 177, 122, 185);
RT_INTERFACE!{static interface IDeviceConnectionChangeTriggerStatics(IDeviceConnectionChangeTriggerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceConnectionChangeTriggerStatics] {
    fn FromIdAsync(&self, deviceId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceConnectionChangeTrigger>) -> HRESULT
}}
impl IDeviceConnectionChangeTriggerStatics {
    #[inline] pub unsafe fn from_id_async(&self, deviceId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<DeviceConnectionChangeTrigger>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FromIdAsync)(self as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDeviceManufacturerNotificationTrigger, 2166852277, 16811, 5850, 134, 194, 127, 123, 240, 145, 47, 91);
RT_INTERFACE!{interface IDeviceManufacturerNotificationTrigger(IDeviceManufacturerNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceManufacturerNotificationTrigger] {
    fn get_TriggerQualifier(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OneShot(&self, out: *mut bool) -> HRESULT
}}
impl IDeviceManufacturerNotificationTrigger {
    #[inline] pub unsafe fn get_trigger_qualifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TriggerQualifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_one_shot(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OneShot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class DeviceManufacturerNotificationTrigger: IDeviceManufacturerNotificationTrigger}
impl RtActivatable<IDeviceManufacturerNotificationTriggerFactory> for DeviceManufacturerNotificationTrigger {}
impl DeviceManufacturerNotificationTrigger {
    #[inline] pub fn create(triggerQualifier: &HStringArg, oneShot: bool) -> Result<ComPtr<DeviceManufacturerNotificationTrigger>> { unsafe {
        <Self as RtActivatable<IDeviceManufacturerNotificationTriggerFactory>>::get_activation_factory().create(triggerQualifier, oneShot)
    }}
}
DEFINE_CLSID!(DeviceManufacturerNotificationTrigger: "Windows.ApplicationModel.Background.DeviceManufacturerNotificationTrigger");
DEFINE_IID!(IID_IDeviceManufacturerNotificationTriggerFactory, 2035670645, 9659, 16723, 161, 162, 48, 41, 252, 171, 182, 82);
RT_INTERFACE!{static interface IDeviceManufacturerNotificationTriggerFactory(IDeviceManufacturerNotificationTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceManufacturerNotificationTriggerFactory] {
    fn Create(&self, triggerQualifier: HSTRING, oneShot: bool, out: *mut *mut DeviceManufacturerNotificationTrigger) -> HRESULT
}}
impl IDeviceManufacturerNotificationTriggerFactory {
    #[inline] pub unsafe fn create(&self, triggerQualifier: &HStringArg, oneShot: bool) -> Result<ComPtr<DeviceManufacturerNotificationTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, triggerQualifier.get(), oneShot, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDeviceServicingTrigger, 447879085, 28212, 18899, 158, 111, 23, 241, 182, 223, 168, 129);
RT_INTERFACE!{interface IDeviceServicingTrigger(IDeviceServicingTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceServicingTrigger] {
    fn RequestAsyncSimple(&self, deviceId: HSTRING, expectedDuration: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceTriggerResult>) -> HRESULT,
    fn RequestAsyncWithArguments(&self, deviceId: HSTRING, expectedDuration: super::super::foundation::TimeSpan, arguments: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceTriggerResult>) -> HRESULT
}}
impl IDeviceServicingTrigger {
    #[inline] pub unsafe fn request_async_simple(&self, deviceId: &HStringArg, expectedDuration: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncOperation<DeviceTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsyncSimple)(self as *const _ as *mut _, deviceId.get(), expectedDuration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_async_with_arguments(&self, deviceId: &HStringArg, expectedDuration: super::super::foundation::TimeSpan, arguments: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<DeviceTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsyncWithArguments)(self as *const _ as *mut _, deviceId.get(), expectedDuration, arguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DeviceServicingTrigger: IDeviceServicingTrigger}
impl RtActivatable<IActivationFactory> for DeviceServicingTrigger {}
DEFINE_CLSID!(DeviceServicingTrigger: "Windows.ApplicationModel.Background.DeviceServicingTrigger");
RT_ENUM! { enum DeviceTriggerResult: i32 {
    Allowed (DeviceTriggerResult_Allowed) = 0, DeniedByUser (DeviceTriggerResult_DeniedByUser) = 1, DeniedBySystem (DeviceTriggerResult_DeniedBySystem) = 2, LowBattery (DeviceTriggerResult_LowBattery) = 3,
}}
DEFINE_IID!(IID_IDeviceUseTrigger, 229015569, 13135, 19799, 182, 236, 109, 202, 100, 180, 18, 228);
RT_INTERFACE!{interface IDeviceUseTrigger(IDeviceUseTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceUseTrigger] {
    fn RequestAsyncSimple(&self, deviceId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceTriggerResult>) -> HRESULT,
    fn RequestAsyncWithArguments(&self, deviceId: HSTRING, arguments: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<DeviceTriggerResult>) -> HRESULT
}}
impl IDeviceUseTrigger {
    #[inline] pub unsafe fn request_async_simple(&self, deviceId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<DeviceTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsyncSimple)(self as *const _ as *mut _, deviceId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_async_with_arguments(&self, deviceId: &HStringArg, arguments: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<DeviceTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsyncWithArguments)(self as *const _ as *mut _, deviceId.get(), arguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DeviceUseTrigger: IDeviceUseTrigger}
impl RtActivatable<IActivationFactory> for DeviceUseTrigger {}
DEFINE_CLSID!(DeviceUseTrigger: "Windows.ApplicationModel.Background.DeviceUseTrigger");
DEFINE_IID!(IID_IDeviceWatcherTrigger, 2757853149, 34163, 16992, 190, 252, 91, 236, 137, 203, 105, 61);
RT_INTERFACE!{interface IDeviceWatcherTrigger(IDeviceWatcherTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceWatcherTrigger] {
    
}}
RT_CLASS!{class DeviceWatcherTrigger: IDeviceWatcherTrigger}
DEFINE_IID!(IID_IEmailStoreNotificationTrigger, 2557282010, 18411, 17000, 164, 242, 243, 247, 113, 136, 56, 138);
RT_INTERFACE!{interface IEmailStoreNotificationTrigger(IEmailStoreNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IEmailStoreNotificationTrigger] {
    
}}
RT_CLASS!{class EmailStoreNotificationTrigger: IEmailStoreNotificationTrigger}
impl RtActivatable<IActivationFactory> for EmailStoreNotificationTrigger {}
DEFINE_CLSID!(EmailStoreNotificationTrigger: "Windows.ApplicationModel.Background.EmailStoreNotificationTrigger");
DEFINE_IID!(IID_IGattCharacteristicNotificationTrigger, 3797913544, 1686, 18255, 167, 50, 242, 146, 176, 206, 188, 93);
RT_INTERFACE!{interface IGattCharacteristicNotificationTrigger(IGattCharacteristicNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTrigger] {
    #[cfg(feature="windows-devices")] fn get_Characteristic(&self, out: *mut *mut super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic) -> HRESULT
}}
impl IGattCharacteristicNotificationTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_characteristic(&self) -> Result<ComPtr<super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Characteristic)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class GattCharacteristicNotificationTrigger: IGattCharacteristicNotificationTrigger}
impl RtActivatable<IGattCharacteristicNotificationTriggerFactory> for GattCharacteristicNotificationTrigger {}
impl RtActivatable<IGattCharacteristicNotificationTriggerFactory2> for GattCharacteristicNotificationTrigger {}
impl GattCharacteristicNotificationTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic) -> Result<ComPtr<GattCharacteristicNotificationTrigger>> { unsafe {
        <Self as RtActivatable<IGattCharacteristicNotificationTriggerFactory>>::get_activation_factory().create(characteristic)
    }}
    #[cfg(feature="windows-devices")] #[inline] pub fn create_with_event_triggering_mode(characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic, eventTriggeringMode: super::super::devices::bluetooth::background::BluetoothEventTriggeringMode) -> Result<ComPtr<GattCharacteristicNotificationTrigger>> { unsafe {
        <Self as RtActivatable<IGattCharacteristicNotificationTriggerFactory2>>::get_activation_factory().create_with_event_triggering_mode(characteristic, eventTriggeringMode)
    }}
}
DEFINE_CLSID!(GattCharacteristicNotificationTrigger: "Windows.ApplicationModel.Background.GattCharacteristicNotificationTrigger");
DEFINE_IID!(IID_IGattCharacteristicNotificationTrigger2, 2468520644, 44558, 17138, 178, 140, 245, 19, 114, 230, 146, 69);
RT_INTERFACE!{interface IGattCharacteristicNotificationTrigger2(IGattCharacteristicNotificationTrigger2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTrigger2] {
    #[cfg(feature="windows-devices")] fn get_EventTriggeringMode(&self, out: *mut super::super::devices::bluetooth::background::BluetoothEventTriggeringMode) -> HRESULT
}}
impl IGattCharacteristicNotificationTrigger2 {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_event_triggering_mode(&self) -> Result<super::super::devices::bluetooth::background::BluetoothEventTriggeringMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EventTriggeringMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerFactory, 1471814037, 45379, 17781, 159, 107, 253, 89, 217, 58, 206, 26);
RT_INTERFACE!{static interface IGattCharacteristicNotificationTriggerFactory(IGattCharacteristicNotificationTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, characteristic: *mut super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic, out: *mut *mut GattCharacteristicNotificationTrigger) -> HRESULT
}}
impl IGattCharacteristicNotificationTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create(&self, characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic) -> Result<ComPtr<GattCharacteristicNotificationTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, characteristic as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGattCharacteristicNotificationTriggerFactory2, 1503193375, 35411, 20127, 163, 44, 35, 205, 51, 102, 76, 238);
RT_INTERFACE!{static interface IGattCharacteristicNotificationTriggerFactory2(IGattCharacteristicNotificationTriggerFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_IGattCharacteristicNotificationTriggerFactory2] {
    #[cfg(feature="windows-devices")] fn CreateWithEventTriggeringMode(&self, characteristic: *mut super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic, eventTriggeringMode: super::super::devices::bluetooth::background::BluetoothEventTriggeringMode, out: *mut *mut GattCharacteristicNotificationTrigger) -> HRESULT
}}
impl IGattCharacteristicNotificationTriggerFactory2 {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create_with_event_triggering_mode(&self, characteristic: &super::super::devices::bluetooth::genericattributeprofile::GattCharacteristic, eventTriggeringMode: super::super::devices::bluetooth::background::BluetoothEventTriggeringMode) -> Result<ComPtr<GattCharacteristicNotificationTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithEventTriggeringMode)(self as *const _ as *mut _, characteristic as *const _ as *mut _, eventTriggeringMode, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGattServiceProviderTrigger, 3720782825, 5463, 19416, 133, 66, 70, 138, 160, 198, 150, 246);
RT_INTERFACE!{interface IGattServiceProviderTrigger(IGattServiceProviderTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderTrigger] {
    fn get_TriggerId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_Service(&self, out: *mut *mut super::super::devices::bluetooth::genericattributeprofile::GattLocalService) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_AdvertisingParameters(&self, value: *mut super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_AdvertisingParameters(&self, out: *mut *mut super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters) -> HRESULT
}}
impl IGattServiceProviderTrigger {
    #[inline] pub unsafe fn get_trigger_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TriggerId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_service(&self) -> Result<ComPtr<super::super::devices::bluetooth::genericattributeprofile::GattLocalService>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Service)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_advertising_parameters(&self, value: &super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AdvertisingParameters)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_advertising_parameters(&self) -> Result<ComPtr<super::super::devices::bluetooth::genericattributeprofile::GattServiceProviderAdvertisingParameters>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AdvertisingParameters)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class GattServiceProviderTrigger: IGattServiceProviderTrigger}
impl RtActivatable<IGattServiceProviderTriggerStatics> for GattServiceProviderTrigger {}
impl GattServiceProviderTrigger {
    #[inline] pub fn create_async(triggerId: &HStringArg, serviceUuid: Guid) -> Result<ComPtr<super::super::foundation::IAsyncOperation<GattServiceProviderTriggerResult>>> { unsafe {
        <Self as RtActivatable<IGattServiceProviderTriggerStatics>>::get_activation_factory().create_async(triggerId, serviceUuid)
    }}
}
DEFINE_CLSID!(GattServiceProviderTrigger: "Windows.ApplicationModel.Background.GattServiceProviderTrigger");
DEFINE_IID!(IID_IGattServiceProviderTriggerResult, 1011257777, 45464, 20100, 186, 212, 207, 74, 210, 153, 237, 58);
RT_INTERFACE!{interface IGattServiceProviderTriggerResult(IGattServiceProviderTriggerResultVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderTriggerResult] {
    fn get_Trigger(&self, out: *mut *mut GattServiceProviderTrigger) -> HRESULT,
    #[cfg(feature="windows-devices")] fn get_Error(&self, out: *mut super::super::devices::bluetooth::BluetoothError) -> HRESULT
}}
impl IGattServiceProviderTriggerResult {
    #[inline] pub unsafe fn get_trigger(&self) -> Result<ComPtr<GattServiceProviderTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Trigger)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_error(&self) -> Result<super::super::devices::bluetooth::BluetoothError> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Error)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class GattServiceProviderTriggerResult: IGattServiceProviderTriggerResult}
DEFINE_IID!(IID_IGattServiceProviderTriggerStatics, 3021185898, 58004, 17809, 165, 166, 100, 137, 26, 130, 129, 83);
RT_INTERFACE!{static interface IGattServiceProviderTriggerStatics(IGattServiceProviderTriggerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IGattServiceProviderTriggerStatics] {
    fn CreateAsync(&self, triggerId: HSTRING, serviceUuid: Guid, out: *mut *mut super::super::foundation::IAsyncOperation<GattServiceProviderTriggerResult>) -> HRESULT
}}
impl IGattServiceProviderTriggerStatics {
    #[inline] pub unsafe fn create_async(&self, triggerId: &HStringArg, serviceUuid: Guid) -> Result<ComPtr<super::super::foundation::IAsyncOperation<GattServiceProviderTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAsync)(self as *const _ as *mut _, triggerId.get(), serviceUuid, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IGeovisitTrigger, 1209593258, 1249, 16679, 154, 76, 25, 53, 27, 138, 128, 164);
RT_INTERFACE!{interface IGeovisitTrigger(IGeovisitTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IGeovisitTrigger] {
    #[cfg(feature="windows-devices")] fn get_MonitoringScope(&self, out: *mut super::super::devices::geolocation::VisitMonitoringScope) -> HRESULT,
    #[cfg(feature="windows-devices")] fn put_MonitoringScope(&self, value: super::super::devices::geolocation::VisitMonitoringScope) -> HRESULT
}}
impl IGeovisitTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_monitoring_scope(&self) -> Result<super::super::devices::geolocation::VisitMonitoringScope> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MonitoringScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_monitoring_scope(&self, value: super::super::devices::geolocation::VisitMonitoringScope) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MonitoringScope)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class GeovisitTrigger: IGeovisitTrigger}
impl RtActivatable<IActivationFactory> for GeovisitTrigger {}
DEFINE_CLSID!(GeovisitTrigger: "Windows.ApplicationModel.Background.GeovisitTrigger");
DEFINE_IID!(IID_ILocationTrigger, 1197894172, 26743, 18462, 128, 38, 255, 126, 20, 168, 17, 160);
RT_INTERFACE!{interface ILocationTrigger(ILocationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ILocationTrigger] {
    fn get_TriggerType(&self, out: *mut LocationTriggerType) -> HRESULT
}}
impl ILocationTrigger {
    #[inline] pub unsafe fn get_trigger_type(&self) -> Result<LocationTriggerType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TriggerType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LocationTrigger: ILocationTrigger}
impl RtActivatable<ILocationTriggerFactory> for LocationTrigger {}
impl LocationTrigger {
    #[inline] pub fn create(triggerType: LocationTriggerType) -> Result<ComPtr<LocationTrigger>> { unsafe {
        <Self as RtActivatable<ILocationTriggerFactory>>::get_activation_factory().create(triggerType)
    }}
}
DEFINE_CLSID!(LocationTrigger: "Windows.ApplicationModel.Background.LocationTrigger");
DEFINE_IID!(IID_ILocationTriggerFactory, 285653767, 65385, 19977, 170, 139, 19, 132, 234, 71, 94, 152);
RT_INTERFACE!{static interface ILocationTriggerFactory(ILocationTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ILocationTriggerFactory] {
    fn Create(&self, triggerType: LocationTriggerType, out: *mut *mut LocationTrigger) -> HRESULT
}}
impl ILocationTriggerFactory {
    #[inline] pub unsafe fn create(&self, triggerType: LocationTriggerType) -> Result<ComPtr<LocationTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, triggerType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum LocationTriggerType: i32 {
    Geofence (LocationTriggerType_Geofence) = 0,
}}
DEFINE_IID!(IID_IMaintenanceTrigger, 1746422915, 64546, 19685, 132, 26, 114, 57, 169, 129, 0, 71);
RT_INTERFACE!{interface IMaintenanceTrigger(IMaintenanceTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IMaintenanceTrigger] {
    fn get_FreshnessTime(&self, out: *mut u32) -> HRESULT,
    fn get_OneShot(&self, out: *mut bool) -> HRESULT
}}
impl IMaintenanceTrigger {
    #[inline] pub unsafe fn get_freshness_time(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FreshnessTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_one_shot(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OneShot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class MaintenanceTrigger: IMaintenanceTrigger}
impl RtActivatable<IMaintenanceTriggerFactory> for MaintenanceTrigger {}
impl MaintenanceTrigger {
    #[inline] pub fn create(freshnessTime: u32, oneShot: bool) -> Result<ComPtr<MaintenanceTrigger>> { unsafe {
        <Self as RtActivatable<IMaintenanceTriggerFactory>>::get_activation_factory().create(freshnessTime, oneShot)
    }}
}
DEFINE_CLSID!(MaintenanceTrigger: "Windows.ApplicationModel.Background.MaintenanceTrigger");
DEFINE_IID!(IID_IMaintenanceTriggerFactory, 1262345006, 38877, 17961, 136, 176, 176, 108, 249, 72, 42, 229);
RT_INTERFACE!{static interface IMaintenanceTriggerFactory(IMaintenanceTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IMaintenanceTriggerFactory] {
    fn Create(&self, freshnessTime: u32, oneShot: bool, out: *mut *mut MaintenanceTrigger) -> HRESULT
}}
impl IMaintenanceTriggerFactory {
    #[inline] pub unsafe fn create(&self, freshnessTime: u32, oneShot: bool) -> Result<ComPtr<MaintenanceTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, freshnessTime, oneShot, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IMediaProcessingTrigger, 2593504869, 35410, 19248, 144, 17, 207, 56, 4, 14, 168, 176);
RT_INTERFACE!{interface IMediaProcessingTrigger(IMediaProcessingTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IMediaProcessingTrigger] {
    fn RequestAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<MediaProcessingTriggerResult>) -> HRESULT,
    fn RequestAsyncWithArguments(&self, arguments: *mut super::super::foundation::collections::ValueSet, out: *mut *mut super::super::foundation::IAsyncOperation<MediaProcessingTriggerResult>) -> HRESULT
}}
impl IMediaProcessingTrigger {
    #[inline] pub unsafe fn request_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<MediaProcessingTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_async_with_arguments(&self, arguments: &super::super::foundation::collections::ValueSet) -> Result<ComPtr<super::super::foundation::IAsyncOperation<MediaProcessingTriggerResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAsyncWithArguments)(self as *const _ as *mut _, arguments as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class MediaProcessingTrigger: IMediaProcessingTrigger}
impl RtActivatable<IActivationFactory> for MediaProcessingTrigger {}
DEFINE_CLSID!(MediaProcessingTrigger: "Windows.ApplicationModel.Background.MediaProcessingTrigger");
RT_ENUM! { enum MediaProcessingTriggerResult: i32 {
    Allowed (MediaProcessingTriggerResult_Allowed) = 0, CurrentlyRunning (MediaProcessingTriggerResult_CurrentlyRunning) = 1, DisabledByPolicy (MediaProcessingTriggerResult_DisabledByPolicy) = 2, UnknownError (MediaProcessingTriggerResult_UnknownError) = 3,
}}
RT_CLASS!{class MobileBroadbandDeviceServiceNotificationTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandDeviceServiceNotificationTrigger {}
DEFINE_CLSID!(MobileBroadbandDeviceServiceNotificationTrigger: "Windows.ApplicationModel.Background.MobileBroadbandDeviceServiceNotificationTrigger");
RT_CLASS!{class MobileBroadbandPinLockStateChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandPinLockStateChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandPinLockStateChangeTrigger: "Windows.ApplicationModel.Background.MobileBroadbandPinLockStateChangeTrigger");
RT_CLASS!{class MobileBroadbandRadioStateChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandRadioStateChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandRadioStateChangeTrigger: "Windows.ApplicationModel.Background.MobileBroadbandRadioStateChangeTrigger");
RT_CLASS!{class MobileBroadbandRegistrationStateChangeTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for MobileBroadbandRegistrationStateChangeTrigger {}
DEFINE_CLSID!(MobileBroadbandRegistrationStateChangeTrigger: "Windows.ApplicationModel.Background.MobileBroadbandRegistrationStateChangeTrigger");
DEFINE_IID!(IID_INetworkOperatorHotspotAuthenticationTrigger, 3881224081, 12289, 19941, 131, 199, 222, 97, 216, 136, 49, 208);
RT_INTERFACE!{interface INetworkOperatorHotspotAuthenticationTrigger(INetworkOperatorHotspotAuthenticationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_INetworkOperatorHotspotAuthenticationTrigger] {
    
}}
RT_CLASS!{class NetworkOperatorHotspotAuthenticationTrigger: INetworkOperatorHotspotAuthenticationTrigger}
impl RtActivatable<IActivationFactory> for NetworkOperatorHotspotAuthenticationTrigger {}
DEFINE_CLSID!(NetworkOperatorHotspotAuthenticationTrigger: "Windows.ApplicationModel.Background.NetworkOperatorHotspotAuthenticationTrigger");
DEFINE_IID!(IID_INetworkOperatorNotificationTrigger, 2416483526, 25549, 18444, 149, 209, 110, 106, 239, 128, 30, 74);
RT_INTERFACE!{interface INetworkOperatorNotificationTrigger(INetworkOperatorNotificationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_INetworkOperatorNotificationTrigger] {
    fn get_NetworkAccountId(&self, out: *mut HSTRING) -> HRESULT
}}
impl INetworkOperatorNotificationTrigger {
    #[inline] pub unsafe fn get_network_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NetworkAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class NetworkOperatorNotificationTrigger: INetworkOperatorNotificationTrigger}
impl RtActivatable<INetworkOperatorNotificationTriggerFactory> for NetworkOperatorNotificationTrigger {}
impl NetworkOperatorNotificationTrigger {
    #[inline] pub fn create(networkAccountId: &HStringArg) -> Result<ComPtr<NetworkOperatorNotificationTrigger>> { unsafe {
        <Self as RtActivatable<INetworkOperatorNotificationTriggerFactory>>::get_activation_factory().create(networkAccountId)
    }}
}
DEFINE_CLSID!(NetworkOperatorNotificationTrigger: "Windows.ApplicationModel.Background.NetworkOperatorNotificationTrigger");
DEFINE_IID!(IID_INetworkOperatorNotificationTriggerFactory, 170016256, 10199, 17235, 173, 185, 146, 101, 170, 234, 87, 157);
RT_INTERFACE!{static interface INetworkOperatorNotificationTriggerFactory(INetworkOperatorNotificationTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_INetworkOperatorNotificationTriggerFactory] {
    fn Create(&self, networkAccountId: HSTRING, out: *mut *mut NetworkOperatorNotificationTrigger) -> HRESULT
}}
impl INetworkOperatorNotificationTriggerFactory {
    #[inline] pub unsafe fn create(&self, networkAccountId: &HStringArg) -> Result<ComPtr<NetworkOperatorNotificationTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, networkAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentAppCanMakePaymentTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for PaymentAppCanMakePaymentTrigger {}
DEFINE_CLSID!(PaymentAppCanMakePaymentTrigger: "Windows.ApplicationModel.Background.PaymentAppCanMakePaymentTrigger");
DEFINE_IID!(IID_IPhoneTrigger, 2379213211, 54469, 18929, 183, 211, 130, 232, 122, 14, 157, 222);
RT_INTERFACE!{interface IPhoneTrigger(IPhoneTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneTrigger] {
    fn get_OneShot(&self, out: *mut bool) -> HRESULT,
    fn get_TriggerType(&self, out: *mut super::calls::background::PhoneTriggerType) -> HRESULT
}}
impl IPhoneTrigger {
    #[inline] pub unsafe fn get_one_shot(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OneShot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_trigger_type(&self) -> Result<super::calls::background::PhoneTriggerType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TriggerType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PhoneTrigger: IPhoneTrigger}
impl RtActivatable<IPhoneTriggerFactory> for PhoneTrigger {}
impl PhoneTrigger {
    #[inline] pub fn create(type_: super::calls::background::PhoneTriggerType, oneShot: bool) -> Result<ComPtr<PhoneTrigger>> { unsafe {
        <Self as RtActivatable<IPhoneTriggerFactory>>::get_activation_factory().create(type_, oneShot)
    }}
}
DEFINE_CLSID!(PhoneTrigger: "Windows.ApplicationModel.Background.PhoneTrigger");
DEFINE_IID!(IID_IPhoneTriggerFactory, 2698591450, 24513, 18683, 165, 70, 50, 38, 32, 64, 21, 123);
RT_INTERFACE!{static interface IPhoneTriggerFactory(IPhoneTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPhoneTriggerFactory] {
    fn Create(&self, type_: super::calls::background::PhoneTriggerType, oneShot: bool, out: *mut *mut PhoneTrigger) -> HRESULT
}}
impl IPhoneTriggerFactory {
    #[inline] pub unsafe fn create(&self, type_: super::calls::background::PhoneTriggerType, oneShot: bool) -> Result<ComPtr<PhoneTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, type_, oneShot, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PushNotificationTrigger: IBackgroundTrigger}
impl RtActivatable<IPushNotificationTriggerFactory> for PushNotificationTrigger {}
impl RtActivatable<IActivationFactory> for PushNotificationTrigger {}
impl PushNotificationTrigger {
    #[inline] pub fn create(applicationId: &HStringArg) -> Result<ComPtr<PushNotificationTrigger>> { unsafe {
        <Self as RtActivatable<IPushNotificationTriggerFactory>>::get_activation_factory().create(applicationId)
    }}
}
DEFINE_CLSID!(PushNotificationTrigger: "Windows.ApplicationModel.Background.PushNotificationTrigger");
DEFINE_IID!(IID_IPushNotificationTriggerFactory, 1842933019, 17806, 20418, 188, 46, 213, 102, 79, 119, 237, 25);
RT_INTERFACE!{static interface IPushNotificationTriggerFactory(IPushNotificationTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPushNotificationTriggerFactory] {
    fn Create(&self, applicationId: HSTRING, out: *mut *mut PushNotificationTrigger) -> HRESULT
}}
impl IPushNotificationTriggerFactory {
    #[inline] pub unsafe fn create(&self, applicationId: &HStringArg) -> Result<ComPtr<PushNotificationTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRcsEndUserMessageAvailableTrigger, 2557283690, 45814, 18047, 169, 120, 164, 64, 145, 193, 26, 102);
RT_INTERFACE!{interface IRcsEndUserMessageAvailableTrigger(IRcsEndUserMessageAvailableTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IRcsEndUserMessageAvailableTrigger] {
    
}}
RT_CLASS!{class RcsEndUserMessageAvailableTrigger: IRcsEndUserMessageAvailableTrigger}
impl RtActivatable<IActivationFactory> for RcsEndUserMessageAvailableTrigger {}
DEFINE_CLSID!(RcsEndUserMessageAvailableTrigger: "Windows.ApplicationModel.Background.RcsEndUserMessageAvailableTrigger");
DEFINE_IID!(IID_IRfcommConnectionTrigger, 3905211106, 2899, 17508, 147, 148, 253, 135, 86, 84, 222, 100);
RT_INTERFACE!{interface IRfcommConnectionTrigger(IRfcommConnectionTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IRfcommConnectionTrigger] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_InboundConnection(&self, out: *mut *mut super::super::devices::bluetooth::background::RfcommInboundConnectionInformation) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_OutboundConnection(&self, out: *mut *mut super::super::devices::bluetooth::background::RfcommOutboundConnectionInformation) -> HRESULT,
    fn get_AllowMultipleConnections(&self, out: *mut bool) -> HRESULT,
    fn put_AllowMultipleConnections(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-networking")] fn get_ProtectionLevel(&self, out: *mut super::super::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(feature="windows-networking")] fn put_ProtectionLevel(&self, value: super::super::networking::sockets::SocketProtectionLevel) -> HRESULT,
    #[cfg(feature="windows-networking")] fn get_RemoteHostName(&self, out: *mut *mut super::super::networking::HostName) -> HRESULT,
    #[cfg(feature="windows-networking")] fn put_RemoteHostName(&self, value: *mut super::super::networking::HostName) -> HRESULT
}}
impl IRfcommConnectionTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_inbound_connection(&self) -> Result<ComPtr<super::super::devices::bluetooth::background::RfcommInboundConnectionInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InboundConnection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_outbound_connection(&self) -> Result<ComPtr<super::super::devices::bluetooth::background::RfcommOutboundConnectionInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutboundConnection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_multiple_connections(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowMultipleConnections)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_multiple_connections(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowMultipleConnections)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-networking")] #[inline] pub unsafe fn get_protection_level(&self) -> Result<super::super::networking::sockets::SocketProtectionLevel> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProtectionLevel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-networking")] #[inline] pub unsafe fn set_protection_level(&self, value: super::super::networking::sockets::SocketProtectionLevel) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ProtectionLevel)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-networking")] #[inline] pub unsafe fn get_remote_host_name(&self) -> Result<ComPtr<super::super::networking::HostName>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteHostName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-networking")] #[inline] pub unsafe fn set_remote_host_name(&self, value: &super::super::networking::HostName) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteHostName)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class RfcommConnectionTrigger: IRfcommConnectionTrigger}
impl RtActivatable<IActivationFactory> for RfcommConnectionTrigger {}
DEFINE_CLSID!(RfcommConnectionTrigger: "Windows.ApplicationModel.Background.RfcommConnectionTrigger");
DEFINE_IID!(IID_ISecondaryAuthenticationFactorAuthenticationTrigger, 4063752999, 20865, 20260, 150, 167, 112, 10, 78, 95, 172, 98);
RT_INTERFACE!{interface ISecondaryAuthenticationFactorAuthenticationTrigger(ISecondaryAuthenticationFactorAuthenticationTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ISecondaryAuthenticationFactorAuthenticationTrigger] {
    
}}
RT_CLASS!{class SecondaryAuthenticationFactorAuthenticationTrigger: ISecondaryAuthenticationFactorAuthenticationTrigger}
impl RtActivatable<IActivationFactory> for SecondaryAuthenticationFactorAuthenticationTrigger {}
DEFINE_CLSID!(SecondaryAuthenticationFactorAuthenticationTrigger: "Windows.ApplicationModel.Background.SecondaryAuthenticationFactorAuthenticationTrigger");
DEFINE_IID!(IID_ISensorDataThresholdTrigger, 1539371890, 54411, 19327, 171, 236, 21, 249, 186, 204, 18, 226);
RT_INTERFACE!{interface ISensorDataThresholdTrigger(ISensorDataThresholdTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ISensorDataThresholdTrigger] {
    
}}
RT_CLASS!{class SensorDataThresholdTrigger: ISensorDataThresholdTrigger}
impl RtActivatable<ISensorDataThresholdTriggerFactory> for SensorDataThresholdTrigger {}
impl SensorDataThresholdTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(threshold: &super::super::devices::sensors::ISensorDataThreshold) -> Result<ComPtr<SensorDataThresholdTrigger>> { unsafe {
        <Self as RtActivatable<ISensorDataThresholdTriggerFactory>>::get_activation_factory().create(threshold)
    }}
}
DEFINE_CLSID!(SensorDataThresholdTrigger: "Windows.ApplicationModel.Background.SensorDataThresholdTrigger");
DEFINE_IID!(IID_ISensorDataThresholdTriggerFactory, 2451564149, 32240, 19875, 151, 179, 229, 68, 238, 133, 127, 230);
RT_INTERFACE!{static interface ISensorDataThresholdTriggerFactory(ISensorDataThresholdTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISensorDataThresholdTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, threshold: *mut super::super::devices::sensors::ISensorDataThreshold, out: *mut *mut SensorDataThresholdTrigger) -> HRESULT
}}
impl ISensorDataThresholdTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create(&self, threshold: &super::super::devices::sensors::ISensorDataThreshold) -> Result<ComPtr<SensorDataThresholdTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, threshold as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISmartCardTrigger, 4114335148, 33994, 18802, 140, 233, 229, 143, 151, 179, 122, 80);
RT_INTERFACE!{interface ISmartCardTrigger(ISmartCardTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardTrigger] {
    #[cfg(feature="windows-devices")] fn get_TriggerType(&self, out: *mut super::super::devices::smartcards::SmartCardTriggerType) -> HRESULT
}}
impl ISmartCardTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_trigger_type(&self) -> Result<super::super::devices::smartcards::SmartCardTriggerType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TriggerType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SmartCardTrigger: ISmartCardTrigger}
impl RtActivatable<ISmartCardTriggerFactory> for SmartCardTrigger {}
impl SmartCardTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(triggerType: super::super::devices::smartcards::SmartCardTriggerType) -> Result<ComPtr<SmartCardTrigger>> { unsafe {
        <Self as RtActivatable<ISmartCardTriggerFactory>>::get_activation_factory().create(triggerType)
    }}
}
DEFINE_CLSID!(SmartCardTrigger: "Windows.ApplicationModel.Background.SmartCardTrigger");
DEFINE_IID!(IID_ISmartCardTriggerFactory, 1673483459, 35265, 19968, 169, 211, 151, 198, 41, 38, 157, 173);
RT_INTERFACE!{static interface ISmartCardTriggerFactory(ISmartCardTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmartCardTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, triggerType: super::super::devices::smartcards::SmartCardTriggerType, out: *mut *mut SmartCardTrigger) -> HRESULT
}}
impl ISmartCardTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create(&self, triggerType: super::super::devices::smartcards::SmartCardTriggerType) -> Result<ComPtr<SmartCardTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, triggerType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SmsMessageReceivedTrigger: IBackgroundTrigger}
impl RtActivatable<ISmsMessageReceivedTriggerFactory> for SmsMessageReceivedTrigger {}
impl SmsMessageReceivedTrigger {
    #[cfg(feature="windows-devices")] #[inline] pub fn create(filterRules: &super::super::devices::sms::SmsFilterRules) -> Result<ComPtr<SmsMessageReceivedTrigger>> { unsafe {
        <Self as RtActivatable<ISmsMessageReceivedTriggerFactory>>::get_activation_factory().create(filterRules)
    }}
}
DEFINE_CLSID!(SmsMessageReceivedTrigger: "Windows.ApplicationModel.Background.SmsMessageReceivedTrigger");
DEFINE_IID!(IID_ISmsMessageReceivedTriggerFactory, 3929725128, 27556, 19122, 141, 33, 188, 107, 9, 199, 117, 100);
RT_INTERFACE!{static interface ISmsMessageReceivedTriggerFactory(ISmsMessageReceivedTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISmsMessageReceivedTriggerFactory] {
    #[cfg(feature="windows-devices")] fn Create(&self, filterRules: *mut super::super::devices::sms::SmsFilterRules, out: *mut *mut SmsMessageReceivedTrigger) -> HRESULT
}}
impl ISmsMessageReceivedTriggerFactory {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn create(&self, filterRules: &super::super::devices::sms::SmsFilterRules) -> Result<ComPtr<SmsMessageReceivedTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, filterRules as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISocketActivityTrigger, 2847668240, 40414, 20362, 131, 227, 176, 224, 231, 165, 13, 112);
RT_INTERFACE!{interface ISocketActivityTrigger(ISocketActivityTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ISocketActivityTrigger] {
    fn get_IsWakeFromLowPowerSupported(&self, out: *mut bool) -> HRESULT
}}
impl ISocketActivityTrigger {
    #[inline] pub unsafe fn get_is_wake_from_low_power_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsWakeFromLowPowerSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SocketActivityTrigger: IBackgroundTrigger}
impl RtActivatable<IActivationFactory> for SocketActivityTrigger {}
DEFINE_CLSID!(SocketActivityTrigger: "Windows.ApplicationModel.Background.SocketActivityTrigger");
DEFINE_IID!(IID_IStorageLibraryContentChangedTrigger, 372760743, 33436, 17852, 146, 155, 161, 231, 234, 120, 216, 155);
RT_INTERFACE!{interface IStorageLibraryContentChangedTrigger(IStorageLibraryContentChangedTriggerVtbl): IInspectable(IInspectableVtbl) [IID_IStorageLibraryContentChangedTrigger] {
    
}}
RT_CLASS!{class StorageLibraryContentChangedTrigger: IStorageLibraryContentChangedTrigger}
impl RtActivatable<IStorageLibraryContentChangedTriggerStatics> for StorageLibraryContentChangedTrigger {}
impl StorageLibraryContentChangedTrigger {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(storageLibrary: &super::super::storage::StorageLibrary) -> Result<ComPtr<StorageLibraryContentChangedTrigger>> { unsafe {
        <Self as RtActivatable<IStorageLibraryContentChangedTriggerStatics>>::get_activation_factory().create(storageLibrary)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_from_libraries(storageLibraries: &super::super::foundation::collections::IIterable<super::super::storage::StorageLibrary>) -> Result<ComPtr<StorageLibraryContentChangedTrigger>> { unsafe {
        <Self as RtActivatable<IStorageLibraryContentChangedTriggerStatics>>::get_activation_factory().create_from_libraries(storageLibraries)
    }}
}
DEFINE_CLSID!(StorageLibraryContentChangedTrigger: "Windows.ApplicationModel.Background.StorageLibraryContentChangedTrigger");
DEFINE_IID!(IID_IStorageLibraryContentChangedTriggerStatics, 2141133625, 24464, 19986, 145, 78, 167, 216, 224, 187, 251, 24);
RT_INTERFACE!{static interface IStorageLibraryContentChangedTriggerStatics(IStorageLibraryContentChangedTriggerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStorageLibraryContentChangedTriggerStatics] {
    #[cfg(feature="windows-storage")] fn Create(&self, storageLibrary: *mut super::super::storage::StorageLibrary, out: *mut *mut StorageLibraryContentChangedTrigger) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateFromLibraries(&self, storageLibraries: *mut super::super::foundation::collections::IIterable<super::super::storage::StorageLibrary>, out: *mut *mut StorageLibraryContentChangedTrigger) -> HRESULT
}}
impl IStorageLibraryContentChangedTriggerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn create(&self, storageLibrary: &super::super::storage::StorageLibrary) -> Result<ComPtr<StorageLibraryContentChangedTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, storageLibrary as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn create_from_libraries(&self, storageLibraries: &super::super::foundation::collections::IIterable<super::super::storage::StorageLibrary>) -> Result<ComPtr<StorageLibraryContentChangedTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFromLibraries)(self as *const _ as *mut _, storageLibraries as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ISystemCondition, 3244274806, 35269, 16907, 171, 211, 251, 48, 48, 71, 33, 40);
RT_INTERFACE!{interface ISystemCondition(ISystemConditionVtbl): IInspectable(IInspectableVtbl) [IID_ISystemCondition] {
    fn get_ConditionType(&self, out: *mut SystemConditionType) -> HRESULT
}}
impl ISystemCondition {
    #[inline] pub unsafe fn get_condition_type(&self) -> Result<SystemConditionType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ConditionType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SystemCondition: ISystemCondition}
impl RtActivatable<ISystemConditionFactory> for SystemCondition {}
impl SystemCondition {
    #[inline] pub fn create(conditionType: SystemConditionType) -> Result<ComPtr<SystemCondition>> { unsafe {
        <Self as RtActivatable<ISystemConditionFactory>>::get_activation_factory().create(conditionType)
    }}
}
DEFINE_CLSID!(SystemCondition: "Windows.ApplicationModel.Background.SystemCondition");
DEFINE_IID!(IID_ISystemConditionFactory, 3530150385, 1447, 18862, 135, 215, 22, 178, 184, 185, 165, 83);
RT_INTERFACE!{static interface ISystemConditionFactory(ISystemConditionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISystemConditionFactory] {
    fn Create(&self, conditionType: SystemConditionType, out: *mut *mut SystemCondition) -> HRESULT
}}
impl ISystemConditionFactory {
    #[inline] pub unsafe fn create(&self, conditionType: SystemConditionType) -> Result<ComPtr<SystemCondition>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, conditionType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum SystemConditionType: i32 {
    Invalid (SystemConditionType_Invalid) = 0, UserPresent (SystemConditionType_UserPresent) = 1, UserNotPresent (SystemConditionType_UserNotPresent) = 2, InternetAvailable (SystemConditionType_InternetAvailable) = 3, InternetNotAvailable (SystemConditionType_InternetNotAvailable) = 4, SessionConnected (SystemConditionType_SessionConnected) = 5, SessionDisconnected (SystemConditionType_SessionDisconnected) = 6, FreeNetworkAvailable (SystemConditionType_FreeNetworkAvailable) = 7, BackgroundWorkCostNotHigh (SystemConditionType_BackgroundWorkCostNotHigh) = 8,
}}
DEFINE_IID!(IID_ISystemTrigger, 494978934, 14152, 17507, 141, 126, 39, 109, 193, 57, 172, 28);
RT_INTERFACE!{interface ISystemTrigger(ISystemTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ISystemTrigger] {
    fn get_OneShot(&self, out: *mut bool) -> HRESULT,
    fn get_TriggerType(&self, out: *mut SystemTriggerType) -> HRESULT
}}
impl ISystemTrigger {
    #[inline] pub unsafe fn get_one_shot(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OneShot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_trigger_type(&self) -> Result<SystemTriggerType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TriggerType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class SystemTrigger: ISystemTrigger}
impl RtActivatable<ISystemTriggerFactory> for SystemTrigger {}
impl SystemTrigger {
    #[inline] pub fn create(triggerType: SystemTriggerType, oneShot: bool) -> Result<ComPtr<SystemTrigger>> { unsafe {
        <Self as RtActivatable<ISystemTriggerFactory>>::get_activation_factory().create(triggerType, oneShot)
    }}
}
DEFINE_CLSID!(SystemTrigger: "Windows.ApplicationModel.Background.SystemTrigger");
DEFINE_IID!(IID_ISystemTriggerFactory, 3892585428, 34705, 17785, 129, 38, 135, 236, 138, 170, 64, 122);
RT_INTERFACE!{static interface ISystemTriggerFactory(ISystemTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ISystemTriggerFactory] {
    fn Create(&self, triggerType: SystemTriggerType, oneShot: bool, out: *mut *mut SystemTrigger) -> HRESULT
}}
impl ISystemTriggerFactory {
    #[inline] pub unsafe fn create(&self, triggerType: SystemTriggerType, oneShot: bool) -> Result<ComPtr<SystemTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, triggerType, oneShot, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum SystemTriggerType: i32 {
    Invalid (SystemTriggerType_Invalid) = 0, SmsReceived (SystemTriggerType_SmsReceived) = 1, UserPresent (SystemTriggerType_UserPresent) = 2, UserAway (SystemTriggerType_UserAway) = 3, NetworkStateChange (SystemTriggerType_NetworkStateChange) = 4, ControlChannelReset (SystemTriggerType_ControlChannelReset) = 5, InternetAvailable (SystemTriggerType_InternetAvailable) = 6, SessionConnected (SystemTriggerType_SessionConnected) = 7, ServicingComplete (SystemTriggerType_ServicingComplete) = 8, LockScreenApplicationAdded (SystemTriggerType_LockScreenApplicationAdded) = 9, LockScreenApplicationRemoved (SystemTriggerType_LockScreenApplicationRemoved) = 10, TimeZoneChange (SystemTriggerType_TimeZoneChange) = 11, OnlineIdConnectedStateChange (SystemTriggerType_OnlineIdConnectedStateChange) = 12, BackgroundWorkCostChange (SystemTriggerType_BackgroundWorkCostChange) = 13, PowerStateChange (SystemTriggerType_PowerStateChange) = 14, DefaultSignInAccountChange (SystemTriggerType_DefaultSignInAccountChange) = 15,
}}
DEFINE_IID!(IID_ITimeTrigger, 1701729622, 2858, 17271, 186, 112, 59, 69, 169, 53, 84, 127);
RT_INTERFACE!{interface ITimeTrigger(ITimeTriggerVtbl): IInspectable(IInspectableVtbl) [IID_ITimeTrigger] {
    fn get_FreshnessTime(&self, out: *mut u32) -> HRESULT,
    fn get_OneShot(&self, out: *mut bool) -> HRESULT
}}
impl ITimeTrigger {
    #[inline] pub unsafe fn get_freshness_time(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FreshnessTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_one_shot(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OneShot)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class TimeTrigger: ITimeTrigger}
impl RtActivatable<ITimeTriggerFactory> for TimeTrigger {}
impl TimeTrigger {
    #[inline] pub fn create(freshnessTime: u32, oneShot: bool) -> Result<ComPtr<TimeTrigger>> { unsafe {
        <Self as RtActivatable<ITimeTriggerFactory>>::get_activation_factory().create(freshnessTime, oneShot)
    }}
}
DEFINE_CLSID!(TimeTrigger: "Windows.ApplicationModel.Background.TimeTrigger");
DEFINE_IID!(IID_ITimeTriggerFactory, 952533758, 39764, 17894, 178, 243, 38, 155, 135, 166, 247, 52);
RT_INTERFACE!{static interface ITimeTriggerFactory(ITimeTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_ITimeTriggerFactory] {
    fn Create(&self, freshnessTime: u32, oneShot: bool, out: *mut *mut TimeTrigger) -> HRESULT
}}
impl ITimeTriggerFactory {
    #[inline] pub unsafe fn create(&self, freshnessTime: u32, oneShot: bool) -> Result<ComPtr<TimeTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, freshnessTime, oneShot, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ToastNotificationActionTrigger: IBackgroundTrigger}
impl RtActivatable<IToastNotificationActionTriggerFactory> for ToastNotificationActionTrigger {}
impl RtActivatable<IActivationFactory> for ToastNotificationActionTrigger {}
impl ToastNotificationActionTrigger {
    #[inline] pub fn create(applicationId: &HStringArg) -> Result<ComPtr<ToastNotificationActionTrigger>> { unsafe {
        <Self as RtActivatable<IToastNotificationActionTriggerFactory>>::get_activation_factory().create(applicationId)
    }}
}
DEFINE_CLSID!(ToastNotificationActionTrigger: "Windows.ApplicationModel.Background.ToastNotificationActionTrigger");
DEFINE_IID!(IID_IToastNotificationActionTriggerFactory, 2963143719, 25728, 17225, 129, 37, 151, 179, 239, 170, 10, 58);
RT_INTERFACE!{static interface IToastNotificationActionTriggerFactory(IToastNotificationActionTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationActionTriggerFactory] {
    fn Create(&self, applicationId: HSTRING, out: *mut *mut ToastNotificationActionTrigger) -> HRESULT
}}
impl IToastNotificationActionTriggerFactory {
    #[inline] pub unsafe fn create(&self, applicationId: &HStringArg) -> Result<ComPtr<ToastNotificationActionTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ToastNotificationHistoryChangedTrigger: IBackgroundTrigger}
impl RtActivatable<IToastNotificationHistoryChangedTriggerFactory> for ToastNotificationHistoryChangedTrigger {}
impl RtActivatable<IActivationFactory> for ToastNotificationHistoryChangedTrigger {}
impl ToastNotificationHistoryChangedTrigger {
    #[inline] pub fn create(applicationId: &HStringArg) -> Result<ComPtr<ToastNotificationHistoryChangedTrigger>> { unsafe {
        <Self as RtActivatable<IToastNotificationHistoryChangedTriggerFactory>>::get_activation_factory().create(applicationId)
    }}
}
DEFINE_CLSID!(ToastNotificationHistoryChangedTrigger: "Windows.ApplicationModel.Background.ToastNotificationHistoryChangedTrigger");
DEFINE_IID!(IID_IToastNotificationHistoryChangedTriggerFactory, 2177301165, 34711, 18309, 129, 180, 176, 204, 203, 115, 209, 217);
RT_INTERFACE!{static interface IToastNotificationHistoryChangedTriggerFactory(IToastNotificationHistoryChangedTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationHistoryChangedTriggerFactory] {
    fn Create(&self, applicationId: HSTRING, out: *mut *mut ToastNotificationHistoryChangedTrigger) -> HRESULT
}}
impl IToastNotificationHistoryChangedTriggerFactory {
    #[inline] pub unsafe fn create(&self, applicationId: &HStringArg) -> Result<ComPtr<ToastNotificationHistoryChangedTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, applicationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserNotificationChangedTrigger: IBackgroundTrigger}
impl RtActivatable<IUserNotificationChangedTriggerFactory> for UserNotificationChangedTrigger {}
impl UserNotificationChangedTrigger {
    #[cfg(feature="windows-ui")] #[inline] pub fn create(notificationKinds: super::super::ui::notifications::NotificationKinds) -> Result<ComPtr<UserNotificationChangedTrigger>> { unsafe {
        <Self as RtActivatable<IUserNotificationChangedTriggerFactory>>::get_activation_factory().create(notificationKinds)
    }}
}
DEFINE_CLSID!(UserNotificationChangedTrigger: "Windows.ApplicationModel.Background.UserNotificationChangedTrigger");
DEFINE_IID!(IID_IUserNotificationChangedTriggerFactory, 3402908524, 27051, 19992, 164, 138, 94, 210, 172, 67, 89, 87);
RT_INTERFACE!{static interface IUserNotificationChangedTriggerFactory(IUserNotificationChangedTriggerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUserNotificationChangedTriggerFactory] {
    #[cfg(feature="windows-ui")] fn Create(&self, notificationKinds: super::super::ui::notifications::NotificationKinds, out: *mut *mut UserNotificationChangedTrigger) -> HRESULT
}}
impl IUserNotificationChangedTriggerFactory {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn create(&self, notificationKinds: super::super::ui::notifications::NotificationKinds) -> Result<ComPtr<UserNotificationChangedTrigger>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, notificationKinds, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.Background
pub mod core { // Windows.ApplicationModel.Core
use ::prelude::*;
DEFINE_IID!(IID_IAppListEntry, 4009816191, 8456, 18698, 135, 122, 138, 159, 23, 194, 95, 173);
RT_INTERFACE!{interface IAppListEntry(IAppListEntryVtbl): IInspectable(IInspectableVtbl) [IID_IAppListEntry] {
    fn get_DisplayInfo(&self, out: *mut *mut super::AppDisplayInfo) -> HRESULT,
    fn LaunchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IAppListEntry {
    #[inline] pub unsafe fn get_display_info(&self) -> Result<ComPtr<super::AppDisplayInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LaunchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppListEntry: IAppListEntry}
DEFINE_IID!(IID_IAppListEntry2, 3500546221, 48949, 17068, 172, 6, 134, 238, 235, 65, 208, 75);
RT_INTERFACE!{interface IAppListEntry2(IAppListEntry2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppListEntry2] {
    fn get_AppUserModelId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppListEntry2 {
    #[inline] pub unsafe fn get_app_user_model_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppUserModelId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AppRestartFailureReason: i32 {
    RestartPending (AppRestartFailureReason_RestartPending) = 0, NotInForeground (AppRestartFailureReason_NotInForeground) = 1, InvalidUser (AppRestartFailureReason_InvalidUser) = 2, Other (AppRestartFailureReason_Other) = 3,
}}
DEFINE_IID!(IID_ICoreApplication, 179107748, 24093, 18911, 128, 52, 251, 106, 104, 188, 94, 209);
RT_INTERFACE!{static interface ICoreApplication(ICoreApplicationVtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplication] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn add_Suspending(&self, handler: *mut super::super::foundation::EventHandler<super::SuspendingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Suspending(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Resuming(&self, handler: *mut super::super::foundation::EventHandler<IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Resuming(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut super::super::foundation::collections::IPropertySet) -> HRESULT,
    fn GetCurrentView(&self, out: *mut *mut CoreApplicationView) -> HRESULT,
    fn Run(&self, viewSource: *mut IFrameworkViewSource) -> HRESULT,
    fn RunWithActivationFactories(&self, activationFactoryCallback: *mut super::super::foundation::IGetActivationFactory) -> HRESULT
}}
impl ICoreApplication {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_suspending(&self, handler: &super::super::foundation::EventHandler<super::SuspendingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Suspending)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_suspending(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Suspending)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_resuming(&self, handler: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Resuming)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_resuming(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Resuming)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IPropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_view(&self) -> Result<ComPtr<CoreApplicationView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn run(&self, viewSource: &IFrameworkViewSource) -> Result<()> {
        let hr = ((*self.lpVtbl).Run)(self as *const _ as *mut _, viewSource as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn run_with_activation_factories(&self, activationFactoryCallback: &super::super::foundation::IGetActivationFactory) -> Result<()> {
        let hr = ((*self.lpVtbl).RunWithActivationFactories)(self as *const _ as *mut _, activationFactoryCallback as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{static class CoreApplication}
impl RtActivatable<ICoreApplication> for CoreApplication {}
impl RtActivatable<ICoreApplication2> for CoreApplication {}
impl RtActivatable<ICoreApplication3> for CoreApplication {}
impl RtActivatable<ICoreApplicationExit> for CoreApplication {}
impl RtActivatable<ICoreApplicationUnhandledError> for CoreApplication {}
impl RtActivatable<ICoreApplicationUseCount> for CoreApplication {}
impl RtActivatable<ICoreImmersiveApplication> for CoreApplication {}
impl RtActivatable<ICoreImmersiveApplication2> for CoreApplication {}
impl RtActivatable<ICoreImmersiveApplication3> for CoreApplication {}
impl CoreApplication {
    #[inline] pub fn get_id() -> Result<HString> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().get_id()
    }}
    #[inline] pub fn add_suspending(handler: &super::super::foundation::EventHandler<super::SuspendingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().add_suspending(handler)
    }}
    #[inline] pub fn remove_suspending(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().remove_suspending(token)
    }}
    #[inline] pub fn add_resuming(handler: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().add_resuming(handler)
    }}
    #[inline] pub fn remove_resuming(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().remove_resuming(token)
    }}
    #[inline] pub fn get_properties() -> Result<ComPtr<super::super::foundation::collections::IPropertySet>> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().get_properties()
    }}
    #[inline] pub fn get_current_view() -> Result<ComPtr<CoreApplicationView>> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().get_current_view()
    }}
    #[inline] pub fn run(viewSource: &IFrameworkViewSource) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().run(viewSource)
    }}
    #[inline] pub fn run_with_activation_factories(activationFactoryCallback: &super::super::foundation::IGetActivationFactory) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication>>::get_activation_factory().run_with_activation_factories(activationFactoryCallback)
    }}
    #[inline] pub fn add_background_activated(handler: &super::super::foundation::EventHandler<super::activation::BackgroundActivatedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().add_background_activated(handler)
    }}
    #[inline] pub fn remove_background_activated(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().remove_background_activated(token)
    }}
    #[inline] pub fn add_leaving_background(handler: &super::super::foundation::EventHandler<super::LeavingBackgroundEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().add_leaving_background(handler)
    }}
    #[inline] pub fn remove_leaving_background(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().remove_leaving_background(token)
    }}
    #[inline] pub fn add_entered_background(handler: &super::super::foundation::EventHandler<super::EnteredBackgroundEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().add_entered_background(handler)
    }}
    #[inline] pub fn remove_entered_background(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().remove_entered_background(token)
    }}
    #[inline] pub fn enable_prelaunch(value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplication2>>::get_activation_factory().enable_prelaunch(value)
    }}
    #[inline] pub fn request_restart_async(launchArguments: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppRestartFailureReason>>> { unsafe {
        <Self as RtActivatable<ICoreApplication3>>::get_activation_factory().request_restart_async(launchArguments)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn request_restart_for_user_async(user: &super::super::system::User, launchArguments: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppRestartFailureReason>>> { unsafe {
        <Self as RtActivatable<ICoreApplication3>>::get_activation_factory().request_restart_for_user_async(user, launchArguments)
    }}
    #[inline] pub fn exit() -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplicationExit>>::get_activation_factory().exit()
    }}
    #[inline] pub fn add_exiting(handler: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplicationExit>>::get_activation_factory().add_exiting(handler)
    }}
    #[inline] pub fn remove_exiting(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplicationExit>>::get_activation_factory().remove_exiting(token)
    }}
    #[inline] pub fn add_unhandled_error_detected(handler: &super::super::foundation::EventHandler<UnhandledErrorDetectedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<ICoreApplicationUnhandledError>>::get_activation_factory().add_unhandled_error_detected(handler)
    }}
    #[inline] pub fn remove_unhandled_error_detected(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplicationUnhandledError>>::get_activation_factory().remove_unhandled_error_detected(token)
    }}
    #[inline] pub fn increment_application_use_count() -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplicationUseCount>>::get_activation_factory().increment_application_use_count()
    }}
    #[inline] pub fn decrement_application_use_count() -> Result<()> { unsafe {
        <Self as RtActivatable<ICoreApplicationUseCount>>::get_activation_factory().decrement_application_use_count()
    }}
    #[inline] pub fn get_views() -> Result<ComPtr<super::super::foundation::collections::IVectorView<CoreApplicationView>>> { unsafe {
        <Self as RtActivatable<ICoreImmersiveApplication>>::get_activation_factory().get_views()
    }}
    #[inline] pub fn create_new_view(runtimeType: &HStringArg, entryPoint: &HStringArg) -> Result<ComPtr<CoreApplicationView>> { unsafe {
        <Self as RtActivatable<ICoreImmersiveApplication>>::get_activation_factory().create_new_view(runtimeType, entryPoint)
    }}
    #[inline] pub fn get_main_view() -> Result<ComPtr<CoreApplicationView>> { unsafe {
        <Self as RtActivatable<ICoreImmersiveApplication>>::get_activation_factory().get_main_view()
    }}
    #[inline] pub fn create_new_view_from_main_view() -> Result<ComPtr<CoreApplicationView>> { unsafe {
        <Self as RtActivatable<ICoreImmersiveApplication2>>::get_activation_factory().create_new_view_from_main_view()
    }}
    #[inline] pub fn create_new_view_with_view_source(viewSource: &IFrameworkViewSource) -> Result<ComPtr<CoreApplicationView>> { unsafe {
        <Self as RtActivatable<ICoreImmersiveApplication3>>::get_activation_factory().create_new_view_with_view_source(viewSource)
    }}
}
DEFINE_CLSID!(CoreApplication: "Windows.ApplicationModel.Core.CoreApplication");
DEFINE_IID!(IID_ICoreApplication2, 2575729147, 6838, 19327, 190, 74, 154, 6, 69, 34, 76, 4);
RT_INTERFACE!{static interface ICoreApplication2(ICoreApplication2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplication2] {
    fn add_BackgroundActivated(&self, handler: *mut super::super::foundation::EventHandler<super::activation::BackgroundActivatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BackgroundActivated(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_LeavingBackground(&self, handler: *mut super::super::foundation::EventHandler<super::LeavingBackgroundEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LeavingBackground(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_EnteredBackground(&self, handler: *mut super::super::foundation::EventHandler<super::EnteredBackgroundEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EnteredBackground(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn EnablePrelaunch(&self, value: bool) -> HRESULT
}}
impl ICoreApplication2 {
    #[inline] pub unsafe fn add_background_activated(&self, handler: &super::super::foundation::EventHandler<super::activation::BackgroundActivatedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BackgroundActivated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_background_activated(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BackgroundActivated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_leaving_background(&self, handler: &super::super::foundation::EventHandler<super::LeavingBackgroundEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LeavingBackground)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_leaving_background(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LeavingBackground)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_entered_background(&self, handler: &super::super::foundation::EventHandler<super::EnteredBackgroundEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EnteredBackground)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_entered_background(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_EnteredBackground)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn enable_prelaunch(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).EnablePrelaunch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplication3, 4276882745, 22923, 17671, 138, 103, 119, 38, 50, 88, 10, 87);
RT_INTERFACE!{static interface ICoreApplication3(ICoreApplication3Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplication3] {
    fn RequestRestartAsync(&self, launchArguments: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<AppRestartFailureReason>) -> HRESULT,
    #[cfg(feature="windows-system")] fn RequestRestartForUserAsync(&self, user: *mut super::super::system::User, launchArguments: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<AppRestartFailureReason>) -> HRESULT
}}
impl ICoreApplication3 {
    #[inline] pub unsafe fn request_restart_async(&self, launchArguments: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppRestartFailureReason>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestRestartAsync)(self as *const _ as *mut _, launchArguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn request_restart_for_user_async(&self, user: &super::super::system::User, launchArguments: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppRestartFailureReason>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestRestartForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, launchArguments.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationExit, 3481683485, 9758, 19314, 154, 205, 68, 237, 42, 206, 106, 41);
RT_INTERFACE!{static interface ICoreApplicationExit(ICoreApplicationExitVtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationExit] {
    fn Exit(&self) -> HRESULT,
    fn add_Exiting(&self, handler: *mut super::super::foundation::EventHandler<IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Exiting(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationExit {
    #[inline] pub unsafe fn exit(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Exit)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_exiting(&self, handler: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Exiting)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_exiting(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Exiting)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationUnhandledError, 4041362096, 56585, 17121, 176, 188, 224, 225, 49, 247, 141, 126);
RT_INTERFACE!{interface ICoreApplicationUnhandledError(ICoreApplicationUnhandledErrorVtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationUnhandledError] {
    fn add_UnhandledErrorDetected(&self, handler: *mut super::super::foundation::EventHandler<UnhandledErrorDetectedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UnhandledErrorDetected(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationUnhandledError {
    #[inline] pub unsafe fn add_unhandled_error_detected(&self, handler: &super::super::foundation::EventHandler<UnhandledErrorDetectedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UnhandledErrorDetected)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unhandled_error_detected(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UnhandledErrorDetected)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationUseCount, 1368245256, 49271, 18267, 128, 158, 11, 192, 197, 126, 75, 116);
RT_INTERFACE!{static interface ICoreApplicationUseCount(ICoreApplicationUseCountVtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationUseCount] {
    fn IncrementApplicationUseCount(&self) -> HRESULT,
    fn DecrementApplicationUseCount(&self) -> HRESULT
}}
impl ICoreApplicationUseCount {
    #[inline] pub unsafe fn increment_application_use_count(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).IncrementApplicationUseCount)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn decrement_application_use_count(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).DecrementApplicationUseCount)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationView, 1670099675, 17693, 18017, 176, 153, 65, 79, 52, 255, 185, 241);
RT_INTERFACE!{interface ICoreApplicationView(ICoreApplicationViewVtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationView] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_CoreWindow(&self, out: *mut *mut super::super::ui::core::CoreWindow) -> HRESULT,
    fn add_Activated(&self, handler: *mut super::super::foundation::TypedEventHandler<CoreApplicationView, super::activation::IActivatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Activated(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_IsMain(&self, out: *mut bool) -> HRESULT,
    fn get_IsHosted(&self, out: *mut bool) -> HRESULT
}}
impl ICoreApplicationView {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_core_window(&self) -> Result<ComPtr<super::super::ui::core::CoreWindow>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CoreWindow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_activated(&self, handler: &super::super::foundation::TypedEventHandler<CoreApplicationView, super::activation::IActivatedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Activated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_activated(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Activated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_main(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMain)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_hosted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHosted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CoreApplicationView: ICoreApplicationView}
DEFINE_IID!(IID_ICoreApplicationView2, 1760262879, 37247, 18667, 154, 235, 125, 229, 62, 8, 106, 177);
RT_INTERFACE!{interface ICoreApplicationView2(ICoreApplicationView2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationView2] {
    #[cfg(feature="windows-ui")] fn get_Dispatcher(&self, out: *mut *mut super::super::ui::core::CoreDispatcher) -> HRESULT
}}
impl ICoreApplicationView2 {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_dispatcher(&self) -> Result<ComPtr<super::super::ui::core::CoreDispatcher>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Dispatcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationView3, 132899251, 42191, 17744, 171, 112, 176, 126, 133, 51, 11, 200);
RT_INTERFACE!{interface ICoreApplicationView3(ICoreApplicationView3Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationView3] {
    fn get_IsComponent(&self, out: *mut bool) -> HRESULT,
    fn get_TitleBar(&self, out: *mut *mut CoreApplicationViewTitleBar) -> HRESULT,
    fn add_HostedViewClosing(&self, handler: *mut super::super::foundation::TypedEventHandler<CoreApplicationView, HostedViewClosingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_HostedViewClosing(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationView3 {
    #[inline] pub unsafe fn get_is_component(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComponent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title_bar(&self) -> Result<ComPtr<CoreApplicationViewTitleBar>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TitleBar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_hosted_view_closing(&self, handler: &super::super::foundation::TypedEventHandler<CoreApplicationView, HostedViewClosingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_HostedViewClosing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_hosted_view_closing(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_HostedViewClosing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationView5, 734041512, 36592, 17517, 158, 96, 58, 62, 4, 40, 198, 113);
RT_INTERFACE!{interface ICoreApplicationView5(ICoreApplicationView5Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationView5] {
    fn get_Properties(&self, out: *mut *mut super::super::foundation::collections::IPropertySet) -> HRESULT
}}
impl ICoreApplicationView5 {
    #[inline] pub unsafe fn get_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IPropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationView6, 3239695514, 1657, 18874, 128, 63, 183, 156, 92, 243, 76, 202);
RT_INTERFACE!{interface ICoreApplicationView6(ICoreApplicationView6Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationView6] {
    #[cfg(feature="windows-system")] fn get_DispatcherQueue(&self, out: *mut *mut super::super::system::DispatcherQueue) -> HRESULT
}}
impl ICoreApplicationView6 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_dispatcher_queue(&self) -> Result<ComPtr<super::super::system::DispatcherQueue>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DispatcherQueue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreApplicationViewTitleBar, 7157219, 57841, 17179, 149, 8, 41, 185, 105, 38, 172, 83);
RT_INTERFACE!{interface ICoreApplicationViewTitleBar(ICoreApplicationViewTitleBarVtbl): IInspectable(IInspectableVtbl) [IID_ICoreApplicationViewTitleBar] {
    fn put_ExtendViewIntoTitleBar(&self, value: bool) -> HRESULT,
    fn get_ExtendViewIntoTitleBar(&self, out: *mut bool) -> HRESULT,
    fn get_SystemOverlayLeftInset(&self, out: *mut f64) -> HRESULT,
    fn get_SystemOverlayRightInset(&self, out: *mut f64) -> HRESULT,
    fn get_Height(&self, out: *mut f64) -> HRESULT,
    fn add_LayoutMetricsChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LayoutMetricsChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_IsVisible(&self, out: *mut bool) -> HRESULT,
    fn add_IsVisibleChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_IsVisibleChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ICoreApplicationViewTitleBar {
    #[inline] pub unsafe fn set_extend_view_into_title_bar(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExtendViewIntoTitleBar)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extend_view_into_title_bar(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendViewIntoTitleBar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_system_overlay_left_inset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemOverlayLeftInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_system_overlay_right_inset(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemOverlayRightInset)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_height(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Height)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_layout_metrics_changed(&self, handler: &super::super::foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LayoutMetricsChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_layout_metrics_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LayoutMetricsChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_is_visible_changed(&self, handler: &super::super::foundation::TypedEventHandler<CoreApplicationViewTitleBar, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_IsVisibleChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_is_visible_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_IsVisibleChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CoreApplicationViewTitleBar: ICoreApplicationViewTitleBar}
DEFINE_IID!(IID_ICoreImmersiveApplication, 450498110, 58530, 16675, 180, 81, 220, 150, 191, 128, 4, 25);
RT_INTERFACE!{static interface ICoreImmersiveApplication(ICoreImmersiveApplicationVtbl): IInspectable(IInspectableVtbl) [IID_ICoreImmersiveApplication] {
    fn get_Views(&self, out: *mut *mut super::super::foundation::collections::IVectorView<CoreApplicationView>) -> HRESULT,
    fn CreateNewView(&self, runtimeType: HSTRING, entryPoint: HSTRING, out: *mut *mut CoreApplicationView) -> HRESULT,
    fn get_MainView(&self, out: *mut *mut CoreApplicationView) -> HRESULT
}}
impl ICoreImmersiveApplication {
    #[inline] pub unsafe fn get_views(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<CoreApplicationView>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Views)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_new_view(&self, runtimeType: &HStringArg, entryPoint: &HStringArg) -> Result<ComPtr<CoreApplicationView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateNewView)(self as *const _ as *mut _, runtimeType.get(), entryPoint.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_main_view(&self) -> Result<ComPtr<CoreApplicationView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MainView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreImmersiveApplication2, 2190351926, 59875, 19708, 155, 102, 72, 183, 142, 169, 187, 44);
RT_INTERFACE!{static interface ICoreImmersiveApplication2(ICoreImmersiveApplication2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreImmersiveApplication2] {
    fn CreateNewViewFromMainView(&self, out: *mut *mut CoreApplicationView) -> HRESULT
}}
impl ICoreImmersiveApplication2 {
    #[inline] pub unsafe fn create_new_view_from_main_view(&self) -> Result<ComPtr<CoreApplicationView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateNewViewFromMainView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreImmersiveApplication3, 882924335, 60941, 16869, 131, 20, 207, 16, 201, 27, 240, 175);
RT_INTERFACE!{static interface ICoreImmersiveApplication3(ICoreImmersiveApplication3Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreImmersiveApplication3] {
    fn CreateNewViewWithViewSource(&self, viewSource: *mut IFrameworkViewSource, out: *mut *mut CoreApplicationView) -> HRESULT
}}
impl ICoreImmersiveApplication3 {
    #[inline] pub unsafe fn create_new_view_with_view_source(&self, viewSource: &IFrameworkViewSource) -> Result<ComPtr<CoreApplicationView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateNewViewWithViewSource)(self as *const _ as *mut _, viewSource as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkView, 4205534416, 35108, 17836, 173, 15, 160, 143, 174, 93, 3, 36);
RT_INTERFACE!{interface IFrameworkView(IFrameworkViewVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkView] {
    fn Initialize(&self, applicationView: *mut CoreApplicationView) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn SetWindow(&self, window: *mut super::super::ui::core::CoreWindow) -> HRESULT,
    fn Load(&self, entryPoint: HSTRING) -> HRESULT,
    fn Run(&self) -> HRESULT,
    fn Uninitialize(&self) -> HRESULT
}}
impl IFrameworkView {
    #[inline] pub unsafe fn initialize(&self, applicationView: &CoreApplicationView) -> Result<()> {
        let hr = ((*self.lpVtbl).Initialize)(self as *const _ as *mut _, applicationView as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_window(&self, window: &super::super::ui::core::CoreWindow) -> Result<()> {
        let hr = ((*self.lpVtbl).SetWindow)(self as *const _ as *mut _, window as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn load(&self, entryPoint: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).Load)(self as *const _ as *mut _, entryPoint.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn run(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Run)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn uninitialize(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Uninitialize)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFrameworkViewSource, 3447129620, 26052, 17004, 148, 148, 52, 252, 67, 85, 72, 98);
RT_INTERFACE!{interface IFrameworkViewSource(IFrameworkViewSourceVtbl): IInspectable(IInspectableVtbl) [IID_IFrameworkViewSource] {
    fn CreateView(&self, out: *mut *mut IFrameworkView) -> HRESULT
}}
impl IFrameworkViewSource {
    #[inline] pub unsafe fn create_view(&self) -> Result<ComPtr<IFrameworkView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IHostedViewClosingEventArgs, 3526923324, 45646, 18320, 172, 181, 62, 66, 67, 196, 255, 135);
RT_INTERFACE!{interface IHostedViewClosingEventArgs(IHostedViewClosingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IHostedViewClosingEventArgs] {
    fn GetDeferral(&self, out: *mut *mut super::super::foundation::Deferral) -> HRESULT
}}
impl IHostedViewClosingEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class HostedViewClosingEventArgs: IHostedViewClosingEventArgs}
DEFINE_IID!(IID_IUnhandledError, 2488907558, 21429, 18054, 158, 175, 250, 129, 98, 220, 57, 128);
RT_INTERFACE!{interface IUnhandledError(IUnhandledErrorVtbl): IInspectable(IInspectableVtbl) [IID_IUnhandledError] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn Propagate(&self) -> HRESULT
}}
impl IUnhandledError {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn propagate(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Propagate)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UnhandledError: IUnhandledError}
DEFINE_IID!(IID_IUnhandledErrorDetectedEventArgs, 1738192779, 45878, 18466, 172, 64, 13, 117, 15, 11, 122, 43);
RT_INTERFACE!{interface IUnhandledErrorDetectedEventArgs(IUnhandledErrorDetectedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUnhandledErrorDetectedEventArgs] {
    fn get_UnhandledError(&self, out: *mut *mut UnhandledError) -> HRESULT
}}
impl IUnhandledErrorDetectedEventArgs {
    #[inline] pub unsafe fn get_unhandled_error(&self) -> Result<ComPtr<UnhandledError>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnhandledError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UnhandledErrorDetectedEventArgs: IUnhandledErrorDetectedEventArgs}
} // Windows.ApplicationModel.Core
pub mod appservice { // Windows.ApplicationModel.AppService
use ::prelude::*;
RT_CLASS!{static class AppServiceCatalog}
impl RtActivatable<IAppServiceCatalogStatics> for AppServiceCatalog {}
impl AppServiceCatalog {
    #[inline] pub fn find_app_service_providers_async(appServiceName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::AppInfo>>>> { unsafe {
        <Self as RtActivatable<IAppServiceCatalogStatics>>::get_activation_factory().find_app_service_providers_async(appServiceName)
    }}
}
DEFINE_CLSID!(AppServiceCatalog: "Windows.ApplicationModel.AppService.AppServiceCatalog");
DEFINE_IID!(IID_IAppServiceCatalogStatics, 4010616071, 53554, 19589, 131, 149, 60, 49, 213, 161, 233, 65);
RT_INTERFACE!{static interface IAppServiceCatalogStatics(IAppServiceCatalogStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceCatalogStatics] {
    fn FindAppServiceProvidersAsync(&self, appServiceName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::AppInfo>>) -> HRESULT
}}
impl IAppServiceCatalogStatics {
    #[inline] pub unsafe fn find_app_service_providers_async(&self, appServiceName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::AppInfo>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppServiceProvidersAsync)(self as *const _ as *mut _, appServiceName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppServiceClosedEventArgs, 3730839286, 51971, 19765, 172, 141, 204, 99, 3, 35, 151, 49);
RT_INTERFACE!{interface IAppServiceClosedEventArgs(IAppServiceClosedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceClosedEventArgs] {
    fn get_Status(&self, out: *mut AppServiceClosedStatus) -> HRESULT
}}
impl IAppServiceClosedEventArgs {
    #[inline] pub unsafe fn get_status(&self) -> Result<AppServiceClosedStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceClosedEventArgs: IAppServiceClosedEventArgs}
RT_ENUM! { enum AppServiceClosedStatus: i32 {
    Completed (AppServiceClosedStatus_Completed) = 0, Canceled (AppServiceClosedStatus_Canceled) = 1, ResourceLimitsExceeded (AppServiceClosedStatus_ResourceLimitsExceeded) = 2, Unknown (AppServiceClosedStatus_Unknown) = 3,
}}
DEFINE_IID!(IID_IAppServiceConnection, 2647946402, 34591, 19794, 137, 169, 158, 9, 5, 49, 189, 39);
RT_INTERFACE!{interface IAppServiceConnection(IAppServiceConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceConnection] {
    fn get_AppServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppServiceName(&self, value: HSTRING) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PackageFamilyName(&self, value: HSTRING) -> HRESULT,
    fn OpenAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<AppServiceConnectionStatus>) -> HRESULT,
    fn SendMessageAsync(&self, message: *mut super::super::foundation::collections::ValueSet, out: *mut *mut super::super::foundation::IAsyncOperation<AppServiceResponse>) -> HRESULT,
    fn add_RequestReceived(&self, handler: *mut super::super::foundation::TypedEventHandler<AppServiceConnection, AppServiceRequestReceivedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RequestReceived(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ServiceClosed(&self, handler: *mut super::super::foundation::TypedEventHandler<AppServiceConnection, AppServiceClosedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServiceClosed(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppServiceConnection {
    #[inline] pub unsafe fn get_app_service_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppServiceName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_app_service_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AppServiceName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_package_family_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PackageFamilyName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn open_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppServiceConnectionStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OpenAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn send_message_async(&self, message: &super::super::foundation::collections::ValueSet) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppServiceResponse>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SendMessageAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_request_received(&self, handler: &super::super::foundation::TypedEventHandler<AppServiceConnection, AppServiceRequestReceivedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RequestReceived)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_request_received(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_RequestReceived)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_service_closed(&self, handler: &super::super::foundation::TypedEventHandler<AppServiceConnection, AppServiceClosedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ServiceClosed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_service_closed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ServiceClosed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceConnection: IAppServiceConnection}
impl RtActivatable<IActivationFactory> for AppServiceConnection {}
DEFINE_CLSID!(AppServiceConnection: "Windows.ApplicationModel.AppService.AppServiceConnection");
DEFINE_IID!(IID_IAppServiceConnection2, 2346700127, 8962, 20413, 128, 97, 82, 81, 28, 47, 139, 249);
RT_INTERFACE!{interface IAppServiceConnection2(IAppServiceConnection2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceConnection2] {
    #[cfg(feature="windows-system")] fn OpenRemoteAsync(&self, remoteSystemConnectionRequest: *mut super::super::system::remotesystems::RemoteSystemConnectionRequest, out: *mut *mut super::super::foundation::IAsyncOperation<AppServiceConnectionStatus>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT,
    #[cfg(feature="windows-system")] fn put_User(&self, value: *mut super::super::system::User) -> HRESULT
}}
impl IAppServiceConnection2 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn open_remote_async(&self, remoteSystemConnectionRequest: &super::super::system::remotesystems::RemoteSystemConnectionRequest) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppServiceConnectionStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OpenRemoteAsync)(self as *const _ as *mut _, remoteSystemConnectionRequest as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn set_user(&self, value: &super::super::system::User) -> Result<()> {
        let hr = ((*self.lpVtbl).put_User)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum AppServiceConnectionStatus: i32 {
    Success (AppServiceConnectionStatus_Success) = 0, AppNotInstalled (AppServiceConnectionStatus_AppNotInstalled) = 1, AppUnavailable (AppServiceConnectionStatus_AppUnavailable) = 2, AppServiceUnavailable (AppServiceConnectionStatus_AppServiceUnavailable) = 3, Unknown (AppServiceConnectionStatus_Unknown) = 4, RemoteSystemUnavailable (AppServiceConnectionStatus_RemoteSystemUnavailable) = 5, RemoteSystemNotSupportedByApp (AppServiceConnectionStatus_RemoteSystemNotSupportedByApp) = 6, NotAuthorized (AppServiceConnectionStatus_NotAuthorized) = 7,
}}
DEFINE_IID!(IID_IAppServiceDeferral, 2115719970, 60080, 16968, 174, 4, 253, 249, 56, 56, 228, 114);
RT_INTERFACE!{interface IAppServiceDeferral(IAppServiceDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IAppServiceDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceDeferral: IAppServiceDeferral}
DEFINE_IID!(IID_IAppServiceRequest, 551914909, 6366, 19201, 128, 186, 144, 167, 98, 4, 227, 200);
RT_INTERFACE!{interface IAppServiceRequest(IAppServiceRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceRequest] {
    fn get_Message(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT,
    fn SendResponseAsync(&self, message: *mut super::super::foundation::collections::ValueSet, out: *mut *mut super::super::foundation::IAsyncOperation<AppServiceResponseStatus>) -> HRESULT
}}
impl IAppServiceRequest {
    #[inline] pub unsafe fn get_message(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn send_response_async(&self, message: &super::super::foundation::collections::ValueSet) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppServiceResponseStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SendResponseAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceRequest: IAppServiceRequest}
DEFINE_IID!(IID_IAppServiceRequestReceivedEventArgs, 1846682464, 65381, 17582, 158, 69, 133, 127, 228, 24, 6, 129);
RT_INTERFACE!{interface IAppServiceRequestReceivedEventArgs(IAppServiceRequestReceivedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceRequestReceivedEventArgs] {
    fn get_Request(&self, out: *mut *mut AppServiceRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut AppServiceDeferral) -> HRESULT
}}
impl IAppServiceRequestReceivedEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppServiceRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<AppServiceDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceRequestReceivedEventArgs: IAppServiceRequestReceivedEventArgs}
DEFINE_IID!(IID_IAppServiceResponse, 2370845932, 39587, 20072, 149, 89, 157, 230, 62, 55, 44, 228);
RT_INTERFACE!{interface IAppServiceResponse(IAppServiceResponseVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceResponse] {
    fn get_Message(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT,
    fn get_Status(&self, out: *mut AppServiceResponseStatus) -> HRESULT
}}
impl IAppServiceResponse {
    #[inline] pub unsafe fn get_message(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<AppServiceResponseStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceResponse: IAppServiceResponse}
RT_ENUM! { enum AppServiceResponseStatus: i32 {
    Success (AppServiceResponseStatus_Success) = 0, Failure (AppServiceResponseStatus_Failure) = 1, ResourceLimitsExceeded (AppServiceResponseStatus_ResourceLimitsExceeded) = 2, Unknown (AppServiceResponseStatus_Unknown) = 3, RemoteSystemUnavailable (AppServiceResponseStatus_RemoteSystemUnavailable) = 4, MessageSizeTooLarge (AppServiceResponseStatus_MessageSizeTooLarge) = 5,
}}
DEFINE_IID!(IID_IAppServiceTriggerDetails, 2292374700, 44328, 16824, 128, 187, 189, 241, 178, 22, 158, 25);
RT_INTERFACE!{interface IAppServiceTriggerDetails(IAppServiceTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceTriggerDetails] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppServiceConnection(&self, out: *mut *mut AppServiceConnection) -> HRESULT
}}
impl IAppServiceTriggerDetails {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_caller_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallerPackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_service_connection(&self) -> Result<ComPtr<AppServiceConnection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppServiceConnection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppServiceTriggerDetails: IAppServiceTriggerDetails}
DEFINE_IID!(IID_IAppServiceTriggerDetails2, 3896333490, 10444, 17394, 180, 101, 192, 72, 46, 89, 226, 220);
RT_INTERFACE!{interface IAppServiceTriggerDetails2(IAppServiceTriggerDetails2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceTriggerDetails2] {
    fn get_IsRemoteSystemConnection(&self, out: *mut bool) -> HRESULT
}}
impl IAppServiceTriggerDetails2 {
    #[inline] pub unsafe fn get_is_remote_system_connection(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRemoteSystemConnection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppServiceTriggerDetails3, 4225179169, 31033, 20072, 158, 60, 119, 128, 20, 122, 171, 182);
RT_INTERFACE!{interface IAppServiceTriggerDetails3(IAppServiceTriggerDetails3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppServiceTriggerDetails3] {
    fn CheckCallerForCapabilityAsync(&self, capabilityName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IAppServiceTriggerDetails3 {
    #[inline] pub unsafe fn check_caller_for_capability_async(&self, capabilityName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CheckCallerForCapabilityAsync)(self as *const _ as *mut _, capabilityName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.AppService
pub mod appointments { // Windows.ApplicationModel.Appointments
use ::prelude::*;
DEFINE_IID!(IID_IAppointment, 3707776815, 11229, 16502, 144, 163, 34, 194, 117, 49, 41, 101);
RT_INTERFACE!{interface IAppointment(IAppointmentVtbl): IInspectable(IInspectableVtbl) [IID_IAppointment] {
    fn get_StartTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_Duration(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: super::super::foundation::TimeSpan) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Location(&self, value: HSTRING) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_Details(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Details(&self, value: HSTRING) -> HRESULT,
    fn get_Reminder(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> HRESULT,
    fn put_Reminder(&self, value: *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> HRESULT,
    fn get_Organizer(&self, out: *mut *mut AppointmentOrganizer) -> HRESULT,
    fn put_Organizer(&self, value: *mut AppointmentOrganizer) -> HRESULT,
    fn get_Invitees(&self, out: *mut *mut super::super::foundation::collections::IVector<AppointmentInvitee>) -> HRESULT,
    fn get_Recurrence(&self, out: *mut *mut AppointmentRecurrence) -> HRESULT,
    fn put_Recurrence(&self, value: *mut AppointmentRecurrence) -> HRESULT,
    fn get_BusyStatus(&self, out: *mut AppointmentBusyStatus) -> HRESULT,
    fn put_BusyStatus(&self, value: AppointmentBusyStatus) -> HRESULT,
    fn get_AllDay(&self, out: *mut bool) -> HRESULT,
    fn put_AllDay(&self, value: bool) -> HRESULT,
    fn get_Sensitivity(&self, out: *mut AppointmentSensitivity) -> HRESULT,
    fn put_Sensitivity(&self, value: AppointmentSensitivity) -> HRESULT,
    fn get_Uri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_Uri(&self, value: *mut super::super::foundation::Uri) -> HRESULT
}}
impl IAppointment {
    #[inline] pub unsafe fn get_start_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_duration(&self, value: super::super::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Duration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_location(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_location(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Location)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_subject(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Subject)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Details)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_details(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Details)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reminder(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::TimeSpan>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Reminder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reminder(&self, value: &super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Reminder)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_organizer(&self) -> Result<ComPtr<AppointmentOrganizer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Organizer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_organizer(&self, value: &AppointmentOrganizer) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Organizer)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_invitees(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<AppointmentInvitee>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Invitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recurrence(&self) -> Result<ComPtr<AppointmentRecurrence>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recurrence)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_recurrence(&self, value: &AppointmentRecurrence) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Recurrence)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_busy_status(&self) -> Result<AppointmentBusyStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BusyStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_busy_status(&self, value: AppointmentBusyStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BusyStatus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_all_day(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllDay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_all_day(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllDay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sensitivity(&self) -> Result<AppointmentSensitivity> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Sensitivity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sensitivity(&self, value: AppointmentSensitivity) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Sensitivity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Uri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class Appointment: IAppointment}
impl RtActivatable<IActivationFactory> for Appointment {}
DEFINE_CLSID!(Appointment: "Windows.ApplicationModel.Appointments.Appointment");
DEFINE_IID!(IID_IAppointment2, 1585813564, 21519, 13394, 155, 92, 13, 215, 173, 76, 101, 162);
RT_INTERFACE!{interface IAppointment2(IAppointment2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointment2] {
    fn get_LocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CalendarId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RoamingId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RoamingId(&self, value: HSTRING) -> HRESULT,
    fn get_OriginalStartTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_IsResponseRequested(&self, out: *mut bool) -> HRESULT,
    fn put_IsResponseRequested(&self, value: bool) -> HRESULT,
    fn get_AllowNewTimeProposal(&self, out: *mut bool) -> HRESULT,
    fn put_AllowNewTimeProposal(&self, value: bool) -> HRESULT,
    fn get_OnlineMeetingLink(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OnlineMeetingLink(&self, value: HSTRING) -> HRESULT,
    fn get_ReplyTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_ReplyTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_UserResponse(&self, out: *mut AppointmentParticipantResponse) -> HRESULT,
    fn put_UserResponse(&self, value: AppointmentParticipantResponse) -> HRESULT,
    fn get_HasInvitees(&self, out: *mut bool) -> HRESULT,
    fn get_IsCanceledMeeting(&self, out: *mut bool) -> HRESULT,
    fn put_IsCanceledMeeting(&self, value: bool) -> HRESULT,
    fn get_IsOrganizedByUser(&self, out: *mut bool) -> HRESULT,
    fn put_IsOrganizedByUser(&self, value: bool) -> HRESULT
}}
impl IAppointment2 {
    #[inline] pub unsafe fn get_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_roaming_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RoamingId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_roaming_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RoamingId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_original_start_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_response_requested(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsResponseRequested)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_response_requested(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsResponseRequested)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_new_time_proposal(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowNewTimeProposal)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_new_time_proposal(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowNewTimeProposal)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_online_meeting_link(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OnlineMeetingLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_online_meeting_link(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OnlineMeetingLink)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reply_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReplyTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reply_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ReplyTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_response(&self) -> Result<AppointmentParticipantResponse> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UserResponse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_user_response(&self, value: AppointmentParticipantResponse) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UserResponse)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_invitees(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasInvitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_canceled_meeting(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCanceledMeeting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_canceled_meeting(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCanceledMeeting)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_organized_by_user(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOrganizedByUser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_organized_by_user(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOrganizedByUser)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointment3, 3217835433, 35169, 18833, 147, 75, 196, 135, 104, 229, 169, 108);
RT_INTERFACE!{interface IAppointment3(IAppointment3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointment3] {
    fn get_ChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn get_RemoteChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn put_RemoteChangeNumber(&self, value: u64) -> HRESULT,
    fn get_DetailsKind(&self, out: *mut AppointmentDetailsKind) -> HRESULT,
    fn put_DetailsKind(&self, value: AppointmentDetailsKind) -> HRESULT
}}
impl IAppointment3 {
    #[inline] pub unsafe fn get_change_number(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_change_number(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RemoteChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_change_number(&self, value: u64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteChangeNumber)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details_kind(&self) -> Result<AppointmentDetailsKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DetailsKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_details_kind(&self, value: AppointmentDetailsKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DetailsKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentBusyStatus: i32 {
    Busy (AppointmentBusyStatus_Busy) = 0, Tentative (AppointmentBusyStatus_Tentative) = 1, Free (AppointmentBusyStatus_Free) = 2, OutOfOffice (AppointmentBusyStatus_OutOfOffice) = 3, WorkingElsewhere (AppointmentBusyStatus_WorkingElsewhere) = 4,
}}
DEFINE_IID!(IID_IAppointmentCalendar, 1383301533, 33593, 15695, 160, 47, 100, 8, 68, 82, 187, 93);
RT_INTERFACE!{interface IAppointmentCalendar(IAppointmentCalendarVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendar] {
    #[cfg(not(feature="windows-ui"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_DisplayColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_LocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsHidden(&self, out: *mut bool) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut AppointmentCalendarOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: AppointmentCalendarOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut AppointmentCalendarOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: AppointmentCalendarOtherAppWriteAccess) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SummaryCardView(&self, out: *mut AppointmentSummaryCardView) -> HRESULT,
    fn put_SummaryCardView(&self, value: AppointmentSummaryCardView) -> HRESULT,
    fn FindAppointmentsAsync(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn FindAppointmentsAsyncWithOptions(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, options: *mut FindAppointmentsOptions, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn FindExceptionsFromMasterAsync(&self, masterLocalId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentException>>) -> HRESULT,
    fn FindAllInstancesAsync(&self, masterLocalId: HSTRING, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn FindAllInstancesAsyncWithOptions(&self, masterLocalId: HSTRING, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, pOptions: *mut FindAppointmentsOptions, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn GetAppointmentAsync(&self, localId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Appointment>) -> HRESULT,
    fn GetAppointmentInstanceAsync(&self, localId: HSTRING, instanceStartTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<Appointment>) -> HRESULT,
    fn FindUnexpandedAppointmentsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn FindUnexpandedAppointmentsAsyncWithOptions(&self, options: *mut FindAppointmentsOptions, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteAppointmentAsync(&self, localId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteAppointmentInstanceAsync(&self, localId: HSTRING, instanceStartTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SaveAppointmentAsync(&self, pAppointment: *mut Appointment, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendar {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_display_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisplayColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_hidden(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHidden)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_read_access(&self) -> Result<AppointmentCalendarOtherAppReadAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppReadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_read_access(&self, value: AppointmentCalendarOtherAppReadAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppReadAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_write_access(&self) -> Result<AppointmentCalendarOtherAppWriteAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppWriteAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_write_access(&self, value: AppointmentCalendarOtherAppWriteAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppWriteAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_summary_card_view(&self) -> Result<AppointmentSummaryCardView> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SummaryCardView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_summary_card_view(&self, value: AppointmentSummaryCardView) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SummaryCardView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointments_async(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentsAsync)(self as *const _ as *mut _, rangeStart, rangeLength, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointments_async_with_options(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, options: &FindAppointmentsOptions) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentsAsyncWithOptions)(self as *const _ as *mut _, rangeStart, rangeLength, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_exceptions_from_master_async(&self, masterLocalId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentException>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindExceptionsFromMasterAsync)(self as *const _ as *mut _, masterLocalId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_all_instances_async(&self, masterLocalId: &HStringArg, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllInstancesAsync)(self as *const _ as *mut _, masterLocalId.get(), rangeStart, rangeLength, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_all_instances_async_with_options(&self, masterLocalId: &HStringArg, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, pOptions: &FindAppointmentsOptions) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllInstancesAsyncWithOptions)(self as *const _ as *mut _, masterLocalId.get(), rangeStart, rangeLength, pOptions as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_async(&self, localId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Appointment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppointmentAsync)(self as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_instance_async(&self, localId: &HStringArg, instanceStartTime: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Appointment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppointmentInstanceAsync)(self as *const _ as *mut _, localId.get(), instanceStartTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_unexpanded_appointments_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindUnexpandedAppointmentsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_unexpanded_appointments_async_with_options(&self, options: &FindAppointmentsOptions) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindUnexpandedAppointmentsAsyncWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_appointment_async(&self, localId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAppointmentAsync)(self as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_appointment_instance_async(&self, localId: &HStringArg, instanceStartTime: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAppointmentInstanceAsync)(self as *const _ as *mut _, localId.get(), instanceStartTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_appointment_async(&self, pAppointment: &Appointment) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAppointmentAsync)(self as *const _ as *mut _, pAppointment as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendar: IAppointmentCalendar}
DEFINE_IID!(IID_IAppointmentCalendar2, 417850402, 9319, 19996, 164, 89, 216, 162, 147, 3, 208, 146);
RT_INTERFACE!{interface IAppointmentCalendar2(IAppointmentCalendar2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendar2] {
    fn get_SyncManager(&self, out: *mut *mut AppointmentCalendarSyncManager) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_DisplayColor(&self, value: super::super::ui::Color) -> HRESULT,
    fn put_IsHidden(&self, value: bool) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CanCreateOrUpdateAppointments(&self, out: *mut bool) -> HRESULT,
    fn put_CanCreateOrUpdateAppointments(&self, value: bool) -> HRESULT,
    fn get_CanCancelMeetings(&self, out: *mut bool) -> HRESULT,
    fn put_CanCancelMeetings(&self, value: bool) -> HRESULT,
    fn get_CanForwardMeetings(&self, out: *mut bool) -> HRESULT,
    fn put_CanForwardMeetings(&self, value: bool) -> HRESULT,
    fn get_CanProposeNewTimeForMeetings(&self, out: *mut bool) -> HRESULT,
    fn put_CanProposeNewTimeForMeetings(&self, value: bool) -> HRESULT,
    fn get_CanUpdateMeetingResponses(&self, out: *mut bool) -> HRESULT,
    fn put_CanUpdateMeetingResponses(&self, value: bool) -> HRESULT,
    fn get_CanNotifyInvitees(&self, out: *mut bool) -> HRESULT,
    fn put_CanNotifyInvitees(&self, value: bool) -> HRESULT,
    fn get_MustNofityInvitees(&self, out: *mut bool) -> HRESULT,
    fn put_MustNofityInvitees(&self, value: bool) -> HRESULT,
    fn TryCreateOrUpdateAppointmentAsync(&self, appointment: *mut Appointment, notifyInvitees: bool, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryCancelMeetingAsync(&self, meeting: *mut Appointment, subject: HSTRING, comment: HSTRING, notifyInvitees: bool, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryForwardMeetingAsync(&self, meeting: *mut Appointment, invitees: *mut super::super::foundation::collections::IIterable<AppointmentInvitee>, subject: HSTRING, forwardHeader: HSTRING, comment: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryProposeNewTimeForMeetingAsync(&self, meeting: *mut Appointment, newStartTime: super::super::foundation::DateTime, newDuration: super::super::foundation::TimeSpan, subject: HSTRING, comment: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryUpdateMeetingResponseAsync(&self, meeting: *mut Appointment, response: AppointmentParticipantResponse, subject: HSTRING, comment: HSTRING, sendUpdate: bool, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IAppointmentCalendar2 {
    #[inline] pub unsafe fn get_sync_manager(&self) -> Result<ComPtr<AppointmentCalendarSyncManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SyncManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_display_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_hidden(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHidden)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_create_or_update_appointments(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanCreateOrUpdateAppointments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_create_or_update_appointments(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanCreateOrUpdateAppointments)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_cancel_meetings(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanCancelMeetings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_cancel_meetings(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanCancelMeetings)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_forward_meetings(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanForwardMeetings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_forward_meetings(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanForwardMeetings)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_propose_new_time_for_meetings(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanProposeNewTimeForMeetings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_propose_new_time_for_meetings(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanProposeNewTimeForMeetings)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_update_meeting_responses(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanUpdateMeetingResponses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_update_meeting_responses(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanUpdateMeetingResponses)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_notify_invitees(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanNotifyInvitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_notify_invitees(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanNotifyInvitees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_must_nofity_invitees(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MustNofityInvitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_must_nofity_invitees(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MustNofityInvitees)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_create_or_update_appointment_async(&self, appointment: &Appointment, notifyInvitees: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCreateOrUpdateAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, notifyInvitees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_cancel_meeting_async(&self, meeting: &Appointment, subject: &HStringArg, comment: &HStringArg, notifyInvitees: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCancelMeetingAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, subject.get(), comment.get(), notifyInvitees, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_forward_meeting_async(&self, meeting: &Appointment, invitees: &super::super::foundation::collections::IIterable<AppointmentInvitee>, subject: &HStringArg, forwardHeader: &HStringArg, comment: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryForwardMeetingAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, invitees as *const _ as *mut _, subject.get(), forwardHeader.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_propose_new_time_for_meeting_async(&self, meeting: &Appointment, newStartTime: super::super::foundation::DateTime, newDuration: super::super::foundation::TimeSpan, subject: &HStringArg, comment: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryProposeNewTimeForMeetingAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, newStartTime, newDuration, subject.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_update_meeting_response_async(&self, meeting: &Appointment, response: AppointmentParticipantResponse, subject: &HStringArg, comment: &HStringArg, sendUpdate: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryUpdateMeetingResponseAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, response, subject.get(), comment.get(), sendUpdate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentCalendar3, 3944993323, 42629, 17070, 132, 149, 179, 17, 154, 219, 65, 103);
RT_INTERFACE!{interface IAppointmentCalendar3(IAppointmentCalendar3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendar3] {
    fn RegisterSyncManagerAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendar3 {
    #[inline] pub unsafe fn register_sync_manager_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterSyncManagerAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentCalendarOtherAppReadAccess: i32 {
    SystemOnly (AppointmentCalendarOtherAppReadAccess_SystemOnly) = 0, Limited (AppointmentCalendarOtherAppReadAccess_Limited) = 1, Full (AppointmentCalendarOtherAppReadAccess_Full) = 2, None (AppointmentCalendarOtherAppReadAccess_None) = 3,
}}
RT_ENUM! { enum AppointmentCalendarOtherAppWriteAccess: i32 {
    None (AppointmentCalendarOtherAppWriteAccess_None) = 0, SystemOnly (AppointmentCalendarOtherAppWriteAccess_SystemOnly) = 1, Limited (AppointmentCalendarOtherAppWriteAccess_Limited) = 2,
}}
DEFINE_IID!(IID_IAppointmentCalendarSyncManager, 723628960, 19199, 17298, 188, 95, 86, 69, 255, 207, 251, 23);
RT_INTERFACE!{interface IAppointmentCalendarSyncManager(IAppointmentCalendarSyncManagerVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarSyncManager] {
    fn get_Status(&self, out: *mut AppointmentCalendarSyncStatus) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_LastAttemptedSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn SyncAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<AppointmentCalendarSyncManager, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppointmentCalendarSyncManager {
    #[inline] pub unsafe fn get_status(&self) -> Result<AppointmentCalendarSyncStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_successful_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastSuccessfulSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_attempted_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastAttemptedSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn sync_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SyncAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_sync_status_changed(&self, handler: &super::super::foundation::TypedEventHandler<AppointmentCalendarSyncManager, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_status_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarSyncManager: IAppointmentCalendarSyncManager}
DEFINE_IID!(IID_IAppointmentCalendarSyncManager2, 1685399725, 3369, 19580, 170, 167, 191, 153, 104, 5, 83, 124);
RT_INTERFACE!{interface IAppointmentCalendarSyncManager2(IAppointmentCalendarSyncManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarSyncManager2] {
    fn put_Status(&self, value: AppointmentCalendarSyncStatus) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT
}}
impl IAppointmentCalendarSyncManager2 {
    #[inline] pub unsafe fn set_status(&self, value: AppointmentCalendarSyncStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Status)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_successful_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastSuccessfulSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_attempted_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastAttemptedSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentCalendarSyncStatus: i32 {
    Idle (AppointmentCalendarSyncStatus_Idle) = 0, Syncing (AppointmentCalendarSyncStatus_Syncing) = 1, UpToDate (AppointmentCalendarSyncStatus_UpToDate) = 2, AuthenticationError (AppointmentCalendarSyncStatus_AuthenticationError) = 3, PolicyError (AppointmentCalendarSyncStatus_PolicyError) = 4, UnknownError (AppointmentCalendarSyncStatus_UnknownError) = 5, ManualAccountRemovalRequired (AppointmentCalendarSyncStatus_ManualAccountRemovalRequired) = 6,
}}
DEFINE_IID!(IID_IAppointmentConflictResult, 3587043518, 12079, 15229, 175, 10, 167, 226, 15, 58, 70, 227);
RT_INTERFACE!{interface IAppointmentConflictResult(IAppointmentConflictResultVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentConflictResult] {
    fn get_Type(&self, out: *mut AppointmentConflictType) -> HRESULT,
    fn get_Date(&self, out: *mut super::super::foundation::DateTime) -> HRESULT
}}
impl IAppointmentConflictResult {
    #[inline] pub unsafe fn get_type(&self) -> Result<AppointmentConflictType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_date(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Date)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentConflictResult: IAppointmentConflictResult}
RT_ENUM! { enum AppointmentConflictType: i32 {
    None (AppointmentConflictType_None) = 0, Adjacent (AppointmentConflictType_Adjacent) = 1, Overlap (AppointmentConflictType_Overlap) = 2,
}}
RT_ENUM! { enum AppointmentDaysOfWeek: u32 {
    None (AppointmentDaysOfWeek_None) = 0, Sunday (AppointmentDaysOfWeek_Sunday) = 1, Monday (AppointmentDaysOfWeek_Monday) = 2, Tuesday (AppointmentDaysOfWeek_Tuesday) = 4, Wednesday (AppointmentDaysOfWeek_Wednesday) = 8, Thursday (AppointmentDaysOfWeek_Thursday) = 16, Friday (AppointmentDaysOfWeek_Friday) = 32, Saturday (AppointmentDaysOfWeek_Saturday) = 64,
}}
RT_ENUM! { enum AppointmentDetailsKind: i32 {
    PlainText (AppointmentDetailsKind_PlainText) = 0, Html (AppointmentDetailsKind_Html) = 1,
}}
DEFINE_IID!(IID_IAppointmentException, 2718394215, 5878, 19406, 159, 90, 134, 0, 184, 1, 159, 203);
RT_INTERFACE!{interface IAppointmentException(IAppointmentExceptionVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentException] {
    fn get_Appointment(&self, out: *mut *mut Appointment) -> HRESULT,
    fn get_ExceptionProperties(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_IsDeleted(&self, out: *mut bool) -> HRESULT
}}
impl IAppointmentException {
    #[inline] pub unsafe fn get_appointment(&self) -> Result<ComPtr<Appointment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Appointment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exception_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExceptionProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_deleted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDeleted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentException: IAppointmentException}
DEFINE_IID!(IID_IAppointmentInvitee, 331286422, 38978, 18779, 176, 231, 239, 143, 121, 192, 112, 29);
RT_INTERFACE!{interface IAppointmentInvitee(IAppointmentInviteeVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentInvitee] {
    fn get_Role(&self, out: *mut AppointmentParticipantRole) -> HRESULT,
    fn put_Role(&self, value: AppointmentParticipantRole) -> HRESULT,
    fn get_Response(&self, out: *mut AppointmentParticipantResponse) -> HRESULT,
    fn put_Response(&self, value: AppointmentParticipantResponse) -> HRESULT
}}
impl IAppointmentInvitee {
    #[inline] pub unsafe fn get_role(&self) -> Result<AppointmentParticipantRole> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Role)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_role(&self, value: AppointmentParticipantRole) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Role)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_response(&self) -> Result<AppointmentParticipantResponse> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Response)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_response(&self, value: AppointmentParticipantResponse) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Response)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentInvitee: IAppointmentInvitee}
impl RtActivatable<IActivationFactory> for AppointmentInvitee {}
DEFINE_CLSID!(AppointmentInvitee: "Windows.ApplicationModel.Appointments.AppointmentInvitee");
RT_CLASS!{static class AppointmentManager}
impl RtActivatable<IAppointmentManagerStatics> for AppointmentManager {}
impl RtActivatable<IAppointmentManagerStatics2> for AppointmentManager {}
impl RtActivatable<IAppointmentManagerStatics3> for AppointmentManager {}
impl AppointmentManager {
    #[inline] pub fn show_add_appointment_async(appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_add_appointment_async(appointment, selection)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_add_appointment_with_placement_async(appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_add_appointment_with_placement_async(appointment, selection, preferredPlacement)
    }}
    #[inline] pub fn show_replace_appointment_async(appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_replace_appointment_async(appointmentId, appointment, selection)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_async(appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_replace_appointment_with_placement_async(appointmentId, appointment, selection, preferredPlacement)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_replace_appointment_with_placement_and_date_async(appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_replace_appointment_with_placement_and_date_async(appointmentId, appointment, selection, preferredPlacement, instanceStartDate)
    }}
    #[inline] pub fn show_remove_appointment_async(appointmentId: &HStringArg, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_remove_appointment_async(appointmentId, selection)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_async(appointmentId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_remove_appointment_with_placement_async(appointmentId, selection, preferredPlacement)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_remove_appointment_with_placement_and_date_async(appointmentId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_remove_appointment_with_placement_and_date_async(appointmentId, selection, preferredPlacement, instanceStartDate)
    }}
    #[inline] pub fn show_time_frame_async(timeToShow: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics>>::get_activation_factory().show_time_frame_async(timeToShow, duration)
    }}
    #[inline] pub fn show_appointment_details_async(appointmentId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().show_appointment_details_async(appointmentId)
    }}
    #[inline] pub fn show_appointment_details_with_date_async(appointmentId: &HStringArg, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().show_appointment_details_with_date_async(appointmentId, instanceStartDate)
    }}
    #[inline] pub fn show_edit_new_appointment_async(appointment: &Appointment) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().show_edit_new_appointment_async(appointment)
    }}
    #[inline] pub fn request_store_async(options: AppointmentStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentStore>>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics2>>::get_activation_factory().request_store_async(options)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<AppointmentManagerForUser>> { unsafe {
        <Self as RtActivatable<IAppointmentManagerStatics3>>::get_activation_factory().get_for_user(user)
    }}
}
DEFINE_CLSID!(AppointmentManager: "Windows.ApplicationModel.Appointments.AppointmentManager");
DEFINE_IID!(IID_IAppointmentManagerForUser, 1881543715, 29644, 18016, 179, 24, 176, 19, 101, 48, 42, 3);
RT_INTERFACE!{interface IAppointmentManagerForUser(IAppointmentManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentManagerForUser] {
    fn ShowAddAppointmentAsync(&self, appointment: *mut Appointment, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowAddAppointmentWithPlacementAsync(&self, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowReplaceAppointmentAsync(&self, appointmentId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowRemoveAppointmentAsync(&self, appointmentId: HSTRING, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn ShowTimeFrameAsync(&self, timeToShow: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAppointmentDetailsAsync(&self, appointmentId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAppointmentDetailsWithDateAsync(&self, appointmentId: HSTRING, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowEditNewAppointmentAsync(&self, appointment: *mut Appointment, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn RequestStoreAsync(&self, options: AppointmentStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentStore>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IAppointmentManagerForUser {
    #[inline] pub unsafe fn show_add_appointment_async(&self, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_add_appointment_with_placement_async(&self, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAppointmentWithPlacementAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_replace_appointment_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentAsync)(self as *const _ as *mut _, appointmentId.get(), appointment as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_replace_appointment_with_placement_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentWithPlacementAsync)(self as *const _ as *mut _, appointmentId.get(), appointment as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_replace_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentWithPlacementAndDateAsync)(self as *const _ as *mut _, appointmentId.get(), appointment as *const _ as *mut _, selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_remove_appointment_async(&self, appointmentId: &HStringArg, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentAsync)(self as *const _ as *mut _, appointmentId.get(), selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_remove_appointment_with_placement_async(&self, appointmentId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentWithPlacementAsync)(self as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_remove_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentWithPlacementAndDateAsync)(self as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_time_frame_async(&self, timeToShow: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowTimeFrameAsync)(self as *const _ as *mut _, timeToShow, duration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_appointment_details_async(&self, appointmentId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAppointmentDetailsAsync)(self as *const _ as *mut _, appointmentId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_appointment_details_with_date_async(&self, appointmentId: &HStringArg, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAppointmentDetailsWithDateAsync)(self as *const _ as *mut _, appointmentId.get(), instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_edit_new_appointment_async(&self, appointment: &Appointment) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowEditNewAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_store_async(&self, options: AppointmentStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentManagerForUser: IAppointmentManagerForUser}
DEFINE_IID!(IID_IAppointmentManagerStatics, 976288257, 23616, 18845, 179, 63, 164, 48, 80, 247, 79, 196);
RT_INTERFACE!{static interface IAppointmentManagerStatics(IAppointmentManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentManagerStatics] {
    fn ShowAddAppointmentAsync(&self, appointment: *mut Appointment, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowAddAppointmentWithPlacementAsync(&self, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowReplaceAppointmentAsync(&self, appointmentId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowRemoveAppointmentAsync(&self, appointmentId: HSTRING, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAsync(&self, appointmentId: HSTRING, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAndDateAsync(&self, appointmentId: HSTRING, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn ShowTimeFrameAsync(&self, timeToShow: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentManagerStatics {
    #[inline] pub unsafe fn show_add_appointment_async(&self, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_add_appointment_with_placement_async(&self, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAppointmentWithPlacementAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_replace_appointment_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentAsync)(self as *const _ as *mut _, appointmentId.get(), appointment as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_replace_appointment_with_placement_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentWithPlacementAsync)(self as *const _ as *mut _, appointmentId.get(), appointment as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_replace_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentWithPlacementAndDateAsync)(self as *const _ as *mut _, appointmentId.get(), appointment as *const _ as *mut _, selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_remove_appointment_async(&self, appointmentId: &HStringArg, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentAsync)(self as *const _ as *mut _, appointmentId.get(), selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_remove_appointment_with_placement_async(&self, appointmentId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentWithPlacementAsync)(self as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_remove_appointment_with_placement_and_date_async(&self, appointmentId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentWithPlacementAndDateAsync)(self as *const _ as *mut _, appointmentId.get(), selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_time_frame_async(&self, timeToShow: super::super::foundation::DateTime, duration: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowTimeFrameAsync)(self as *const _ as *mut _, timeToShow, duration, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentManagerStatics2, 176289293, 53327, 16436, 175, 114, 163, 101, 115, 180, 95, 240);
RT_INTERFACE!{static interface IAppointmentManagerStatics2(IAppointmentManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentManagerStatics2] {
    fn ShowAppointmentDetailsAsync(&self, appointmentId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAppointmentDetailsWithDateAsync(&self, appointmentId: HSTRING, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowEditNewAppointmentAsync(&self, appointment: *mut Appointment, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn RequestStoreAsync(&self, options: AppointmentStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentStore>) -> HRESULT
}}
impl IAppointmentManagerStatics2 {
    #[inline] pub unsafe fn show_appointment_details_async(&self, appointmentId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAppointmentDetailsAsync)(self as *const _ as *mut _, appointmentId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_appointment_details_with_date_async(&self, appointmentId: &HStringArg, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAppointmentDetailsWithDateAsync)(self as *const _ as *mut _, appointmentId.get(), instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_edit_new_appointment_async(&self, appointment: &Appointment) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowEditNewAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_store_async(&self, options: AppointmentStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentManagerStatics3, 798679196, 45900, 19911, 163, 93, 202, 253, 136, 174, 62, 198);
RT_INTERFACE!{static interface IAppointmentManagerStatics3(IAppointmentManagerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentManagerStatics3] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut AppointmentManagerForUser) -> HRESULT
}}
impl IAppointmentManagerStatics3 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<AppointmentManagerForUser>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentOrganizer: IAppointmentParticipant}
impl RtActivatable<IActivationFactory> for AppointmentOrganizer {}
DEFINE_CLSID!(AppointmentOrganizer: "Windows.ApplicationModel.Appointments.AppointmentOrganizer");
DEFINE_IID!(IID_IAppointmentParticipant, 1633560834, 38680, 18043, 131, 251, 178, 147, 161, 145, 33, 222);
RT_INTERFACE!{interface IAppointmentParticipant(IAppointmentParticipantVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentParticipant] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Address(&self, value: HSTRING) -> HRESULT
}}
impl IAppointmentParticipant {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Address)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Address)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentParticipantResponse: i32 {
    None (AppointmentParticipantResponse_None) = 0, Tentative (AppointmentParticipantResponse_Tentative) = 1, Accepted (AppointmentParticipantResponse_Accepted) = 2, Declined (AppointmentParticipantResponse_Declined) = 3, Unknown (AppointmentParticipantResponse_Unknown) = 4,
}}
RT_ENUM! { enum AppointmentParticipantRole: i32 {
    RequiredAttendee (AppointmentParticipantRole_RequiredAttendee) = 0, OptionalAttendee (AppointmentParticipantRole_OptionalAttendee) = 1, Resource (AppointmentParticipantRole_Resource) = 2,
}}
RT_CLASS!{static class AppointmentProperties}
impl RtActivatable<IAppointmentPropertiesStatics> for AppointmentProperties {}
impl RtActivatable<IAppointmentPropertiesStatics2> for AppointmentProperties {}
impl AppointmentProperties {
    #[inline] pub fn get_subject() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_subject()
    }}
    #[inline] pub fn get_location() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_location()
    }}
    #[inline] pub fn get_start_time() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_start_time()
    }}
    #[inline] pub fn get_duration() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_duration()
    }}
    #[inline] pub fn get_reminder() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_reminder()
    }}
    #[inline] pub fn get_busy_status() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_busy_status()
    }}
    #[inline] pub fn get_sensitivity() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_sensitivity()
    }}
    #[inline] pub fn get_original_start_time() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_original_start_time()
    }}
    #[inline] pub fn get_is_response_requested() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_is_response_requested()
    }}
    #[inline] pub fn get_allow_new_time_proposal() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_allow_new_time_proposal()
    }}
    #[inline] pub fn get_all_day() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_all_day()
    }}
    #[inline] pub fn get_details() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_details()
    }}
    #[inline] pub fn get_online_meeting_link() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_online_meeting_link()
    }}
    #[inline] pub fn get_reply_time() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_reply_time()
    }}
    #[inline] pub fn get_organizer() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_organizer()
    }}
    #[inline] pub fn get_user_response() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_user_response()
    }}
    #[inline] pub fn get_has_invitees() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_has_invitees()
    }}
    #[inline] pub fn get_is_canceled_meeting() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_is_canceled_meeting()
    }}
    #[inline] pub fn get_is_organized_by_user() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_is_organized_by_user()
    }}
    #[inline] pub fn get_recurrence() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_recurrence()
    }}
    #[inline] pub fn get_uri() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_uri()
    }}
    #[inline] pub fn get_invitees() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_invitees()
    }}
    #[inline] pub fn get_default_properties() -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics>>::get_activation_factory().get_default_properties()
    }}
    #[inline] pub fn get_change_number() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics2>>::get_activation_factory().get_change_number()
    }}
    #[inline] pub fn get_remote_change_number() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics2>>::get_activation_factory().get_remote_change_number()
    }}
    #[inline] pub fn get_details_kind() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentPropertiesStatics2>>::get_activation_factory().get_details_kind()
    }}
}
DEFINE_CLSID!(AppointmentProperties: "Windows.ApplicationModel.Appointments.AppointmentProperties");
DEFINE_IID!(IID_IAppointmentPropertiesStatics, 622075881, 26798, 15022, 133, 95, 188, 68, 65, 202, 162, 52);
RT_INTERFACE!{static interface IAppointmentPropertiesStatics(IAppointmentPropertiesStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentPropertiesStatics] {
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StartTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Duration(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Reminder(&self, out: *mut HSTRING) -> HRESULT,
    fn get_BusyStatus(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Sensitivity(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OriginalStartTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsResponseRequested(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllowNewTimeProposal(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllDay(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Details(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OnlineMeetingLink(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ReplyTime(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Organizer(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserResponse(&self, out: *mut HSTRING) -> HRESULT,
    fn get_HasInvitees(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsCanceledMeeting(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsOrganizedByUser(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recurrence(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Invitees(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DefaultProperties(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IAppointmentPropertiesStatics {
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_location(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_time(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reminder(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Reminder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_busy_status(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BusyStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sensitivity(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Sensitivity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_original_start_time(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_response_requested(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsResponseRequested)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_new_time_proposal(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllowNewTimeProposal)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_all_day(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllDay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Details)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_online_meeting_link(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OnlineMeetingLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reply_time(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReplyTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_organizer(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Organizer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_response(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserResponse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_invitees(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HasInvitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_canceled_meeting(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsCanceledMeeting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_organized_by_user(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IsOrganizedByUser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recurrence(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recurrence)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_invitees(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Invitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentPropertiesStatics2, 3757851467, 45079, 17885, 138, 245, 209, 99, 209, 8, 1, 187);
RT_INTERFACE!{static interface IAppointmentPropertiesStatics2(IAppointmentPropertiesStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentPropertiesStatics2] {
    fn get_ChangeNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteChangeNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DetailsKind(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentPropertiesStatics2 {
    #[inline] pub unsafe fn get_change_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_change_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details_kind(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DetailsKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentRecurrence, 3631955587, 5542, 18555, 185, 89, 12, 54, 30, 96, 233, 84);
RT_INTERFACE!{interface IAppointmentRecurrence(IAppointmentRecurrenceVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentRecurrence] {
    fn get_Unit(&self, out: *mut AppointmentRecurrenceUnit) -> HRESULT,
    fn put_Unit(&self, value: AppointmentRecurrenceUnit) -> HRESULT,
    fn get_Occurrences(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn put_Occurrences(&self, value: *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_Until(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_Until(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Interval(&self, out: *mut u32) -> HRESULT,
    fn put_Interval(&self, value: u32) -> HRESULT,
    fn get_DaysOfWeek(&self, out: *mut AppointmentDaysOfWeek) -> HRESULT,
    fn put_DaysOfWeek(&self, value: AppointmentDaysOfWeek) -> HRESULT,
    fn get_WeekOfMonth(&self, out: *mut AppointmentWeekOfMonth) -> HRESULT,
    fn put_WeekOfMonth(&self, value: AppointmentWeekOfMonth) -> HRESULT,
    fn get_Month(&self, out: *mut u32) -> HRESULT,
    fn put_Month(&self, value: u32) -> HRESULT,
    fn get_Day(&self, out: *mut u32) -> HRESULT,
    fn put_Day(&self, value: u32) -> HRESULT
}}
impl IAppointmentRecurrence {
    #[inline] pub unsafe fn get_unit(&self) -> Result<AppointmentRecurrenceUnit> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Unit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_unit(&self, value: AppointmentRecurrenceUnit) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Unit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_occurrences(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Occurrences)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_occurrences(&self, value: &super::super::foundation::IReference<u32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Occurrences)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_until(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Until)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_until(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Until)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_interval(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Interval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_interval(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Interval)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_days_of_week(&self) -> Result<AppointmentDaysOfWeek> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DaysOfWeek)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_days_of_week(&self, value: AppointmentDaysOfWeek) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DaysOfWeek)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_of_month(&self) -> Result<AppointmentWeekOfMonth> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WeekOfMonth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_week_of_month(&self, value: AppointmentWeekOfMonth) -> Result<()> {
        let hr = ((*self.lpVtbl).put_WeekOfMonth)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Month)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Month)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Day)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Day)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentRecurrence: IAppointmentRecurrence}
impl RtActivatable<IActivationFactory> for AppointmentRecurrence {}
DEFINE_CLSID!(AppointmentRecurrence: "Windows.ApplicationModel.Appointments.AppointmentRecurrence");
DEFINE_IID!(IID_IAppointmentRecurrence2, 1039377120, 1447, 20304, 159, 134, 176, 63, 148, 54, 37, 77);
RT_INTERFACE!{interface IAppointmentRecurrence2(IAppointmentRecurrence2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentRecurrence2] {
    fn get_RecurrenceType(&self, out: *mut RecurrenceType) -> HRESULT,
    fn get_TimeZone(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TimeZone(&self, value: HSTRING) -> HRESULT
}}
impl IAppointmentRecurrence2 {
    #[inline] pub unsafe fn get_recurrence_type(&self) -> Result<RecurrenceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RecurrenceType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_time_zone(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TimeZone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_time_zone(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TimeZone)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentRecurrence3, 2315228889, 55885, 18967, 141, 210, 28, 235, 194, 181, 255, 157);
RT_INTERFACE!{interface IAppointmentRecurrence3(IAppointmentRecurrence3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentRecurrence3] {
    fn get_CalendarIdentifier(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentRecurrence3 {
    #[inline] pub unsafe fn get_calendar_identifier(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIdentifier)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentRecurrenceUnit: i32 {
    Daily (AppointmentRecurrenceUnit_Daily) = 0, Weekly (AppointmentRecurrenceUnit_Weekly) = 1, Monthly (AppointmentRecurrenceUnit_Monthly) = 2, MonthlyOnDay (AppointmentRecurrenceUnit_MonthlyOnDay) = 3, Yearly (AppointmentRecurrenceUnit_Yearly) = 4, YearlyOnDay (AppointmentRecurrenceUnit_YearlyOnDay) = 5,
}}
RT_ENUM! { enum AppointmentSensitivity: i32 {
    Public (AppointmentSensitivity_Public) = 0, Private (AppointmentSensitivity_Private) = 1,
}}
DEFINE_IID!(IID_IAppointmentStore, 2757857676, 31303, 19862, 150, 201, 21, 205, 138, 5, 167, 53);
RT_INTERFACE!{interface IAppointmentStore(IAppointmentStoreVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStore] {
    fn get_ChangeTracker(&self, out: *mut *mut AppointmentStoreChangeTracker) -> HRESULT,
    fn CreateAppointmentCalendarAsync(&self, name: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentCalendar>) -> HRESULT,
    fn GetAppointmentCalendarAsync(&self, calendarId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentCalendar>) -> HRESULT,
    fn GetAppointmentAsync(&self, localId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Appointment>) -> HRESULT,
    fn GetAppointmentInstanceAsync(&self, localId: HSTRING, instanceStartTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<Appointment>) -> HRESULT,
    fn FindAppointmentCalendarsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentCalendar>>) -> HRESULT,
    fn FindAppointmentCalendarsAsyncWithOptions(&self, options: FindAppointmentCalendarsOptions, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentCalendar>>) -> HRESULT,
    fn FindAppointmentsAsync(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn FindAppointmentsAsyncWithOptions(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, options: *mut FindAppointmentsOptions, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>) -> HRESULT,
    fn FindConflictAsync(&self, appointment: *mut Appointment, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentConflictResult>) -> HRESULT,
    fn FindConflictAsyncWithInstanceStart(&self, appointment: *mut Appointment, instanceStartTime: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentConflictResult>) -> HRESULT,
    fn MoveAppointmentAsync(&self, appointment: *mut Appointment, destinationCalendar: *mut AppointmentCalendar, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAddAppointmentAsync(&self, appointment: *mut Appointment, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowReplaceAppointmentAsync(&self, localId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowReplaceAppointmentWithPlacementAndDateAsync(&self, localId: HSTRING, appointment: *mut Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowRemoveAppointmentAsync(&self, localId: HSTRING, selection: super::super::foundation::Rect, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy16(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowRemoveAppointmentWithPlacementAndDateAsync(&self, localId: HSTRING, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn ShowAppointmentDetailsAsync(&self, localId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAppointmentDetailsWithDateAsync(&self, localId: HSTRING, instanceStartDate: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowEditNewAppointmentAsync(&self, appointment: *mut Appointment, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn FindLocalIdsFromRoamingIdAsync(&self, roamingId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>) -> HRESULT
}}
impl IAppointmentStore {
    #[inline] pub unsafe fn get_change_tracker(&self) -> Result<ComPtr<AppointmentStoreChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangeTracker)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_appointment_calendar_async(&self, name: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentCalendar>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAppointmentCalendarAsync)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_calendar_async(&self, calendarId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentCalendar>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppointmentCalendarAsync)(self as *const _ as *mut _, calendarId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_async(&self, localId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Appointment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppointmentAsync)(self as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_instance_async(&self, localId: &HStringArg, instanceStartTime: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Appointment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppointmentInstanceAsync)(self as *const _ as *mut _, localId.get(), instanceStartTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointment_calendars_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentCalendar>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentCalendarsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointment_calendars_async_with_options(&self, options: FindAppointmentCalendarsOptions) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentCalendar>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentCalendarsAsyncWithOptions)(self as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointments_async(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentsAsync)(self as *const _ as *mut _, rangeStart, rangeLength, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointments_async_with_options(&self, rangeStart: super::super::foundation::DateTime, rangeLength: super::super::foundation::TimeSpan, options: &FindAppointmentsOptions) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Appointment>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentsAsyncWithOptions)(self as *const _ as *mut _, rangeStart, rangeLength, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_conflict_async(&self, appointment: &Appointment) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentConflictResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindConflictAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_conflict_async_with_instance_start(&self, appointment: &Appointment, instanceStartTime: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentConflictResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindConflictAsyncWithInstanceStart)(self as *const _ as *mut _, appointment as *const _ as *mut _, instanceStartTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_appointment_async(&self, appointment: &Appointment, destinationCalendar: &AppointmentCalendar) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MoveAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, destinationCalendar as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_add_appointment_async(&self, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_replace_appointment_async(&self, localId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentAsync)(self as *const _ as *mut _, localId.get(), appointment as *const _ as *mut _, selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_replace_appointment_with_placement_and_date_async(&self, localId: &HStringArg, appointment: &Appointment, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowReplaceAppointmentWithPlacementAndDateAsync)(self as *const _ as *mut _, localId.get(), appointment as *const _ as *mut _, selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_remove_appointment_async(&self, localId: &HStringArg, selection: super::super::foundation::Rect) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentAsync)(self as *const _ as *mut _, localId.get(), selection, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_remove_appointment_with_placement_and_date_async(&self, localId: &HStringArg, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowRemoveAppointmentWithPlacementAndDateAsync)(self as *const _ as *mut _, localId.get(), selection, preferredPlacement, instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_appointment_details_async(&self, localId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAppointmentDetailsAsync)(self as *const _ as *mut _, localId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_appointment_details_with_date_async(&self, localId: &HStringArg, instanceStartDate: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAppointmentDetailsWithDateAsync)(self as *const _ as *mut _, localId.get(), instanceStartDate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_edit_new_appointment_async(&self, appointment: &Appointment) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowEditNewAppointmentAsync)(self as *const _ as *mut _, appointment as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_local_ids_from_roaming_id_async(&self, roamingId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindLocalIdsFromRoamingIdAsync)(self as *const _ as *mut _, roamingId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentStore: IAppointmentStore}
DEFINE_IID!(IID_IAppointmentStore2, 633637920, 7233, 16975, 128, 132, 103, 193, 207, 224, 168, 84);
RT_INTERFACE!{interface IAppointmentStore2(IAppointmentStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStore2] {
    fn add_StoreChanged(&self, pHandler: *mut super::super::foundation::TypedEventHandler<AppointmentStore, AppointmentStoreChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StoreChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn CreateAppointmentCalendarInAccountAsync(&self, name: HSTRING, userDataAccountId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<AppointmentCalendar>) -> HRESULT
}}
impl IAppointmentStore2 {
    #[inline] pub unsafe fn add_store_changed(&self, pHandler: &super::super::foundation::TypedEventHandler<AppointmentStore, AppointmentStoreChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StoreChanged)(self as *const _ as *mut _, pHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_store_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_StoreChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_appointment_calendar_in_account_async(&self, name: &HStringArg, userDataAccountId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<AppointmentCalendar>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAppointmentCalendarInAccountAsync)(self as *const _ as *mut _, name.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentStore3, 1112642571, 45176, 18186, 154, 64, 194, 224, 23, 97, 247, 47);
RT_INTERFACE!{interface IAppointmentStore3(IAppointmentStore3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStore3] {
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut *mut AppointmentStoreChangeTracker) -> HRESULT
}}
impl IAppointmentStore3 {
    #[inline] pub unsafe fn get_change_tracker(&self, identity: &HStringArg) -> Result<ComPtr<AppointmentStoreChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeTracker)(self as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentStoreAccessType: i32 {
    AppCalendarsReadWrite (AppointmentStoreAccessType_AppCalendarsReadWrite) = 0, AllCalendarsReadOnly (AppointmentStoreAccessType_AllCalendarsReadOnly) = 1, AllCalendarsReadWrite (AppointmentStoreAccessType_AllCalendarsReadWrite) = 2,
}}
DEFINE_IID!(IID_IAppointmentStoreChange, 2779177013, 2611, 13908, 132, 99, 181, 67, 233, 12, 59, 121);
RT_INTERFACE!{interface IAppointmentStoreChange(IAppointmentStoreChangeVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChange] {
    fn get_Appointment(&self, out: *mut *mut Appointment) -> HRESULT,
    fn get_ChangeType(&self, out: *mut AppointmentStoreChangeType) -> HRESULT
}}
impl IAppointmentStoreChange {
    #[inline] pub unsafe fn get_appointment(&self) -> Result<ComPtr<Appointment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Appointment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_type(&self) -> Result<AppointmentStoreChangeType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentStoreChange: IAppointmentStoreChange}
DEFINE_IID!(IID_IAppointmentStoreChange2, 3011317198, 21009, 17410, 166, 8, 169, 111, 231, 11, 142, 226);
RT_INTERFACE!{interface IAppointmentStoreChange2(IAppointmentStoreChange2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChange2] {
    fn get_AppointmentCalendar(&self, out: *mut *mut AppointmentCalendar) -> HRESULT
}}
impl IAppointmentStoreChange2 {
    #[inline] pub unsafe fn get_appointment_calendar(&self) -> Result<ComPtr<AppointmentCalendar>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendar)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentStoreChangedDeferral, 1287135270, 65243, 19395, 150, 98, 149, 169, 190, 253, 244, 223);
RT_INTERFACE!{interface IAppointmentStoreChangedDeferral(IAppointmentStoreChangedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IAppointmentStoreChangedDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentStoreChangedDeferral: IAppointmentStoreChangedDeferral}
DEFINE_IID!(IID_IAppointmentStoreChangedEventArgs, 579205305, 1937, 16766, 191, 234, 204, 109, 65, 99, 108, 140);
RT_INTERFACE!{interface IAppointmentStoreChangedEventArgs(IAppointmentStoreChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChangedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut AppointmentStoreChangedDeferral) -> HRESULT
}}
impl IAppointmentStoreChangedEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<AppointmentStoreChangedDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentStoreChangedEventArgs: IAppointmentStoreChangedEventArgs}
DEFINE_IID!(IID_IAppointmentStoreChangeReader, 2334394865, 26099, 17056, 150, 29, 76, 32, 155, 243, 3, 112);
RT_INTERFACE!{interface IAppointmentStoreChangeReader(IAppointmentStoreChangeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChangeReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentStoreChange>>) -> HRESULT,
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAccept: *mut AppointmentStoreChange) -> HRESULT
}}
impl IAppointmentStoreChangeReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppointmentStoreChange>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn accept_changes(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChanges)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn accept_changes_through(&self, lastChangeToAccept: &AppointmentStoreChange) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChangesThrough)(self as *const _ as *mut _, lastChangeToAccept as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentStoreChangeReader: IAppointmentStoreChangeReader}
DEFINE_IID!(IID_IAppointmentStoreChangeTracker, 455472305, 36558, 20247, 147, 200, 230, 65, 36, 88, 253, 92);
RT_INTERFACE!{interface IAppointmentStoreChangeTracker(IAppointmentStoreChangeTrackerVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChangeTracker] {
    fn GetChangeReader(&self, out: *mut *mut AppointmentStoreChangeReader) -> HRESULT,
    fn Enable(&self) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IAppointmentStoreChangeTracker {
    #[inline] pub unsafe fn get_change_reader(&self) -> Result<ComPtr<AppointmentStoreChangeReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn enable(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Enable)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Reset)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentStoreChangeTracker: IAppointmentStoreChangeTracker}
DEFINE_IID!(IID_IAppointmentStoreChangeTracker2, 3060444997, 38210, 19703, 133, 80, 235, 55, 14, 12, 8, 211);
RT_INTERFACE!{interface IAppointmentStoreChangeTracker2(IAppointmentStoreChangeTracker2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreChangeTracker2] {
    fn get_IsTracking(&self, out: *mut bool) -> HRESULT
}}
impl IAppointmentStoreChangeTracker2 {
    #[inline] pub unsafe fn get_is_tracking(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTracking)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum AppointmentStoreChangeType: i32 {
    AppointmentCreated (AppointmentStoreChangeType_AppointmentCreated) = 0, AppointmentModified (AppointmentStoreChangeType_AppointmentModified) = 1, AppointmentDeleted (AppointmentStoreChangeType_AppointmentDeleted) = 2, ChangeTrackingLost (AppointmentStoreChangeType_ChangeTrackingLost) = 3, CalendarCreated (AppointmentStoreChangeType_CalendarCreated) = 4, CalendarModified (AppointmentStoreChangeType_CalendarModified) = 5, CalendarDeleted (AppointmentStoreChangeType_CalendarDeleted) = 6,
}}
DEFINE_IID!(IID_IAppointmentStoreNotificationTriggerDetails, 2603862801, 49921, 16926, 175, 239, 4, 126, 207, 167, 106, 219);
RT_INTERFACE!{interface IAppointmentStoreNotificationTriggerDetails(IAppointmentStoreNotificationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentStoreNotificationTriggerDetails] {
    
}}
RT_CLASS!{class AppointmentStoreNotificationTriggerDetails: IAppointmentStoreNotificationTriggerDetails}
RT_ENUM! { enum AppointmentSummaryCardView: i32 {
    System (AppointmentSummaryCardView_System) = 0, App (AppointmentSummaryCardView_App) = 1,
}}
RT_ENUM! { enum AppointmentWeekOfMonth: i32 {
    First (AppointmentWeekOfMonth_First) = 0, Second (AppointmentWeekOfMonth_Second) = 1, Third (AppointmentWeekOfMonth_Third) = 2, Fourth (AppointmentWeekOfMonth_Fourth) = 3, Last (AppointmentWeekOfMonth_Last) = 4,
}}
RT_ENUM! { enum FindAppointmentCalendarsOptions: u32 {
    None (FindAppointmentCalendarsOptions_None) = 0, IncludeHidden (FindAppointmentCalendarsOptions_IncludeHidden) = 1,
}}
DEFINE_IID!(IID_IFindAppointmentsOptions, 1442307157, 39234, 12422, 130, 181, 44, 178, 159, 100, 213, 245);
RT_INTERFACE!{interface IFindAppointmentsOptions(IFindAppointmentsOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IFindAppointmentsOptions] {
    fn get_CalendarIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_FetchProperties(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_IncludeHidden(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeHidden(&self, value: bool) -> HRESULT,
    fn get_MaxCount(&self, out: *mut u32) -> HRESULT,
    fn put_MaxCount(&self, value: u32) -> HRESULT
}}
impl IFindAppointmentsOptions {
    #[inline] pub unsafe fn get_calendar_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalendarIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fetch_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FetchProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_include_hidden(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncludeHidden)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_include_hidden(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncludeHidden)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_count(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_count(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxCount)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FindAppointmentsOptions: IFindAppointmentsOptions}
impl RtActivatable<IActivationFactory> for FindAppointmentsOptions {}
DEFINE_CLSID!(FindAppointmentsOptions: "Windows.ApplicationModel.Appointments.FindAppointmentsOptions");
RT_ENUM! { enum RecurrenceType: i32 {
    Master (RecurrenceType_Master) = 0, Instance (RecurrenceType_Instance) = 1, ExceptionInstance (RecurrenceType_ExceptionInstance) = 2,
}}
pub mod appointmentsprovider { // Windows.ApplicationModel.Appointments.AppointmentsProvider
use ::prelude::*;
DEFINE_IID!(IID_IAddAppointmentOperation, 3964312307, 25101, 19561, 173, 215, 151, 148, 233, 24, 8, 31);
RT_INTERFACE!{interface IAddAppointmentOperation(IAddAppointmentOperationVtbl): IInspectable(IInspectableVtbl) [IID_IAddAppointmentOperation] {
    fn get_AppointmentInformation(&self, out: *mut *mut super::Appointment) -> HRESULT,
    fn get_SourcePackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self, itemId: HSTRING) -> HRESULT,
    fn ReportCanceled(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT,
    fn DismissUI(&self) -> HRESULT
}}
impl IAddAppointmentOperation {
    #[inline] pub unsafe fn get_appointment_information(&self) -> Result<ComPtr<super::Appointment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentInformation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self, itemId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _, itemId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_canceled(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCanceled)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_error(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportError)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn dismiss_ui(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).DismissUI)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AddAppointmentOperation: IAddAppointmentOperation}
RT_CLASS!{static class AppointmentsProviderLaunchActionVerbs}
impl RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics> for AppointmentsProviderLaunchActionVerbs {}
impl RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics2> for AppointmentsProviderLaunchActionVerbs {}
impl AppointmentsProviderLaunchActionVerbs {
    #[inline] pub fn get_add_appointment() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_add_appointment()
    }}
    #[inline] pub fn get_replace_appointment() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_replace_appointment()
    }}
    #[inline] pub fn get_remove_appointment() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_remove_appointment()
    }}
    #[inline] pub fn get_show_time_frame() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics>>::get_activation_factory().get_show_time_frame()
    }}
    #[inline] pub fn get_show_appointment_details() -> Result<HString> { unsafe {
        <Self as RtActivatable<IAppointmentsProviderLaunchActionVerbsStatics2>>::get_activation_factory().get_show_appointment_details()
    }}
}
DEFINE_CLSID!(AppointmentsProviderLaunchActionVerbs: "Windows.ApplicationModel.Appointments.AppointmentsProvider.AppointmentsProviderLaunchActionVerbs");
DEFINE_IID!(IID_IAppointmentsProviderLaunchActionVerbsStatics, 920369704, 40494, 18886, 142, 247, 58, 183, 165, 220, 200, 184);
RT_INTERFACE!{static interface IAppointmentsProviderLaunchActionVerbsStatics(IAppointmentsProviderLaunchActionVerbsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderLaunchActionVerbsStatics] {
    fn get_AddAppointment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ReplaceAppointment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoveAppointment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ShowTimeFrame(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderLaunchActionVerbsStatics {
    #[inline] pub unsafe fn get_add_appointment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddAppointment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_replace_appointment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReplaceAppointment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remove_appointment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoveAppointment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_show_time_frame(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShowTimeFrame)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentsProviderLaunchActionVerbsStatics2, 4019210660, 44833, 18236, 136, 220, 118, 205, 137, 246, 12, 165);
RT_INTERFACE!{static interface IAppointmentsProviderLaunchActionVerbsStatics2(IAppointmentsProviderLaunchActionVerbsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderLaunchActionVerbsStatics2] {
    fn get_ShowAppointmentDetails(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderLaunchActionVerbsStatics2 {
    #[inline] pub unsafe fn get_show_appointment_details(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShowAppointmentDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IRemoveAppointmentOperation, 146172602, 65075, 18125, 165, 12, 168, 255, 179, 38, 5, 55);
RT_INTERFACE!{interface IRemoveAppointmentOperation(IRemoveAppointmentOperationVtbl): IInspectable(IInspectableVtbl) [IID_IRemoveAppointmentOperation] {
    fn get_AppointmentId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstanceStartDate(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_SourcePackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT,
    fn ReportCanceled(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT,
    fn DismissUI(&self) -> HRESULT
}}
impl IRemoveAppointmentOperation {
    #[inline] pub unsafe fn get_appointment_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_instance_start_date(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstanceStartDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_canceled(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCanceled)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_error(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportError)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn dismiss_ui(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).DismissUI)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class RemoveAppointmentOperation: IRemoveAppointmentOperation}
DEFINE_IID!(IID_IReplaceAppointmentOperation, 4103093659, 40545, 19938, 167, 50, 38, 135, 192, 125, 29, 232);
RT_INTERFACE!{interface IReplaceAppointmentOperation(IReplaceAppointmentOperationVtbl): IInspectable(IInspectableVtbl) [IID_IReplaceAppointmentOperation] {
    fn get_AppointmentId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentInformation(&self, out: *mut *mut super::Appointment) -> HRESULT,
    fn get_InstanceStartDate(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_SourcePackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self, itemId: HSTRING) -> HRESULT,
    fn ReportCanceled(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT,
    fn DismissUI(&self) -> HRESULT
}}
impl IReplaceAppointmentOperation {
    #[inline] pub unsafe fn get_appointment_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_information(&self) -> Result<ComPtr<super::Appointment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentInformation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_instance_start_date(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstanceStartDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourcePackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self, itemId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _, itemId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_canceled(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCanceled)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_error(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportError)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn dismiss_ui(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).DismissUI)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ReplaceAppointmentOperation: IReplaceAppointmentOperation}
} // Windows.ApplicationModel.Appointments.AppointmentsProvider
pub mod dataprovider { // Windows.ApplicationModel.Appointments.DataProvider
use ::prelude::*;
DEFINE_IID!(IID_IAppointmentCalendarCancelMeetingRequest, 1229328269, 25652, 16599, 173, 70, 98, 151, 65, 147, 20, 209);
RT_INTERFACE!{interface IAppointmentCalendarCancelMeetingRequest(IAppointmentCalendarCancelMeetingRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarCancelMeetingRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NotifyInvitees(&self, out: *mut bool) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendarCancelMeetingRequest {
    #[inline] pub unsafe fn get_appointment_calendar_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendarLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_original_start_time(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentOriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_notify_invitees(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NotifyInvitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarCancelMeetingRequest: IAppointmentCalendarCancelMeetingRequest}
DEFINE_IID!(IID_IAppointmentCalendarCancelMeetingRequestEventArgs, 444186134, 32560, 20021, 190, 239, 157, 44, 123, 109, 202, 225);
RT_INTERFACE!{interface IAppointmentCalendarCancelMeetingRequestEventArgs(IAppointmentCalendarCancelMeetingRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarCancelMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut AppointmentCalendarCancelMeetingRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IAppointmentCalendarCancelMeetingRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppointmentCalendarCancelMeetingRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarCancelMeetingRequestEventArgs: IAppointmentCalendarCancelMeetingRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarCreateOrUpdateAppointmentRequest, 778236594, 51862, 18604, 145, 36, 64, 107, 25, 254, 250, 112);
RT_INTERFACE!{interface IAppointmentCalendarCreateOrUpdateAppointmentRequest(IAppointmentCalendarCreateOrUpdateAppointmentRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarCreateOrUpdateAppointmentRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Appointment(&self, out: *mut *mut super::Appointment) -> HRESULT,
    fn get_NotifyInvitees(&self, out: *mut bool) -> HRESULT,
    fn get_ChangedProperties(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn ReportCompletedAsync(&self, createdOrUpdatedAppointment: *mut super::Appointment, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendarCreateOrUpdateAppointmentRequest {
    #[inline] pub unsafe fn get_appointment_calendar_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendarLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment(&self) -> Result<ComPtr<super::Appointment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Appointment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_notify_invitees(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NotifyInvitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_changed_properties(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangedProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, createdOrUpdatedAppointment: &super::Appointment) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, createdOrUpdatedAppointment as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarCreateOrUpdateAppointmentRequest: IAppointmentCalendarCreateOrUpdateAppointmentRequest}
DEFINE_IID!(IID_IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs, 3482185000, 46, 19447, 142, 157, 94, 32, 212, 154, 163, 186);
RT_INTERFACE!{interface IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs(IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut AppointmentCalendarCreateOrUpdateAppointmentRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppointmentCalendarCreateOrUpdateAppointmentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs: IAppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarForwardMeetingRequest, 2196106838, 9910, 16979, 138, 143, 108, 245, 242, 255, 120, 132);
RT_INTERFACE!{interface IAppointmentCalendarForwardMeetingRequest(IAppointmentCalendarForwardMeetingRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarForwardMeetingRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_Invitees(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<super::AppointmentInvitee>) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ForwardHeader(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendarForwardMeetingRequest {
    #[inline] pub unsafe fn get_appointment_calendar_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendarLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_original_start_time(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentOriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_invitees(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::AppointmentInvitee>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Invitees)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_forward_header(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForwardHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarForwardMeetingRequest: IAppointmentCalendarForwardMeetingRequest}
DEFINE_IID!(IID_IAppointmentCalendarForwardMeetingRequestEventArgs, 822678810, 9122, 17149, 156, 130, 201, 166, 13, 89, 248, 168);
RT_INTERFACE!{interface IAppointmentCalendarForwardMeetingRequestEventArgs(IAppointmentCalendarForwardMeetingRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarForwardMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut AppointmentCalendarForwardMeetingRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IAppointmentCalendarForwardMeetingRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppointmentCalendarForwardMeetingRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarForwardMeetingRequestEventArgs: IAppointmentCalendarForwardMeetingRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarProposeNewTimeForMeetingRequest, 3457967093, 60918, 17347, 130, 183, 190, 107, 54, 140, 105, 0);
RT_INTERFACE!{interface IAppointmentCalendarProposeNewTimeForMeetingRequest(IAppointmentCalendarProposeNewTimeForMeetingRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarProposeNewTimeForMeetingRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_NewStartTime(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_NewDuration(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendarProposeNewTimeForMeetingRequest {
    #[inline] pub unsafe fn get_appointment_calendar_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendarLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_original_start_time(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentOriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_start_time(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_duration(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarProposeNewTimeForMeetingRequest: IAppointmentCalendarProposeNewTimeForMeetingRequest}
DEFINE_IID!(IID_IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs, 3537336280, 65233, 17024, 163, 186, 46, 31, 71, 96, 154, 162);
RT_INTERFACE!{interface IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs(IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut AppointmentCalendarProposeNewTimeForMeetingRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppointmentCalendarProposeNewTimeForMeetingRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs: IAppointmentCalendarProposeNewTimeForMeetingRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarSyncManagerSyncRequest, 313210923, 29027, 19030, 154, 78, 114, 35, 168, 74, 223, 70);
RT_INTERFACE!{interface IAppointmentCalendarSyncManagerSyncRequest(IAppointmentCalendarSyncManagerSyncRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarSyncManagerSyncRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendarSyncManagerSyncRequest {
    #[inline] pub unsafe fn get_appointment_calendar_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendarLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarSyncManagerSyncRequest: IAppointmentCalendarSyncManagerSyncRequest}
DEFINE_IID!(IID_IAppointmentCalendarSyncManagerSyncRequestEventArgs, 3390555895, 644, 20189, 135, 186, 77, 143, 105, 220, 245, 192);
RT_INTERFACE!{interface IAppointmentCalendarSyncManagerSyncRequestEventArgs(IAppointmentCalendarSyncManagerSyncRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut AppointmentCalendarSyncManagerSyncRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IAppointmentCalendarSyncManagerSyncRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppointmentCalendarSyncManagerSyncRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarSyncManagerSyncRequestEventArgs: IAppointmentCalendarSyncManagerSyncRequestEventArgs}
DEFINE_IID!(IID_IAppointmentCalendarUpdateMeetingResponseRequest, 2741854348, 49821, 19348, 176, 134, 126, 159, 247, 189, 132, 160);
RT_INTERFACE!{interface IAppointmentCalendarUpdateMeetingResponseRequest(IAppointmentCalendarUpdateMeetingResponseRequestVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarUpdateMeetingResponseRequest] {
    fn get_AppointmentCalendarLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentLocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>) -> HRESULT,
    fn get_Response(&self, out: *mut super::AppointmentParticipantResponse) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SendUpdate(&self, out: *mut bool) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IAppointmentCalendarUpdateMeetingResponseRequest {
    #[inline] pub unsafe fn get_appointment_calendar_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentCalendarLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentLocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_original_start_time(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<::rt::gen::windows::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentOriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_response(&self) -> Result<super::AppointmentParticipantResponse> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Response)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_send_update(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SendUpdate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarUpdateMeetingResponseRequest: IAppointmentCalendarUpdateMeetingResponseRequest}
DEFINE_IID!(IID_IAppointmentCalendarUpdateMeetingResponseRequestEventArgs, 2289408131, 38847, 18333, 174, 213, 11, 232, 206, 86, 125, 30);
RT_INTERFACE!{interface IAppointmentCalendarUpdateMeetingResponseRequestEventArgs(IAppointmentCalendarUpdateMeetingResponseRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentCalendarUpdateMeetingResponseRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut AppointmentCalendarUpdateMeetingResponseRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IAppointmentCalendarUpdateMeetingResponseRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<AppointmentCalendarUpdateMeetingResponseRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentCalendarUpdateMeetingResponseRequestEventArgs: IAppointmentCalendarUpdateMeetingResponseRequestEventArgs}
DEFINE_IID!(IID_IAppointmentDataProviderConnection, 4091387267, 12884, 18015, 171, 219, 146, 128, 70, 85, 44, 244);
RT_INTERFACE!{interface IAppointmentDataProviderConnection(IAppointmentDataProviderConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentDataProviderConnection] {
    fn add_SyncRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarSyncManagerSyncRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CreateOrUpdateAppointmentRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateOrUpdateAppointmentRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CancelMeetingRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCancelMeetingRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CancelMeetingRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ForwardMeetingRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarForwardMeetingRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ForwardMeetingRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ProposeNewTimeForMeetingRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProposeNewTimeForMeetingRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_UpdateMeetingResponseRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarUpdateMeetingResponseRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateMeetingResponseRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IAppointmentDataProviderConnection {
    #[inline] pub unsafe fn add_sync_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarSyncManagerSyncRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_create_or_update_appointment_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCreateOrUpdateAppointmentRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CreateOrUpdateAppointmentRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_create_or_update_appointment_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CreateOrUpdateAppointmentRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_cancel_meeting_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarCancelMeetingRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CancelMeetingRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_cancel_meeting_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CancelMeetingRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_forward_meeting_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarForwardMeetingRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ForwardMeetingRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_forward_meeting_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ForwardMeetingRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_propose_new_time_for_meeting_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarProposeNewTimeForMeetingRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ProposeNewTimeForMeetingRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_propose_new_time_for_meeting_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ProposeNewTimeForMeetingRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_update_meeting_response_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppointmentDataProviderConnection, AppointmentCalendarUpdateMeetingResponseRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UpdateMeetingResponseRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_update_meeting_response_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UpdateMeetingResponseRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Start)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentDataProviderConnection: IAppointmentDataProviderConnection}
DEFINE_IID!(IID_IAppointmentDataProviderTriggerDetails, 3005758465, 32274, 20062, 177, 239, 116, 251, 104, 172, 111, 42);
RT_INTERFACE!{interface IAppointmentDataProviderTriggerDetails(IAppointmentDataProviderTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut *mut AppointmentDataProviderConnection) -> HRESULT
}}
impl IAppointmentDataProviderTriggerDetails {
    #[inline] pub unsafe fn get_connection(&self) -> Result<ComPtr<AppointmentDataProviderConnection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Connection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentDataProviderTriggerDetails: IAppointmentDataProviderTriggerDetails}
} // Windows.ApplicationModel.Appointments.DataProvider
} // Windows.ApplicationModel.Appointments
pub mod activation { // Windows.ApplicationModel.Activation
use ::prelude::*;
DEFINE_IID!(IID_IActivatedEventArgs, 3479508755, 52488, 20440, 182, 151, 162, 129, 182, 84, 78, 46);
RT_INTERFACE!{interface IActivatedEventArgs(IActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IActivatedEventArgs] {
    fn get_Kind(&self, out: *mut ActivationKind) -> HRESULT,
    fn get_PreviousExecutionState(&self, out: *mut ApplicationExecutionState) -> HRESULT,
    fn get_SplashScreen(&self, out: *mut *mut SplashScreen) -> HRESULT
}}
impl IActivatedEventArgs {
    #[inline] pub unsafe fn get_kind(&self) -> Result<ActivationKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_previous_execution_state(&self) -> Result<ApplicationExecutionState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PreviousExecutionState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_splash_screen(&self) -> Result<ComPtr<SplashScreen>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SplashScreen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IActivatedEventArgsWithUser, 485530526, 39266, 18742, 128, 255, 175, 200, 232, 174, 92, 140);
RT_INTERFACE!{interface IActivatedEventArgsWithUser(IActivatedEventArgsWithUserVtbl): IInspectable(IInspectableVtbl) [IID_IActivatedEventArgsWithUser] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IActivatedEventArgsWithUser {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ActivationKind: i32 {
    Launch (ActivationKind_Launch) = 0, Search (ActivationKind_Search) = 1, ShareTarget (ActivationKind_ShareTarget) = 2, File (ActivationKind_File) = 3, Protocol (ActivationKind_Protocol) = 4, FileOpenPicker (ActivationKind_FileOpenPicker) = 5, FileSavePicker (ActivationKind_FileSavePicker) = 6, CachedFileUpdater (ActivationKind_CachedFileUpdater) = 7, ContactPicker (ActivationKind_ContactPicker) = 8, Device (ActivationKind_Device) = 9, PrintTaskSettings (ActivationKind_PrintTaskSettings) = 10, CameraSettings (ActivationKind_CameraSettings) = 11, RestrictedLaunch (ActivationKind_RestrictedLaunch) = 12, AppointmentsProvider (ActivationKind_AppointmentsProvider) = 13, Contact (ActivationKind_Contact) = 14, LockScreenCall (ActivationKind_LockScreenCall) = 15, VoiceCommand (ActivationKind_VoiceCommand) = 16, LockScreen (ActivationKind_LockScreen) = 17, PickerReturned (ActivationKind_PickerReturned) = 1000, WalletAction (ActivationKind_WalletAction) = 1001, PickFileContinuation (ActivationKind_PickFileContinuation) = 1002, PickSaveFileContinuation (ActivationKind_PickSaveFileContinuation) = 1003, PickFolderContinuation (ActivationKind_PickFolderContinuation) = 1004, WebAuthenticationBrokerContinuation (ActivationKind_WebAuthenticationBrokerContinuation) = 1005, WebAccountProvider (ActivationKind_WebAccountProvider) = 1006, ComponentUI (ActivationKind_ComponentUI) = 1007, ProtocolForResults (ActivationKind_ProtocolForResults) = 1009, ToastNotification (ActivationKind_ToastNotification) = 1010, Print3DWorkflow (ActivationKind_Print3DWorkflow) = 1011, DialReceiver (ActivationKind_DialReceiver) = 1012, DevicePairing (ActivationKind_DevicePairing) = 1013, UserDataAccountsProvider (ActivationKind_UserDataAccountsProvider) = 1014, FilePickerExperience (ActivationKind_FilePickerExperience) = 1015, LockScreenComponent (ActivationKind_LockScreenComponent) = 1016, ContactPanel (ActivationKind_ContactPanel) = 1017, PrintWorkflowForegroundTask (ActivationKind_PrintWorkflowForegroundTask) = 1018, GameUIProvider (ActivationKind_GameUIProvider) = 1019, StartupTask (ActivationKind_StartupTask) = 1020, CommandLineLaunch (ActivationKind_CommandLineLaunch) = 1021,
}}
RT_ENUM! { enum ApplicationExecutionState: i32 {
    NotRunning (ApplicationExecutionState_NotRunning) = 0, Running (ApplicationExecutionState_Running) = 1, Suspended (ApplicationExecutionState_Suspended) = 2, Terminated (ApplicationExecutionState_Terminated) = 3, ClosedByUser (ApplicationExecutionState_ClosedByUser) = 4,
}}
DEFINE_IID!(IID_IApplicationViewActivatedEventArgs, 2467098443, 47145, 16636, 136, 244, 133, 19, 232, 166, 71, 56);
RT_INTERFACE!{interface IApplicationViewActivatedEventArgs(IApplicationViewActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IApplicationViewActivatedEventArgs] {
    fn get_CurrentlyShownApplicationViewId(&self, out: *mut i32) -> HRESULT
}}
impl IApplicationViewActivatedEventArgs {
    #[inline] pub unsafe fn get_currently_shown_application_view_id(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CurrentlyShownApplicationViewId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentsProviderActivatedEventArgs, 862241797, 37692, 20093, 160, 52, 80, 15, 184, 220, 217, 243);
RT_INTERFACE!{interface IAppointmentsProviderActivatedEventArgs(IAppointmentsProviderActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderActivatedEventArgs] {
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderActivatedEventArgs {
    #[inline] pub unsafe fn get_verb(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Verb)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppointmentsProviderAddAppointmentActivatedEventArgs, 2726695783, 52965, 20045, 158, 215, 65, 195, 78, 193, 139, 2);
RT_INTERFACE!{interface IAppointmentsProviderAddAppointmentActivatedEventArgs(IAppointmentsProviderAddAppointmentActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderAddAppointmentActivatedEventArgs] {
    fn get_AddAppointmentOperation(&self, out: *mut *mut super::appointments::appointmentsprovider::AddAppointmentOperation) -> HRESULT
}}
impl IAppointmentsProviderAddAppointmentActivatedEventArgs {
    #[inline] pub unsafe fn get_add_appointment_operation(&self) -> Result<ComPtr<super::appointments::appointmentsprovider::AddAppointmentOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddAppointmentOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentsProviderAddAppointmentActivatedEventArgs: IAppointmentsProviderAddAppointmentActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, 1964980920, 2958, 17692, 159, 21, 150, 110, 105, 155, 172, 37);
RT_INTERFACE!{interface IAppointmentsProviderRemoveAppointmentActivatedEventArgs(IAppointmentsProviderRemoveAppointmentActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderRemoveAppointmentActivatedEventArgs] {
    fn get_RemoveAppointmentOperation(&self, out: *mut *mut super::appointments::appointmentsprovider::RemoveAppointmentOperation) -> HRESULT
}}
impl IAppointmentsProviderRemoveAppointmentActivatedEventArgs {
    #[inline] pub unsafe fn get_remove_appointment_operation(&self) -> Result<ComPtr<super::appointments::appointmentsprovider::RemoveAppointmentOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoveAppointmentOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentsProviderRemoveAppointmentActivatedEventArgs: IAppointmentsProviderRemoveAppointmentActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, 357677012, 43393, 16487, 138, 98, 5, 36, 228, 173, 225, 33);
RT_INTERFACE!{interface IAppointmentsProviderReplaceAppointmentActivatedEventArgs(IAppointmentsProviderReplaceAppointmentActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderReplaceAppointmentActivatedEventArgs] {
    fn get_ReplaceAppointmentOperation(&self, out: *mut *mut super::appointments::appointmentsprovider::ReplaceAppointmentOperation) -> HRESULT
}}
impl IAppointmentsProviderReplaceAppointmentActivatedEventArgs {
    #[inline] pub unsafe fn get_replace_appointment_operation(&self) -> Result<ComPtr<super::appointments::appointmentsprovider::ReplaceAppointmentOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReplaceAppointmentOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentsProviderReplaceAppointmentActivatedEventArgs: IAppointmentsProviderReplaceAppointmentActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, 962130021, 38977, 19621, 153, 155, 136, 81, 152, 185, 239, 42);
RT_INTERFACE!{interface IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs] {
    fn get_InstanceStartDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_LocalId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RoamingId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs {
    #[inline] pub unsafe fn get_instance_start_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstanceStartDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LocalId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_roaming_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RoamingId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentsProviderShowAppointmentDetailsActivatedEventArgs: IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs}
DEFINE_IID!(IID_IAppointmentsProviderShowTimeFrameActivatedEventArgs, 2611915686, 3595, 18858, 186, 188, 18, 177, 220, 119, 73, 134);
RT_INTERFACE!{interface IAppointmentsProviderShowTimeFrameActivatedEventArgs(IAppointmentsProviderShowTimeFrameActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppointmentsProviderShowTimeFrameActivatedEventArgs] {
    fn get_TimeToShow(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_Duration(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT
}}
impl IAppointmentsProviderShowTimeFrameActivatedEventArgs {
    #[inline] pub unsafe fn get_time_to_show(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TimeToShow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppointmentsProviderShowTimeFrameActivatedEventArgs: IAppointmentsProviderShowTimeFrameActivatedEventArgs}
DEFINE_IID!(IID_IBackgroundActivatedEventArgs, 2870263520, 59232, 17422, 169, 28, 68, 121, 109, 227, 169, 45);
RT_INTERFACE!{interface IBackgroundActivatedEventArgs(IBackgroundActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IBackgroundActivatedEventArgs] {
    fn get_TaskInstance(&self, out: *mut *mut super::background::IBackgroundTaskInstance) -> HRESULT
}}
impl IBackgroundActivatedEventArgs {
    #[inline] pub unsafe fn get_task_instance(&self) -> Result<ComPtr<super::background::IBackgroundTaskInstance>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskInstance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class BackgroundActivatedEventArgs: IBackgroundActivatedEventArgs}
DEFINE_IID!(IID_ICachedFileUpdaterActivatedEventArgs, 3496915399, 14341, 20171, 183, 87, 108, 241, 94, 38, 254, 243);
RT_INTERFACE!{interface ICachedFileUpdaterActivatedEventArgs(ICachedFileUpdaterActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICachedFileUpdaterActivatedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_CachedFileUpdaterUI(&self, out: *mut *mut super::super::storage::provider::CachedFileUpdaterUI) -> HRESULT
}}
impl ICachedFileUpdaterActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_cached_file_updater_ui(&self) -> Result<ComPtr<super::super::storage::provider::CachedFileUpdaterUI>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CachedFileUpdaterUI)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CachedFileUpdaterActivatedEventArgs: ICachedFileUpdaterActivatedEventArgs}
DEFINE_IID!(IID_ICameraSettingsActivatedEventArgs, 4217873672, 11693, 18698, 145, 112, 220, 160, 54, 235, 17, 75);
RT_INTERFACE!{interface ICameraSettingsActivatedEventArgs(ICameraSettingsActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICameraSettingsActivatedEventArgs] {
    fn get_VideoDeviceController(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn get_VideoDeviceExtension(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl ICameraSettingsActivatedEventArgs {
    #[inline] pub unsafe fn get_video_device_controller(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VideoDeviceController)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_video_device_extension(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VideoDeviceExtension)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CameraSettingsActivatedEventArgs: ICameraSettingsActivatedEventArgs}
DEFINE_IID!(IID_ICommandLineActivatedEventArgs, 1158039340, 106, 18667, 138, 251, 208, 122, 178, 94, 51, 102);
RT_INTERFACE!{interface ICommandLineActivatedEventArgs(ICommandLineActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICommandLineActivatedEventArgs] {
    fn get_Operation(&self, out: *mut *mut CommandLineActivationOperation) -> HRESULT
}}
impl ICommandLineActivatedEventArgs {
    #[inline] pub unsafe fn get_operation(&self) -> Result<ComPtr<CommandLineActivationOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Operation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CommandLineActivatedEventArgs: ICommandLineActivatedEventArgs}
DEFINE_IID!(IID_ICommandLineActivationOperation, 2571839553, 50590, 20329, 188, 253, 182, 30, 212, 230, 34, 235);
RT_INTERFACE!{interface ICommandLineActivationOperation(ICommandLineActivationOperationVtbl): IInspectable(IInspectableVtbl) [IID_ICommandLineActivationOperation] {
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CurrentDirectoryPath(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ExitCode(&self, value: i32) -> HRESULT,
    fn get_ExitCode(&self, out: *mut i32) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut super::super::foundation::Deferral) -> HRESULT
}}
impl ICommandLineActivationOperation {
    #[inline] pub unsafe fn get_arguments(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_directory_path(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentDirectoryPath)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_exit_code(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExitCode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_exit_code(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExitCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CommandLineActivationOperation: ICommandLineActivationOperation}
DEFINE_IID!(IID_IContactActivatedEventArgs, 3592921540, 49189, 19521, 157, 239, 241, 234, 250, 208, 117, 231);
RT_INTERFACE!{interface IContactActivatedEventArgs(IContactActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactActivatedEventArgs] {
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactActivatedEventArgs {
    #[inline] pub unsafe fn get_verb(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Verb)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactCallActivatedEventArgs, 3269399751, 12523, 16838, 179, 188, 91, 22, 148, 249, 218, 179);
RT_INTERFACE!{interface IContactCallActivatedEventArgs(IContactCallActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactCallActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::contacts::Contact) -> HRESULT
}}
impl IContactCallActivatedEventArgs {
    #[inline] pub unsafe fn get_service_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_service_user_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceUserId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::contacts::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactCallActivatedEventArgs: IContactCallActivatedEventArgs}
DEFINE_IID!(IID_IContactMapActivatedEventArgs, 3006003312, 61159, 19154, 170, 241, 168, 126, 255, 207, 0, 164);
RT_INTERFACE!{interface IContactMapActivatedEventArgs(IContactMapActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactMapActivatedEventArgs] {
    fn get_Address(&self, out: *mut *mut super::contacts::ContactAddress) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::contacts::Contact) -> HRESULT
}}
impl IContactMapActivatedEventArgs {
    #[inline] pub unsafe fn get_address(&self) -> Result<ComPtr<super::contacts::ContactAddress>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Address)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::contacts::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactMapActivatedEventArgs: IContactMapActivatedEventArgs}
DEFINE_IID!(IID_IContactMessageActivatedEventArgs, 3730410930, 3587, 17328, 191, 86, 188, 196, 11, 49, 98, 223);
RT_INTERFACE!{interface IContactMessageActivatedEventArgs(IContactMessageActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactMessageActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::contacts::Contact) -> HRESULT
}}
impl IContactMessageActivatedEventArgs {
    #[inline] pub unsafe fn get_service_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_service_user_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceUserId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::contacts::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactMessageActivatedEventArgs: IContactMessageActivatedEventArgs}
DEFINE_IID!(IID_IContactPanelActivatedEventArgs, 1388012516, 54228, 19299, 128, 81, 74, 242, 8, 44, 171, 128);
RT_INTERFACE!{interface IContactPanelActivatedEventArgs(IContactPanelActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactPanelActivatedEventArgs] {
    fn get_ContactPanel(&self, out: *mut *mut super::contacts::ContactPanel) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::contacts::Contact) -> HRESULT
}}
impl IContactPanelActivatedEventArgs {
    #[inline] pub unsafe fn get_contact_panel(&self) -> Result<ComPtr<super::contacts::ContactPanel>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactPanel)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::contacts::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPanelActivatedEventArgs: IContactPanelActivatedEventArgs}
DEFINE_IID!(IID_IContactPickerActivatedEventArgs, 3461851879, 25673, 17831, 151, 31, 209, 19, 190, 122, 137, 54);
RT_INTERFACE!{interface IContactPickerActivatedEventArgs(IContactPickerActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactPickerActivatedEventArgs] {
    fn get_ContactPickerUI(&self, out: *mut *mut super::contacts::provider::ContactPickerUI) -> HRESULT
}}
impl IContactPickerActivatedEventArgs {
    #[inline] pub unsafe fn get_contact_picker_ui(&self) -> Result<ComPtr<super::contacts::provider::ContactPickerUI>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactPickerUI)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPickerActivatedEventArgs: IContactPickerActivatedEventArgs}
DEFINE_IID!(IID_IContactPostActivatedEventArgs, 3009035367, 61927, 18005, 173, 110, 72, 87, 88, 143, 85, 47);
RT_INTERFACE!{interface IContactPostActivatedEventArgs(IContactPostActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactPostActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::contacts::Contact) -> HRESULT
}}
impl IContactPostActivatedEventArgs {
    #[inline] pub unsafe fn get_service_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_service_user_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceUserId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::contacts::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPostActivatedEventArgs: IContactPostActivatedEventArgs}
DEFINE_IID!(IID_IContactsProviderActivatedEventArgs, 1166073000, 22352, 18710, 170, 82, 192, 130, 149, 33, 235, 148);
RT_INTERFACE!{interface IContactsProviderActivatedEventArgs(IContactsProviderActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactsProviderActivatedEventArgs] {
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactsProviderActivatedEventArgs {
    #[inline] pub unsafe fn get_verb(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Verb)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactVideoCallActivatedEventArgs, 1627889080, 58343, 19279, 133, 141, 92, 99, 169, 110, 246, 132);
RT_INTERFACE!{interface IContactVideoCallActivatedEventArgs(IContactVideoCallActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactVideoCallActivatedEventArgs] {
    fn get_ServiceId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ServiceUserId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::contacts::Contact) -> HRESULT
}}
impl IContactVideoCallActivatedEventArgs {
    #[inline] pub unsafe fn get_service_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_service_user_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceUserId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::contacts::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactVideoCallActivatedEventArgs: IContactVideoCallActivatedEventArgs}
DEFINE_IID!(IID_IContinuationActivatedEventArgs, 3850438325, 5471, 19092, 167, 66, 199, 224, 143, 78, 24, 140);
RT_INTERFACE!{interface IContinuationActivatedEventArgs(IContinuationActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContinuationActivatedEventArgs] {
    fn get_ContinuationData(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT
}}
impl IContinuationActivatedEventArgs {
    #[inline] pub unsafe fn get_continuation_data(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContinuationData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDeviceActivatedEventArgs, 3444619689, 52752, 17618, 130, 52, 195, 85, 160, 115, 239, 51);
RT_INTERFACE!{interface IDeviceActivatedEventArgs(IDeviceActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceActivatedEventArgs] {
    fn get_DeviceInformationId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDeviceActivatedEventArgs {
    #[inline] pub unsafe fn get_device_information_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceInformationId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_verb(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Verb)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DeviceActivatedEventArgs: IDeviceActivatedEventArgs}
DEFINE_IID!(IID_IDevicePairingActivatedEventArgs, 3953185252, 60614, 16712, 148, 237, 244, 179, 126, 192, 91, 62);
RT_INTERFACE!{interface IDevicePairingActivatedEventArgs(IDevicePairingActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDevicePairingActivatedEventArgs] {
    #[cfg(feature="windows-devices")] fn get_DeviceInformation(&self, out: *mut *mut super::super::devices::enumeration::DeviceInformation) -> HRESULT
}}
impl IDevicePairingActivatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_device_information(&self) -> Result<ComPtr<super::super::devices::enumeration::DeviceInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceInformation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DevicePairingActivatedEventArgs: IDevicePairingActivatedEventArgs}
DEFINE_IID!(IID_IDialReceiverActivatedEventArgs, 4218912471, 34286, 17774, 164, 77, 133, 215, 48, 231, 10, 237);
RT_INTERFACE!{interface IDialReceiverActivatedEventArgs(IDialReceiverActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDialReceiverActivatedEventArgs] {
    fn get_AppName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDialReceiverActivatedEventArgs {
    #[inline] pub unsafe fn get_app_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DialReceiverActivatedEventArgs: IDialReceiverActivatedEventArgs}
DEFINE_IID!(IID_IFileActivatedEventArgs, 3140156467, 37809, 17133, 139, 38, 35, 109, 217, 199, 132, 150);
RT_INTERFACE!{interface IFileActivatedEventArgs(IFileActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFileActivatedEventArgs] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Files(&self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::storage::IStorageItem>) -> HRESULT,
    fn get_Verb(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_files(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<super::super::storage::IStorageItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Files)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_verb(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Verb)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FileActivatedEventArgs: IFileActivatedEventArgs}
DEFINE_IID!(IID_IFileActivatedEventArgsWithCallerPackageFamilyName, 761327723, 53855, 19749, 134, 83, 225, 197, 225, 16, 131, 9);
RT_INTERFACE!{interface IFileActivatedEventArgsWithCallerPackageFamilyName(IFileActivatedEventArgsWithCallerPackageFamilyNameVtbl): IInspectable(IInspectableVtbl) [IID_IFileActivatedEventArgsWithCallerPackageFamilyName] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileActivatedEventArgsWithCallerPackageFamilyName {
    #[inline] pub unsafe fn get_caller_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallerPackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFileActivatedEventArgsWithNeighboringFiles, 1127981476, 57826, 18685, 183, 252, 181, 214, 238, 230, 80, 51);
RT_INTERFACE!{interface IFileActivatedEventArgsWithNeighboringFiles(IFileActivatedEventArgsWithNeighboringFilesVtbl): IInspectable(IInspectableVtbl) [IID_IFileActivatedEventArgsWithNeighboringFiles] {
    #[cfg(feature="windows-storage")] fn get_NeighboringFilesQuery(&self, out: *mut *mut super::super::storage::search::StorageFileQueryResult) -> HRESULT
}}
impl IFileActivatedEventArgsWithNeighboringFiles {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_neighboring_files_query(&self) -> Result<ComPtr<super::super::storage::search::StorageFileQueryResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NeighboringFilesQuery)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFileOpenPickerActivatedEventArgs, 1921151106, 21797, 19442, 188, 9, 31, 80, 149, 212, 150, 77);
RT_INTERFACE!{interface IFileOpenPickerActivatedEventArgs(IFileOpenPickerActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFileOpenPickerActivatedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_FileOpenPickerUI(&self, out: *mut *mut super::super::storage::pickers::provider::FileOpenPickerUI) -> HRESULT
}}
impl IFileOpenPickerActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_file_open_picker_ui(&self) -> Result<ComPtr<super::super::storage::pickers::provider::FileOpenPickerUI>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FileOpenPickerUI)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FileOpenPickerActivatedEventArgs: IFileOpenPickerActivatedEventArgs}
DEFINE_IID!(IID_IFileOpenPickerActivatedEventArgs2, 1584602982, 36127, 17915, 175, 29, 115, 32, 92, 143, 199, 161);
RT_INTERFACE!{interface IFileOpenPickerActivatedEventArgs2(IFileOpenPickerActivatedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IFileOpenPickerActivatedEventArgs2] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileOpenPickerActivatedEventArgs2 {
    #[inline] pub unsafe fn get_caller_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallerPackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFileOpenPickerContinuationEventArgs, 4042932026, 54504, 19155, 156, 52, 35, 8, 243, 47, 206, 201);
RT_INTERFACE!{interface IFileOpenPickerContinuationEventArgs(IFileOpenPickerContinuationEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFileOpenPickerContinuationEventArgs] {
    #[cfg(feature="windows-storage")] fn get_Files(&self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::storage::StorageFile>) -> HRESULT
}}
impl IFileOpenPickerContinuationEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_files(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<super::super::storage::StorageFile>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Files)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FileOpenPickerContinuationEventArgs: IFileOpenPickerContinuationEventArgs}
DEFINE_IID!(IID_IFileSavePickerActivatedEventArgs, 2176949489, 29926, 17287, 130, 235, 187, 143, 214, 75, 67, 70);
RT_INTERFACE!{interface IFileSavePickerActivatedEventArgs(IFileSavePickerActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFileSavePickerActivatedEventArgs] {
    #[cfg(feature="windows-storage")] fn get_FileSavePickerUI(&self, out: *mut *mut super::super::storage::pickers::provider::FileSavePickerUI) -> HRESULT
}}
impl IFileSavePickerActivatedEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_file_save_picker_ui(&self) -> Result<ComPtr<super::super::storage::pickers::provider::FileSavePickerUI>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FileSavePickerUI)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FileSavePickerActivatedEventArgs: IFileSavePickerActivatedEventArgs}
DEFINE_IID!(IID_IFileSavePickerActivatedEventArgs2, 1802763795, 11506, 19784, 140, 188, 175, 103, 210, 63, 28, 231);
RT_INTERFACE!{interface IFileSavePickerActivatedEventArgs2(IFileSavePickerActivatedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IFileSavePickerActivatedEventArgs2] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IFileSavePickerActivatedEventArgs2 {
    #[inline] pub unsafe fn get_caller_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallerPackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enterprise_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnterpriseId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFileSavePickerContinuationEventArgs, 746876897, 15277, 20275, 140, 139, 228, 111, 174, 130, 75, 75);
RT_INTERFACE!{interface IFileSavePickerContinuationEventArgs(IFileSavePickerContinuationEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFileSavePickerContinuationEventArgs] {
    #[cfg(feature="windows-storage")] fn get_File(&self, out: *mut *mut super::super::storage::StorageFile) -> HRESULT
}}
impl IFileSavePickerContinuationEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_file(&self) -> Result<ComPtr<super::super::storage::StorageFile>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_File)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FileSavePickerContinuationEventArgs: IFileSavePickerContinuationEventArgs}
DEFINE_IID!(IID_IFolderPickerContinuationEventArgs, 1367876454, 40779, 18831, 190, 176, 66, 104, 79, 110, 28, 41);
RT_INTERFACE!{interface IFolderPickerContinuationEventArgs(IFolderPickerContinuationEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IFolderPickerContinuationEventArgs] {
    #[cfg(feature="windows-storage")] fn get_Folder(&self, out: *mut *mut super::super::storage::StorageFolder) -> HRESULT
}}
impl IFolderPickerContinuationEventArgs {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_folder(&self) -> Result<ComPtr<super::super::storage::StorageFolder>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Folder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class FolderPickerContinuationEventArgs: IFolderPickerContinuationEventArgs}
DEFINE_IID!(IID_ILaunchActivatedEventArgs, 4224269862, 41290, 19279, 130, 176, 51, 190, 217, 32, 175, 82);
RT_INTERFACE!{interface ILaunchActivatedEventArgs(ILaunchActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILaunchActivatedEventArgs] {
    fn get_Arguments(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TileId(&self, out: *mut HSTRING) -> HRESULT
}}
impl ILaunchActivatedEventArgs {
    #[inline] pub unsafe fn get_arguments(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Arguments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tile_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TileId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LaunchActivatedEventArgs: ILaunchActivatedEventArgs}
DEFINE_IID!(IID_ILaunchActivatedEventArgs2, 265518780, 40393, 18101, 154, 206, 189, 149, 212, 86, 83, 69);
RT_INTERFACE!{interface ILaunchActivatedEventArgs2(ILaunchActivatedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_ILaunchActivatedEventArgs2] {
    fn get_TileActivatedInfo(&self, out: *mut *mut TileActivatedInfo) -> HRESULT
}}
impl ILaunchActivatedEventArgs2 {
    #[inline] pub unsafe fn get_tile_activated_info(&self) -> Result<ComPtr<TileActivatedInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TileActivatedInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILockScreenActivatedEventArgs, 1017608550, 24840, 19009, 130, 32, 238, 125, 19, 60, 133, 50);
RT_INTERFACE!{interface ILockScreenActivatedEventArgs(ILockScreenActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenActivatedEventArgs] {
    fn get_Info(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl ILockScreenActivatedEventArgs {
    #[inline] pub unsafe fn get_info(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Info)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenActivatedEventArgs: ILockScreenActivatedEventArgs}
DEFINE_IID!(IID_ILockScreenCallActivatedEventArgs, 116621246, 46578, 17547, 177, 62, 227, 40, 172, 28, 81, 106);
RT_INTERFACE!{interface ILockScreenCallActivatedEventArgs(ILockScreenCallActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenCallActivatedEventArgs] {
    fn get_CallUI(&self, out: *mut *mut super::calls::LockScreenCallUI) -> HRESULT
}}
impl ILockScreenCallActivatedEventArgs {
    #[inline] pub unsafe fn get_call_ui(&self) -> Result<ComPtr<super::calls::LockScreenCallUI>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallUI)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenCallActivatedEventArgs: ILockScreenCallActivatedEventArgs}
RT_CLASS!{class LockScreenComponentActivatedEventArgs: IActivatedEventArgs}
DEFINE_IID!(IID_IPickerReturnedActivatedEventArgs, 906883001, 43475, 18820, 164, 237, 158, 199, 52, 96, 73, 33);
RT_INTERFACE!{interface IPickerReturnedActivatedEventArgs(IPickerReturnedActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPickerReturnedActivatedEventArgs] {
    fn get_PickerOperationId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPickerReturnedActivatedEventArgs {
    #[inline] pub unsafe fn get_picker_operation_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PickerOperationId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PickerReturnedActivatedEventArgs: IPickerReturnedActivatedEventArgs}
DEFINE_IID!(IID_IPrelaunchActivatedEventArgs, 205812091, 6647, 18646, 176, 70, 207, 34, 130, 110, 170, 116);
RT_INTERFACE!{interface IPrelaunchActivatedEventArgs(IPrelaunchActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrelaunchActivatedEventArgs] {
    fn get_PrelaunchActivated(&self, out: *mut bool) -> HRESULT
}}
impl IPrelaunchActivatedEventArgs {
    #[inline] pub unsafe fn get_prelaunch_activated(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PrelaunchActivated)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPrint3DWorkflowActivatedEventArgs, 1062725515, 62124, 17945, 131, 2, 239, 133, 94, 28, 155, 144);
RT_INTERFACE!{interface IPrint3DWorkflowActivatedEventArgs(IPrint3DWorkflowActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrint3DWorkflowActivatedEventArgs] {
    #[cfg(feature="windows-devices")] fn get_Workflow(&self, out: *mut *mut super::super::devices::printers::extensions::Print3DWorkflow) -> HRESULT
}}
impl IPrint3DWorkflowActivatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_workflow(&self) -> Result<ComPtr<super::super::devices::printers::extensions::Print3DWorkflow>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Workflow)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Print3DWorkflowActivatedEventArgs: IPrint3DWorkflowActivatedEventArgs}
DEFINE_IID!(IID_IPrintTaskSettingsActivatedEventArgs, 3996164297, 52822, 18533, 186, 142, 137, 84, 172, 39, 17, 7);
RT_INTERFACE!{interface IPrintTaskSettingsActivatedEventArgs(IPrintTaskSettingsActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPrintTaskSettingsActivatedEventArgs] {
    #[cfg(feature="windows-devices")] fn get_Configuration(&self, out: *mut *mut super::super::devices::printers::extensions::PrintTaskConfiguration) -> HRESULT
}}
impl IPrintTaskSettingsActivatedEventArgs {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_configuration(&self) -> Result<ComPtr<super::super::devices::printers::extensions::PrintTaskConfiguration>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Configuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PrintTaskSettingsActivatedEventArgs: IPrintTaskSettingsActivatedEventArgs}
DEFINE_IID!(IID_IProtocolActivatedEventArgs, 1620440285, 47040, 18091, 129, 254, 217, 15, 54, 208, 13, 36);
RT_INTERFACE!{interface IProtocolActivatedEventArgs(IProtocolActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IProtocolActivatedEventArgs] {
    fn get_Uri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT
}}
impl IProtocolActivatedEventArgs {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ProtocolActivatedEventArgs: IProtocolActivatedEventArgs}
DEFINE_IID!(IID_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, 3628731410, 23695, 17292, 131, 203, 194, 143, 204, 11, 47, 219);
RT_INTERFACE!{interface IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndDataVtbl): IInspectable(IInspectableVtbl) [IID_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData] {
    fn get_CallerPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Data(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT
}}
impl IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData {
    #[inline] pub unsafe fn get_caller_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CallerPackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProtocolForResultsActivatedEventArgs, 3880858306, 31463, 17687, 128, 172, 219, 232, 215, 204, 91, 156);
RT_INTERFACE!{interface IProtocolForResultsActivatedEventArgs(IProtocolForResultsActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IProtocolForResultsActivatedEventArgs] {
    #[cfg(feature="windows-system")] fn get_ProtocolForResultsOperation(&self, out: *mut *mut super::super::system::ProtocolForResultsOperation) -> HRESULT
}}
impl IProtocolForResultsActivatedEventArgs {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_protocol_for_results_operation(&self) -> Result<ComPtr<super::super::system::ProtocolForResultsOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProtocolForResultsOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ProtocolForResultsActivatedEventArgs: IProtocolForResultsActivatedEventArgs}
DEFINE_IID!(IID_IRestrictedLaunchActivatedEventArgs, 3770133633, 49091, 17220, 165, 218, 25, 253, 90, 39, 186, 174);
RT_INTERFACE!{interface IRestrictedLaunchActivatedEventArgs(IRestrictedLaunchActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRestrictedLaunchActivatedEventArgs] {
    fn get_SharedContext(&self, out: *mut *mut IInspectable) -> HRESULT
}}
impl IRestrictedLaunchActivatedEventArgs {
    #[inline] pub unsafe fn get_shared_context(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SharedContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RestrictedLaunchActivatedEventArgs: IRestrictedLaunchActivatedEventArgs}
DEFINE_IID!(IID_ISearchActivatedEventArgs, 2360568145, 22728, 17379, 148, 188, 65, 211, 63, 139, 99, 14);
RT_INTERFACE!{interface ISearchActivatedEventArgs(ISearchActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchActivatedEventArgs] {
    fn get_QueryText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT
}}
impl ISearchActivatedEventArgs {
    #[inline] pub unsafe fn get_query_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QueryText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class SearchActivatedEventArgs: ISearchActivatedEventArgs}
DEFINE_IID!(IID_ISearchActivatedEventArgsWithLinguisticDetails, 3231658970, 2219, 18737, 155, 124, 69, 16, 37, 242, 31, 129);
RT_INTERFACE!{interface ISearchActivatedEventArgsWithLinguisticDetails(ISearchActivatedEventArgsWithLinguisticDetailsVtbl): IInspectable(IInspectableVtbl) [IID_ISearchActivatedEventArgsWithLinguisticDetails] {
    fn get_LinguisticDetails(&self, out: *mut *mut super::search::SearchPaneQueryLinguisticDetails) -> HRESULT
}}
impl ISearchActivatedEventArgsWithLinguisticDetails {
    #[inline] pub unsafe fn get_linguistic_details(&self) -> Result<ComPtr<super::search::SearchPaneQueryLinguisticDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinguisticDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShareTargetActivatedEventArgs, 1272641992, 52658, 19147, 191, 195, 102, 72, 86, 51, 120, 236);
RT_INTERFACE!{interface IShareTargetActivatedEventArgs(IShareTargetActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IShareTargetActivatedEventArgs] {
    fn get_ShareOperation(&self, out: *mut *mut super::datatransfer::sharetarget::ShareOperation) -> HRESULT
}}
impl IShareTargetActivatedEventArgs {
    #[inline] pub unsafe fn get_share_operation(&self) -> Result<ComPtr<super::datatransfer::sharetarget::ShareOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShareOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ShareTargetActivatedEventArgs: IShareTargetActivatedEventArgs}
DEFINE_IID!(IID_ISplashScreen, 3394082652, 54486, 17392, 151, 192, 8, 51, 198, 57, 28, 36);
RT_INTERFACE!{interface ISplashScreen(ISplashScreenVtbl): IInspectable(IInspectableVtbl) [IID_ISplashScreen] {
    fn get_ImageLocation(&self, out: *mut super::super::foundation::Rect) -> HRESULT,
    fn add_Dismissed(&self, handler: *mut super::super::foundation::TypedEventHandler<SplashScreen, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Dismissed(&self, cookie: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ISplashScreen {
    #[inline] pub unsafe fn get_image_location(&self) -> Result<super::super::foundation::Rect> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ImageLocation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_dismissed(&self, handler: &super::super::foundation::TypedEventHandler<SplashScreen, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Dismissed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_dismissed(&self, cookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Dismissed)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class SplashScreen: ISplashScreen}
DEFINE_IID!(IID_IStartupTaskActivatedEventArgs, 61938264, 21110, 19857, 134, 33, 84, 97, 24, 100, 213, 250);
RT_INTERFACE!{interface IStartupTaskActivatedEventArgs(IStartupTaskActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IStartupTaskActivatedEventArgs] {
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStartupTaskActivatedEventArgs {
    #[inline] pub unsafe fn get_task_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StartupTaskActivatedEventArgs: IStartupTaskActivatedEventArgs}
DEFINE_IID!(IID_ITileActivatedInfo, 2162467761, 14720, 20247, 183, 56, 137, 25, 78, 11, 143, 101);
RT_INTERFACE!{interface ITileActivatedInfo(ITileActivatedInfoVtbl): IInspectable(IInspectableVtbl) [IID_ITileActivatedInfo] {
    #[cfg(feature="windows-ui")] fn get_RecentlyShownNotifications(&self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::ui::notifications::ShownTileNotification>) -> HRESULT
}}
impl ITileActivatedInfo {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_recently_shown_notifications(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<super::super::ui::notifications::ShownTileNotification>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecentlyShownNotifications)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TileActivatedInfo: ITileActivatedInfo}
DEFINE_IID!(IID_IToastNotificationActivatedEventArgs, 2460512130, 21136, 17181, 190, 133, 196, 170, 238, 184, 104, 95);
RT_INTERFACE!{interface IToastNotificationActivatedEventArgs(IToastNotificationActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IToastNotificationActivatedEventArgs] {
    fn get_Argument(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserInput(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT
}}
impl IToastNotificationActivatedEventArgs {
    #[inline] pub unsafe fn get_argument(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Argument)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_input(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserInput)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ToastNotificationActivatedEventArgs: IToastNotificationActivatedEventArgs}
DEFINE_IID!(IID_IUserDataAccountProviderActivatedEventArgs, 466220835, 36593, 19025, 166, 58, 254, 113, 30, 234, 182, 7);
RT_INTERFACE!{interface IUserDataAccountProviderActivatedEventArgs(IUserDataAccountProviderActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountProviderActivatedEventArgs] {
    fn get_Operation(&self, out: *mut *mut super::userdataaccounts::provider::IUserDataAccountProviderOperation) -> HRESULT
}}
impl IUserDataAccountProviderActivatedEventArgs {
    #[inline] pub unsafe fn get_operation(&self) -> Result<ComPtr<super::userdataaccounts::provider::IUserDataAccountProviderOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Operation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountProviderActivatedEventArgs: IUserDataAccountProviderActivatedEventArgs}
DEFINE_IID!(IID_IViewSwitcherProvider, 871532710, 23596, 19751, 186, 199, 117, 54, 8, 143, 18, 25);
RT_INTERFACE!{interface IViewSwitcherProvider(IViewSwitcherProviderVtbl): IInspectable(IInspectableVtbl) [IID_IViewSwitcherProvider] {
    #[cfg(feature="windows-ui")] fn get_ViewSwitcher(&self, out: *mut *mut super::super::ui::viewmanagement::ActivationViewSwitcher) -> HRESULT
}}
impl IViewSwitcherProvider {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_view_switcher(&self) -> Result<ComPtr<super::super::ui::viewmanagement::ActivationViewSwitcher>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ViewSwitcher)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVoiceCommandActivatedEventArgs, 2878528765, 36163, 19942, 151, 117, 32, 112, 75, 88, 27, 0);
RT_INTERFACE!{interface IVoiceCommandActivatedEventArgs(IVoiceCommandActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandActivatedEventArgs] {
    #[cfg(feature="windows-media")] fn get_Result(&self, out: *mut *mut super::super::media::speechrecognition::SpeechRecognitionResult) -> HRESULT
}}
impl IVoiceCommandActivatedEventArgs {
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_result(&self) -> Result<ComPtr<super::super::media::speechrecognition::SpeechRecognitionResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Result)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandActivatedEventArgs: IVoiceCommandActivatedEventArgs}
DEFINE_IID!(IID_IWalletActionActivatedEventArgs, 4244374139, 6682, 19746, 146, 63, 174, 111, 69, 250, 82, 217);
RT_INTERFACE!{interface IWalletActionActivatedEventArgs(IWalletActionActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWalletActionActivatedEventArgs] {
    fn get_ItemId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ActionKind(&self, out: *mut super::wallet::WalletActionKind) -> HRESULT,
    fn get_ActionId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IWalletActionActivatedEventArgs {
    #[inline] pub unsafe fn get_item_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ItemId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_action_kind(&self) -> Result<super::wallet::WalletActionKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ActionKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_action_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActionId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WalletActionActivatedEventArgs: IWalletActionActivatedEventArgs}
DEFINE_IID!(IID_IWebAccountProviderActivatedEventArgs, 1924601716, 39146, 19663, 151, 82, 70, 217, 5, 16, 4, 241);
RT_INTERFACE!{interface IWebAccountProviderActivatedEventArgs(IWebAccountProviderActivatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebAccountProviderActivatedEventArgs] {
    #[cfg(feature="windows-security")] fn get_Operation(&self, out: *mut *mut super::super::security::authentication::web::provider::IWebAccountProviderOperation) -> HRESULT
}}
impl IWebAccountProviderActivatedEventArgs {
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn get_operation(&self) -> Result<ComPtr<super::super::security::authentication::web::provider::IWebAccountProviderOperation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Operation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WebAccountProviderActivatedEventArgs: IWebAccountProviderActivatedEventArgs}
DEFINE_IID!(IID_IWebAuthenticationBrokerContinuationEventArgs, 1977459668, 30484, 17725, 183, 255, 185, 94, 58, 23, 9, 218);
RT_INTERFACE!{interface IWebAuthenticationBrokerContinuationEventArgs(IWebAuthenticationBrokerContinuationEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IWebAuthenticationBrokerContinuationEventArgs] {
    #[cfg(feature="windows-security")] fn get_WebAuthenticationResult(&self, out: *mut *mut super::super::security::authentication::web::WebAuthenticationResult) -> HRESULT
}}
impl IWebAuthenticationBrokerContinuationEventArgs {
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn get_web_authentication_result(&self) -> Result<ComPtr<super::super::security::authentication::web::WebAuthenticationResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebAuthenticationResult)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WebAuthenticationBrokerContinuationEventArgs: IWebAuthenticationBrokerContinuationEventArgs}
} // Windows.ApplicationModel.Activation
pub mod chat { // Windows.ApplicationModel.Chat
use ::prelude::*;
DEFINE_IID!(IID_IChatCapabilities, 989820860, 14793, 19921, 173, 45, 57, 100, 221, 157, 64, 63);
RT_INTERFACE!{interface IChatCapabilities(IChatCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IChatCapabilities] {
    fn get_IsOnline(&self, out: *mut bool) -> HRESULT,
    fn get_IsChatCapable(&self, out: *mut bool) -> HRESULT,
    fn get_IsFileTransferCapable(&self, out: *mut bool) -> HRESULT,
    fn get_IsGeoLocationPushCapable(&self, out: *mut bool) -> HRESULT,
    fn get_IsIntegratedMessagingCapable(&self, out: *mut bool) -> HRESULT
}}
impl IChatCapabilities {
    #[inline] pub unsafe fn get_is_online(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOnline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_chat_capable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsChatCapable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_file_transfer_capable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFileTransferCapable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_geo_location_push_capable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGeoLocationPushCapable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_integrated_messaging_capable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIntegratedMessagingCapable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ChatCapabilities: IChatCapabilities}
RT_CLASS!{static class ChatCapabilitiesManager}
impl RtActivatable<IChatCapabilitiesManagerStatics> for ChatCapabilitiesManager {}
impl ChatCapabilitiesManager {
    #[inline] pub fn get_cached_capabilities_async(address: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatCapabilities>>> { unsafe {
        <Self as RtActivatable<IChatCapabilitiesManagerStatics>>::get_activation_factory().get_cached_capabilities_async(address)
    }}
    #[inline] pub fn get_capabilities_from_network_async(address: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatCapabilities>>> { unsafe {
        <Self as RtActivatable<IChatCapabilitiesManagerStatics>>::get_activation_factory().get_capabilities_from_network_async(address)
    }}
}
DEFINE_CLSID!(ChatCapabilitiesManager: "Windows.ApplicationModel.Chat.ChatCapabilitiesManager");
DEFINE_IID!(IID_IChatCapabilitiesManagerStatics, 3044683568, 28737, 17806, 176, 207, 124, 13, 159, 234, 51, 58);
RT_INTERFACE!{static interface IChatCapabilitiesManagerStatics(IChatCapabilitiesManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IChatCapabilitiesManagerStatics] {
    fn GetCachedCapabilitiesAsync(&self, address: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatCapabilities>) -> HRESULT,
    fn GetCapabilitiesFromNetworkAsync(&self, address: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatCapabilities>) -> HRESULT
}}
impl IChatCapabilitiesManagerStatics {
    #[inline] pub unsafe fn get_cached_capabilities_async(&self, address: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatCapabilities>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCachedCapabilitiesAsync)(self as *const _ as *mut _, address.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_capabilities_from_network_async(&self, address: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatCapabilities>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCapabilitiesFromNetworkAsync)(self as *const _ as *mut _, address.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatConversation, 2777417741, 6767, 18140, 143, 61, 245, 2, 134, 96, 182, 238);
RT_INTERFACE!{interface IChatConversation(IChatConversationVtbl): IInspectable(IInspectableVtbl) [IID_IChatConversation] {
    fn get_HasUnreadMessages(&self, out: *mut bool) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_IsConversationMuted(&self, out: *mut bool) -> HRESULT,
    fn put_IsConversationMuted(&self, value: bool) -> HRESULT,
    fn get_MostRecentMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Participants(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_ThreadingInfo(&self, out: *mut *mut ChatConversationThreadingInfo) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetMessageReader(&self, out: *mut *mut ChatMessageReader) -> HRESULT,
    fn MarkAllMessagesAsReadAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkMessagesAsReadAsync(&self, value: super::super::foundation::DateTime, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn NotifyLocalParticipantComposing(&self, transportId: HSTRING, participantAddress: HSTRING, isComposing: bool) -> HRESULT,
    fn NotifyRemoteParticipantComposing(&self, transportId: HSTRING, participantAddress: HSTRING, isComposing: bool) -> HRESULT,
    fn add_RemoteParticipantComposingChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<ChatConversation, RemoteParticipantComposingChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_RemoteParticipantComposingChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IChatConversation {
    #[inline] pub unsafe fn get_has_unread_messages(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasUnreadMessages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_subject(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Subject)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_conversation_muted(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsConversationMuted)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_conversation_muted(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsConversationMuted)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_most_recent_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MostRecentMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_participants(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Participants)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_threading_info(&self) -> Result<ComPtr<ChatConversationThreadingInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThreadingInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader(&self) -> Result<ComPtr<ChatMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_all_messages_as_read_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkAllMessagesAsReadAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_messages_as_read_async(&self, value: super::super::foundation::DateTime) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkMessagesAsReadAsync)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_local_participant_composing(&self, transportId: &HStringArg, participantAddress: &HStringArg, isComposing: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyLocalParticipantComposing)(self as *const _ as *mut _, transportId.get(), participantAddress.get(), isComposing);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn notify_remote_participant_composing(&self, transportId: &HStringArg, participantAddress: &HStringArg, isComposing: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).NotifyRemoteParticipantComposing)(self as *const _ as *mut _, transportId.get(), participantAddress.get(), isComposing);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_remote_participant_composing_changed(&self, handler: &super::super::foundation::TypedEventHandler<ChatConversation, RemoteParticipantComposingChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_RemoteParticipantComposingChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_remote_participant_composing_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_RemoteParticipantComposingChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatConversation: IChatConversation}
DEFINE_IID!(IID_IChatConversation2, 167972049, 38970, 18346, 154, 144, 238, 72, 238, 153, 123, 89);
RT_INTERFACE!{interface IChatConversation2(IChatConversation2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatConversation2] {
    fn get_CanModifyParticipants(&self, out: *mut bool) -> HRESULT,
    fn put_CanModifyParticipants(&self, value: bool) -> HRESULT
}}
impl IChatConversation2 {
    #[inline] pub unsafe fn get_can_modify_participants(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanModifyParticipants)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_modify_participants(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanModifyParticipants)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatConversationReader, 89208530, 56882, 19015, 169, 58, 179, 220, 8, 51, 133, 43);
RT_INTERFACE!{interface IChatConversationReader(IChatConversationReaderVtbl): IInspectable(IInspectableVtbl) [IID_IChatConversationReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatConversation>>) -> HRESULT,
    fn ReadBatchWithCountAsync(&self, count: i32, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatConversation>>) -> HRESULT
}}
impl IChatConversationReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatConversation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn read_batch_with_count_async(&self, count: i32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatConversation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchWithCountAsync)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatConversationReader: IChatConversationReader}
DEFINE_IID!(IID_IChatConversationThreadingInfo, 857481692, 31239, 17442, 163, 44, 36, 190, 124, 109, 171, 36);
RT_INTERFACE!{interface IChatConversationThreadingInfo(IChatConversationThreadingInfoVtbl): IInspectable(IInspectableVtbl) [IID_IChatConversationThreadingInfo] {
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactId(&self, value: HSTRING) -> HRESULT,
    fn get_Custom(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Custom(&self, value: HSTRING) -> HRESULT,
    fn get_ConversationId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ConversationId(&self, value: HSTRING) -> HRESULT,
    fn get_Participants(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_Kind(&self, out: *mut ChatConversationThreadingKind) -> HRESULT,
    fn put_Kind(&self, value: ChatConversationThreadingKind) -> HRESULT
}}
impl IChatConversationThreadingInfo {
    #[inline] pub unsafe fn get_contact_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contact_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContactId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Custom)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_custom(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Custom)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConversationId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_conversation_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ConversationId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_participants(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Participants)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<ChatConversationThreadingKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: ChatConversationThreadingKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatConversationThreadingInfo: IChatConversationThreadingInfo}
impl RtActivatable<IActivationFactory> for ChatConversationThreadingInfo {}
DEFINE_CLSID!(ChatConversationThreadingInfo: "Windows.ApplicationModel.Chat.ChatConversationThreadingInfo");
RT_ENUM! { enum ChatConversationThreadingKind: i32 {
    Participants (ChatConversationThreadingKind_Participants) = 0, ContactId (ChatConversationThreadingKind_ContactId) = 1, ConversationId (ChatConversationThreadingKind_ConversationId) = 2, Custom (ChatConversationThreadingKind_Custom) = 3,
}}
DEFINE_IID!(IID_IChatItem, 2270285824, 52913, 16963, 184, 3, 21, 212, 90, 29, 212, 40);
RT_INTERFACE!{interface IChatItem(IChatItemVtbl): IInspectable(IInspectableVtbl) [IID_IChatItem] {
    fn get_ItemKind(&self, out: *mut ChatItemKind) -> HRESULT
}}
impl IChatItem {
    #[inline] pub unsafe fn get_item_kind(&self) -> Result<ChatItemKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum ChatItemKind: i32 {
    Message (ChatItemKind_Message) = 0, Conversation (ChatItemKind_Conversation) = 1,
}}
DEFINE_IID!(IID_IChatMessage, 1262028074, 4418, 20617, 118, 218, 242, 219, 61, 23, 205, 5);
RT_INTERFACE!{interface IChatMessage(IChatMessageVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessage] {
    fn get_Attachments(&self, out: *mut *mut super::super::foundation::collections::IVector<ChatMessageAttachment>) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_From(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsForwardingDisabled(&self, out: *mut bool) -> HRESULT,
    fn get_IsIncoming(&self, out: *mut bool) -> HRESULT,
    fn get_IsRead(&self, out: *mut bool) -> HRESULT,
    fn get_LocalTimestamp(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_NetworkTimestamp(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_Recipients(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_RecipientSendStatuses(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, ChatMessageStatus>) -> HRESULT,
    fn get_Status(&self, out: *mut ChatMessageStatus) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TransportId(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessage {
    #[inline] pub unsafe fn get_attachments(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ChatMessageAttachment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Attachments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_body(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Body)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_body(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Body)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_from(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_From)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_forwarding_disabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsForwardingDisabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_incoming(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIncoming)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_read(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRead)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_local_timestamp(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LocalTimestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_network_timestamp(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NetworkTimestamp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recipients(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recipients)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recipient_send_statuses(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, ChatMessageStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecipientSendStatuses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<ChatMessageStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_friendly_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportFriendlyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transport_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransportId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessage: IChatMessage}
impl RtActivatable<IActivationFactory> for ChatMessage {}
DEFINE_CLSID!(ChatMessage: "Windows.ApplicationModel.Chat.ChatMessage");
DEFINE_IID!(IID_IChatMessage2, 2254865202, 21567, 18933, 172, 113, 108, 42, 252, 101, 101, 253);
RT_INTERFACE!{interface IChatMessage2(IChatMessage2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessage2] {
    fn get_EstimatedDownloadSize(&self, out: *mut u64) -> HRESULT,
    fn put_EstimatedDownloadSize(&self, value: u64) -> HRESULT,
    fn put_From(&self, value: HSTRING) -> HRESULT,
    fn get_IsAutoReply(&self, out: *mut bool) -> HRESULT,
    fn put_IsAutoReply(&self, value: bool) -> HRESULT,
    fn put_IsForwardingDisabled(&self, value: bool) -> HRESULT,
    fn get_IsReplyDisabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsIncoming(&self, value: bool) -> HRESULT,
    fn put_IsRead(&self, value: bool) -> HRESULT,
    fn get_IsSeen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeen(&self, value: bool) -> HRESULT,
    fn get_IsSimMessage(&self, out: *mut bool) -> HRESULT,
    fn put_LocalTimestamp(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_MessageKind(&self, out: *mut ChatMessageKind) -> HRESULT,
    fn put_MessageKind(&self, value: ChatMessageKind) -> HRESULT,
    fn get_MessageOperatorKind(&self, out: *mut ChatMessageOperatorKind) -> HRESULT,
    fn put_MessageOperatorKind(&self, value: ChatMessageOperatorKind) -> HRESULT,
    fn put_NetworkTimestamp(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_IsReceivedDuringQuietHours(&self, out: *mut bool) -> HRESULT,
    fn put_IsReceivedDuringQuietHours(&self, value: bool) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn put_Status(&self, value: ChatMessageStatus) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_ShouldSuppressNotification(&self, out: *mut bool) -> HRESULT,
    fn put_ShouldSuppressNotification(&self, value: bool) -> HRESULT,
    fn get_ThreadingInfo(&self, out: *mut *mut ChatConversationThreadingInfo) -> HRESULT,
    fn put_ThreadingInfo(&self, value: *mut ChatConversationThreadingInfo) -> HRESULT,
    fn get_RecipientsDeliveryInfos(&self, out: *mut *mut super::super::foundation::collections::IVector<ChatRecipientDeliveryInfo>) -> HRESULT
}}
impl IChatMessage2 {
    #[inline] pub unsafe fn get_estimated_download_size(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EstimatedDownloadSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_estimated_download_size(&self, value: u64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EstimatedDownloadSize)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_from(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_From)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_auto_reply(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAutoReply)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_auto_reply(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsAutoReply)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_forwarding_disabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsForwardingDisabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_reply_disabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReplyDisabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_incoming(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsIncoming)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_read(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRead)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seen(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSeen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_seen(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSeen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_sim_message(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSimMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_local_timestamp(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LocalTimestamp)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_kind(&self) -> Result<ChatMessageKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MessageKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_message_kind(&self, value: ChatMessageKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MessageKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_operator_kind(&self) -> Result<ChatMessageOperatorKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MessageOperatorKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_message_operator_kind(&self, value: ChatMessageOperatorKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MessageOperatorKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_network_timestamp(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_NetworkTimestamp)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_received_during_quiet_hours(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReceivedDuringQuietHours)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_received_during_quiet_hours(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsReceivedDuringQuietHours)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_status(&self, value: ChatMessageStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Status)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_subject(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Subject)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_should_suppress_notification(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldSuppressNotification)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_should_suppress_notification(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShouldSuppressNotification)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_threading_info(&self) -> Result<ComPtr<ChatConversationThreadingInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ThreadingInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_threading_info(&self, value: &ChatConversationThreadingInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ThreadingInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recipients_delivery_infos(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ChatRecipientDeliveryInfo>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecipientsDeliveryInfos)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessage3, 1961570224, 15271, 17823, 142, 11, 232, 175, 15, 235, 217, 173);
RT_INTERFACE!{interface IChatMessage3(IChatMessage3Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessage3] {
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IChatMessage3 {
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessage4, 756304655, 53951, 17932, 170, 104, 109, 63, 132, 131, 201, 191);
RT_INTERFACE!{interface IChatMessage4(IChatMessage4Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessage4] {
    fn get_SyncId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SyncId(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessage4 {
    #[inline] pub unsafe fn get_sync_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SyncId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sync_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SyncId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageAttachment, 3351575924, 48995, 22763, 80, 140, 139, 134, 63, 241, 107, 103);
RT_INTERFACE!{interface IChatMessageAttachment(IChatMessageAttachmentVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageAttachment] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DataStreamReference(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_DataStreamReference(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_GroupId(&self, out: *mut u32) -> HRESULT,
    fn put_GroupId(&self, value: u32) -> HRESULT,
    fn get_MimeType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MimeType(&self, value: HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessageAttachment {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_data_stream_reference(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataStreamReference)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_data_stream_reference(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DataStreamReference)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_group_id(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_GroupId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_group_id(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_GroupId)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mime_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MimeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mime_type(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MimeType)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageAttachment: IChatMessageAttachment}
impl RtActivatable<IChatMessageAttachmentFactory> for ChatMessageAttachment {}
impl ChatMessageAttachment {
    #[cfg(feature="windows-storage")] #[inline] pub fn create_chat_message_attachment(mimeType: &HStringArg, dataStreamReference: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<ChatMessageAttachment>> { unsafe {
        <Self as RtActivatable<IChatMessageAttachmentFactory>>::get_activation_factory().create_chat_message_attachment(mimeType, dataStreamReference)
    }}
}
DEFINE_CLSID!(ChatMessageAttachment: "Windows.ApplicationModel.Chat.ChatMessageAttachment");
DEFINE_IID!(IID_IChatMessageAttachment2, 1591317104, 32209, 19079, 168, 206, 172, 221, 135, 216, 13, 200);
RT_INTERFACE!{interface IChatMessageAttachment2(IChatMessageAttachment2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageAttachment2] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_TransferProgress(&self, out: *mut f64) -> HRESULT,
    fn put_TransferProgress(&self, value: f64) -> HRESULT,
    fn get_OriginalFileName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OriginalFileName(&self, value: HSTRING) -> HRESULT
}}
impl IChatMessageAttachment2 {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Thumbnail)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transfer_progress(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransferProgress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transfer_progress(&self, value: f64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransferProgress)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_original_file_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OriginalFileName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_original_file_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OriginalFileName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageAttachmentFactory, 542659234, 41814, 23409, 108, 169, 102, 201, 133, 183, 208, 213);
RT_INTERFACE!{static interface IChatMessageAttachmentFactory(IChatMessageAttachmentFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageAttachmentFactory] {
    #[cfg(feature="windows-storage")] fn CreateChatMessageAttachment(&self, mimeType: HSTRING, dataStreamReference: *mut super::super::storage::streams::IRandomAccessStreamReference, out: *mut *mut ChatMessageAttachment) -> HRESULT
}}
impl IChatMessageAttachmentFactory {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn create_chat_message_attachment(&self, mimeType: &HStringArg, dataStreamReference: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<ChatMessageAttachment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateChatMessageAttachment)(self as *const _ as *mut _, mimeType.get(), dataStreamReference as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{static class ChatMessageBlocking}
impl RtActivatable<IChatMessageBlockingStatic> for ChatMessageBlocking {}
impl ChatMessageBlocking {
    #[inline] pub fn mark_message_as_blocked_async(localChatMessageId: &HStringArg, blocked: bool) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IChatMessageBlockingStatic>>::get_activation_factory().mark_message_as_blocked_async(localChatMessageId, blocked)
    }}
}
DEFINE_CLSID!(ChatMessageBlocking: "Windows.ApplicationModel.Chat.ChatMessageBlocking");
DEFINE_IID!(IID_IChatMessageBlockingStatic, 4139361152, 52714, 4580, 136, 48, 8, 0, 32, 12, 154, 102);
RT_INTERFACE!{static interface IChatMessageBlockingStatic(IChatMessageBlockingStaticVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageBlockingStatic] {
    fn MarkMessageAsBlockedAsync(&self, localChatMessageId: HSTRING, blocked: bool, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IChatMessageBlockingStatic {
    #[inline] pub unsafe fn mark_message_as_blocked_async(&self, localChatMessageId: &HStringArg, blocked: bool) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkMessageAsBlockedAsync)(self as *const _ as *mut _, localChatMessageId.get(), blocked, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageChange, 471384917, 16926, 21688, 109, 56, 107, 58, 108, 130, 252, 204);
RT_INTERFACE!{interface IChatMessageChange(IChatMessageChangeVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageChange] {
    fn get_ChangeType(&self, out: *mut ChatMessageChangeType) -> HRESULT,
    fn get_Message(&self, out: *mut *mut ChatMessage) -> HRESULT
}}
impl IChatMessageChange {
    #[inline] pub unsafe fn get_change_type(&self) -> Result<ChatMessageChangeType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<ComPtr<ChatMessage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageChange: IChatMessageChange}
DEFINE_IID!(IID_IChatMessageChangedDeferral, 4224103180, 30860, 19916, 172, 231, 98, 130, 56, 41, 104, 207);
RT_INTERFACE!{interface IChatMessageChangedDeferral(IChatMessageChangedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IChatMessageChangedDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageChangedDeferral: IChatMessageChangedDeferral}
DEFINE_IID!(IID_IChatMessageChangedEventArgs, 3065462317, 26908, 20191, 134, 96, 110, 185, 137, 104, 146, 227);
RT_INTERFACE!{interface IChatMessageChangedEventArgs(IChatMessageChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageChangedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut ChatMessageChangedDeferral) -> HRESULT
}}
impl IChatMessageChangedEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<ChatMessageChangedDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageChangedEventArgs: IChatMessageChangedEventArgs}
DEFINE_IID!(IID_IChatMessageChangeReader, 338063392, 10446, 24358, 123, 5, 154, 92, 124, 206, 135, 202);
RT_INTERFACE!{interface IChatMessageChangeReader(IChatMessageChangeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageChangeReader] {
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAcknowledge: *mut ChatMessageChange) -> HRESULT,
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessageChange>>) -> HRESULT
}}
impl IChatMessageChangeReader {
    #[inline] pub unsafe fn accept_changes(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChanges)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn accept_changes_through(&self, lastChangeToAcknowledge: &ChatMessageChange) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChangesThrough)(self as *const _ as *mut _, lastChangeToAcknowledge as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessageChange>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageChangeReader: IChatMessageChangeReader}
DEFINE_IID!(IID_IChatMessageChangeTracker, 1622667366, 28832, 21028, 80, 140, 36, 46, 247, 193, 208, 111);
RT_INTERFACE!{interface IChatMessageChangeTracker(IChatMessageChangeTrackerVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageChangeTracker] {
    fn Enable(&self) -> HRESULT,
    fn GetChangeReader(&self, out: *mut *mut ChatMessageChangeReader) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IChatMessageChangeTracker {
    #[inline] pub unsafe fn enable(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Enable)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_reader(&self) -> Result<ComPtr<ChatMessageChangeReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Reset)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageChangeTracker: IChatMessageChangeTracker}
RT_ENUM! { enum ChatMessageChangeType: i32 {
    MessageCreated (ChatMessageChangeType_MessageCreated) = 0, MessageModified (ChatMessageChangeType_MessageModified) = 1, MessageDeleted (ChatMessageChangeType_MessageDeleted) = 2, ChangeTrackingLost (ChatMessageChangeType_ChangeTrackingLost) = 3,
}}
RT_ENUM! { enum ChatMessageKind: i32 {
    Standard (ChatMessageKind_Standard) = 0, FileTransferRequest (ChatMessageKind_FileTransferRequest) = 1, TransportCustom (ChatMessageKind_TransportCustom) = 2, JoinedConversation (ChatMessageKind_JoinedConversation) = 3, LeftConversation (ChatMessageKind_LeftConversation) = 4, OtherParticipantJoinedConversation (ChatMessageKind_OtherParticipantJoinedConversation) = 5, OtherParticipantLeftConversation (ChatMessageKind_OtherParticipantLeftConversation) = 6,
}}
RT_CLASS!{static class ChatMessageManager}
impl RtActivatable<IChatMessageManager2Statics> for ChatMessageManager {}
impl RtActivatable<IChatMessageManagerStatic> for ChatMessageManager {}
impl RtActivatable<IChatMessageManagerStatics3> for ChatMessageManager {}
impl ChatMessageManager {
    #[inline] pub fn register_transport_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IChatMessageManager2Statics>>::get_activation_factory().register_transport_async()
    }}
    #[inline] pub fn get_transport_async(transportId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessageTransport>>> { unsafe {
        <Self as RtActivatable<IChatMessageManager2Statics>>::get_activation_factory().get_transport_async(transportId)
    }}
    #[inline] pub fn get_transports_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessageTransport>>>> { unsafe {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().get_transports_async()
    }}
    #[inline] pub fn request_store_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessageStore>>> { unsafe {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().request_store_async()
    }}
    #[inline] pub fn show_compose_sms_message_async(message: &ChatMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().show_compose_sms_message_async(message)
    }}
    #[inline] pub fn show_sms_settings() -> Result<()> { unsafe {
        <Self as RtActivatable<IChatMessageManagerStatic>>::get_activation_factory().show_sms_settings()
    }}
    #[inline] pub fn request_sync_manager_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatSyncManager>>> { unsafe {
        <Self as RtActivatable<IChatMessageManagerStatics3>>::get_activation_factory().request_sync_manager_async()
    }}
}
DEFINE_CLSID!(ChatMessageManager: "Windows.ApplicationModel.Chat.ChatMessageManager");
DEFINE_IID!(IID_IChatMessageManager2Statics, 491075855, 40783, 20021, 150, 78, 27, 156, 166, 26, 192, 68);
RT_INTERFACE!{static interface IChatMessageManager2Statics(IChatMessageManager2StaticsVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageManager2Statics] {
    fn RegisterTransportAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetTransportAsync(&self, transportId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatMessageTransport>) -> HRESULT
}}
impl IChatMessageManager2Statics {
    #[inline] pub unsafe fn register_transport_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterTransportAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_async(&self, transportId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessageTransport>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTransportAsync)(self as *const _ as *mut _, transportId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageManagerStatic, 4049363191, 54760, 24210, 85, 109, 224, 59, 96, 37, 49, 4);
RT_INTERFACE!{static interface IChatMessageManagerStatic(IChatMessageManagerStaticVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageManagerStatic] {
    fn GetTransportsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessageTransport>>) -> HRESULT,
    fn RequestStoreAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ChatMessageStore>) -> HRESULT,
    fn ShowComposeSmsMessageAsync(&self, message: *mut ChatMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowSmsSettings(&self) -> HRESULT
}}
impl IChatMessageManagerStatic {
    #[inline] pub unsafe fn get_transports_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessageTransport>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTransportsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_store_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessageStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_compose_sms_message_async(&self, message: &ChatMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowComposeSmsMessageAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_sms_settings(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowSmsSettings)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageManagerStatics3, 546013965, 26453, 18636, 154, 179, 253, 3, 196, 99, 252, 146);
RT_INTERFACE!{static interface IChatMessageManagerStatics3(IChatMessageManagerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageManagerStatics3] {
    fn RequestSyncManagerAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ChatSyncManager>) -> HRESULT
}}
impl IChatMessageManagerStatics3 {
    #[inline] pub unsafe fn request_sync_manager_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatSyncManager>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestSyncManagerAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageNotificationTriggerDetails, 4248063483, 12387, 19991, 133, 134, 198, 192, 130, 98, 230, 192);
RT_INTERFACE!{interface IChatMessageNotificationTriggerDetails(IChatMessageNotificationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageNotificationTriggerDetails] {
    fn get_ChatMessage(&self, out: *mut *mut ChatMessage) -> HRESULT
}}
impl IChatMessageNotificationTriggerDetails {
    #[inline] pub unsafe fn get_chat_message(&self) -> Result<ComPtr<ChatMessage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChatMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageNotificationTriggerDetails: IChatMessageNotificationTriggerDetails}
DEFINE_IID!(IID_IChatMessageNotificationTriggerDetails2, 1807033056, 43527, 20433, 148, 113, 119, 147, 79, 183, 94, 230);
RT_INTERFACE!{interface IChatMessageNotificationTriggerDetails2(IChatMessageNotificationTriggerDetails2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageNotificationTriggerDetails2] {
    fn get_ShouldDisplayToast(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldUpdateDetailText(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldUpdateBadge(&self, out: *mut bool) -> HRESULT,
    fn get_ShouldUpdateActionCenter(&self, out: *mut bool) -> HRESULT
}}
impl IChatMessageNotificationTriggerDetails2 {
    #[inline] pub unsafe fn get_should_display_toast(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldDisplayToast)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_should_update_detail_text(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldUpdateDetailText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_should_update_badge(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldUpdateBadge)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_should_update_action_center(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShouldUpdateActionCenter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum ChatMessageOperatorKind: i32 {
    Unspecified (ChatMessageOperatorKind_Unspecified) = 0, Sms (ChatMessageOperatorKind_Sms) = 1, Mms (ChatMessageOperatorKind_Mms) = 2, Rcs (ChatMessageOperatorKind_Rcs) = 3,
}}
DEFINE_IID!(IID_IChatMessageReader, 3068819662, 17545, 22265, 118, 170, 226, 4, 104, 37, 20, 207);
RT_INTERFACE!{interface IChatMessageReader(IChatMessageReaderVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessage>>) -> HRESULT
}}
impl IChatMessageReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessage>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageReader: IChatMessageReader}
DEFINE_IID!(IID_IChatMessageReader2, 2305046147, 25787, 18189, 157, 244, 13, 232, 190, 26, 5, 191);
RT_INTERFACE!{interface IChatMessageReader2(IChatMessageReader2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageReader2] {
    fn ReadBatchWithCountAsync(&self, count: i32, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessage>>) -> HRESULT
}}
impl IChatMessageReader2 {
    #[inline] pub unsafe fn read_batch_with_count_async(&self, count: i32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ChatMessage>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchWithCountAsync)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ChatMessageStatus: i32 {
    Draft (ChatMessageStatus_Draft) = 0, Sending (ChatMessageStatus_Sending) = 1, Sent (ChatMessageStatus_Sent) = 2, SendRetryNeeded (ChatMessageStatus_SendRetryNeeded) = 3, SendFailed (ChatMessageStatus_SendFailed) = 4, Received (ChatMessageStatus_Received) = 5, ReceiveDownloadNeeded (ChatMessageStatus_ReceiveDownloadNeeded) = 6, ReceiveDownloadFailed (ChatMessageStatus_ReceiveDownloadFailed) = 7, ReceiveDownloading (ChatMessageStatus_ReceiveDownloading) = 8, Deleted (ChatMessageStatus_Deleted) = 9, Declined (ChatMessageStatus_Declined) = 10, Cancelled (ChatMessageStatus_Cancelled) = 11, Recalled (ChatMessageStatus_Recalled) = 12, ReceiveRetryNeeded (ChatMessageStatus_ReceiveRetryNeeded) = 13,
}}
DEFINE_IID!(IID_IChatMessageStore, 838008065, 52470, 22539, 73, 118, 10, 7, 221, 93, 59, 71);
RT_INTERFACE!{interface IChatMessageStore(IChatMessageStoreVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageStore] {
    fn get_ChangeTracker(&self, out: *mut *mut ChatMessageChangeTracker) -> HRESULT,
    fn DeleteMessageAsync(&self, localMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DownloadMessageAsync(&self, localChatMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetMessageAsync(&self, localChatMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatMessage>) -> HRESULT,
    fn GetMessageReader1(&self, out: *mut *mut ChatMessageReader) -> HRESULT,
    fn GetMessageReader2(&self, recentTimeLimit: super::super::foundation::TimeSpan, out: *mut *mut ChatMessageReader) -> HRESULT,
    fn MarkMessageReadAsync(&self, localChatMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn RetrySendMessageAsync(&self, localChatMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SendMessageAsync(&self, chatMessage: *mut ChatMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ValidateMessage(&self, chatMessage: *mut ChatMessage, out: *mut *mut ChatMessageValidationResult) -> HRESULT,
    fn add_MessageChanged(&self, value: *mut super::super::foundation::TypedEventHandler<ChatMessageStore, ChatMessageChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageChanged(&self, value: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IChatMessageStore {
    #[inline] pub unsafe fn get_change_tracker(&self) -> Result<ComPtr<ChatMessageChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangeTracker)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_message_async(&self, localMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteMessageAsync)(self as *const _ as *mut _, localMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn download_message_async(&self, localChatMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DownloadMessageAsync)(self as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_async(&self, localChatMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageAsync)(self as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader1(&self) -> Result<ComPtr<ChatMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReader1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader2(&self, recentTimeLimit: super::super::foundation::TimeSpan) -> Result<ComPtr<ChatMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReader2)(self as *const _ as *mut _, recentTimeLimit, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_message_read_async(&self, localChatMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkMessageReadAsync)(self as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn retry_send_message_async(&self, localChatMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RetrySendMessageAsync)(self as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn send_message_async(&self, chatMessage: &ChatMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SendMessageAsync)(self as *const _ as *mut _, chatMessage as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn validate_message(&self, chatMessage: &ChatMessage) -> Result<ComPtr<ChatMessageValidationResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ValidateMessage)(self as *const _ as *mut _, chatMessage as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_message_changed(&self, value: &super::super::foundation::TypedEventHandler<ChatMessageStore, ChatMessageChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MessageChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_message_changed(&self, value: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MessageChanged)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageStore: IChatMessageStore}
DEFINE_IID!(IID_IChatMessageStore2, 2907555054, 15060, 18715, 179, 17, 171, 223, 155, 178, 39, 104);
RT_INTERFACE!{interface IChatMessageStore2(IChatMessageStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageStore2] {
    fn ForwardMessageAsync(&self, localChatMessageId: HSTRING, addresses: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<ChatMessage>) -> HRESULT,
    fn GetConversationAsync(&self, conversationId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatConversation>) -> HRESULT,
    fn GetConversationForTransportsAsync(&self, conversationId: HSTRING, transportIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<ChatConversation>) -> HRESULT,
    fn GetConversationFromThreadingInfoAsync(&self, threadingInfo: *mut ChatConversationThreadingInfo, out: *mut *mut super::super::foundation::IAsyncOperation<ChatConversation>) -> HRESULT,
    fn GetConversationReader(&self, out: *mut *mut ChatConversationReader) -> HRESULT,
    fn GetConversationForTransportsReader(&self, transportIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut ChatConversationReader) -> HRESULT,
    fn GetMessageByRemoteIdAsync(&self, transportId: HSTRING, remoteId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatMessage>) -> HRESULT,
    fn GetUnseenCountAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<i32>) -> HRESULT,
    fn GetUnseenCountForTransportsReaderAsync(&self, transportIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<i32>) -> HRESULT,
    fn MarkAsSeenAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkAsSeenForTransportsAsync(&self, transportIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetSearchReader(&self, value: *mut ChatQueryOptions, out: *mut *mut ChatSearchReader) -> HRESULT,
    fn SaveMessageAsync(&self, chatMessage: *mut ChatMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn TryCancelDownloadMessageAsync(&self, localChatMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryCancelSendMessageAsync(&self, localChatMessageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_StoreChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<ChatMessageStore, ChatMessageStoreChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StoreChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IChatMessageStore2 {
    #[inline] pub unsafe fn forward_message_async(&self, localChatMessageId: &HStringArg, addresses: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ForwardMessageAsync)(self as *const _ as *mut _, localChatMessageId.get(), addresses as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_async(&self, conversationId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatConversation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationAsync)(self as *const _ as *mut _, conversationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_for_transports_async(&self, conversationId: &HStringArg, transportIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatConversation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationForTransportsAsync)(self as *const _ as *mut _, conversationId.get(), transportIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_from_threading_info_async(&self, threadingInfo: &ChatConversationThreadingInfo) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatConversation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationFromThreadingInfoAsync)(self as *const _ as *mut _, threadingInfo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader(&self) -> Result<ComPtr<ChatConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_for_transports_reader(&self, transportIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<ChatConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationForTransportsReader)(self as *const _ as *mut _, transportIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_by_remote_id_async(&self, transportId: &HStringArg, remoteId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageByRemoteIdAsync)(self as *const _ as *mut _, transportId.get(), remoteId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unseen_count_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUnseenCountAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unseen_count_for_transports_reader_async(&self, transportIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUnseenCountForTransportsReaderAsync)(self as *const _ as *mut _, transportIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_as_seen_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkAsSeenAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_as_seen_for_transports_async(&self, transportIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkAsSeenForTransportsAsync)(self as *const _ as *mut _, transportIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_reader(&self, value: &ChatQueryOptions) -> Result<ComPtr<ChatSearchReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSearchReader)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_message_async(&self, chatMessage: &ChatMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveMessageAsync)(self as *const _ as *mut _, chatMessage as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_cancel_download_message_async(&self, localChatMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCancelDownloadMessageAsync)(self as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_cancel_send_message_async(&self, localChatMessageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCancelSendMessageAsync)(self as *const _ as *mut _, localChatMessageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_store_changed(&self, handler: &super::super::foundation::TypedEventHandler<ChatMessageStore, ChatMessageStoreChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StoreChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_store_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_StoreChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageStore3, 2598091529, 17221, 20161, 139, 116, 183, 51, 130, 67, 113, 156);
RT_INTERFACE!{interface IChatMessageStore3(IChatMessageStore3Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageStore3] {
    fn GetMessageBySyncIdAsync(&self, syncId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ChatMessage>) -> HRESULT
}}
impl IChatMessageStore3 {
    #[inline] pub unsafe fn get_message_by_sync_id_async(&self, syncId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ChatMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageBySyncIdAsync)(self as *const _ as *mut _, syncId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageStoreChangedEventArgs, 1707503532, 65164, 18132, 145, 25, 87, 184, 65, 3, 17, 213);
RT_INTERFACE!{interface IChatMessageStoreChangedEventArgs(IChatMessageStoreChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageStoreChangedEventArgs] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ChatStoreChangedEventKind) -> HRESULT
}}
impl IChatMessageStoreChangedEventArgs {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<ChatStoreChangedEventKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageStoreChangedEventArgs: IChatMessageStoreChangedEventArgs}
DEFINE_IID!(IID_IChatMessageTransport, 1672076280, 59059, 23706, 95, 133, 212, 121, 37, 185, 189, 24);
RT_INTERFACE!{interface IChatMessageTransport(IChatMessageTransportVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageTransport] {
    fn get_IsAppSetAsNotificationProvider(&self, out: *mut bool) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_TransportFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn RequestSetAsNotificationProviderAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IChatMessageTransport {
    #[inline] pub unsafe fn get_is_app_set_as_notification_provider(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAppSetAsNotificationProvider)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_friendly_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportFriendlyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_set_as_notification_provider_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestSetAsNotificationProviderAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageTransport: IChatMessageTransport}
DEFINE_IID!(IID_IChatMessageTransport2, 2426885666, 55370, 19490, 169, 77, 84, 68, 68, 237, 200, 161);
RT_INTERFACE!{interface IChatMessageTransport2(IChatMessageTransport2Vtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageTransport2] {
    fn get_Configuration(&self, out: *mut *mut ChatMessageTransportConfiguration) -> HRESULT,
    fn get_TransportKind(&self, out: *mut ChatMessageTransportKind) -> HRESULT
}}
impl IChatMessageTransport2 {
    #[inline] pub unsafe fn get_configuration(&self) -> Result<ComPtr<ChatMessageTransportConfiguration>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Configuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_kind(&self) -> Result<ChatMessageTransportKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransportKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IChatMessageTransportConfiguration, 2275407653, 6664, 19146, 160, 117, 51, 85, 18, 99, 18, 230);
RT_INTERFACE!{interface IChatMessageTransportConfiguration(IChatMessageTransportConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageTransportConfiguration] {
    fn get_MaxAttachmentCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxMessageSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_MaxRecipientCount(&self, out: *mut i32) -> HRESULT,
    #[cfg(not(feature="windows-media"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-media")] fn get_SupportedVideoFormat(&self, out: *mut *mut super::super::media::mediaproperties::MediaEncodingProfile) -> HRESULT,
    fn get_ExtendedProperties(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> HRESULT
}}
impl IChatMessageTransportConfiguration {
    #[inline] pub unsafe fn get_max_attachment_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxAttachmentCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_message_size_in_kilobytes(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxMessageSizeInKilobytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_recipient_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxRecipientCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_supported_video_format(&self) -> Result<ComPtr<super::super::media::mediaproperties::MediaEncodingProfile>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedVideoFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extended_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtendedProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageTransportConfiguration: IChatMessageTransportConfiguration}
RT_ENUM! { enum ChatMessageTransportKind: i32 {
    Text (ChatMessageTransportKind_Text) = 0, Untriaged (ChatMessageTransportKind_Untriaged) = 1, Blocked (ChatMessageTransportKind_Blocked) = 2, Custom (ChatMessageTransportKind_Custom) = 3,
}}
DEFINE_IID!(IID_IChatMessageValidationResult, 636041731, 10476, 22665, 86, 155, 126, 72, 107, 18, 111, 24);
RT_INTERFACE!{interface IChatMessageValidationResult(IChatMessageValidationResultVtbl): IInspectable(IInspectableVtbl) [IID_IChatMessageValidationResult] {
    fn get_MaxPartCount(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_PartCount(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_RemainingCharacterCountInPart(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_Status(&self, out: *mut ChatMessageValidationStatus) -> HRESULT
}}
impl IChatMessageValidationResult {
    #[inline] pub unsafe fn get_max_part_count(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxPartCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_part_count(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PartCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remaining_character_count_in_part(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemainingCharacterCountInPart)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<ChatMessageValidationStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ChatMessageValidationResult: IChatMessageValidationResult}
RT_ENUM! { enum ChatMessageValidationStatus: i32 {
    Valid (ChatMessageValidationStatus_Valid) = 0, NoRecipients (ChatMessageValidationStatus_NoRecipients) = 1, InvalidData (ChatMessageValidationStatus_InvalidData) = 2, MessageTooLarge (ChatMessageValidationStatus_MessageTooLarge) = 3, TooManyRecipients (ChatMessageValidationStatus_TooManyRecipients) = 4, TransportInactive (ChatMessageValidationStatus_TransportInactive) = 5, TransportNotFound (ChatMessageValidationStatus_TransportNotFound) = 6, TooManyAttachments (ChatMessageValidationStatus_TooManyAttachments) = 7, InvalidRecipients (ChatMessageValidationStatus_InvalidRecipients) = 8, InvalidBody (ChatMessageValidationStatus_InvalidBody) = 9, InvalidOther (ChatMessageValidationStatus_InvalidOther) = 10, ValidWithLargeMessage (ChatMessageValidationStatus_ValidWithLargeMessage) = 11, VoiceRoamingRestriction (ChatMessageValidationStatus_VoiceRoamingRestriction) = 12, DataRoamingRestriction (ChatMessageValidationStatus_DataRoamingRestriction) = 13,
}}
DEFINE_IID!(IID_IChatQueryOptions, 802383014, 48950, 17143, 183, 231, 146, 60, 10, 171, 254, 22);
RT_INTERFACE!{interface IChatQueryOptions(IChatQueryOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IChatQueryOptions] {
    fn get_SearchString(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SearchString(&self, value: HSTRING) -> HRESULT
}}
impl IChatQueryOptions {
    #[inline] pub unsafe fn get_search_string(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SearchString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_string(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchString)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatQueryOptions: IChatQueryOptions}
impl RtActivatable<IActivationFactory> for ChatQueryOptions {}
DEFINE_CLSID!(ChatQueryOptions: "Windows.ApplicationModel.Chat.ChatQueryOptions");
DEFINE_IID!(IID_IChatRecipientDeliveryInfo, 4291277474, 10300, 19466, 138, 14, 140, 51, 189, 191, 5, 69);
RT_INTERFACE!{interface IChatRecipientDeliveryInfo(IChatRecipientDeliveryInfoVtbl): IInspectable(IInspectableVtbl) [IID_IChatRecipientDeliveryInfo] {
    fn get_TransportAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TransportAddress(&self, value: HSTRING) -> HRESULT,
    fn get_DeliveryTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_DeliveryTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_ReadTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_ReadTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_TransportErrorCodeCategory(&self, out: *mut ChatTransportErrorCodeCategory) -> HRESULT,
    fn get_TransportInterpretedErrorCode(&self, out: *mut ChatTransportInterpretedErrorCode) -> HRESULT,
    fn get_TransportErrorCode(&self, out: *mut i32) -> HRESULT,
    fn get_IsErrorPermanent(&self, out: *mut bool) -> HRESULT,
    fn get_Status(&self, out: *mut ChatMessageStatus) -> HRESULT
}}
impl IChatRecipientDeliveryInfo {
    #[inline] pub unsafe fn get_transport_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transport_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransportAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_delivery_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeliveryTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_delivery_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DeliveryTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_read_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReadTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_read_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ReadTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_error_code_category(&self) -> Result<ChatTransportErrorCodeCategory> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransportErrorCodeCategory)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_interpreted_error_code(&self) -> Result<ChatTransportInterpretedErrorCode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransportInterpretedErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_error_code(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransportErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_error_permanent(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsErrorPermanent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<ChatMessageStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ChatRecipientDeliveryInfo: IChatRecipientDeliveryInfo}
impl RtActivatable<IActivationFactory> for ChatRecipientDeliveryInfo {}
DEFINE_CLSID!(ChatRecipientDeliveryInfo: "Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo");
RT_ENUM! { enum ChatRestoreHistorySpan: i32 {
    LastMonth (ChatRestoreHistorySpan_LastMonth) = 0, LastYear (ChatRestoreHistorySpan_LastYear) = 1, AnyTime (ChatRestoreHistorySpan_AnyTime) = 2,
}}
DEFINE_IID!(IID_IChatSearchReader, 1181089353, 36896, 18258, 152, 13, 57, 97, 35, 37, 245, 137);
RT_INTERFACE!{interface IChatSearchReader(IChatSearchReaderVtbl): IInspectable(IInspectableVtbl) [IID_IChatSearchReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<IChatItem>>) -> HRESULT,
    fn ReadBatchWithCountAsync(&self, count: i32, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<IChatItem>>) -> HRESULT
}}
impl IChatSearchReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<IChatItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn read_batch_with_count_async(&self, count: i32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<IChatItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchWithCountAsync)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatSearchReader: IChatSearchReader}
RT_ENUM! { enum ChatStoreChangedEventKind: i32 {
    NotificationsMissed (ChatStoreChangedEventKind_NotificationsMissed) = 0, StoreModified (ChatStoreChangedEventKind_StoreModified) = 1, MessageCreated (ChatStoreChangedEventKind_MessageCreated) = 2, MessageModified (ChatStoreChangedEventKind_MessageModified) = 3, MessageDeleted (ChatStoreChangedEventKind_MessageDeleted) = 4, ConversationModified (ChatStoreChangedEventKind_ConversationModified) = 5, ConversationDeleted (ChatStoreChangedEventKind_ConversationDeleted) = 6, ConversationTransportDeleted (ChatStoreChangedEventKind_ConversationTransportDeleted) = 7,
}}
DEFINE_IID!(IID_IChatSyncConfiguration, 167274930, 27124, 19199, 130, 182, 6, 153, 47, 244, 2, 210);
RT_INTERFACE!{interface IChatSyncConfiguration(IChatSyncConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IChatSyncConfiguration] {
    fn get_IsSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_RestoreHistorySpan(&self, out: *mut ChatRestoreHistorySpan) -> HRESULT,
    fn put_RestoreHistorySpan(&self, value: ChatRestoreHistorySpan) -> HRESULT
}}
impl IChatSyncConfiguration {
    #[inline] pub unsafe fn get_is_sync_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSyncEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_sync_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSyncEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_restore_history_span(&self) -> Result<ChatRestoreHistorySpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RestoreHistorySpan)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_restore_history_span(&self, value: ChatRestoreHistorySpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RestoreHistorySpan)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ChatSyncConfiguration: IChatSyncConfiguration}
DEFINE_IID!(IID_IChatSyncManager, 2074422371, 9808, 18543, 180, 180, 107, 217, 211, 214, 60, 132);
RT_INTERFACE!{interface IChatSyncManager(IChatSyncManagerVtbl): IInspectable(IInspectableVtbl) [IID_IChatSyncManager] {
    fn get_Configuration(&self, out: *mut *mut ChatSyncConfiguration) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn AssociateAccountAsync(&self, webAccount: *mut super::super::security::credentials::WebAccount, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn UnassociateAccountAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-security")] fn IsAccountAssociated(&self, webAccount: *mut super::super::security::credentials::WebAccount, out: *mut bool) -> HRESULT,
    fn StartSync(&self) -> HRESULT,
    fn SetConfigurationAsync(&self, configuration: *mut ChatSyncConfiguration, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IChatSyncManager {
    #[inline] pub unsafe fn get_configuration(&self) -> Result<ComPtr<ChatSyncConfiguration>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Configuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn associate_account_async(&self, webAccount: &super::super::security::credentials::WebAccount) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AssociateAccountAsync)(self as *const _ as *mut _, webAccount as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn unassociate_account_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UnassociateAccountAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn is_account_associated(&self, webAccount: &super::super::security::credentials::WebAccount) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsAccountAssociated)(self as *const _ as *mut _, webAccount as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_sync(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).StartSync)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_configuration_async(&self, configuration: &ChatSyncConfiguration) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetConfigurationAsync)(self as *const _ as *mut _, configuration as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ChatSyncManager: IChatSyncManager}
RT_ENUM! { enum ChatTransportErrorCodeCategory: i32 {
    None (ChatTransportErrorCodeCategory_None) = 0, Http (ChatTransportErrorCodeCategory_Http) = 1, Network (ChatTransportErrorCodeCategory_Network) = 2, MmsServer (ChatTransportErrorCodeCategory_MmsServer) = 3,
}}
RT_ENUM! { enum ChatTransportInterpretedErrorCode: i32 {
    None (ChatTransportInterpretedErrorCode_None) = 0, Unknown (ChatTransportInterpretedErrorCode_Unknown) = 1, InvalidRecipientAddress (ChatTransportInterpretedErrorCode_InvalidRecipientAddress) = 2, NetworkConnectivity (ChatTransportInterpretedErrorCode_NetworkConnectivity) = 3, ServiceDenied (ChatTransportInterpretedErrorCode_ServiceDenied) = 4, Timeout (ChatTransportInterpretedErrorCode_Timeout) = 5,
}}
DEFINE_IID!(IID_IRcsEndUserMessage, 3620578795, 52183, 20283, 133, 38, 181, 6, 222, 195, 92, 83);
RT_INTERFACE!{interface IRcsEndUserMessage(IRcsEndUserMessageVtbl): IInspectable(IInspectableVtbl) [IID_IRcsEndUserMessage] {
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsPinRequired(&self, out: *mut bool) -> HRESULT,
    fn get_Actions(&self, out: *mut *mut super::super::foundation::collections::IVectorView<RcsEndUserMessageAction>) -> HRESULT,
    fn SendResponseAsync(&self, action: *mut RcsEndUserMessageAction, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SendResponseWithPinAsync(&self, action: *mut RcsEndUserMessageAction, pin: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IRcsEndUserMessage {
    #[inline] pub unsafe fn get_transport_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_pin_required(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsPinRequired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_actions(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<RcsEndUserMessageAction>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Actions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn send_response_async(&self, action: &RcsEndUserMessageAction) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SendResponseAsync)(self as *const _ as *mut _, action as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn send_response_with_pin_async(&self, action: &RcsEndUserMessageAction, pin: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SendResponseWithPinAsync)(self as *const _ as *mut _, action as *const _ as *mut _, pin.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RcsEndUserMessage: IRcsEndUserMessage}
DEFINE_IID!(IID_IRcsEndUserMessageAction, 2453112631, 39746, 18131, 157, 94, 60, 27, 45, 174, 124, 184);
RT_INTERFACE!{interface IRcsEndUserMessageAction(IRcsEndUserMessageActionVtbl): IInspectable(IInspectableVtbl) [IID_IRcsEndUserMessageAction] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT
}}
impl IRcsEndUserMessageAction {
    #[inline] pub unsafe fn get_label(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Label)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RcsEndUserMessageAction: IRcsEndUserMessageAction}
DEFINE_IID!(IID_IRcsEndUserMessageAvailableEventArgs, 759541249, 16265, 16874, 151, 2, 158, 158, 212, 17, 170, 152);
RT_INTERFACE!{interface IRcsEndUserMessageAvailableEventArgs(IRcsEndUserMessageAvailableEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRcsEndUserMessageAvailableEventArgs] {
    fn get_IsMessageAvailable(&self, out: *mut bool) -> HRESULT,
    fn get_Message(&self, out: *mut *mut RcsEndUserMessage) -> HRESULT
}}
impl IRcsEndUserMessageAvailableEventArgs {
    #[inline] pub unsafe fn get_is_message_available(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMessageAvailable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<ComPtr<RcsEndUserMessage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RcsEndUserMessageAvailableEventArgs: IRcsEndUserMessageAvailableEventArgs}
DEFINE_IID!(IID_IRcsEndUserMessageAvailableTriggerDetails, 1536652333, 13599, 18066, 180, 30, 27, 3, 93, 193, 137, 134);
RT_INTERFACE!{interface IRcsEndUserMessageAvailableTriggerDetails(IRcsEndUserMessageAvailableTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IRcsEndUserMessageAvailableTriggerDetails] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IRcsEndUserMessageAvailableTriggerDetails {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class RcsEndUserMessageAvailableTriggerDetails: IRcsEndUserMessageAvailableTriggerDetails}
DEFINE_IID!(IID_IRcsEndUserMessageManager, 810856026, 19743, 19289, 148, 51, 18, 108, 115, 78, 134, 166);
RT_INTERFACE!{interface IRcsEndUserMessageManager(IRcsEndUserMessageManagerVtbl): IInspectable(IInspectableVtbl) [IID_IRcsEndUserMessageManager] {
    fn add_MessageAvailableChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<RcsEndUserMessageManager, RcsEndUserMessageAvailableEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MessageAvailableChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IRcsEndUserMessageManager {
    #[inline] pub unsafe fn add_message_available_changed(&self, handler: &super::super::foundation::TypedEventHandler<RcsEndUserMessageManager, RcsEndUserMessageAvailableEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MessageAvailableChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_message_available_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MessageAvailableChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class RcsEndUserMessageManager: IRcsEndUserMessageManager}
RT_CLASS!{static class RcsManager}
impl RtActivatable<IRcsManagerStatics> for RcsManager {}
impl RcsManager {
    #[inline] pub fn get_end_user_message_manager() -> Result<ComPtr<RcsEndUserMessageManager>> { unsafe {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().get_end_user_message_manager()
    }}
    #[inline] pub fn get_transports_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<RcsTransport>>>> { unsafe {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().get_transports_async()
    }}
    #[inline] pub fn get_transport_async(transportId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<RcsTransport>>> { unsafe {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().get_transport_async(transportId)
    }}
    #[inline] pub fn leave_conversation_async(conversation: &ChatConversation) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IRcsManagerStatics>>::get_activation_factory().leave_conversation_async(conversation)
    }}
}
DEFINE_CLSID!(RcsManager: "Windows.ApplicationModel.Chat.RcsManager");
DEFINE_IID!(IID_IRcsManagerStatics, 2099710661, 2749, 20273, 155, 153, 165, 158, 113, 167, 183, 49);
RT_INTERFACE!{static interface IRcsManagerStatics(IRcsManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IRcsManagerStatics] {
    fn GetEndUserMessageManager(&self, out: *mut *mut RcsEndUserMessageManager) -> HRESULT,
    fn GetTransportsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<RcsTransport>>) -> HRESULT,
    fn GetTransportAsync(&self, transportId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<RcsTransport>) -> HRESULT,
    fn LeaveConversationAsync(&self, conversation: *mut ChatConversation, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IRcsManagerStatics {
    #[inline] pub unsafe fn get_end_user_message_manager(&self) -> Result<ComPtr<RcsEndUserMessageManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEndUserMessageManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transports_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<RcsTransport>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTransportsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_async(&self, transportId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<RcsTransport>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTransportAsync)(self as *const _ as *mut _, transportId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn leave_conversation_async(&self, conversation: &ChatConversation) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LeaveConversationAsync)(self as *const _ as *mut _, conversation as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum RcsServiceKind: i32 {
    Chat (RcsServiceKind_Chat) = 0, GroupChat (RcsServiceKind_GroupChat) = 1, FileTransfer (RcsServiceKind_FileTransfer) = 2, Capability (RcsServiceKind_Capability) = 3,
}}
DEFINE_IID!(IID_IRcsServiceKindSupportedChangedEventArgs, 4101939780, 59267, 18534, 179, 167, 78, 92, 207, 2, 48, 112);
RT_INTERFACE!{interface IRcsServiceKindSupportedChangedEventArgs(IRcsServiceKindSupportedChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRcsServiceKindSupportedChangedEventArgs] {
    fn get_ServiceKind(&self, out: *mut RcsServiceKind) -> HRESULT
}}
impl IRcsServiceKindSupportedChangedEventArgs {
    #[inline] pub unsafe fn get_service_kind(&self) -> Result<RcsServiceKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ServiceKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RcsServiceKindSupportedChangedEventArgs: IRcsServiceKindSupportedChangedEventArgs}
DEFINE_IID!(IID_IRcsTransport, 4272113497, 62332, 17177, 133, 70, 236, 132, 210, 29, 48, 255);
RT_INTERFACE!{interface IRcsTransport(IRcsTransportVtbl): IInspectable(IInspectableVtbl) [IID_IRcsTransport] {
    fn get_ExtendedProperties(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, IInspectable>) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_TransportFriendlyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Configuration(&self, out: *mut *mut RcsTransportConfiguration) -> HRESULT,
    fn IsStoreAndForwardEnabled(&self, serviceKind: RcsServiceKind, out: *mut bool) -> HRESULT,
    fn IsServiceKindSupported(&self, serviceKind: RcsServiceKind, out: *mut bool) -> HRESULT,
    fn add_ServiceKindSupportedChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<RcsTransport, RcsServiceKindSupportedChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServiceKindSupportedChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IRcsTransport {
    #[inline] pub unsafe fn get_extended_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtendedProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_friendly_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportFriendlyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transport_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_configuration(&self) -> Result<ComPtr<RcsTransportConfiguration>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Configuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_store_and_forward_enabled(&self, serviceKind: RcsServiceKind) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsStoreAndForwardEnabled)(self as *const _ as *mut _, serviceKind, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_service_kind_supported(&self, serviceKind: RcsServiceKind) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsServiceKindSupported)(self as *const _ as *mut _, serviceKind, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_service_kind_supported_changed(&self, handler: &super::super::foundation::TypedEventHandler<RcsTransport, RcsServiceKindSupportedChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ServiceKindSupportedChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_service_kind_supported_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ServiceKindSupportedChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class RcsTransport: IRcsTransport}
DEFINE_IID!(IID_IRcsTransportConfiguration, 533508354, 9330, 19385, 153, 136, 193, 33, 28, 131, 232, 169);
RT_INTERFACE!{interface IRcsTransportConfiguration(IRcsTransportConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IRcsTransportConfiguration] {
    fn get_MaxAttachmentCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxMessageSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_MaxGroupMessageSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_MaxRecipientCount(&self, out: *mut i32) -> HRESULT,
    fn get_MaxFileSizeInKilobytes(&self, out: *mut i32) -> HRESULT,
    fn get_WarningFileSizeInKilobytes(&self, out: *mut i32) -> HRESULT
}}
impl IRcsTransportConfiguration {
    #[inline] pub unsafe fn get_max_attachment_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxAttachmentCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_message_size_in_kilobytes(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxMessageSizeInKilobytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_group_message_size_in_kilobytes(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxGroupMessageSizeInKilobytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_recipient_count(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxRecipientCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_file_size_in_kilobytes(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxFileSizeInKilobytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_warning_file_size_in_kilobytes(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WarningFileSizeInKilobytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RcsTransportConfiguration: IRcsTransportConfiguration}
DEFINE_IID!(IID_IRemoteParticipantComposingChangedEventArgs, 515917223, 53193, 17865, 152, 118, 68, 159, 43, 193, 128, 245);
RT_INTERFACE!{interface IRemoteParticipantComposingChangedEventArgs(IRemoteParticipantComposingChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IRemoteParticipantComposingChangedEventArgs] {
    fn get_TransportId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParticipantAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsComposing(&self, out: *mut bool) -> HRESULT
}}
impl IRemoteParticipantComposingChangedEventArgs {
    #[inline] pub unsafe fn get_transport_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransportId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_participant_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ParticipantAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_composing(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsComposing)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class RemoteParticipantComposingChangedEventArgs: IRemoteParticipantComposingChangedEventArgs}
} // Windows.ApplicationModel.Chat
pub mod contacts { // Windows.ApplicationModel.Contacts
use ::prelude::*;
DEFINE_IID!(IID_IAggregateContactManager, 58316253, 56154, 20435, 181, 78, 77, 241, 121, 23, 162, 18);
RT_INTERFACE!{interface IAggregateContactManager(IAggregateContactManagerVtbl): IInspectable(IInspectableVtbl) [IID_IAggregateContactManager] {
    fn FindRawContactsAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Contact>>) -> HRESULT,
    fn TryLinkContactsAsync(&self, primaryContact: *mut Contact, secondaryContact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn UnlinkRawContactAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn TrySetPreferredSourceForPictureAsync(&self, aggregateContact: *mut Contact, rawContact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IAggregateContactManager {
    #[inline] pub unsafe fn find_raw_contacts_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Contact>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindRawContactsAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_link_contacts_async(&self, primaryContact: &Contact, secondaryContact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryLinkContactsAsync)(self as *const _ as *mut _, primaryContact as *const _ as *mut _, secondaryContact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn unlink_raw_contact_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UnlinkRawContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_set_preferred_source_for_picture_async(&self, aggregateContact: &Contact, rawContact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetPreferredSourceForPictureAsync)(self as *const _ as *mut _, aggregateContact as *const _ as *mut _, rawContact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AggregateContactManager: IAggregateContactManager}
DEFINE_IID!(IID_IAggregateContactManager2, 1586283224, 43469, 17456, 156, 75, 1, 52, 141, 178, 202, 80);
RT_INTERFACE!{interface IAggregateContactManager2(IAggregateContactManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IAggregateContactManager2] {
    fn SetRemoteIdentificationInformationAsync(&self, contactListId: HSTRING, remoteSourceId: HSTRING, accountId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IAggregateContactManager2 {
    #[inline] pub unsafe fn set_remote_identification_information_async(&self, contactListId: &HStringArg, remoteSourceId: &HStringArg, accountId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetRemoteIdentificationInformationAsync)(self as *const _ as *mut _, contactListId.get(), remoteSourceId.get(), accountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContact, 3959452403, 8472, 16457, 158, 188, 23, 240, 171, 105, 43, 100);
RT_INTERFACE!{interface IContact(IContactVtbl): IInspectable(IInspectableVtbl) [IID_IContact] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_Fields(&self, out: *mut *mut super::super::foundation::collections::IVector<IContactField>) -> HRESULT
}}
impl IContact {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Thumbnail)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fields(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<IContactField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Fields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class Contact: IContact}
impl RtActivatable<IActivationFactory> for Contact {}
DEFINE_CLSID!(Contact: "Windows.ApplicationModel.Contacts.Contact");
DEFINE_IID!(IID_IContact2, 4078105445, 47991, 19604, 128, 45, 131, 40, 206, 228, 12, 8);
RT_INTERFACE!{interface IContact2(IContact2Vtbl): IInspectable(IInspectableVtbl) [IID_IContact2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Notes(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Notes(&self, value: HSTRING) -> HRESULT,
    fn get_Phones(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactPhone>) -> HRESULT,
    fn get_Emails(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactEmail>) -> HRESULT,
    fn get_Addresses(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactAddress>) -> HRESULT,
    fn get_ConnectedServiceAccounts(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactConnectedServiceAccount>) -> HRESULT,
    fn get_ImportantDates(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactDate>) -> HRESULT,
    fn get_DataSuppliers(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_JobInfo(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactJobInfo>) -> HRESULT,
    fn get_SignificantOthers(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactSignificantOther>) -> HRESULT,
    fn get_Websites(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactWebsite>) -> HRESULT,
    fn get_ProviderProperties(&self, out: *mut *mut super::super::foundation::collections::IPropertySet) -> HRESULT
}}
impl IContact2 {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_notes(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Notes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_notes(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Notes)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phones(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactPhone>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Phones)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_emails(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactEmail>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Emails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_addresses(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactAddress>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Addresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_connected_service_accounts(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactConnectedServiceAccount>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConnectedServiceAccounts)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_important_dates(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactDate>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImportantDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_suppliers(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DataSuppliers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_job_info(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactJobInfo>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_JobInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_significant_others(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactSignificantOther>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SignificantOthers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_websites(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactWebsite>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Websites)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_provider_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IPropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProviderProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContact3, 1210064487, 57486, 17060, 181, 97, 65, 208, 140, 169, 87, 93);
RT_INTERFACE!{interface IContact3(IContact3Vtbl): IInspectable(IInspectableVtbl) [IID_IContact3] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayPictureUserUpdateTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_DisplayPictureUserUpdateTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_IsMe(&self, out: *mut bool) -> HRESULT,
    fn get_AggregateId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_RingToneToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RingToneToken(&self, value: HSTRING) -> HRESULT,
    fn get_IsDisplayPictureManuallySet(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy10(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_LargeDisplayPicture(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy11(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SmallDisplayPicture(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy12(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SourceDisplayPicture(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy13(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SourceDisplayPicture(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_TextToneToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextToneToken(&self, value: HSTRING) -> HRESULT,
    fn get_IsAggregate(&self, out: *mut bool) -> HRESULT,
    fn get_FullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayNameOverride(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayNameOverride(&self, value: HSTRING) -> HRESULT,
    fn get_Nickname(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Nickname(&self, value: HSTRING) -> HRESULT,
    fn get_SortName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContact3 {
    #[inline] pub unsafe fn get_contact_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_picture_user_update_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DisplayPictureUserUpdateTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_picture_user_update_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayPictureUserUpdateTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_me(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMe)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aggregate_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AggregateId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ring_tone_token(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RingToneToken)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_ring_tone_token(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RingToneToken)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_display_picture_manually_set(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDisplayPictureManuallySet)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_large_display_picture(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LargeDisplayPicture)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_small_display_picture(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SmallDisplayPicture)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_source_display_picture(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceDisplayPicture)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_source_display_picture(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SourceDisplayPicture)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_tone_token(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextToneToken)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_tone_token(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextToneToken)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_aggregate(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAggregate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_full_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FullName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name_override(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayNameOverride)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name_override(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayNameOverride)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_nickname(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Nickname)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_nickname(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Nickname)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sort_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SortName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactAddress, 2537149338, 17102, 18546, 141, 112, 48, 99, 170, 88, 75, 112);
RT_INTERFACE!{interface IContactAddress(IContactAddressVtbl): IInspectable(IInspectableVtbl) [IID_IContactAddress] {
    fn get_StreetAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_StreetAddress(&self, value: HSTRING) -> HRESULT,
    fn get_Locality(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Locality(&self, value: HSTRING) -> HRESULT,
    fn get_Region(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Region(&self, value: HSTRING) -> HRESULT,
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Country(&self, value: HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PostalCode(&self, value: HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactAddressKind) -> HRESULT,
    fn put_Kind(&self, value: ContactAddressKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactAddress {
    #[inline] pub unsafe fn get_street_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StreetAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_street_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StreetAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_locality(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Locality)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_locality(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Locality)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_region(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Region)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_region(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Region)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_country(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Country)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_country(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Country)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_postal_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PostalCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_postal_code(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PostalCode)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<ContactAddressKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: ContactAddressKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactAddress: IContactAddress}
impl RtActivatable<IActivationFactory> for ContactAddress {}
DEFINE_CLSID!(ContactAddress: "Windows.ApplicationModel.Contacts.ContactAddress");
RT_ENUM! { enum ContactAddressKind: i32 {
    Home (ContactAddressKind_Home) = 0, Work (ContactAddressKind_Work) = 1, Other (ContactAddressKind_Other) = 2,
}}
DEFINE_IID!(IID_IContactAnnotation, 2183119599, 32065, 17570, 132, 195, 96, 162, 129, 221, 123, 134);
RT_INTERFACE!{interface IContactAnnotation(IContactAnnotationVtbl): IInspectable(IInspectableVtbl) [IID_IContactAnnotation] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AnnotationListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactId(&self, value: HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_SupportedOperations(&self, out: *mut ContactAnnotationOperations) -> HRESULT,
    fn put_SupportedOperations(&self, value: ContactAnnotationOperations) -> HRESULT,
    fn get_IsDisabled(&self, out: *mut bool) -> HRESULT,
    fn get_ProviderProperties(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT
}}
impl IContactAnnotation {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contact_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContactId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_operations(&self) -> Result<ContactAnnotationOperations> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SupportedOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_supported_operations(&self, value: ContactAnnotationOperations) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SupportedOperations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_disabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDisabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_provider_properties(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProviderProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactAnnotation: IContactAnnotation}
impl RtActivatable<IActivationFactory> for ContactAnnotation {}
DEFINE_CLSID!(ContactAnnotation: "Windows.ApplicationModel.Contacts.ContactAnnotation");
DEFINE_IID!(IID_IContactAnnotation2, 3063016691, 19127, 18975, 153, 65, 12, 156, 243, 23, 27, 117);
RT_INTERFACE!{interface IContactAnnotation2(IContactAnnotation2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactAnnotation2] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContactListId(&self, value: HSTRING) -> HRESULT
}}
impl IContactAnnotation2 {
    #[inline] pub unsafe fn get_contact_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contact_list_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContactListId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactAnnotationList, 2460255914, 23688, 17849, 170, 208, 70, 24, 136, 230, 141, 138);
RT_INTERFACE!{interface IContactAnnotationList(IContactAnnotationListVtbl): IInspectable(IInspectableVtbl) [IID_IContactAnnotationList] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProviderPackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn TrySaveAnnotationAsync(&self, annotation: *mut ContactAnnotation, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn GetAnnotationAsync(&self, annotationId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ContactAnnotation>) -> HRESULT,
    fn FindAnnotationsByRemoteIdAsync(&self, remoteId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>) -> HRESULT,
    fn FindAnnotationsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>) -> HRESULT,
    fn DeleteAnnotationAsync(&self, annotation: *mut ContactAnnotation, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IContactAnnotationList {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_provider_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProviderPackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_save_annotation_async(&self, annotation: &ContactAnnotation) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySaveAnnotationAsync)(self as *const _ as *mut _, annotation as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_async(&self, annotationId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotationAsync)(self as *const _ as *mut _, annotationId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_annotations_by_remote_id_async(&self, remoteId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAnnotationsByRemoteIdAsync)(self as *const _ as *mut _, remoteId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_annotations_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAnnotationsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_annotation_async(&self, annotation: &ContactAnnotation) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAnnotationAsync)(self as *const _ as *mut _, annotation as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactAnnotationList: IContactAnnotationList}
RT_ENUM! { enum ContactAnnotationOperations: u32 {
    None (ContactAnnotationOperations_None) = 0, ContactProfile (ContactAnnotationOperations_ContactProfile) = 1, Message (ContactAnnotationOperations_Message) = 2, AudioCall (ContactAnnotationOperations_AudioCall) = 4, VideoCall (ContactAnnotationOperations_VideoCall) = 8, SocialFeeds (ContactAnnotationOperations_SocialFeeds) = 16, Share (ContactAnnotationOperations_Share) = 32,
}}
DEFINE_IID!(IID_IContactAnnotationStore, 598537386, 31351, 17789, 130, 3, 152, 127, 75, 49, 175, 9);
RT_INTERFACE!{interface IContactAnnotationStore(IContactAnnotationStoreVtbl): IInspectable(IInspectableVtbl) [IID_IContactAnnotationStore] {
    fn FindContactIdsByEmailAsync(&self, emailAddress: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>) -> HRESULT,
    fn FindContactIdsByPhoneNumberAsync(&self, phoneNumber: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>) -> HRESULT,
    fn FindAnnotationsForContactAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>) -> HRESULT,
    fn DisableAnnotationAsync(&self, annotation: *mut ContactAnnotation, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn CreateAnnotationListAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ContactAnnotationList>) -> HRESULT,
    fn CreateAnnotationListInAccountAsync(&self, userDataAccountId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ContactAnnotationList>) -> HRESULT,
    fn GetAnnotationListAsync(&self, annotationListId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ContactAnnotationList>) -> HRESULT,
    fn FindAnnotationListsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotationList>>) -> HRESULT
}}
impl IContactAnnotationStore {
    #[inline] pub unsafe fn find_contact_ids_by_email_async(&self, emailAddress: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactIdsByEmailAsync)(self as *const _ as *mut _, emailAddress.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_contact_ids_by_phone_number_async(&self, phoneNumber: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactIdsByPhoneNumberAsync)(self as *const _ as *mut _, phoneNumber.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_annotations_for_contact_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAnnotationsForContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn disable_annotation_async(&self, annotation: &ContactAnnotation) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DisableAnnotationAsync)(self as *const _ as *mut _, annotation as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_annotation_list_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotationList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAnnotationListAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_annotation_list_in_account_async(&self, userDataAccountId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotationList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAnnotationListInAccountAsync)(self as *const _ as *mut _, userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_list_async(&self, annotationListId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotationList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAnnotationListAsync)(self as *const _ as *mut _, annotationListId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_annotation_lists_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotationList>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAnnotationListsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactAnnotationStore: IContactAnnotationStore}
DEFINE_IID!(IID_IContactAnnotationStore2, 2128487421, 25063, 18791, 142, 197, 189, 242, 128, 162, 64, 99);
RT_INTERFACE!{interface IContactAnnotationStore2(IContactAnnotationStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactAnnotationStore2] {
    fn FindAnnotationsForContactListAsync(&self, contactListId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>) -> HRESULT
}}
impl IContactAnnotationStore2 {
    #[inline] pub unsafe fn find_annotations_for_contact_list_async(&self, contactListId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactAnnotation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAnnotationsForContactListAsync)(self as *const _ as *mut _, contactListId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactAnnotationStoreAccessType: i32 {
    AppAnnotationsReadWrite (ContactAnnotationStoreAccessType_AppAnnotationsReadWrite) = 0, AllAnnotationsReadWrite (ContactAnnotationStoreAccessType_AllAnnotationsReadWrite) = 1,
}}
DEFINE_IID!(IID_IContactBatch, 902928173, 49102, 18107, 147, 248, 165, 176, 110, 197, 226, 1);
RT_INTERFACE!{interface IContactBatch(IContactBatchVtbl): IInspectable(IInspectableVtbl) [IID_IContactBatch] {
    fn get_Contacts(&self, out: *mut *mut super::super::foundation::collections::IVectorView<Contact>) -> HRESULT,
    fn get_Status(&self, out: *mut ContactBatchStatus) -> HRESULT
}}
impl IContactBatch {
    #[inline] pub unsafe fn get_contacts(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contacts)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<ContactBatchStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ContactBatch: IContactBatch}
RT_ENUM! { enum ContactBatchStatus: i32 {
    Success (ContactBatchStatus_Success) = 0, ServerSearchSyncManagerError (ContactBatchStatus_ServerSearchSyncManagerError) = 1, ServerSearchUnknownError (ContactBatchStatus_ServerSearchUnknownError) = 2,
}}
DEFINE_IID!(IID_IContactCardDelayedDataLoader, 3054172418, 5446, 17229, 134, 156, 110, 53, 32, 118, 14, 243);
RT_INTERFACE!{interface IContactCardDelayedDataLoader(IContactCardDelayedDataLoaderVtbl): IInspectable(IInspectableVtbl) [IID_IContactCardDelayedDataLoader] {
    fn SetData(&self, contact: *mut Contact) -> HRESULT
}}
impl IContactCardDelayedDataLoader {
    #[inline] pub unsafe fn set_data(&self, contact: &Contact) -> Result<()> {
        let hr = ((*self.lpVtbl).SetData)(self as *const _ as *mut _, contact as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactCardDelayedDataLoader: IContactCardDelayedDataLoader}
RT_ENUM! { enum ContactCardHeaderKind: i32 {
    Default (ContactCardHeaderKind_Default) = 0, Basic (ContactCardHeaderKind_Basic) = 1, Enterprise (ContactCardHeaderKind_Enterprise) = 2,
}}
DEFINE_IID!(IID_IContactCardOptions, 2349485950, 27318, 20287, 190, 114, 129, 114, 54, 238, 234, 91);
RT_INTERFACE!{interface IContactCardOptions(IContactCardOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IContactCardOptions] {
    fn get_HeaderKind(&self, out: *mut ContactCardHeaderKind) -> HRESULT,
    fn put_HeaderKind(&self, value: ContactCardHeaderKind) -> HRESULT,
    fn get_InitialTabKind(&self, out: *mut ContactCardTabKind) -> HRESULT,
    fn put_InitialTabKind(&self, value: ContactCardTabKind) -> HRESULT
}}
impl IContactCardOptions {
    #[inline] pub unsafe fn get_header_kind(&self) -> Result<ContactCardHeaderKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HeaderKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_header_kind(&self, value: ContactCardHeaderKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_initial_tab_kind(&self) -> Result<ContactCardTabKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InitialTabKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_initial_tab_kind(&self, value: ContactCardTabKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_InitialTabKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactCardOptions: IContactCardOptions}
impl RtActivatable<IActivationFactory> for ContactCardOptions {}
DEFINE_CLSID!(ContactCardOptions: "Windows.ApplicationModel.Contacts.ContactCardOptions");
DEFINE_IID!(IID_IContactCardOptions2, 2401704864, 55115, 19654, 159, 83, 27, 14, 181, 209, 39, 60);
RT_INTERFACE!{interface IContactCardOptions2(IContactCardOptions2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactCardOptions2] {
    fn get_ServerSearchContactListIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IContactCardOptions2 {
    #[inline] pub unsafe fn get_server_search_contact_list_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServerSearchContactListIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactCardTabKind: i32 {
    Default (ContactCardTabKind_Default) = 0, Email (ContactCardTabKind_Email) = 1, Messaging (ContactCardTabKind_Messaging) = 2, Phone (ContactCardTabKind_Phone) = 3, Video (ContactCardTabKind_Video) = 4, OrganizationalHierarchy (ContactCardTabKind_OrganizationalHierarchy) = 5,
}}
DEFINE_IID!(IID_IContactChange, 2501724944, 27225, 18208, 164, 225, 54, 61, 152, 193, 53, 213);
RT_INTERFACE!{interface IContactChange(IContactChangeVtbl): IInspectable(IInspectableVtbl) [IID_IContactChange] {
    fn get_ChangeType(&self, out: *mut ContactChangeType) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut Contact) -> HRESULT
}}
impl IContactChange {
    #[inline] pub unsafe fn get_change_type(&self) -> Result<ContactChangeType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactChange: IContactChange}
DEFINE_IID!(IID_IContactChangedDeferral, 3306437352, 6915, 18168, 182, 148, 165, 35, 232, 60, 252, 182);
RT_INTERFACE!{interface IContactChangedDeferral(IContactChangedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IContactChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IContactChangedDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactChangedDeferral: IContactChangedDeferral}
DEFINE_IID!(IID_IContactChangedEventArgs, 1381924817, 29683, 19325, 169, 24, 88, 11, 228, 54, 97, 33);
RT_INTERFACE!{interface IContactChangedEventArgs(IContactChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactChangedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut ContactChangedDeferral) -> HRESULT
}}
impl IContactChangedEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<ContactChangedDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactChangedEventArgs: IContactChangedEventArgs}
DEFINE_IID!(IID_IContactChangeReader, 561191418, 11532, 17120, 169, 218, 62, 205, 86, 167, 138, 71);
RT_INTERFACE!{interface IContactChangeReader(IContactChangeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IContactChangeReader] {
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAccept: *mut ContactChange) -> HRESULT,
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactChange>>) -> HRESULT
}}
impl IContactChangeReader {
    #[inline] pub unsafe fn accept_changes(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChanges)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn accept_changes_through(&self, lastChangeToAccept: &ContactChange) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChangesThrough)(self as *const _ as *mut _, lastChangeToAccept as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactChange>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactChangeReader: IContactChangeReader}
DEFINE_IID!(IID_IContactChangeTracker, 1855531346, 12443, 16461, 151, 18, 179, 123, 211, 2, 120, 170);
RT_INTERFACE!{interface IContactChangeTracker(IContactChangeTrackerVtbl): IInspectable(IInspectableVtbl) [IID_IContactChangeTracker] {
    fn Enable(&self) -> HRESULT,
    fn GetChangeReader(&self, out: *mut *mut ContactChangeReader) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IContactChangeTracker {
    #[inline] pub unsafe fn enable(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Enable)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_reader(&self) -> Result<ComPtr<ContactChangeReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Reset)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactChangeTracker: IContactChangeTracker}
DEFINE_IID!(IID_IContactChangeTracker2, 2139803900, 37665, 19736, 156, 9, 215, 8, 198, 63, 205, 49);
RT_INTERFACE!{interface IContactChangeTracker2(IContactChangeTracker2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactChangeTracker2] {
    fn get_IsTracking(&self, out: *mut bool) -> HRESULT
}}
impl IContactChangeTracker2 {
    #[inline] pub unsafe fn get_is_tracking(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTracking)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactChangeType: i32 {
    Created (ContactChangeType_Created) = 0, Modified (ContactChangeType_Modified) = 1, Deleted (ContactChangeType_Deleted) = 2, ChangeTrackingLost (ContactChangeType_ChangeTrackingLost) = 3,
}}
DEFINE_IID!(IID_IContactConnectedServiceAccount, 4143461715, 43559, 18225, 142, 74, 61, 236, 92, 233, 238, 201);
RT_INTERFACE!{interface IContactConnectedServiceAccount(IContactConnectedServiceAccountVtbl): IInspectable(IInspectableVtbl) [IID_IContactConnectedServiceAccount] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_ServiceName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ServiceName(&self, value: HSTRING) -> HRESULT
}}
impl IContactConnectedServiceAccount {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_service_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ServiceName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_service_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ServiceName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactConnectedServiceAccount: IContactConnectedServiceAccount}
impl RtActivatable<IActivationFactory> for ContactConnectedServiceAccount {}
DEFINE_CLSID!(ContactConnectedServiceAccount: "Windows.ApplicationModel.Contacts.ContactConnectedServiceAccount");
DEFINE_IID!(IID_IContactDate, 4271418982, 45573, 18740, 145, 116, 15, 242, 176, 86, 87, 7);
RT_INTERFACE!{interface IContactDate(IContactDateVtbl): IInspectable(IInspectableVtbl) [IID_IContactDate] {
    fn get_Day(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn put_Day(&self, value: *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_Month(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn put_Month(&self, value: *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_Year(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_Year(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactDateKind) -> HRESULT,
    fn put_Kind(&self, value: ContactDateKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactDate {
    #[inline] pub unsafe fn get_day(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Day)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day(&self, value: &super::super::foundation::IReference<u32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Day)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Month)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month(&self, value: &super::super::foundation::IReference<u32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Month)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_year(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Year)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_year(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Year)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<ContactDateKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: ContactDateKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactDate: IContactDate}
impl RtActivatable<IActivationFactory> for ContactDate {}
DEFINE_CLSID!(ContactDate: "Windows.ApplicationModel.Contacts.ContactDate");
RT_ENUM! { enum ContactDateKind: i32 {
    Birthday (ContactDateKind_Birthday) = 0, Anniversary (ContactDateKind_Anniversary) = 1, Other (ContactDateKind_Other) = 2,
}}
DEFINE_IID!(IID_IContactEmail, 2426542505, 58323, 19811, 153, 59, 5, 185, 165, 57, 58, 191);
RT_INTERFACE!{interface IContactEmail(IContactEmailVtbl): IInspectable(IInspectableVtbl) [IID_IContactEmail] {
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Address(&self, value: HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactEmailKind) -> HRESULT,
    fn put_Kind(&self, value: ContactEmailKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactEmail {
    #[inline] pub unsafe fn get_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Address)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Address)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<ContactEmailKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: ContactEmailKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactEmail: IContactEmail}
impl RtActivatable<IActivationFactory> for ContactEmail {}
DEFINE_CLSID!(ContactEmail: "Windows.ApplicationModel.Contacts.ContactEmail");
RT_ENUM! { enum ContactEmailKind: i32 {
    Personal (ContactEmailKind_Personal) = 0, Work (ContactEmailKind_Work) = 1, Other (ContactEmailKind_Other) = 2,
}}
DEFINE_IID!(IID_IContactField, 2977319018, 53907, 18732, 160, 88, 219, 87, 91, 62, 60, 15);
RT_INTERFACE!{interface IContactField(IContactFieldVtbl): IInspectable(IInspectableVtbl) [IID_IContactField] {
    fn get_Type(&self, out: *mut ContactFieldType) -> HRESULT,
    fn get_Category(&self, out: *mut ContactFieldCategory) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactField {
    #[inline] pub unsafe fn get_type(&self) -> Result<ContactFieldType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_category(&self) -> Result<ContactFieldCategory> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Category)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactField: IContactField}
impl RtActivatable<IContactFieldFactory> for ContactField {}
impl ContactField {
    #[inline] pub fn create_field_default(value: &HStringArg, type_: ContactFieldType) -> Result<ComPtr<ContactField>> { unsafe {
        <Self as RtActivatable<IContactFieldFactory>>::get_activation_factory().create_field_default(value, type_)
    }}
    #[inline] pub fn create_field_category(value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ComPtr<ContactField>> { unsafe {
        <Self as RtActivatable<IContactFieldFactory>>::get_activation_factory().create_field_category(value, type_, category)
    }}
    #[inline] pub fn create_field_custom(name: &HStringArg, value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ComPtr<ContactField>> { unsafe {
        <Self as RtActivatable<IContactFieldFactory>>::get_activation_factory().create_field_custom(name, value, type_, category)
    }}
}
DEFINE_CLSID!(ContactField: "Windows.ApplicationModel.Contacts.ContactField");
RT_ENUM! { enum ContactFieldCategory: i32 {
    None (ContactFieldCategory_None) = 0, Home (ContactFieldCategory_Home) = 1, Work (ContactFieldCategory_Work) = 2, Mobile (ContactFieldCategory_Mobile) = 3, Other (ContactFieldCategory_Other) = 4,
}}
DEFINE_IID!(IID_IContactFieldFactory, 2246218047, 3658, 19006, 137, 148, 64, 106, 231, 237, 100, 110);
RT_INTERFACE!{static interface IContactFieldFactory(IContactFieldFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContactFieldFactory] {
    fn CreateField_Default(&self, value: HSTRING, type_: ContactFieldType, out: *mut *mut ContactField) -> HRESULT,
    fn CreateField_Category(&self, value: HSTRING, type_: ContactFieldType, category: ContactFieldCategory, out: *mut *mut ContactField) -> HRESULT,
    fn CreateField_Custom(&self, name: HSTRING, value: HSTRING, type_: ContactFieldType, category: ContactFieldCategory, out: *mut *mut ContactField) -> HRESULT
}}
impl IContactFieldFactory {
    #[inline] pub unsafe fn create_field_default(&self, value: &HStringArg, type_: ContactFieldType) -> Result<ComPtr<ContactField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateField_Default)(self as *const _ as *mut _, value.get(), type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_field_category(&self, value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ComPtr<ContactField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateField_Category)(self as *const _ as *mut _, value.get(), type_, category, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_field_custom(&self, name: &HStringArg, value: &HStringArg, type_: ContactFieldType, category: ContactFieldCategory) -> Result<ComPtr<ContactField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateField_Custom)(self as *const _ as *mut _, name.get(), value.get(), type_, category, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactFieldFactory: IContactFieldFactory}
impl RtActivatable<IActivationFactory> for ContactFieldFactory {}
DEFINE_CLSID!(ContactFieldFactory: "Windows.ApplicationModel.Contacts.ContactFieldFactory");
RT_ENUM! { enum ContactFieldType: i32 {
    Email (ContactFieldType_Email) = 0, PhoneNumber (ContactFieldType_PhoneNumber) = 1, Location (ContactFieldType_Location) = 2, InstantMessage (ContactFieldType_InstantMessage) = 3, Custom (ContactFieldType_Custom) = 4, ConnectedServiceAccount (ContactFieldType_ConnectedServiceAccount) = 5, ImportantDate (ContactFieldType_ImportantDate) = 6, Address (ContactFieldType_Address) = 7, SignificantOther (ContactFieldType_SignificantOther) = 8, Notes (ContactFieldType_Notes) = 9, Website (ContactFieldType_Website) = 10, JobInfo (ContactFieldType_JobInfo) = 11,
}}
DEFINE_IID!(IID_IContactGroup, 1505618689, 40602, 18269, 191, 229, 163, 123, 128, 109, 133, 44);
RT_INTERFACE!{interface IContactGroup(IContactGroupVtbl): IInspectable(IInspectableVtbl) [IID_IContactGroup] {
    
}}
RT_CLASS!{class ContactGroup: IContactGroup}
DEFINE_IID!(IID_IContactInformation, 660518612, 27182, 17016, 169, 20, 228, 96, 213, 240, 136, 246);
RT_INTERFACE!{interface IContactInformation(IContactInformationVtbl): IInspectable(IInspectableVtbl) [IID_IContactInformation] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetThumbnailAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>) -> HRESULT,
    fn get_Emails(&self, out: *mut *mut super::super::foundation::collections::IVectorView<ContactField>) -> HRESULT,
    fn get_PhoneNumbers(&self, out: *mut *mut super::super::foundation::collections::IVectorView<ContactField>) -> HRESULT,
    fn get_Locations(&self, out: *mut *mut super::super::foundation::collections::IVectorView<ContactLocationField>) -> HRESULT,
    fn get_InstantMessages(&self, out: *mut *mut super::super::foundation::collections::IVectorView<ContactInstantMessageField>) -> HRESULT,
    fn get_CustomFields(&self, out: *mut *mut super::super::foundation::collections::IVectorView<ContactField>) -> HRESULT,
    fn QueryCustomFields(&self, customName: HSTRING, out: *mut *mut super::super::foundation::collections::IVectorView<ContactField>) -> HRESULT
}}
impl IContactInformation {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_thumbnail_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamWithContentType>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetThumbnailAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_emails(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Emails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_locations(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactLocationField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Locations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_instant_messages(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactInstantMessageField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstantMessages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom_fields(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomFields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn query_custom_fields(&self, customName: &HStringArg) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactField>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).QueryCustomFields)(self as *const _ as *mut _, customName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactInformation: IContactInformation}
DEFINE_IID!(IID_IContactInstantMessageField, 3437443895, 3461, 16890, 180, 61, 218, 89, 156, 62, 176, 9);
RT_INTERFACE!{interface IContactInstantMessageField(IContactInstantMessageFieldVtbl): IInspectable(IInspectableVtbl) [IID_IContactInstantMessageField] {
    fn get_UserName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Service(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LaunchUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT
}}
impl IContactInstantMessageField {
    #[inline] pub unsafe fn get_user_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_service(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Service)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_launch_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LaunchUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactInstantMessageField: IContactInstantMessageField}
impl RtActivatable<IContactInstantMessageFieldFactory> for ContactInstantMessageField {}
impl ContactInstantMessageField {
    #[inline] pub fn create_instant_message_default(userName: &HStringArg) -> Result<ComPtr<ContactInstantMessageField>> { unsafe {
        <Self as RtActivatable<IContactInstantMessageFieldFactory>>::get_activation_factory().create_instant_message_default(userName)
    }}
    #[inline] pub fn create_instant_message_category(userName: &HStringArg, category: ContactFieldCategory) -> Result<ComPtr<ContactInstantMessageField>> { unsafe {
        <Self as RtActivatable<IContactInstantMessageFieldFactory>>::get_activation_factory().create_instant_message_category(userName, category)
    }}
    #[inline] pub fn create_instant_message_all(userName: &HStringArg, category: ContactFieldCategory, service: &HStringArg, displayText: &HStringArg, verb: &super::super::foundation::Uri) -> Result<ComPtr<ContactInstantMessageField>> { unsafe {
        <Self as RtActivatable<IContactInstantMessageFieldFactory>>::get_activation_factory().create_instant_message_all(userName, category, service, displayText, verb)
    }}
}
DEFINE_CLSID!(ContactInstantMessageField: "Windows.ApplicationModel.Contacts.ContactInstantMessageField");
DEFINE_IID!(IID_IContactInstantMessageFieldFactory, 3121309588, 37283, 19378, 177, 185, 105, 165, 223, 240, 186, 9);
RT_INTERFACE!{static interface IContactInstantMessageFieldFactory(IContactInstantMessageFieldFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContactInstantMessageFieldFactory] {
    fn CreateInstantMessage_Default(&self, userName: HSTRING, out: *mut *mut ContactInstantMessageField) -> HRESULT,
    fn CreateInstantMessage_Category(&self, userName: HSTRING, category: ContactFieldCategory, out: *mut *mut ContactInstantMessageField) -> HRESULT,
    fn CreateInstantMessage_All(&self, userName: HSTRING, category: ContactFieldCategory, service: HSTRING, displayText: HSTRING, verb: *mut super::super::foundation::Uri, out: *mut *mut ContactInstantMessageField) -> HRESULT
}}
impl IContactInstantMessageFieldFactory {
    #[inline] pub unsafe fn create_instant_message_default(&self, userName: &HStringArg) -> Result<ComPtr<ContactInstantMessageField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstantMessage_Default)(self as *const _ as *mut _, userName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instant_message_category(&self, userName: &HStringArg, category: ContactFieldCategory) -> Result<ComPtr<ContactInstantMessageField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstantMessage_Category)(self as *const _ as *mut _, userName.get(), category, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_instant_message_all(&self, userName: &HStringArg, category: ContactFieldCategory, service: &HStringArg, displayText: &HStringArg, verb: &super::super::foundation::Uri) -> Result<ComPtr<ContactInstantMessageField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateInstantMessage_All)(self as *const _ as *mut _, userName.get(), category, service.get(), displayText.get(), verb as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactJobInfo, 1829862220, 52816, 19267, 158, 105, 177, 130, 88, 234, 83, 21);
RT_INTERFACE!{interface IContactJobInfo(IContactJobInfoVtbl): IInspectable(IInspectableVtbl) [IID_IContactJobInfo] {
    fn get_CompanyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyName(&self, value: HSTRING) -> HRESULT,
    fn get_CompanyYomiName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyYomiName(&self, value: HSTRING) -> HRESULT,
    fn get_Department(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Department(&self, value: HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Manager(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Manager(&self, value: HSTRING) -> HRESULT,
    fn get_Office(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Office(&self, value: HSTRING) -> HRESULT,
    fn get_CompanyAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CompanyAddress(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactJobInfo {
    #[inline] pub unsafe fn get_company_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompanyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_company_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompanyName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_company_yomi_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompanyYomiName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_company_yomi_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompanyYomiName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_department(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Department)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_department(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Department)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manager(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Manager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_manager(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Manager)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_office(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Office)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_office(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Office)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_company_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompanyAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_company_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompanyAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactJobInfo: IContactJobInfo}
impl RtActivatable<IActivationFactory> for ContactJobInfo {}
DEFINE_CLSID!(ContactJobInfo: "Windows.ApplicationModel.Contacts.ContactJobInfo");
RT_CLASS!{static class ContactLaunchActionVerbs}
impl RtActivatable<IContactLaunchActionVerbsStatics> for ContactLaunchActionVerbs {}
impl ContactLaunchActionVerbs {
    #[inline] pub fn get_call() -> Result<HString> { unsafe {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_call()
    }}
    #[inline] pub fn get_message() -> Result<HString> { unsafe {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_message()
    }}
    #[inline] pub fn get_map() -> Result<HString> { unsafe {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_map()
    }}
    #[inline] pub fn get_post() -> Result<HString> { unsafe {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_post()
    }}
    #[inline] pub fn get_video_call() -> Result<HString> { unsafe {
        <Self as RtActivatable<IContactLaunchActionVerbsStatics>>::get_activation_factory().get_video_call()
    }}
}
DEFINE_CLSID!(ContactLaunchActionVerbs: "Windows.ApplicationModel.Contacts.ContactLaunchActionVerbs");
DEFINE_IID!(IID_IContactLaunchActionVerbsStatics, 4212273878, 61043, 18151, 135, 97, 17, 205, 1, 87, 114, 143);
RT_INTERFACE!{static interface IContactLaunchActionVerbsStatics(IContactLaunchActionVerbsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContactLaunchActionVerbsStatics] {
    fn get_Call(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Map(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Post(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VideoCall(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactLaunchActionVerbsStatics {
    #[inline] pub unsafe fn get_call(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Call)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_map(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Map)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_post(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Post)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_video_call(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VideoCall)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactList, 383642741, 14636, 18501, 157, 251, 81, 163, 231, 239, 62, 66);
RT_INTERFACE!{interface IContactList(IContactListVtbl): IInspectable(IInspectableVtbl) [IID_IContactList] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsHidden(&self, out: *mut bool) -> HRESULT,
    fn put_IsHidden(&self, value: bool) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut ContactListOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: ContactListOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut ContactListOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: ContactListOtherAppWriteAccess) -> HRESULT,
    fn get_ChangeTracker(&self, out: *mut *mut ContactChangeTracker) -> HRESULT,
    fn get_SyncManager(&self, out: *mut *mut ContactListSyncManager) -> HRESULT,
    fn get_SupportsServerSearch(&self, out: *mut bool) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn add_ContactChanged(&self, value: *mut super::super::foundation::TypedEventHandler<ContactList, ContactChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContactChanged(&self, value: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetContactFromRemoteIdAsync(&self, remoteId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn GetMeContactAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn GetContactReader(&self, out: *mut *mut ContactReader) -> HRESULT,
    fn GetContactReaderWithOptions(&self, options: *mut ContactQueryOptions, out: *mut *mut ContactReader) -> HRESULT,
    fn SaveContactAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteContactAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetContactAsync(&self, contactId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT
}}
impl IContactList {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_hidden(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsHidden)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_hidden(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsHidden)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_read_access(&self) -> Result<ContactListOtherAppReadAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppReadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_read_access(&self, value: ContactListOtherAppReadAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppReadAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_write_access(&self) -> Result<ContactListOtherAppWriteAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppWriteAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_write_access(&self, value: ContactListOtherAppWriteAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppWriteAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_tracker(&self) -> Result<ComPtr<ContactChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangeTracker)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sync_manager(&self) -> Result<ComPtr<ContactListSyncManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SyncManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supports_server_search(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SupportsServerSearch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_contact_changed(&self, value: &super::super::foundation::TypedEventHandler<ContactList, ContactChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContactChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_contact_changed(&self, value: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContactChanged)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_from_remote_id_async(&self, remoteId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactFromRemoteIdAsync)(self as *const _ as *mut _, remoteId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_me_contact_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMeContactAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_reader(&self) -> Result<ComPtr<ContactReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_reader_with_options(&self, options: &ContactQueryOptions) -> Result<ComPtr<ContactReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_contact_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_contact_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_async(&self, contactId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactAsync)(self as *const _ as *mut _, contactId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactList: IContactList}
DEFINE_IID!(IID_IContactList2, 3409527732, 17744, 19915, 146, 41, 64, 255, 145, 251, 2, 3);
RT_INTERFACE!{interface IContactList2(IContactList2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactList2] {
    fn RegisterSyncManagerAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn put_SupportsServerSearch(&self, value: bool) -> HRESULT,
    fn get_SyncConstraints(&self, out: *mut *mut ContactListSyncConstraints) -> HRESULT
}}
impl IContactList2 {
    #[inline] pub unsafe fn register_sync_manager_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterSyncManagerAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_supports_server_search(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SupportsServerSearch)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sync_constraints(&self) -> Result<ComPtr<ContactListSyncConstraints>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SyncConstraints)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactList3, 360246871, 9980, 16872, 168, 80, 90, 163, 37, 20, 172, 169);
RT_INTERFACE!{interface IContactList3(IContactList3Vtbl): IInspectable(IInspectableVtbl) [IID_IContactList3] {
    fn get_LimitedWriteOperations(&self, out: *mut *mut ContactListLimitedWriteOperations) -> HRESULT,
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut *mut ContactChangeTracker) -> HRESULT
}}
impl IContactList3 {
    #[inline] pub unsafe fn get_limited_write_operations(&self) -> Result<ComPtr<ContactListLimitedWriteOperations>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LimitedWriteOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_tracker(&self, identity: &HStringArg) -> Result<ComPtr<ContactChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeTracker)(self as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactListLimitedWriteOperations, 3784840154, 18955, 17592, 154, 31, 160, 243, 210, 24, 23, 95);
RT_INTERFACE!{interface IContactListLimitedWriteOperations(IContactListLimitedWriteOperationsVtbl): IInspectable(IInspectableVtbl) [IID_IContactListLimitedWriteOperations] {
    fn TryCreateOrUpdateContactAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryDeleteContactAsync(&self, contactId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IContactListLimitedWriteOperations {
    #[inline] pub unsafe fn try_create_or_update_contact_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCreateOrUpdateContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_delete_contact_async(&self, contactId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryDeleteContactAsync)(self as *const _ as *mut _, contactId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListLimitedWriteOperations: IContactListLimitedWriteOperations}
RT_ENUM! { enum ContactListOtherAppReadAccess: i32 {
    SystemOnly (ContactListOtherAppReadAccess_SystemOnly) = 0, Limited (ContactListOtherAppReadAccess_Limited) = 1, Full (ContactListOtherAppReadAccess_Full) = 2, None (ContactListOtherAppReadAccess_None) = 3,
}}
RT_ENUM! { enum ContactListOtherAppWriteAccess: i32 {
    None (ContactListOtherAppWriteAccess_None) = 0, SystemOnly (ContactListOtherAppWriteAccess_SystemOnly) = 1, Limited (ContactListOtherAppWriteAccess_Limited) = 2,
}}
DEFINE_IID!(IID_IContactListSyncConstraints, 2997927681, 12386, 20014, 150, 157, 1, 141, 25, 135, 243, 20);
RT_INTERFACE!{interface IContactListSyncConstraints(IContactListSyncConstraintsVtbl): IInspectable(IInspectableVtbl) [IID_IContactListSyncConstraints] {
    fn get_CanSyncDescriptions(&self, out: *mut bool) -> HRESULT,
    fn put_CanSyncDescriptions(&self, value: bool) -> HRESULT,
    fn get_MaxHomePhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxHomePhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxMobilePhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxMobilePhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxWorkPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxWorkPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxOtherPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxOtherPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxPagerPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxPagerPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxBusinessFaxPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxBusinessFaxPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxHomeFaxPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxHomeFaxPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxCompanyPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxCompanyPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxAssistantPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxAssistantPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxRadioPhoneNumbers(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxRadioPhoneNumbers(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxPersonalEmailAddresses(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxPersonalEmailAddresses(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxWorkEmailAddresses(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxWorkEmailAddresses(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxOtherEmailAddresses(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxOtherEmailAddresses(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxHomeAddresses(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxHomeAddresses(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxWorkAddresses(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxWorkAddresses(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxOtherAddresses(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxOtherAddresses(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxBirthdayDates(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxBirthdayDates(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxAnniversaryDates(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxAnniversaryDates(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxOtherDates(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxOtherDates(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxOtherRelationships(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxOtherRelationships(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxSpouseRelationships(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxSpouseRelationships(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxPartnerRelationships(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxPartnerRelationships(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxSiblingRelationships(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxSiblingRelationships(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxParentRelationships(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxParentRelationships(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxChildRelationships(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxChildRelationships(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxJobInfo(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxJobInfo(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_MaxWebsites(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_MaxWebsites(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT
}}
impl IContactListSyncConstraints {
    #[inline] pub unsafe fn get_can_sync_descriptions(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanSyncDescriptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_sync_descriptions(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanSyncDescriptions)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_home_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxHomePhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_home_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxHomePhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_mobile_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxMobilePhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_mobile_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxMobilePhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_work_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxWorkPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_work_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxWorkPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_other_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxOtherPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_other_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxOtherPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_pager_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxPagerPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_pager_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxPagerPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_business_fax_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxBusinessFaxPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_business_fax_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxBusinessFaxPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_home_fax_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxHomeFaxPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_home_fax_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxHomeFaxPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_company_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxCompanyPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_company_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxCompanyPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_assistant_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxAssistantPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_assistant_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxAssistantPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_radio_phone_numbers(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxRadioPhoneNumbers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_radio_phone_numbers(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxRadioPhoneNumbers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_personal_email_addresses(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxPersonalEmailAddresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_personal_email_addresses(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxPersonalEmailAddresses)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_work_email_addresses(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxWorkEmailAddresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_work_email_addresses(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxWorkEmailAddresses)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_other_email_addresses(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxOtherEmailAddresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_other_email_addresses(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxOtherEmailAddresses)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_home_addresses(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxHomeAddresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_home_addresses(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxHomeAddresses)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_work_addresses(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxWorkAddresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_work_addresses(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxWorkAddresses)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_other_addresses(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxOtherAddresses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_other_addresses(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxOtherAddresses)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_birthday_dates(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxBirthdayDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_birthday_dates(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxBirthdayDates)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_anniversary_dates(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxAnniversaryDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_anniversary_dates(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxAnniversaryDates)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_other_dates(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxOtherDates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_other_dates(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxOtherDates)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_other_relationships(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxOtherRelationships)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_other_relationships(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxOtherRelationships)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_spouse_relationships(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxSpouseRelationships)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_spouse_relationships(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxSpouseRelationships)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_partner_relationships(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxPartnerRelationships)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_partner_relationships(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxPartnerRelationships)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_sibling_relationships(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxSiblingRelationships)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_sibling_relationships(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxSiblingRelationships)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_parent_relationships(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxParentRelationships)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_parent_relationships(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxParentRelationships)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_child_relationships(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxChildRelationships)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_child_relationships(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxChildRelationships)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_job_info(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxJobInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_job_info(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxJobInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_max_websites(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MaxWebsites)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_max_websites(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MaxWebsites)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListSyncConstraints: IContactListSyncConstraints}
DEFINE_IID!(IID_IContactListSyncManager, 342787006, 31013, 19148, 157, 229, 33, 221, 208, 111, 134, 116);
RT_INTERFACE!{interface IContactListSyncManager(IContactListSyncManagerVtbl): IInspectable(IInspectableVtbl) [IID_IContactListSyncManager] {
    fn get_Status(&self, out: *mut ContactListSyncStatus) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_LastAttemptedSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn SyncAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<ContactListSyncManager, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactListSyncManager {
    #[inline] pub unsafe fn get_status(&self) -> Result<ContactListSyncStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_successful_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastSuccessfulSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_attempted_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastAttemptedSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn sync_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SyncAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_sync_status_changed(&self, handler: &super::super::foundation::TypedEventHandler<ContactListSyncManager, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_status_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListSyncManager: IContactListSyncManager}
DEFINE_IID!(IID_IContactListSyncManager2, 2841186887, 47957, 20003, 129, 40, 55, 1, 52, 168, 93, 13);
RT_INTERFACE!{interface IContactListSyncManager2(IContactListSyncManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactListSyncManager2] {
    fn put_Status(&self, value: ContactListSyncStatus) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT
}}
impl IContactListSyncManager2 {
    #[inline] pub unsafe fn set_status(&self, value: ContactListSyncStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Status)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_successful_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastSuccessfulSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_attempted_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastAttemptedSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactListSyncStatus: i32 {
    Idle (ContactListSyncStatus_Idle) = 0, Syncing (ContactListSyncStatus_Syncing) = 1, UpToDate (ContactListSyncStatus_UpToDate) = 2, AuthenticationError (ContactListSyncStatus_AuthenticationError) = 3, PolicyError (ContactListSyncStatus_PolicyError) = 4, UnknownError (ContactListSyncStatus_UnknownError) = 5, ManualAccountRemovalRequired (ContactListSyncStatus_ManualAccountRemovalRequired) = 6,
}}
DEFINE_IID!(IID_IContactLocationField, 2663387010, 43886, 19254, 137, 227, 178, 59, 192, 161, 218, 204);
RT_INTERFACE!{interface IContactLocationField(IContactLocationFieldVtbl): IInspectable(IInspectableVtbl) [IID_IContactLocationField] {
    fn get_UnstructuredAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Street(&self, out: *mut HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Region(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactLocationField {
    #[inline] pub unsafe fn get_unstructured_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnstructuredAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_street(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Street)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_city(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_City)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_region(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Region)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_country(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Country)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_postal_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PostalCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactLocationField: IContactLocationField}
impl RtActivatable<IContactLocationFieldFactory> for ContactLocationField {}
impl ContactLocationField {
    #[inline] pub fn create_location_default(unstructuredAddress: &HStringArg) -> Result<ComPtr<ContactLocationField>> { unsafe {
        <Self as RtActivatable<IContactLocationFieldFactory>>::get_activation_factory().create_location_default(unstructuredAddress)
    }}
    #[inline] pub fn create_location_category(unstructuredAddress: &HStringArg, category: ContactFieldCategory) -> Result<ComPtr<ContactLocationField>> { unsafe {
        <Self as RtActivatable<IContactLocationFieldFactory>>::get_activation_factory().create_location_category(unstructuredAddress, category)
    }}
    #[inline] pub fn create_location_all(unstructuredAddress: &HStringArg, category: ContactFieldCategory, street: &HStringArg, city: &HStringArg, region: &HStringArg, country: &HStringArg, postalCode: &HStringArg) -> Result<ComPtr<ContactLocationField>> { unsafe {
        <Self as RtActivatable<IContactLocationFieldFactory>>::get_activation_factory().create_location_all(unstructuredAddress, category, street, city, region, country, postalCode)
    }}
}
DEFINE_CLSID!(ContactLocationField: "Windows.ApplicationModel.Contacts.ContactLocationField");
DEFINE_IID!(IID_IContactLocationFieldFactory, 4154012375, 12255, 17406, 143, 24, 65, 137, 115, 144, 188, 254);
RT_INTERFACE!{static interface IContactLocationFieldFactory(IContactLocationFieldFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContactLocationFieldFactory] {
    fn CreateLocation_Default(&self, unstructuredAddress: HSTRING, out: *mut *mut ContactLocationField) -> HRESULT,
    fn CreateLocation_Category(&self, unstructuredAddress: HSTRING, category: ContactFieldCategory, out: *mut *mut ContactLocationField) -> HRESULT,
    fn CreateLocation_All(&self, unstructuredAddress: HSTRING, category: ContactFieldCategory, street: HSTRING, city: HSTRING, region: HSTRING, country: HSTRING, postalCode: HSTRING, out: *mut *mut ContactLocationField) -> HRESULT
}}
impl IContactLocationFieldFactory {
    #[inline] pub unsafe fn create_location_default(&self, unstructuredAddress: &HStringArg) -> Result<ComPtr<ContactLocationField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLocation_Default)(self as *const _ as *mut _, unstructuredAddress.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_location_category(&self, unstructuredAddress: &HStringArg, category: ContactFieldCategory) -> Result<ComPtr<ContactLocationField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLocation_Category)(self as *const _ as *mut _, unstructuredAddress.get(), category, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_location_all(&self, unstructuredAddress: &HStringArg, category: ContactFieldCategory, street: &HStringArg, city: &HStringArg, region: &HStringArg, country: &HStringArg, postalCode: &HStringArg) -> Result<ComPtr<ContactLocationField>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateLocation_All)(self as *const _ as *mut _, unstructuredAddress.get(), category, street.get(), city.get(), region.get(), country.get(), postalCode.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{static class ContactManager}
impl RtActivatable<IContactManagerStatics> for ContactManager {}
impl RtActivatable<IContactManagerStatics2> for ContactManager {}
impl RtActivatable<IContactManagerStatics3> for ContactManager {}
impl RtActivatable<IContactManagerStatics4> for ContactManager {}
impl RtActivatable<IContactManagerStatics5> for ContactManager {}
impl ContactManager {
    #[inline] pub fn show_contact_card(contact: &Contact, selection: super::super::foundation::Rect) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics>>::get_activation_factory().show_contact_card(contact, selection)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_contact_card_with_placement(contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics>>::get_activation_factory().show_contact_card_with_placement(contact, selection, preferredPlacement)
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_delay_loaded_contact_card(contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<ContactCardDelayedDataLoader>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics>>::get_activation_factory().show_delay_loaded_contact_card(contact, selection, preferredPlacement)
    }}
    #[inline] pub fn request_store_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactStore>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics2>>::get_activation_factory().request_store_async()
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async(contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().convert_contact_to_vcard_async(contact)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_contact_to_vcard_async_with_max_bytes(contact: &Contact, maxBytes: u32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().convert_contact_to_vcard_async_with_max_bytes(contact, maxBytes)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn convert_vcard_to_contact_async(vCard: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().convert_vcard_to_contact_async(vCard)
    }}
    #[inline] pub fn request_store_async_with_access_type(accessType: ContactStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactStore>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().request_store_async_with_access_type(accessType)
    }}
    #[inline] pub fn request_annotation_store_async(accessType: ContactAnnotationStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotationStore>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().request_annotation_store_async(accessType)
    }}
    #[inline] pub fn is_show_contact_card_supported() -> Result<bool> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().is_show_contact_card_supported()
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_contact_card_with_options(contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().show_contact_card_with_options(contact, selection, preferredPlacement, contactCardOptions)
    }}
    #[inline] pub fn is_show_delay_loaded_contact_card_supported() -> Result<bool> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().is_show_delay_loaded_contact_card_supported()
    }}
    #[cfg(feature="windows-ui")] #[inline] pub fn show_delay_loaded_contact_card_with_options(contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<ComPtr<ContactCardDelayedDataLoader>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().show_delay_loaded_contact_card_with_options(contact, selection, preferredPlacement, contactCardOptions)
    }}
    #[inline] pub fn show_full_contact_card(contact: &Contact, fullContactCardOptions: &FullContactCardOptions) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().show_full_contact_card(contact, fullContactCardOptions)
    }}
    #[inline] pub fn get_system_display_name_order() -> Result<ContactNameOrder> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().get_system_display_name_order()
    }}
    #[inline] pub fn set_system_display_name_order(value: ContactNameOrder) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().set_system_display_name_order(value)
    }}
    #[inline] pub fn get_system_sort_order() -> Result<ContactNameOrder> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().get_system_sort_order()
    }}
    #[inline] pub fn set_system_sort_order(value: ContactNameOrder) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics3>>::get_activation_factory().set_system_sort_order(value)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<ContactManagerForUser>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics4>>::get_activation_factory().get_for_user(user)
    }}
    #[inline] pub fn is_show_full_contact_card_supported_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> { unsafe {
        <Self as RtActivatable<IContactManagerStatics5>>::get_activation_factory().is_show_full_contact_card_supported_async()
    }}
    #[inline] pub fn get_include_middle_name_in_system_display_and_sort() -> Result<bool> { unsafe {
        <Self as RtActivatable<IContactManagerStatics5>>::get_activation_factory().get_include_middle_name_in_system_display_and_sort()
    }}
    #[inline] pub fn set_include_middle_name_in_system_display_and_sort(value: bool) -> Result<()> { unsafe {
        <Self as RtActivatable<IContactManagerStatics5>>::get_activation_factory().set_include_middle_name_in_system_display_and_sort(value)
    }}
}
DEFINE_CLSID!(ContactManager: "Windows.ApplicationModel.Contacts.ContactManager");
DEFINE_IID!(IID_IContactManagerForUser, 3075193431, 4214, 19439, 174, 243, 84, 104, 109, 24, 56, 125);
RT_INTERFACE!{interface IContactManagerForUser(IContactManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerForUser] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsyncWithMaxBytes(&self, contact: *mut Contact, maxBytes: u32, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertVCardToContactAsync(&self, vCard: *mut super::super::storage::streams::IRandomAccessStreamReference, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn RequestStoreAsync(&self, accessType: ContactStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<ContactStore>) -> HRESULT,
    fn RequestAnnotationStoreAsync(&self, accessType: ContactAnnotationStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<ContactAnnotationStore>) -> HRESULT,
    fn get_SystemDisplayNameOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemDisplayNameOrder(&self, value: ContactNameOrder) -> HRESULT,
    fn get_SystemSortOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemSortOrder(&self, value: ContactNameOrder) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IContactManagerForUser {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn convert_contact_to_vcard_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertContactToVCardAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn convert_contact_to_vcard_async_with_max_bytes(&self, contact: &Contact, maxBytes: u32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertContactToVCardAsyncWithMaxBytes)(self as *const _ as *mut _, contact as *const _ as *mut _, maxBytes, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn convert_vcard_to_contact_async(&self, vCard: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertVCardToContactAsync)(self as *const _ as *mut _, vCard as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_store_async(&self, accessType: ContactStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_annotation_store_async(&self, accessType: ContactAnnotationStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotationStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAnnotationStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_system_display_name_order(&self) -> Result<ContactNameOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemDisplayNameOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_system_display_name_order(&self, value: ContactNameOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SystemDisplayNameOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_system_sort_order(&self) -> Result<ContactNameOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemSortOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_system_sort_order(&self, value: ContactNameOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SystemSortOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactManagerForUser: IContactManagerForUser}
DEFINE_IID!(IID_IContactManagerForUser2, 1296473134, 15221, 19059, 187, 48, 115, 102, 69, 71, 34, 86);
RT_INTERFACE!{interface IContactManagerForUser2(IContactManagerForUser2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerForUser2] {
    fn ShowFullContactCard(&self, contact: *mut Contact, fullContactCardOptions: *mut FullContactCardOptions) -> HRESULT
}}
impl IContactManagerForUser2 {
    #[inline] pub unsafe fn show_full_contact_card(&self, contact: &Contact, fullContactCardOptions: &FullContactCardOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowFullContactCard)(self as *const _ as *mut _, contact as *const _ as *mut _, fullContactCardOptions as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactManagerStatics, 2180127424, 63073, 18184, 186, 79, 211, 134, 189, 13, 98, 46);
RT_INTERFACE!{static interface IContactManagerStatics(IContactManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerStatics] {
    fn ShowContactCard(&self, contact: *mut Contact, selection: super::super::foundation::Rect) -> HRESULT,
    #[cfg(feature="windows-ui")] fn ShowContactCardWithPlacement(&self, contact: *mut Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> HRESULT,
    #[cfg(feature="windows-ui")] fn ShowDelayLoadedContactCard(&self, contact: *mut Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, out: *mut *mut ContactCardDelayedDataLoader) -> HRESULT
}}
impl IContactManagerStatics {
    #[inline] pub unsafe fn show_contact_card(&self, contact: &Contact, selection: super::super::foundation::Rect) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowContactCard)(self as *const _ as *mut _, contact as *const _ as *mut _, selection);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_contact_card_with_placement(&self, contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowContactCardWithPlacement)(self as *const _ as *mut _, contact as *const _ as *mut _, selection, preferredPlacement);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_delay_loaded_contact_card(&self, contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement) -> Result<ComPtr<ContactCardDelayedDataLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowDelayLoadedContactCard)(self as *const _ as *mut _, contact as *const _ as *mut _, selection, preferredPlacement, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactManagerStatics2, 2709055008, 18392, 18636, 150, 60, 149, 146, 182, 229, 16, 198);
RT_INTERFACE!{static interface IContactManagerStatics2(IContactManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerStatics2] {
    fn RequestStoreAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ContactStore>) -> HRESULT
}}
impl IContactManagerStatics2 {
    #[inline] pub unsafe fn request_store_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactManagerStatics3, 3301719362, 30086, 18730, 147, 11, 123, 193, 56, 252, 33, 57);
RT_INTERFACE!{static interface IContactManagerStatics3(IContactManagerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerStatics3] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsync(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertContactToVCardAsyncWithMaxBytes(&self, contact: *mut Contact, maxBytes: u32, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn ConvertVCardToContactAsync(&self, vCard: *mut super::super::storage::streams::IRandomAccessStreamReference, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn RequestStoreAsyncWithAccessType(&self, accessType: ContactStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<ContactStore>) -> HRESULT,
    fn RequestAnnotationStoreAsync(&self, accessType: ContactAnnotationStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<ContactAnnotationStore>) -> HRESULT,
    fn IsShowContactCardSupported(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowContactCardWithOptions(&self, contact: *mut Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: *mut ContactCardOptions) -> HRESULT,
    fn IsShowDelayLoadedContactCardSupported(&self, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-ui")] fn ShowDelayLoadedContactCardWithOptions(&self, contact: *mut Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: *mut ContactCardOptions, out: *mut *mut ContactCardDelayedDataLoader) -> HRESULT,
    fn ShowFullContactCard(&self, contact: *mut Contact, fullContactCardOptions: *mut FullContactCardOptions) -> HRESULT,
    fn get_SystemDisplayNameOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemDisplayNameOrder(&self, value: ContactNameOrder) -> HRESULT,
    fn get_SystemSortOrder(&self, out: *mut ContactNameOrder) -> HRESULT,
    fn put_SystemSortOrder(&self, value: ContactNameOrder) -> HRESULT
}}
impl IContactManagerStatics3 {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn convert_contact_to_vcard_async(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertContactToVCardAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn convert_contact_to_vcard_async_with_max_bytes(&self, contact: &Contact, maxBytes: u32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertContactToVCardAsyncWithMaxBytes)(self as *const _ as *mut _, contact as *const _ as *mut _, maxBytes, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn convert_vcard_to_contact_async(&self, vCard: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertVCardToContactAsync)(self as *const _ as *mut _, vCard as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_store_async_with_access_type(&self, accessType: ContactStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsyncWithAccessType)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_annotation_store_async(&self, accessType: ContactAnnotationStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactAnnotationStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAnnotationStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_show_contact_card_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsShowContactCardSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_contact_card_with_options(&self, contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowContactCardWithOptions)(self as *const _ as *mut _, contact as *const _ as *mut _, selection, preferredPlacement, contactCardOptions as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_show_delay_loaded_contact_card_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsShowDelayLoadedContactCardSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn show_delay_loaded_contact_card_with_options(&self, contact: &Contact, selection: super::super::foundation::Rect, preferredPlacement: super::super::ui::popups::Placement, contactCardOptions: &ContactCardOptions) -> Result<ComPtr<ContactCardDelayedDataLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowDelayLoadedContactCardWithOptions)(self as *const _ as *mut _, contact as *const _ as *mut _, selection, preferredPlacement, contactCardOptions as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_full_contact_card(&self, contact: &Contact, fullContactCardOptions: &FullContactCardOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowFullContactCard)(self as *const _ as *mut _, contact as *const _ as *mut _, fullContactCardOptions as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_system_display_name_order(&self) -> Result<ContactNameOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemDisplayNameOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_system_display_name_order(&self, value: ContactNameOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SystemDisplayNameOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_system_sort_order(&self) -> Result<ContactNameOrder> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SystemSortOrder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_system_sort_order(&self, value: ContactNameOrder) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SystemSortOrder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactManagerStatics4, 613950066, 13435, 18140, 141, 149, 81, 189, 65, 225, 90, 175);
RT_INTERFACE!{static interface IContactManagerStatics4(IContactManagerStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerStatics4] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut ContactManagerForUser) -> HRESULT
}}
impl IContactManagerStatics4 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<ContactManagerForUser>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactManagerStatics5, 4149811847, 44215, 20397, 144, 242, 168, 171, 100, 205, 187, 164);
RT_INTERFACE!{static interface IContactManagerStatics5(IContactManagerStatics5Vtbl): IInspectable(IInspectableVtbl) [IID_IContactManagerStatics5] {
    fn IsShowFullContactCardSupportedAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn get_IncludeMiddleNameInSystemDisplayAndSort(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeMiddleNameInSystemDisplayAndSort(&self, value: bool) -> HRESULT
}}
impl IContactManagerStatics5 {
    #[inline] pub unsafe fn is_show_full_contact_card_supported_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IsShowFullContactCardSupportedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_include_middle_name_in_system_display_and_sort(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncludeMiddleNameInSystemDisplayAndSort)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_include_middle_name_in_system_display_and_sort(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncludeMiddleNameInSystemDisplayAndSort)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactMatchReason, 3163694340, 59352, 16702, 149, 244, 183, 92, 84, 199, 64, 119);
RT_INTERFACE!{interface IContactMatchReason(IContactMatchReasonVtbl): IInspectable(IInspectableVtbl) [IID_IContactMatchReason] {
    fn get_Field(&self, out: *mut ContactMatchReasonKind) -> HRESULT,
    #[cfg(not(feature="windows-data"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-data")] fn get_Segments(&self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::data::text::TextSegment>) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactMatchReason {
    #[inline] pub unsafe fn get_field(&self) -> Result<ContactMatchReasonKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Field)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-data")] #[inline] pub unsafe fn get_segments(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<super::super::data::text::TextSegment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Segments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactMatchReason: IContactMatchReason}
RT_ENUM! { enum ContactMatchReasonKind: i32 {
    Name (ContactMatchReasonKind_Name) = 0, EmailAddress (ContactMatchReasonKind_EmailAddress) = 1, PhoneNumber (ContactMatchReasonKind_PhoneNumber) = 2, JobInfo (ContactMatchReasonKind_JobInfo) = 3, YomiName (ContactMatchReasonKind_YomiName) = 4, Other (ContactMatchReasonKind_Other) = 5,
}}
DEFINE_IID!(IID_IContactName, 4093962619, 36916, 17724, 142, 191, 20, 10, 56, 200, 111, 29);
RT_INTERFACE!{interface IContactName(IContactNameVtbl): IInspectable(IInspectableVtbl) [IID_IContactName] {
    fn get_FirstName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FirstName(&self, value: HSTRING) -> HRESULT,
    fn get_LastName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LastName(&self, value: HSTRING) -> HRESULT,
    fn get_MiddleName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MiddleName(&self, value: HSTRING) -> HRESULT,
    fn get_YomiGivenName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_YomiGivenName(&self, value: HSTRING) -> HRESULT,
    fn get_YomiFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_YomiFamilyName(&self, value: HSTRING) -> HRESULT,
    fn get_HonorificNameSuffix(&self, out: *mut HSTRING) -> HRESULT,
    fn put_HonorificNameSuffix(&self, value: HSTRING) -> HRESULT,
    fn get_HonorificNamePrefix(&self, out: *mut HSTRING) -> HRESULT,
    fn put_HonorificNamePrefix(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_YomiDisplayName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactName {
    #[inline] pub unsafe fn get_first_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FirstName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_first_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FirstName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LastName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_middle_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MiddleName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_middle_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MiddleName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_yomi_given_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YomiGivenName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_yomi_given_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_YomiGivenName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_yomi_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YomiFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_yomi_family_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_YomiFamilyName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_honorific_name_suffix(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HonorificNameSuffix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_honorific_name_suffix(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HonorificNameSuffix)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_honorific_name_prefix(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HonorificNamePrefix)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_honorific_name_prefix(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HonorificNamePrefix)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_yomi_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_YomiDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactNameOrder: i32 {
    FirstNameLastName (ContactNameOrder_FirstNameLastName) = 0, LastNameFirstName (ContactNameOrder_LastNameFirstName) = 1,
}}
DEFINE_IID!(IID_IContactPanel, 1103041125, 53998, 19351, 168, 10, 125, 141, 100, 204, 166, 245);
RT_INTERFACE!{interface IContactPanel(IContactPanelVtbl): IInspectable(IInspectableVtbl) [IID_IContactPanel] {
    fn ClosePanel(&self) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HeaderColor(&self, out: *mut *mut super::super::foundation::IReference<super::super::ui::Color>) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_HeaderColor(&self, value: *mut super::super::foundation::IReference<super::super::ui::Color>) -> HRESULT,
    fn add_LaunchFullAppRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<ContactPanel, ContactPanelLaunchFullAppRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LaunchFullAppRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Closing(&self, handler: *mut super::super::foundation::TypedEventHandler<ContactPanel, ContactPanelClosingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Closing(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactPanel {
    #[inline] pub unsafe fn close_panel(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ClosePanel)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_header_color(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::ui::Color>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_header_color(&self, value: &super::super::foundation::IReference<super::super::ui::Color>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderColor)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_launch_full_app_requested(&self, handler: &super::super::foundation::TypedEventHandler<ContactPanel, ContactPanelLaunchFullAppRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LaunchFullAppRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_launch_full_app_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LaunchFullAppRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_closing(&self, handler: &super::super::foundation::TypedEventHandler<ContactPanel, ContactPanelClosingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Closing)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_closing(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Closing)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPanel: IContactPanel}
DEFINE_IID!(IID_IContactPanelClosingEventArgs, 572617939, 53067, 18135, 183, 57, 110, 220, 22, 17, 11, 251);
RT_INTERFACE!{interface IContactPanelClosingEventArgs(IContactPanelClosingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactPanelClosingEventArgs] {
    fn GetDeferral(&self, out: *mut *mut super::super::foundation::Deferral) -> HRESULT
}}
impl IContactPanelClosingEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPanelClosingEventArgs: IContactPanelClosingEventArgs}
DEFINE_IID!(IID_IContactPanelLaunchFullAppRequestedEventArgs, 2295733262, 9140, 19432, 138, 252, 7, 44, 37, 164, 25, 13);
RT_INTERFACE!{interface IContactPanelLaunchFullAppRequestedEventArgs(IContactPanelLaunchFullAppRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactPanelLaunchFullAppRequestedEventArgs] {
    fn get_Handled(&self, out: *mut bool) -> HRESULT,
    fn put_Handled(&self, value: bool) -> HRESULT
}}
impl IContactPanelLaunchFullAppRequestedEventArgs {
    #[inline] pub unsafe fn get_handled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Handled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_handled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Handled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPanelLaunchFullAppRequestedEventArgs: IContactPanelLaunchFullAppRequestedEventArgs}
DEFINE_IID!(IID_IContactPhone, 1182640997, 10002, 20306, 183, 131, 158, 168, 17, 28, 99, 205);
RT_INTERFACE!{interface IContactPhone(IContactPhoneVtbl): IInspectable(IInspectableVtbl) [IID_IContactPhone] {
    fn get_Number(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Number(&self, value: HSTRING) -> HRESULT,
    fn get_Kind(&self, out: *mut ContactPhoneKind) -> HRESULT,
    fn put_Kind(&self, value: ContactPhoneKind) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactPhone {
    #[inline] pub unsafe fn get_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Number)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_number(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Number)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<ContactPhoneKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: ContactPhoneKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPhone: IContactPhone}
impl RtActivatable<IActivationFactory> for ContactPhone {}
DEFINE_CLSID!(ContactPhone: "Windows.ApplicationModel.Contacts.ContactPhone");
RT_ENUM! { enum ContactPhoneKind: i32 {
    Home (ContactPhoneKind_Home) = 0, Mobile (ContactPhoneKind_Mobile) = 1, Work (ContactPhoneKind_Work) = 2, Other (ContactPhoneKind_Other) = 3, Pager (ContactPhoneKind_Pager) = 4, BusinessFax (ContactPhoneKind_BusinessFax) = 5, HomeFax (ContactPhoneKind_HomeFax) = 6, Company (ContactPhoneKind_Company) = 7, Assistant (ContactPhoneKind_Assistant) = 8, Radio (ContactPhoneKind_Radio) = 9,
}}
DEFINE_IID!(IID_IContactPicker, 235535761, 17144, 16469, 144, 160, 137, 111, 150, 115, 137, 54);
RT_INTERFACE!{interface IContactPicker(IContactPickerVtbl): IInspectable(IInspectableVtbl) [IID_IContactPicker] {
    fn get_CommitButtonText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CommitButtonText(&self, value: HSTRING) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut ContactSelectionMode) -> HRESULT,
    fn put_SelectionMode(&self, value: ContactSelectionMode) -> HRESULT,
    fn get_DesiredFields(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn PickSingleContactAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ContactInformation>) -> HRESULT,
    fn PickMultipleContactsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactInformation>>) -> HRESULT
}}
impl IContactPicker {
    #[inline] pub unsafe fn get_commit_button_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommitButtonText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_commit_button_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CommitButtonText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode(&self) -> Result<ContactSelectionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_mode(&self, value: ContactSelectionMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_fields(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredFields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn pick_single_contact_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PickSingleContactAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn pick_multiple_contacts_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactInformation>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PickMultipleContactsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPicker: IContactPicker}
impl RtActivatable<IContactPickerStatics> for ContactPicker {}
impl RtActivatable<IActivationFactory> for ContactPicker {}
impl ContactPicker {
    #[cfg(feature="windows-system")] #[inline] pub fn create_for_user(user: &super::super::system::User) -> Result<ComPtr<ContactPicker>> { unsafe {
        <Self as RtActivatable<IContactPickerStatics>>::get_activation_factory().create_for_user(user)
    }}
    #[inline] pub fn is_supported_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> { unsafe {
        <Self as RtActivatable<IContactPickerStatics>>::get_activation_factory().is_supported_async()
    }}
}
DEFINE_CLSID!(ContactPicker: "Windows.ApplicationModel.Contacts.ContactPicker");
DEFINE_IID!(IID_IContactPicker2, 3008369103, 23791, 19748, 170, 12, 52, 12, 82, 8, 114, 93);
RT_INTERFACE!{interface IContactPicker2(IContactPicker2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactPicker2] {
    fn get_DesiredFieldsWithContactFieldType(&self, out: *mut *mut super::super::foundation::collections::IVector<ContactFieldType>) -> HRESULT,
    fn PickContactAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn PickContactsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVector<Contact>>) -> HRESULT
}}
impl IContactPicker2 {
    #[inline] pub unsafe fn get_desired_fields_with_contact_field_type(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ContactFieldType>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredFieldsWithContactFieldType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn pick_contact_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PickContactAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn pick_contacts_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVector<Contact>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).PickContactsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactPicker3, 242365205, 45635, 19437, 133, 22, 34, 177, 167, 172, 10, 206);
RT_INTERFACE!{interface IContactPicker3(IContactPicker3Vtbl): IInspectable(IInspectableVtbl) [IID_IContactPicker3] {
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IContactPicker3 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactPickerStatics, 1955119145, 27219, 16984, 163, 233, 98, 223, 246, 120, 75, 108);
RT_INTERFACE!{static interface IContactPickerStatics(IContactPickerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IContactPickerStatics] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn CreateForUser(&self, user: *mut super::super::system::User, out: *mut *mut ContactPicker) -> HRESULT,
    fn IsSupportedAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IContactPickerStatics {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn create_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<ContactPicker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_supported_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IsSupportedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactQueryDesiredFields: u32 {
    None (ContactQueryDesiredFields_None) = 0, PhoneNumber (ContactQueryDesiredFields_PhoneNumber) = 1, EmailAddress (ContactQueryDesiredFields_EmailAddress) = 2, PostalAddress (ContactQueryDesiredFields_PostalAddress) = 4,
}}
DEFINE_IID!(IID_IContactQueryOptions, 1141427358, 32124, 17136, 138, 199, 245, 7, 51, 236, 219, 193);
RT_INTERFACE!{interface IContactQueryOptions(IContactQueryOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IContactQueryOptions] {
    fn get_TextSearch(&self, out: *mut *mut ContactQueryTextSearch) -> HRESULT,
    fn get_ContactListIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_IncludeContactsFromHiddenLists(&self, out: *mut bool) -> HRESULT,
    fn put_IncludeContactsFromHiddenLists(&self, value: bool) -> HRESULT,
    fn get_DesiredFields(&self, out: *mut ContactQueryDesiredFields) -> HRESULT,
    fn put_DesiredFields(&self, value: ContactQueryDesiredFields) -> HRESULT,
    fn get_DesiredOperations(&self, out: *mut ContactAnnotationOperations) -> HRESULT,
    fn put_DesiredOperations(&self, value: ContactAnnotationOperations) -> HRESULT,
    fn get_AnnotationListIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IContactQueryOptions {
    #[inline] pub unsafe fn get_text_search(&self) -> Result<ComPtr<ContactQueryTextSearch>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextSearch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_list_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_include_contacts_from_hidden_lists(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncludeContactsFromHiddenLists)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_include_contacts_from_hidden_lists(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncludeContactsFromHiddenLists)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_fields(&self) -> Result<ContactQueryDesiredFields> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredFields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_fields(&self, value: ContactQueryDesiredFields) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredFields)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_operations(&self) -> Result<ContactAnnotationOperations> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_desired_operations(&self, value: ContactAnnotationOperations) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredOperations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_annotation_list_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AnnotationListIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactQueryOptions: IContactQueryOptions}
impl RtActivatable<IContactQueryOptionsFactory> for ContactQueryOptions {}
impl RtActivatable<IActivationFactory> for ContactQueryOptions {}
impl ContactQueryOptions {
    #[inline] pub fn create_with_text(text: &HStringArg) -> Result<ComPtr<ContactQueryOptions>> { unsafe {
        <Self as RtActivatable<IContactQueryOptionsFactory>>::get_activation_factory().create_with_text(text)
    }}
    #[inline] pub fn create_with_text_and_fields(text: &HStringArg, fields: ContactQuerySearchFields) -> Result<ComPtr<ContactQueryOptions>> { unsafe {
        <Self as RtActivatable<IContactQueryOptionsFactory>>::get_activation_factory().create_with_text_and_fields(text, fields)
    }}
}
DEFINE_CLSID!(ContactQueryOptions: "Windows.ApplicationModel.Contacts.ContactQueryOptions");
DEFINE_IID!(IID_IContactQueryOptionsFactory, 1413462599, 36071, 18123, 157, 172, 154, 164, 42, 27, 200, 226);
RT_INTERFACE!{static interface IContactQueryOptionsFactory(IContactQueryOptionsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IContactQueryOptionsFactory] {
    fn CreateWithText(&self, text: HSTRING, out: *mut *mut ContactQueryOptions) -> HRESULT,
    fn CreateWithTextAndFields(&self, text: HSTRING, fields: ContactQuerySearchFields, out: *mut *mut ContactQueryOptions) -> HRESULT
}}
impl IContactQueryOptionsFactory {
    #[inline] pub unsafe fn create_with_text(&self, text: &HStringArg) -> Result<ComPtr<ContactQueryOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithText)(self as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_text_and_fields(&self, text: &HStringArg, fields: ContactQuerySearchFields) -> Result<ComPtr<ContactQueryOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithTextAndFields)(self as *const _ as *mut _, text.get(), fields, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactQuerySearchFields: u32 {
    None (ContactQuerySearchFields_None) = 0, Name (ContactQuerySearchFields_Name) = 1, Email (ContactQuerySearchFields_Email) = 2, Phone (ContactQuerySearchFields_Phone) = 4, All (ContactQuerySearchFields_All) = 4294967295,
}}
RT_ENUM! { enum ContactQuerySearchScope: i32 {
    Local (ContactQuerySearchScope_Local) = 0, Server (ContactQuerySearchScope_Server) = 1,
}}
DEFINE_IID!(IID_IContactQueryTextSearch, 4158912971, 43351, 17307, 160, 183, 28, 2, 161, 150, 63, 240);
RT_INTERFACE!{interface IContactQueryTextSearch(IContactQueryTextSearchVtbl): IInspectable(IInspectableVtbl) [IID_IContactQueryTextSearch] {
    fn get_Fields(&self, out: *mut ContactQuerySearchFields) -> HRESULT,
    fn put_Fields(&self, value: ContactQuerySearchFields) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT,
    fn get_SearchScope(&self, out: *mut ContactQuerySearchScope) -> HRESULT,
    fn put_SearchScope(&self, value: ContactQuerySearchScope) -> HRESULT
}}
impl IContactQueryTextSearch {
    #[inline] pub unsafe fn get_fields(&self) -> Result<ContactQuerySearchFields> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Fields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fields(&self, value: ContactQuerySearchFields) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Fields)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_scope(&self) -> Result<ContactQuerySearchScope> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SearchScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_scope(&self, value: ContactQuerySearchScope) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchScope)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactQueryTextSearch: IContactQueryTextSearch}
DEFINE_IID!(IID_IContactReader, 3549946926, 5256, 17138, 191, 100, 37, 63, 72, 132, 191, 237);
RT_INTERFACE!{interface IContactReader(IContactReaderVtbl): IInspectable(IInspectableVtbl) [IID_IContactReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ContactBatch>) -> HRESULT,
    fn GetMatchingPropertiesWithMatchReason(&self, contact: *mut Contact, out: *mut *mut super::super::foundation::collections::IVectorView<ContactMatchReason>) -> HRESULT
}}
impl IContactReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactBatch>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_matching_properties_with_match_reason(&self, contact: &Contact) -> Result<ComPtr<super::super::foundation::collections::IVectorView<ContactMatchReason>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMatchingPropertiesWithMatchReason)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactReader: IContactReader}
RT_ENUM! { enum ContactRelationship: i32 {
    Other (ContactRelationship_Other) = 0, Spouse (ContactRelationship_Spouse) = 1, Partner (ContactRelationship_Partner) = 2, Sibling (ContactRelationship_Sibling) = 3, Parent (ContactRelationship_Parent) = 4, Child (ContactRelationship_Child) = 5,
}}
RT_ENUM! { enum ContactSelectionMode: i32 {
    Contacts (ContactSelectionMode_Contacts) = 0, Fields (ContactSelectionMode_Fields) = 1,
}}
DEFINE_IID!(IID_IContactSignificantOther, 2289284523, 50683, 18136, 147, 254, 218, 63, 241, 147, 64, 84);
RT_INTERFACE!{interface IContactSignificantOther(IContactSignificantOtherVtbl): IInspectable(IInspectableVtbl) [IID_IContactSignificantOther] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactSignificantOther {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactSignificantOther: IContactSignificantOther}
impl RtActivatable<IActivationFactory> for ContactSignificantOther {}
DEFINE_CLSID!(ContactSignificantOther: "Windows.ApplicationModel.Contacts.ContactSignificantOther");
DEFINE_IID!(IID_IContactSignificantOther2, 2373702772, 16131, 17912, 186, 15, 196, 237, 55, 214, 66, 25);
RT_INTERFACE!{interface IContactSignificantOther2(IContactSignificantOther2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactSignificantOther2] {
    fn get_Relationship(&self, out: *mut ContactRelationship) -> HRESULT,
    fn put_Relationship(&self, value: ContactRelationship) -> HRESULT
}}
impl IContactSignificantOther2 {
    #[inline] pub unsafe fn get_relationship(&self) -> Result<ContactRelationship> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Relationship)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_relationship(&self, value: ContactRelationship) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Relationship)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactStore, 740428560, 14956, 17043, 185, 188, 254, 152, 127, 110, 13, 82);
RT_INTERFACE!{interface IContactStore(IContactStoreVtbl): IInspectable(IInspectableVtbl) [IID_IContactStore] {
    fn FindContactsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Contact>>) -> HRESULT,
    fn FindContactsWithSearchTextAsync(&self, searchText: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Contact>>) -> HRESULT,
    fn GetContactAsync(&self, contactId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT
}}
impl IContactStore {
    #[inline] pub unsafe fn find_contacts_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Contact>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_contacts_with_search_text_async(&self, searchText: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<Contact>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactsWithSearchTextAsync)(self as *const _ as *mut _, searchText.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_async(&self, contactId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactAsync)(self as *const _ as *mut _, contactId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactStore: IContactStore}
DEFINE_IID!(IID_IContactStore2, 416160802, 60373, 19451, 182, 144, 95, 79, 39, 196, 240, 232);
RT_INTERFACE!{interface IContactStore2(IContactStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactStore2] {
    fn get_ChangeTracker(&self, out: *mut *mut ContactChangeTracker) -> HRESULT,
    fn add_ContactChanged(&self, value: *mut super::super::foundation::TypedEventHandler<ContactStore, ContactChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContactChanged(&self, value: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_AggregateContactManager(&self, out: *mut *mut AggregateContactManager) -> HRESULT,
    fn FindContactListsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactList>>) -> HRESULT,
    fn GetContactListAsync(&self, contactListId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ContactList>) -> HRESULT,
    fn CreateContactListAsync(&self, displayName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ContactList>) -> HRESULT,
    fn GetMeContactAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<Contact>) -> HRESULT,
    fn GetContactReader(&self, out: *mut *mut ContactReader) -> HRESULT,
    fn GetContactReaderWithOptions(&self, options: *mut ContactQueryOptions, out: *mut *mut ContactReader) -> HRESULT,
    fn CreateContactListInAccountAsync(&self, displayName: HSTRING, userDataAccountId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<ContactList>) -> HRESULT
}}
impl IContactStore2 {
    #[inline] pub unsafe fn get_change_tracker(&self) -> Result<ComPtr<ContactChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangeTracker)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_contact_changed(&self, value: &super::super::foundation::TypedEventHandler<ContactStore, ContactChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContactChanged)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_contact_changed(&self, value: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContactChanged)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_aggregate_contact_manager(&self) -> Result<ComPtr<AggregateContactManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AggregateContactManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_contact_lists_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<ContactList>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactListsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_list_async(&self, contactListId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactListAsync)(self as *const _ as *mut _, contactListId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_contact_list_async(&self, displayName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateContactListAsync)(self as *const _ as *mut _, displayName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_me_contact_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMeContactAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_reader(&self) -> Result<ComPtr<ContactReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_reader_with_options(&self, options: &ContactQueryOptions) -> Result<ComPtr<ContactReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContactReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_contact_list_in_account_async(&self, displayName: &HStringArg, userDataAccountId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ContactList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateContactListInAccountAsync)(self as *const _ as *mut _, displayName.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactStore3, 3414699116, 78, 16464, 135, 240, 132, 4, 7, 238, 104, 24);
RT_INTERFACE!{interface IContactStore3(IContactStore3Vtbl): IInspectable(IInspectableVtbl) [IID_IContactStore3] {
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut *mut ContactChangeTracker) -> HRESULT
}}
impl IContactStore3 {
    #[inline] pub unsafe fn get_change_tracker(&self, identity: &HStringArg) -> Result<ComPtr<ContactChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeTracker)(self as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ContactStoreAccessType: i32 {
    AppContactsReadWrite (ContactStoreAccessType_AppContactsReadWrite) = 0, AllContactsReadOnly (ContactStoreAccessType_AllContactsReadOnly) = 1, AllContactsReadWrite (ContactStoreAccessType_AllContactsReadWrite) = 2,
}}
DEFINE_IID!(IID_IContactStoreNotificationTriggerDetails, 2880608470, 34698, 20363, 169, 206, 70, 187, 125, 28, 132, 206);
RT_INTERFACE!{interface IContactStoreNotificationTriggerDetails(IContactStoreNotificationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IContactStoreNotificationTriggerDetails] {
    
}}
RT_CLASS!{class ContactStoreNotificationTriggerDetails: IContactStoreNotificationTriggerDetails}
DEFINE_IID!(IID_IContactWebsite, 2668822902, 56347, 16469, 173, 102, 101, 47, 57, 217, 144, 232);
RT_INTERFACE!{interface IContactWebsite(IContactWebsiteVtbl): IInspectable(IInspectableVtbl) [IID_IContactWebsite] {
    fn get_Uri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_Uri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT
}}
impl IContactWebsite {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Uri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactWebsite: IContactWebsite}
impl RtActivatable<IActivationFactory> for ContactWebsite {}
DEFINE_CLSID!(ContactWebsite: "Windows.ApplicationModel.Contacts.ContactWebsite");
DEFINE_IID!(IID_IContactWebsite2, 4169066782, 22087, 16488, 187, 94, 75, 111, 67, 124, 227, 8);
RT_INTERFACE!{interface IContactWebsite2(IContactWebsite2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactWebsite2] {
    fn get_RawValue(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RawValue(&self, value: HSTRING) -> HRESULT
}}
impl IContactWebsite2 {
    #[inline] pub unsafe fn get_raw_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RawValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_raw_value(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RawValue)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IFullContactCardOptions, 2269397868, 23801, 18051, 189, 202, 161, 253, 235, 248, 219, 206);
RT_INTERFACE!{interface IFullContactCardOptions(IFullContactCardOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IFullContactCardOptions] {
    #[cfg(feature="windows-ui")] fn get_DesiredRemainingView(&self, out: *mut super::super::ui::viewmanagement::ViewSizePreference) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_DesiredRemainingView(&self, value: super::super::ui::viewmanagement::ViewSizePreference) -> HRESULT
}}
impl IFullContactCardOptions {
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_desired_remaining_view(&self) -> Result<super::super::ui::viewmanagement::ViewSizePreference> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DesiredRemainingView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_desired_remaining_view(&self, value: super::super::ui::viewmanagement::ViewSizePreference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DesiredRemainingView)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class FullContactCardOptions: IFullContactCardOptions}
impl RtActivatable<IActivationFactory> for FullContactCardOptions {}
DEFINE_CLSID!(FullContactCardOptions: "Windows.ApplicationModel.Contacts.FullContactCardOptions");
RT_CLASS!{static class KnownContactField}
impl RtActivatable<IKnownContactFieldStatics> for KnownContactField {}
impl KnownContactField {
    #[inline] pub fn get_email() -> Result<HString> { unsafe {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_email()
    }}
    #[inline] pub fn get_phone_number() -> Result<HString> { unsafe {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_phone_number()
    }}
    #[inline] pub fn get_location() -> Result<HString> { unsafe {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_location()
    }}
    #[inline] pub fn get_instant_message() -> Result<HString> { unsafe {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().get_instant_message()
    }}
    #[inline] pub fn convert_name_to_type(name: &HStringArg) -> Result<ContactFieldType> { unsafe {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().convert_name_to_type(name)
    }}
    #[inline] pub fn convert_type_to_name(type_: ContactFieldType) -> Result<HString> { unsafe {
        <Self as RtActivatable<IKnownContactFieldStatics>>::get_activation_factory().convert_type_to_name(type_)
    }}
}
DEFINE_CLSID!(KnownContactField: "Windows.ApplicationModel.Contacts.KnownContactField");
DEFINE_IID!(IID_IKnownContactFieldStatics, 772676370, 54823, 20426, 186, 212, 31, 175, 22, 140, 125, 20);
RT_INTERFACE!{static interface IKnownContactFieldStatics(IKnownContactFieldStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IKnownContactFieldStatics] {
    fn get_Email(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstantMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn ConvertNameToType(&self, name: HSTRING, out: *mut ContactFieldType) -> HRESULT,
    fn ConvertTypeToName(&self, type_: ContactFieldType, out: *mut HSTRING) -> HRESULT
}}
impl IKnownContactFieldStatics {
    #[inline] pub unsafe fn get_email(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Email)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phone_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_location(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_instant_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstantMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn convert_name_to_type(&self, name: &HStringArg) -> Result<ContactFieldType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ConvertNameToType)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn convert_type_to_name(&self, type_: ContactFieldType) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ConvertTypeToName)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPinnedContactIdsQueryResult, 2107319634, 5497, 19932, 135, 31, 163, 10, 58, 234, 155, 161);
RT_INTERFACE!{interface IPinnedContactIdsQueryResult(IPinnedContactIdsQueryResultVtbl): IInspectable(IInspectableVtbl) [IID_IPinnedContactIdsQueryResult] {
    fn get_ContactIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IPinnedContactIdsQueryResult {
    #[inline] pub unsafe fn get_contact_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PinnedContactIdsQueryResult: IPinnedContactIdsQueryResult}
DEFINE_IID!(IID_IPinnedContactManager, 4240208908, 57814, 17859, 184, 182, 163, 86, 4, 225, 103, 160);
RT_INTERFACE!{interface IPinnedContactManager(IPinnedContactManagerVtbl): IInspectable(IInspectableVtbl) [IID_IPinnedContactManager] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT,
    fn IsPinSurfaceSupported(&self, surface: PinnedContactSurface, out: *mut bool) -> HRESULT,
    fn IsContactPinned(&self, contact: *mut Contact, surface: PinnedContactSurface, out: *mut bool) -> HRESULT,
    fn RequestPinContactAsync(&self, contact: *mut Contact, surface: PinnedContactSurface, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestPinContactsAsync(&self, contacts: *mut super::super::foundation::collections::IIterable<Contact>, surface: PinnedContactSurface, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn RequestUnpinContactAsync(&self, contact: *mut Contact, surface: PinnedContactSurface, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn SignalContactActivity(&self, contact: *mut Contact) -> HRESULT,
    fn GetPinnedContactIdsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<PinnedContactIdsQueryResult>) -> HRESULT
}}
impl IPinnedContactManager {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_pin_surface_supported(&self, surface: PinnedContactSurface) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsPinSurfaceSupported)(self as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_contact_pinned(&self, contact: &Contact, surface: PinnedContactSurface) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsContactPinned)(self as *const _ as *mut _, contact as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_pin_contact_async(&self, contact: &Contact, surface: PinnedContactSurface) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestPinContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_pin_contacts_async(&self, contacts: &super::super::foundation::collections::IIterable<Contact>, surface: PinnedContactSurface) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestPinContactsAsync)(self as *const _ as *mut _, contacts as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_unpin_contact_async(&self, contact: &Contact, surface: PinnedContactSurface) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestUnpinContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, surface, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn signal_contact_activity(&self, contact: &Contact) -> Result<()> {
        let hr = ((*self.lpVtbl).SignalContactActivity)(self as *const _ as *mut _, contact as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pinned_contact_ids_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PinnedContactIdsQueryResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPinnedContactIdsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PinnedContactManager: IPinnedContactManager}
impl RtActivatable<IPinnedContactManagerStatics> for PinnedContactManager {}
impl PinnedContactManager {
    #[inline] pub fn get_default() -> Result<ComPtr<PinnedContactManager>> { unsafe {
        <Self as RtActivatable<IPinnedContactManagerStatics>>::get_activation_factory().get_default()
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<PinnedContactManager>> { unsafe {
        <Self as RtActivatable<IPinnedContactManagerStatics>>::get_activation_factory().get_for_user(user)
    }}
    #[inline] pub fn is_supported() -> Result<bool> { unsafe {
        <Self as RtActivatable<IPinnedContactManagerStatics>>::get_activation_factory().is_supported()
    }}
}
DEFINE_CLSID!(PinnedContactManager: "Windows.ApplicationModel.Contacts.PinnedContactManager");
DEFINE_IID!(IID_IPinnedContactManagerStatics, 4133276798, 65017, 18538, 172, 233, 188, 49, 29, 10, 231, 240);
RT_INTERFACE!{static interface IPinnedContactManagerStatics(IPinnedContactManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPinnedContactManagerStatics] {
    fn GetDefault(&self, out: *mut *mut PinnedContactManager) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut PinnedContactManager) -> HRESULT,
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IPinnedContactManagerStatics {
    #[inline] pub unsafe fn get_default(&self) -> Result<ComPtr<PinnedContactManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<PinnedContactManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum PinnedContactSurface: i32 {
    StartMenu (PinnedContactSurface_StartMenu) = 0, Taskbar (PinnedContactSurface_Taskbar) = 1,
}}
pub mod dataprovider { // Windows.ApplicationModel.Contacts.DataProvider
use ::prelude::*;
DEFINE_IID!(IID_IContactDataProviderConnection, 439978578, 35997, 19823, 164, 224, 17, 30, 154, 18, 90, 48);
RT_INTERFACE!{interface IContactDataProviderConnection(IContactDataProviderConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IContactDataProviderConnection] {
    fn add_SyncRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListSyncManagerSyncRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ServerSearchReadBatchRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListServerSearchReadBatchRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServerSearchReadBatchRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IContactDataProviderConnection {
    #[inline] pub unsafe fn add_sync_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListSyncManagerSyncRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_server_search_read_batch_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListServerSearchReadBatchRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ServerSearchReadBatchRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_server_search_read_batch_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ServerSearchReadBatchRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Start)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactDataProviderConnection: IContactDataProviderConnection}
DEFINE_IID!(IID_IContactDataProviderConnection2, 2714970032, 6508, 19453, 143, 15, 198, 141, 103, 242, 73, 211);
RT_INTERFACE!{interface IContactDataProviderConnection2(IContactDataProviderConnection2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactDataProviderConnection2] {
    fn add_CreateOrUpdateContactRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListCreateOrUpdateContactRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateOrUpdateContactRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DeleteContactRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListDeleteContactRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeleteContactRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactDataProviderConnection2 {
    #[inline] pub unsafe fn add_create_or_update_contact_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListCreateOrUpdateContactRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CreateOrUpdateContactRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_create_or_update_contact_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CreateOrUpdateContactRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_delete_contact_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<ContactDataProviderConnection, ContactListDeleteContactRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DeleteContactRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_delete_contact_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DeleteContactRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactDataProviderTriggerDetails, 1383138494, 15458, 17352, 154, 231, 219, 83, 22, 133, 205, 153);
RT_INTERFACE!{interface IContactDataProviderTriggerDetails(IContactDataProviderTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IContactDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut *mut ContactDataProviderConnection) -> HRESULT
}}
impl IContactDataProviderTriggerDetails {
    #[inline] pub unsafe fn get_connection(&self) -> Result<ComPtr<ContactDataProviderConnection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Connection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactDataProviderTriggerDetails: IContactDataProviderTriggerDetails}
DEFINE_IID!(IID_IContactListCreateOrUpdateContactRequest, 3031384351, 51273, 18384, 177, 25, 145, 207, 96, 91, 47, 42);
RT_INTERFACE!{interface IContactListCreateOrUpdateContactRequest(IContactListCreateOrUpdateContactRequestVtbl): IInspectable(IInspectableVtbl) [IID_IContactListCreateOrUpdateContactRequest] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Contact(&self, out: *mut *mut super::Contact) -> HRESULT,
    fn ReportCompletedAsync(&self, createdOrUpdatedContact: *mut super::Contact, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IContactListCreateOrUpdateContactRequest {
    #[inline] pub unsafe fn get_contact_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact(&self) -> Result<ComPtr<super::Contact>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contact)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, createdOrUpdatedContact: &super::Contact) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, createdOrUpdatedContact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListCreateOrUpdateContactRequest: IContactListCreateOrUpdateContactRequest}
DEFINE_IID!(IID_IContactListCreateOrUpdateContactRequestEventArgs, 2233210512, 6737, 19212, 174, 239, 18, 64, 172, 91, 237, 117);
RT_INTERFACE!{interface IContactListCreateOrUpdateContactRequestEventArgs(IContactListCreateOrUpdateContactRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactListCreateOrUpdateContactRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut ContactListCreateOrUpdateContactRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IContactListCreateOrUpdateContactRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<ContactListCreateOrUpdateContactRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListCreateOrUpdateContactRequestEventArgs: IContactListCreateOrUpdateContactRequestEventArgs}
DEFINE_IID!(IID_IContactListDeleteContactRequest, 1578190471, 52739, 19941, 133, 87, 156, 207, 85, 45, 71, 42);
RT_INTERFACE!{interface IContactListDeleteContactRequest(IContactListDeleteContactRequestVtbl): IInspectable(IInspectableVtbl) [IID_IContactListDeleteContactRequest] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContactId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IContactListDeleteContactRequest {
    #[inline] pub unsafe fn get_contact_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListDeleteContactRequest: IContactListDeleteContactRequest}
DEFINE_IID!(IID_IContactListDeleteContactRequestEventArgs, 2988463265, 59642, 19893, 147, 137, 45, 18, 238, 125, 21, 238);
RT_INTERFACE!{interface IContactListDeleteContactRequestEventArgs(IContactListDeleteContactRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactListDeleteContactRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut ContactListDeleteContactRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IContactListDeleteContactRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<ContactListDeleteContactRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListDeleteContactRequestEventArgs: IContactListDeleteContactRequestEventArgs}
DEFINE_IID!(IID_IContactListServerSearchReadBatchRequest, 3128388247, 16432, 18725, 159, 180, 20, 59, 41, 94, 101, 59);
RT_INTERFACE!{interface IContactListServerSearchReadBatchRequest(IContactListServerSearchReadBatchRequestVtbl): IInspectable(IInspectableVtbl) [IID_IContactListServerSearchReadBatchRequest] {
    fn get_SessionId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Options(&self, out: *mut *mut super::ContactQueryOptions) -> HRESULT,
    fn get_SuggestedBatchSize(&self, out: *mut u32) -> HRESULT,
    fn SaveContactAsync(&self, contact: *mut super::Contact, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, batchStatus: super::ContactBatchStatus, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IContactListServerSearchReadBatchRequest {
    #[inline] pub unsafe fn get_session_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SessionId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contact_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_options(&self) -> Result<ComPtr<super::ContactQueryOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Options)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_suggested_batch_size(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SuggestedBatchSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_contact_async(&self, contact: &super::Contact) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveContactAsync)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self, batchStatus: super::ContactBatchStatus) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, batchStatus, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListServerSearchReadBatchRequest: IContactListServerSearchReadBatchRequest}
DEFINE_IID!(IID_IContactListServerSearchReadBatchRequestEventArgs, 438823035, 27095, 20046, 128, 66, 134, 28, 186, 97, 71, 30);
RT_INTERFACE!{interface IContactListServerSearchReadBatchRequestEventArgs(IContactListServerSearchReadBatchRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactListServerSearchReadBatchRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut ContactListServerSearchReadBatchRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IContactListServerSearchReadBatchRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<ContactListServerSearchReadBatchRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListServerSearchReadBatchRequestEventArgs: IContactListServerSearchReadBatchRequestEventArgs}
DEFINE_IID!(IID_IContactListSyncManagerSyncRequest, 1007572900, 50407, 18800, 154, 143, 154, 102, 162, 187, 108, 26);
RT_INTERFACE!{interface IContactListSyncManagerSyncRequest(IContactListSyncManagerSyncRequestVtbl): IInspectable(IInspectableVtbl) [IID_IContactListSyncManagerSyncRequest] {
    fn get_ContactListId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IContactListSyncManagerSyncRequest {
    #[inline] pub unsafe fn get_contact_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContactListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListSyncManagerSyncRequest: IContactListSyncManagerSyncRequest}
DEFINE_IID!(IID_IContactListSyncManagerSyncRequestEventArgs, 361647532, 17517, 20240, 175, 194, 2, 104, 62, 197, 51, 166);
RT_INTERFACE!{interface IContactListSyncManagerSyncRequestEventArgs(IContactListSyncManagerSyncRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactListSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut ContactListSyncManagerSyncRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IContactListSyncManagerSyncRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<ContactListSyncManagerSyncRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactListSyncManagerSyncRequestEventArgs: IContactListSyncManagerSyncRequestEventArgs}
} // Windows.ApplicationModel.Contacts.DataProvider
pub mod provider { // Windows.ApplicationModel.Contacts.Provider
use ::prelude::*;
RT_ENUM! { enum AddContactResult: i32 {
    Added (AddContactResult_Added) = 0, AlreadyAdded (AddContactResult_AlreadyAdded) = 1, Unavailable (AddContactResult_Unavailable) = 2,
}}
DEFINE_IID!(IID_IContactPickerUI, 3805025126, 53094, 17348, 169, 106, 165, 161, 18, 219, 71, 70);
RT_INTERFACE!{interface IContactPickerUI(IContactPickerUIVtbl): IInspectable(IInspectableVtbl) [IID_IContactPickerUI] {
    fn AddContact(&self, id: HSTRING, contact: *mut super::Contact, out: *mut AddContactResult) -> HRESULT,
    fn RemoveContact(&self, id: HSTRING) -> HRESULT,
    fn ContainsContact(&self, id: HSTRING, out: *mut bool) -> HRESULT,
    fn get_DesiredFields(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_SelectionMode(&self, out: *mut super::ContactSelectionMode) -> HRESULT,
    fn add_ContactRemoved(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<ContactPickerUI, ContactRemovedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContactRemoved(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IContactPickerUI {
    #[inline] pub unsafe fn add_contact(&self, id: &HStringArg, contact: &super::Contact) -> Result<AddContactResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).AddContact)(self as *const _ as *mut _, id.get(), contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_contact(&self, id: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveContact)(self as *const _ as *mut _, id.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn contains_contact(&self, id: &HStringArg) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ContainsContact)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_fields(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredFields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_mode(&self) -> Result<super::ContactSelectionMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SelectionMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_contact_removed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<ContactPickerUI, ContactRemovedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContactRemoved)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_contact_removed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContactRemoved)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ContactPickerUI: IContactPickerUI}
DEFINE_IID!(IID_IContactPickerUI2, 1849990696, 31525, 18841, 155, 11, 135, 84, 0, 161, 232, 200);
RT_INTERFACE!{interface IContactPickerUI2(IContactPickerUI2Vtbl): IInspectable(IInspectableVtbl) [IID_IContactPickerUI2] {
    fn AddContact(&self, contact: *mut super::Contact, out: *mut AddContactResult) -> HRESULT,
    fn get_DesiredFieldsWithContactFieldType(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<super::ContactFieldType>) -> HRESULT
}}
impl IContactPickerUI2 {
    #[inline] pub unsafe fn add_contact(&self, contact: &super::Contact) -> Result<AddContactResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).AddContact)(self as *const _ as *mut _, contact as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_desired_fields_with_contact_field_type(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<super::ContactFieldType>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DesiredFieldsWithContactFieldType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IContactRemovedEventArgs, 1865761592, 13058, 19731, 173, 141, 173, 204, 15, 249, 228, 124);
RT_INTERFACE!{interface IContactRemovedEventArgs(IContactRemovedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IContactRemovedEventArgs] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IContactRemovedEventArgs {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ContactRemovedEventArgs: IContactRemovedEventArgs}
} // Windows.ApplicationModel.Contacts.Provider
} // Windows.ApplicationModel.Contacts
pub mod datatransfer { // Windows.ApplicationModel.DataTransfer
use ::prelude::*;
RT_CLASS!{static class Clipboard}
impl RtActivatable<IClipboardStatics> for Clipboard {}
impl Clipboard {
    #[inline] pub fn get_content() -> Result<ComPtr<DataPackageView>> { unsafe {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().get_content()
    }}
    #[inline] pub fn set_content(content: &DataPackage) -> Result<()> { unsafe {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().set_content(content)
    }}
    #[inline] pub fn flush() -> Result<()> { unsafe {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().flush()
    }}
    #[inline] pub fn clear() -> Result<()> { unsafe {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().clear()
    }}
    #[inline] pub fn add_content_changed(changeHandler: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> { unsafe {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().add_content_changed(changeHandler)
    }}
    #[inline] pub fn remove_content_changed(token: super::super::foundation::EventRegistrationToken) -> Result<()> { unsafe {
        <Self as RtActivatable<IClipboardStatics>>::get_activation_factory().remove_content_changed(token)
    }}
}
DEFINE_CLSID!(Clipboard: "Windows.ApplicationModel.DataTransfer.Clipboard");
DEFINE_IID!(IID_IClipboardStatics, 3324502673, 13538, 18787, 142, 237, 147, 203, 176, 234, 61, 112);
RT_INTERFACE!{static interface IClipboardStatics(IClipboardStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IClipboardStatics] {
    fn GetContent(&self, out: *mut *mut DataPackageView) -> HRESULT,
    fn SetContent(&self, content: *mut DataPackage) -> HRESULT,
    fn Flush(&self) -> HRESULT,
    fn Clear(&self) -> HRESULT,
    fn add_ContentChanged(&self, changeHandler: *mut super::super::foundation::EventHandler<IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ContentChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IClipboardStatics {
    #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetContent)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content(&self, content: &DataPackage) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContent)(self as *const _ as *mut _, content as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn flush(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Flush)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_content_changed(&self, changeHandler: &super::super::foundation::EventHandler<IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ContentChanged)(self as *const _ as *mut _, changeHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_content_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ContentChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackage, 1642853831, 61418, 17222, 149, 84, 152, 29, 126, 25, 143, 254);
RT_INTERFACE!{interface IDataPackage(IDataPackageVtbl): IInspectable(IInspectableVtbl) [IID_IDataPackage] {
    fn GetView(&self, out: *mut *mut DataPackageView) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut DataPackagePropertySet) -> HRESULT,
    fn get_RequestedOperation(&self, out: *mut DataPackageOperation) -> HRESULT,
    fn put_RequestedOperation(&self, value: DataPackageOperation) -> HRESULT,
    fn add_OperationCompleted(&self, handler: *mut super::super::foundation::TypedEventHandler<DataPackage, OperationCompletedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_OperationCompleted(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_Destroyed(&self, handler: *mut super::super::foundation::TypedEventHandler<DataPackage, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Destroyed(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn SetData(&self, formatId: HSTRING, value: *mut IInspectable) -> HRESULT,
    fn SetDataProvider(&self, formatId: HSTRING, delayRenderer: *mut DataProviderHandler) -> HRESULT,
    fn SetText(&self, value: HSTRING) -> HRESULT,
    fn SetUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn SetHtmlFormat(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_ResourceMap(&self, out: *mut *mut super::super::foundation::collections::IMap<HString, super::super::storage::streams::RandomAccessStreamReference>) -> HRESULT,
    fn SetRtf(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetBitmap(&self, value: *mut super::super::storage::streams::RandomAccessStreamReference) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStorageItemsReadOnly(&self, value: *mut super::super::foundation::collections::IIterable<super::super::storage::IStorageItem>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetStorageItems(&self, value: *mut super::super::foundation::collections::IIterable<super::super::storage::IStorageItem>, readOnly: bool) -> HRESULT
}}
impl IDataPackage {
    #[inline] pub unsafe fn get_view(&self) -> Result<ComPtr<DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_properties(&self) -> Result<ComPtr<DataPackagePropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requested_operation(&self) -> Result<DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestedOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_requested_operation(&self, value: DataPackageOperation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestedOperation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_operation_completed(&self, handler: &super::super::foundation::TypedEventHandler<DataPackage, OperationCompletedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_OperationCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_operation_completed(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_OperationCompleted)(self as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_destroyed(&self, handler: &super::super::foundation::TypedEventHandler<DataPackage, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Destroyed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_destroyed(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Destroyed)(self as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data(&self, formatId: &HStringArg, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetData)(self as *const _ as *mut _, formatId.get(), value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data_provider(&self, formatId: &HStringArg, delayRenderer: &DataProviderHandler) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDataProvider)(self as *const _ as *mut _, formatId.get(), delayRenderer as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).SetUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_html_format(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetHtmlFormat)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_resource_map(&self) -> Result<ComPtr<super::super::foundation::collections::IMap<HString, super::super::storage::streams::RandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ResourceMap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_rtf(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetRtf)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_bitmap(&self, value: &super::super::storage::streams::RandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).SetBitmap)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_storage_items_read_only(&self, value: &super::super::foundation::collections::IIterable<super::super::storage::IStorageItem>) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStorageItemsReadOnly)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_storage_items(&self, value: &super::super::foundation::collections::IIterable<super::super::storage::IStorageItem>, readOnly: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStorageItems)(self as *const _ as *mut _, value as *const _ as *mut _, readOnly);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataPackage: IDataPackage}
impl RtActivatable<IActivationFactory> for DataPackage {}
DEFINE_CLSID!(DataPackage: "Windows.ApplicationModel.DataTransfer.DataPackage");
DEFINE_IID!(IID_IDataPackage2, 68952041, 9225, 17889, 165, 56, 76, 83, 238, 238, 4, 167);
RT_INTERFACE!{interface IDataPackage2(IDataPackage2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackage2] {
    fn SetApplicationLink(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn SetWebLink(&self, value: *mut super::super::foundation::Uri) -> HRESULT
}}
impl IDataPackage2 {
    #[inline] pub unsafe fn set_application_link(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).SetApplicationLink)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_web_link(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).SetWebLink)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackage3, 2297634653, 30843, 19762, 150, 90, 169, 131, 129, 5, 160, 86);
RT_INTERFACE!{interface IDataPackage3(IDataPackage3Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackage3] {
    fn add_ShareCompleted(&self, handler: *mut super::super::foundation::TypedEventHandler<DataPackage, ShareCompletedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ShareCompleted(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IDataPackage3 {
    #[inline] pub unsafe fn add_share_completed(&self, handler: &super::super::foundation::TypedEventHandler<DataPackage, ShareCompletedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ShareCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_share_completed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ShareCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum DataPackageOperation: u32 {
    None (DataPackageOperation_None) = 0, Copy (DataPackageOperation_Copy) = 1, Move (DataPackageOperation_Move) = 2, Link (DataPackageOperation_Link) = 4,
}}
DEFINE_IID!(IID_IDataPackagePropertySet, 3441202155, 19532, 17466, 168, 211, 245, 194, 65, 233, 22, 137);
RT_INTERFACE!{interface IDataPackagePropertySet(IDataPackagePropertySetVtbl): IInspectable(IInspectableVtbl) [IID_IDataPackagePropertySet] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_FileTypes(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_ApplicationName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ApplicationName(&self, value: HSTRING) -> HRESULT,
    fn get_ApplicationListingUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_ApplicationListingUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT
}}
impl IDataPackagePropertySet {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_thumbnail(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Thumbnail)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_file_types(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FileTypes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_application_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_application_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ApplicationName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_application_listing_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationListingUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_application_listing_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ApplicationListingUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataPackagePropertySet: IDataPackagePropertySet}
DEFINE_IID!(IID_IDataPackagePropertySet2, 3947912522, 38912, 18090, 177, 129, 123, 111, 15, 43, 145, 154);
RT_INTERFACE!{interface IDataPackagePropertySet2(IDataPackagePropertySet2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackagePropertySet2] {
    fn get_ContentSourceWebLink(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_ContentSourceWebLink(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_ContentSourceApplicationLink(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_ContentSourceApplicationLink(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PackageFamilyName(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Square30x30Logo(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Square30x30Logo(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_LogoBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_LogoBackgroundColor(&self, value: super::super::ui::Color) -> HRESULT
}}
impl IDataPackagePropertySet2 {
    #[inline] pub unsafe fn get_content_source_web_link(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentSourceWebLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_source_web_link(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentSourceWebLink)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_source_application_link(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentSourceApplicationLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_source_application_link(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentSourceApplicationLink)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_package_family_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PackageFamilyName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_square30x30_logo(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square30x30Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_square30x30_logo(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Square30x30Logo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_logo_background_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LogoBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_logo_background_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LogoBackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackagePropertySet3, 2659712411, 20997, 16411, 135, 74, 69, 86, 83, 189, 57, 232);
RT_INTERFACE!{interface IDataPackagePropertySet3(IDataPackagePropertySet3Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackagePropertySet3] {
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EnterpriseId(&self, value: HSTRING) -> HRESULT
}}
impl IDataPackagePropertySet3 {
    #[inline] pub unsafe fn get_enterprise_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnterpriseId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enterprise_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EnterpriseId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackagePropertySetView, 3108826113, 3098, 19543, 190, 85, 117, 208, 18, 137, 115, 93);
RT_INTERFACE!{interface IDataPackagePropertySetView(IDataPackagePropertySetViewVtbl): IInspectable(IInspectableVtbl) [IID_IDataPackagePropertySetView] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut *mut super::super::storage::streams::RandomAccessStreamReference) -> HRESULT,
    fn get_FileTypes(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_ApplicationName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ApplicationListingUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT
}}
impl IDataPackagePropertySetView {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<super::super::storage::streams::RandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_file_types(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FileTypes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_application_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_application_listing_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationListingUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DataPackagePropertySetView: IDataPackagePropertySetView}
DEFINE_IID!(IID_IDataPackagePropertySetView2, 1616138395, 36542, 20459, 156, 30, 117, 230, 157, 229, 75, 132);
RT_INTERFACE!{interface IDataPackagePropertySetView2(IDataPackagePropertySetView2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackagePropertySetView2] {
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentSourceWebLink(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn get_ContentSourceApplicationLink(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Square30x30Logo(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_LogoBackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT
}}
impl IDataPackagePropertySetView2 {
    #[inline] pub unsafe fn get_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_source_web_link(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentSourceWebLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_source_application_link(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentSourceApplicationLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_square30x30_logo(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Square30x30Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_logo_background_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LogoBackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackagePropertySetView3, 3681963237, 53620, 18780, 132, 252, 26, 81, 246, 171, 69, 215);
RT_INTERFACE!{interface IDataPackagePropertySetView3(IDataPackagePropertySetView3Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackagePropertySetView3] {
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IDataPackagePropertySetView3 {
    #[inline] pub unsafe fn get_enterprise_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnterpriseId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackageView, 2072249457, 22784, 19845, 169, 11, 16, 203, 133, 254, 53, 82);
RT_INTERFACE!{interface IDataPackageView(IDataPackageViewVtbl): IInspectable(IInspectableVtbl) [IID_IDataPackageView] {
    fn get_Properties(&self, out: *mut *mut DataPackagePropertySetView) -> HRESULT,
    fn get_RequestedOperation(&self, out: *mut DataPackageOperation) -> HRESULT,
    fn ReportOperationCompleted(&self, value: DataPackageOperation) -> HRESULT,
    fn get_AvailableFormats(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn Contains(&self, formatId: HSTRING, out: *mut bool) -> HRESULT,
    fn GetDataAsync(&self, formatId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<IInspectable>) -> HRESULT,
    fn GetTextAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetCustomTextAsync(&self, formatId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetUriAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::Uri>) -> HRESULT,
    fn GetHtmlFormatAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetResourceMapAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IMapView<HString, super::super::storage::streams::RandomAccessStreamReference>>) -> HRESULT,
    fn GetRtfAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetBitmapAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetStorageItemsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::super::storage::IStorageItem>>) -> HRESULT
}}
impl IDataPackageView {
    #[inline] pub unsafe fn get_properties(&self) -> Result<ComPtr<DataPackagePropertySetView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requested_operation(&self) -> Result<DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestedOperation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_operation_completed(&self, value: DataPackageOperation) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportOperationCompleted)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_available_formats(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AvailableFormats)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn contains(&self, formatId: &HStringArg) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).Contains)(self as *const _ as *mut _, formatId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data_async(&self, formatId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<IInspectable>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDataAsync)(self as *const _ as *mut _, formatId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTextAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom_text_async(&self, formatId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCustomTextAsync)(self as *const _ as *mut _, formatId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::Uri>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUriAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_html_format_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetHtmlFormatAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_resource_map_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IMapView<HString, super::super::storage::streams::RandomAccessStreamReference>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetResourceMapAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rtf_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetRtfAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_bitmap_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::RandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetBitmapAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_storage_items_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::super::storage::IStorageItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStorageItemsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DataPackageView: IDataPackageView}
DEFINE_IID!(IID_IDataPackageView2, 1089256085, 9296, 19485, 182, 180, 237, 69, 70, 61, 238, 156);
RT_INTERFACE!{interface IDataPackageView2(IDataPackageView2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackageView2] {
    fn GetApplicationLinkAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::Uri>) -> HRESULT,
    fn GetWebLinkAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::Uri>) -> HRESULT
}}
impl IDataPackageView2 {
    #[inline] pub unsafe fn get_application_link_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::Uri>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetApplicationLinkAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_web_link_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::Uri>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetWebLinkAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackageView3, 3547820456, 56749, 17032, 132, 40, 209, 202, 227, 148, 18, 139);
RT_INTERFACE!{interface IDataPackageView3(IDataPackageView3Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackageView3] {
    #[cfg(feature="windows-security")] fn RequestAccessAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult>) -> HRESULT,
    #[cfg(feature="windows-security")] fn RequestAccessWithEnterpriseIdAsync(&self, enterpriseId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult>) -> HRESULT,
    #[cfg(feature="windows-security")] fn UnlockAndAssumeEnterpriseIdentity(&self, out: *mut super::super::security::enterprisedata::ProtectionPolicyEvaluationResult) -> HRESULT
}}
impl IDataPackageView3 {
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn request_access_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAccessAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn request_access_with_enterprise_id_async(&self, enterpriseId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAccessWithEnterpriseIdAsync)(self as *const _ as *mut _, enterpriseId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn unlock_and_assume_enterprise_identity(&self) -> Result<super::super::security::enterprisedata::ProtectionPolicyEvaluationResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).UnlockAndAssumeEnterpriseIdentity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataPackageView4, 3756617503, 57410, 17459, 160, 159, 38, 214, 255, 218, 139, 133);
RT_INTERFACE!{interface IDataPackageView4(IDataPackageView4Vtbl): IInspectable(IInspectableVtbl) [IID_IDataPackageView4] {
    fn SetAcceptedFormatId(&self, formatId: HSTRING) -> HRESULT
}}
impl IDataPackageView4 {
    #[inline] pub unsafe fn set_accepted_format_id(&self, formatId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetAcceptedFormatId)(self as *const _ as *mut _, formatId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataProviderDeferral, 3268354931, 11558, 17369, 182, 157, 220, 184, 109, 3, 246, 218);
RT_INTERFACE!{interface IDataProviderDeferral(IDataProviderDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IDataProviderDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IDataProviderDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataProviderDeferral: IDataProviderDeferral}
DEFINE_IID!(IID_DataProviderHandler, 3891058464, 62196, 18989, 146, 14, 23, 10, 47, 72, 42, 39);
RT_DELEGATE!{delegate DataProviderHandler(DataProviderHandlerVtbl, DataProviderHandlerImpl) [IID_DataProviderHandler] {
    fn Invoke(&self, request: *mut DataProviderRequest) -> HRESULT
}}
impl DataProviderHandler {
    #[inline] pub unsafe fn invoke(&self, request: &DataProviderRequest) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, request as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataProviderRequest, 3954995543, 54216, 18394, 172, 222, 248, 35, 136, 213, 247, 22);
RT_INTERFACE!{interface IDataProviderRequest(IDataProviderRequestVtbl): IInspectable(IInspectableVtbl) [IID_IDataProviderRequest] {
    fn get_FormatId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Deadline(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut DataProviderDeferral) -> HRESULT,
    fn SetData(&self, value: *mut IInspectable) -> HRESULT
}}
impl IDataProviderRequest {
    #[inline] pub unsafe fn get_format_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormatId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deadline(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Deadline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<DataProviderDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).SetData)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataProviderRequest: IDataProviderRequest}
DEFINE_IID!(IID_IDataRequest, 1128377915, 64530, 20051, 140, 2, 172, 113, 76, 65, 90, 39);
RT_INTERFACE!{interface IDataRequest(IDataRequestVtbl): IInspectable(IInspectableVtbl) [IID_IDataRequest] {
    fn get_Data(&self, out: *mut *mut DataPackage) -> HRESULT,
    fn put_Data(&self, value: *mut DataPackage) -> HRESULT,
    fn get_Deadline(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn FailWithDisplayText(&self, value: HSTRING) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut DataRequestDeferral) -> HRESULT
}}
impl IDataRequest {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<DataPackage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_data(&self, value: &DataPackage) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Data)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deadline(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Deadline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn fail_with_display_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).FailWithDisplayText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<DataRequestDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DataRequest: IDataRequest}
DEFINE_IID!(IID_IDataRequestDeferral, 1841608863, 902, 16995, 135, 193, 237, 125, 206, 48, 137, 14);
RT_INTERFACE!{interface IDataRequestDeferral(IDataRequestDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IDataRequestDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IDataRequestDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataRequestDeferral: IDataRequestDeferral}
DEFINE_IID!(IID_IDataRequestedEventArgs, 3414927367, 27333, 17353, 138, 197, 155, 162, 50, 22, 49, 130);
RT_INTERFACE!{interface IDataRequestedEventArgs(IDataRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IDataRequestedEventArgs] {
    fn get_Request(&self, out: *mut *mut DataRequest) -> HRESULT
}}
impl IDataRequestedEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<DataRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class DataRequestedEventArgs: IDataRequestedEventArgs}
DEFINE_IID!(IID_IDataTransferManager, 2781539995, 34568, 18897, 141, 54, 103, 210, 90, 141, 160, 12);
RT_INTERFACE!{interface IDataTransferManager(IDataTransferManagerVtbl): IInspectable(IInspectableVtbl) [IID_IDataTransferManager] {
    fn add_DataRequested(&self, eventHandler: *mut super::super::foundation::TypedEventHandler<DataTransferManager, DataRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DataRequested(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_TargetApplicationChosen(&self, eventHandler: *mut super::super::foundation::TypedEventHandler<DataTransferManager, TargetApplicationChosenEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TargetApplicationChosen(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IDataTransferManager {
    #[inline] pub unsafe fn add_data_requested(&self, eventHandler: &super::super::foundation::TypedEventHandler<DataTransferManager, DataRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DataRequested)(self as *const _ as *mut _, eventHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_data_requested(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DataRequested)(self as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_target_application_chosen(&self, eventHandler: &super::super::foundation::TypedEventHandler<DataTransferManager, TargetApplicationChosenEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TargetApplicationChosen)(self as *const _ as *mut _, eventHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_target_application_chosen(&self, eventCookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TargetApplicationChosen)(self as *const _ as *mut _, eventCookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DataTransferManager: IDataTransferManager}
impl RtActivatable<IDataTransferManagerStatics> for DataTransferManager {}
impl RtActivatable<IDataTransferManagerStatics2> for DataTransferManager {}
impl RtActivatable<IDataTransferManagerStatics3> for DataTransferManager {}
impl DataTransferManager {
    #[inline] pub fn show_share_ui() -> Result<()> { unsafe {
        <Self as RtActivatable<IDataTransferManagerStatics>>::get_activation_factory().show_share_ui()
    }}
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<DataTransferManager>> { unsafe {
        <Self as RtActivatable<IDataTransferManagerStatics>>::get_activation_factory().get_for_current_view()
    }}
    #[inline] pub fn is_supported() -> Result<bool> { unsafe {
        <Self as RtActivatable<IDataTransferManagerStatics2>>::get_activation_factory().is_supported()
    }}
    #[inline] pub fn show_share_uiwith_options(options: &ShareUIOptions) -> Result<()> { unsafe {
        <Self as RtActivatable<IDataTransferManagerStatics3>>::get_activation_factory().show_share_uiwith_options(options)
    }}
}
DEFINE_CLSID!(DataTransferManager: "Windows.ApplicationModel.DataTransfer.DataTransferManager");
DEFINE_IID!(IID_IDataTransferManager2, 816741745, 35752, 19458, 142, 63, 221, 178, 59, 56, 135, 21);
RT_INTERFACE!{interface IDataTransferManager2(IDataTransferManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataTransferManager2] {
    fn add_ShareProvidersRequested(&self, handler: *mut super::super::foundation::TypedEventHandler<DataTransferManager, ShareProvidersRequestedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ShareProvidersRequested(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IDataTransferManager2 {
    #[inline] pub unsafe fn add_share_providers_requested(&self, handler: &super::super::foundation::TypedEventHandler<DataTransferManager, ShareProvidersRequestedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ShareProvidersRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_share_providers_requested(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ShareProvidersRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTransferManagerStatics, 2849636778, 57358, 19710, 170, 68, 45, 217, 50, 220, 163, 216);
RT_INTERFACE!{static interface IDataTransferManagerStatics(IDataTransferManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IDataTransferManagerStatics] {
    fn ShowShareUI(&self) -> HRESULT,
    fn GetForCurrentView(&self, out: *mut *mut DataTransferManager) -> HRESULT
}}
impl IDataTransferManagerStatics {
    #[inline] pub unsafe fn show_share_ui(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowShareUI)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<DataTransferManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTransferManagerStatics2, 3310273260, 40855, 19811, 152, 104, 57, 94, 39, 26, 216, 245);
RT_INTERFACE!{static interface IDataTransferManagerStatics2(IDataTransferManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IDataTransferManagerStatics2] {
    fn IsSupported(&self, out: *mut bool) -> HRESULT
}}
impl IDataTransferManagerStatics2 {
    #[inline] pub unsafe fn is_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IDataTransferManagerStatics3, 92558451, 27778, 20316, 172, 35, 98, 228, 88, 54, 31, 172);
RT_INTERFACE!{static interface IDataTransferManagerStatics3(IDataTransferManagerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IDataTransferManagerStatics3] {
    fn ShowShareUIWithOptions(&self, options: *mut ShareUIOptions) -> HRESULT
}}
impl IDataTransferManagerStatics3 {
    #[inline] pub unsafe fn show_share_uiwith_options(&self, options: &ShareUIOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowShareUIWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{static class HtmlFormatHelper}
impl RtActivatable<IHtmlFormatHelperStatics> for HtmlFormatHelper {}
impl HtmlFormatHelper {
    #[inline] pub fn get_static_fragment(htmlFormat: &HStringArg) -> Result<HString> { unsafe {
        <Self as RtActivatable<IHtmlFormatHelperStatics>>::get_activation_factory().get_static_fragment(htmlFormat)
    }}
    #[inline] pub fn create_html_format(htmlFragment: &HStringArg) -> Result<HString> { unsafe {
        <Self as RtActivatable<IHtmlFormatHelperStatics>>::get_activation_factory().create_html_format(htmlFragment)
    }}
}
DEFINE_CLSID!(HtmlFormatHelper: "Windows.ApplicationModel.DataTransfer.HtmlFormatHelper");
DEFINE_IID!(IID_IHtmlFormatHelperStatics, 3794696009, 56688, 17519, 174, 252, 97, 206, 229, 159, 101, 94);
RT_INTERFACE!{static interface IHtmlFormatHelperStatics(IHtmlFormatHelperStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHtmlFormatHelperStatics] {
    fn GetStaticFragment(&self, htmlFormat: HSTRING, out: *mut HSTRING) -> HRESULT,
    fn CreateHtmlFormat(&self, htmlFragment: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IHtmlFormatHelperStatics {
    #[inline] pub unsafe fn get_static_fragment(&self, htmlFormat: &HStringArg) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStaticFragment)(self as *const _ as *mut _, htmlFormat.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_html_format(&self, htmlFragment: &HStringArg) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateHtmlFormat)(self as *const _ as *mut _, htmlFragment.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IOperationCompletedEventArgs, 3887018653, 1309, 20395, 177, 169, 71, 253, 119, 247, 10, 65);
RT_INTERFACE!{interface IOperationCompletedEventArgs(IOperationCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IOperationCompletedEventArgs] {
    fn get_Operation(&self, out: *mut DataPackageOperation) -> HRESULT
}}
impl IOperationCompletedEventArgs {
    #[inline] pub unsafe fn get_operation(&self) -> Result<DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Operation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class OperationCompletedEventArgs: IOperationCompletedEventArgs}
DEFINE_IID!(IID_IOperationCompletedEventArgs2, 2240782451, 7705, 16645, 178, 247, 200, 71, 136, 8, 213, 98);
RT_INTERFACE!{interface IOperationCompletedEventArgs2(IOperationCompletedEventArgs2Vtbl): IInspectable(IInspectableVtbl) [IID_IOperationCompletedEventArgs2] {
    fn get_AcceptedFormatId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IOperationCompletedEventArgs2 {
    #[inline] pub unsafe fn get_accepted_format_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AcceptedFormatId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShareCompletedEventArgs, 1165280322, 63763, 20320, 157, 247, 204, 64, 96, 171, 25, 22);
RT_INTERFACE!{interface IShareCompletedEventArgs(IShareCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IShareCompletedEventArgs] {
    fn get_ShareTarget(&self, out: *mut *mut ShareTargetInfo) -> HRESULT
}}
impl IShareCompletedEventArgs {
    #[inline] pub unsafe fn get_share_target(&self) -> Result<ComPtr<ShareTargetInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShareTarget)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ShareCompletedEventArgs: IShareCompletedEventArgs}
RT_CLASS!{static class SharedStorageAccessManager}
impl RtActivatable<ISharedStorageAccessManagerStatics> for SharedStorageAccessManager {}
impl SharedStorageAccessManager {
    #[cfg(feature="windows-storage")] #[inline] pub fn add_file(file: &super::super::storage::IStorageFile) -> Result<HString> { unsafe {
        <Self as RtActivatable<ISharedStorageAccessManagerStatics>>::get_activation_factory().add_file(file)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn redeem_token_for_file_async(token: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::StorageFile>>> { unsafe {
        <Self as RtActivatable<ISharedStorageAccessManagerStatics>>::get_activation_factory().redeem_token_for_file_async(token)
    }}
    #[inline] pub fn remove_file(token: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<ISharedStorageAccessManagerStatics>>::get_activation_factory().remove_file(token)
    }}
}
DEFINE_CLSID!(SharedStorageAccessManager: "Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager");
DEFINE_IID!(IID_ISharedStorageAccessManagerStatics, 3323144922, 13489, 18505, 189, 95, 208, 159, 238, 49, 88, 197);
RT_INTERFACE!{static interface ISharedStorageAccessManagerStatics(ISharedStorageAccessManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ISharedStorageAccessManagerStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn AddFile(&self, file: *mut super::super::storage::IStorageFile, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn RedeemTokenForFileAsync(&self, token: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::StorageFile>) -> HRESULT,
    fn RemoveFile(&self, token: HSTRING) -> HRESULT
}}
impl ISharedStorageAccessManagerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn add_file(&self, file: &super::super::storage::IStorageFile) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AddFile)(self as *const _ as *mut _, file as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn redeem_token_for_file_async(&self, token: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::StorageFile>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RedeemTokenForFileAsync)(self as *const _ as *mut _, token.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_file(&self, token: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveFile)(self as *const _ as *mut _, token.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShareProvider, 799793190, 17470, 19674, 175, 37, 141, 129, 7, 14, 253, 128);
RT_INTERFACE!{interface IShareProvider(IShareProviderVtbl): IInspectable(IInspectableVtbl) [IID_IShareProvider] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_DisplayIcon(&self, out: *mut *mut super::super::storage::streams::RandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_BackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    fn get_Tag(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_Tag(&self, value: *mut IInspectable) -> HRESULT
}}
impl IShareProvider {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_display_icon(&self) -> Result<ComPtr<super::super::storage::streams::RandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayIcon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_background_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tag(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tag(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ShareProvider: IShareProvider}
impl RtActivatable<IShareProviderFactory> for ShareProvider {}
impl ShareProvider {
    #[cfg(all(feature="windows-storage",feature="windows-ui"))] #[inline] pub fn create(title: &HStringArg, displayIcon: &super::super::storage::streams::RandomAccessStreamReference, backgroundColor: super::super::ui::Color, handler: &ShareProviderHandler) -> Result<ComPtr<ShareProvider>> { unsafe {
        <Self as RtActivatable<IShareProviderFactory>>::get_activation_factory().create(title, displayIcon, backgroundColor, handler)
    }}
}
DEFINE_CLSID!(ShareProvider: "Windows.ApplicationModel.DataTransfer.ShareProvider");
DEFINE_IID!(IID_IShareProviderFactory, 388634444, 59294, 20333, 176, 125, 18, 143, 70, 158, 2, 150);
RT_INTERFACE!{static interface IShareProviderFactory(IShareProviderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IShareProviderFactory] {
    #[cfg(all(feature="windows-storage",feature="windows-ui"))] fn Create(&self, title: HSTRING, displayIcon: *mut super::super::storage::streams::RandomAccessStreamReference, backgroundColor: super::super::ui::Color, handler: *mut ShareProviderHandler, out: *mut *mut ShareProvider) -> HRESULT
}}
impl IShareProviderFactory {
    #[cfg(all(feature="windows-storage",feature="windows-ui"))] #[inline] pub unsafe fn create(&self, title: &HStringArg, displayIcon: &super::super::storage::streams::RandomAccessStreamReference, backgroundColor: super::super::ui::Color, handler: &ShareProviderHandler) -> Result<ComPtr<ShareProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, title.get(), displayIcon as *const _ as *mut _, backgroundColor, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ShareProviderHandler, 3891911098, 57786, 20045, 189, 101, 212, 56, 69, 211, 33, 47);
RT_DELEGATE!{delegate ShareProviderHandler(ShareProviderHandlerVtbl, ShareProviderHandlerImpl) [IID_ShareProviderHandler] {
    fn Invoke(&self, operation: *mut ShareProviderOperation) -> HRESULT
}}
impl ShareProviderHandler {
    #[inline] pub unsafe fn invoke(&self, operation: &ShareProviderOperation) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, operation as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShareProviderOperation, 432994615, 54325, 16761, 182, 175, 20, 224, 73, 43, 105, 246);
RT_INTERFACE!{interface IShareProviderOperation(IShareProviderOperationVtbl): IInspectable(IInspectableVtbl) [IID_IShareProviderOperation] {
    fn get_Data(&self, out: *mut *mut DataPackageView) -> HRESULT,
    fn get_Provider(&self, out: *mut *mut ShareProvider) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT
}}
impl IShareProviderOperation {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_provider(&self) -> Result<ComPtr<ShareProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Provider)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ShareProviderOperation: IShareProviderOperation}
DEFINE_IID!(IID_IShareProvidersRequestedEventArgs, 4169724758, 41976, 20430, 133, 228, 136, 38, 230, 59, 231, 153);
RT_INTERFACE!{interface IShareProvidersRequestedEventArgs(IShareProvidersRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IShareProvidersRequestedEventArgs] {
    fn get_Providers(&self, out: *mut *mut super::super::foundation::collections::IVector<ShareProvider>) -> HRESULT,
    fn get_Data(&self, out: *mut *mut DataPackageView) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut super::super::foundation::Deferral) -> HRESULT
}}
impl IShareProvidersRequestedEventArgs {
    #[inline] pub unsafe fn get_providers(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<ShareProvider>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Providers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ShareProvidersRequestedEventArgs: IShareProvidersRequestedEventArgs}
DEFINE_IID!(IID_IShareTargetInfo, 945546759, 50920, 16660, 178, 148, 40, 243, 187, 111, 153, 4);
RT_INTERFACE!{interface IShareTargetInfo(IShareTargetInfoVtbl): IInspectable(IInspectableVtbl) [IID_IShareTargetInfo] {
    fn get_AppUserModelId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ShareProvider(&self, out: *mut *mut ShareProvider) -> HRESULT
}}
impl IShareTargetInfo {
    #[inline] pub unsafe fn get_app_user_model_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppUserModelId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_share_provider(&self) -> Result<ComPtr<ShareProvider>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShareProvider)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ShareTargetInfo: IShareTargetInfo}
DEFINE_IID!(IID_IShareUIOptions, 1929022080, 13359, 19856, 149, 81, 42, 224, 78, 55, 104, 12);
RT_INTERFACE!{interface IShareUIOptions(IShareUIOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IShareUIOptions] {
    fn get_Theme(&self, out: *mut ShareUITheme) -> HRESULT,
    fn put_Theme(&self, value: ShareUITheme) -> HRESULT,
    fn get_SelectionRect(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::Rect>) -> HRESULT,
    fn put_SelectionRect(&self, value: *mut super::super::foundation::IReference<super::super::foundation::Rect>) -> HRESULT
}}
impl IShareUIOptions {
    #[inline] pub unsafe fn get_theme(&self) -> Result<ShareUITheme> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Theme)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_theme(&self, value: ShareUITheme) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Theme)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selection_rect(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::Rect>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectionRect)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_selection_rect(&self, value: &super::super::foundation::IReference<super::super::foundation::Rect>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SelectionRect)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ShareUIOptions: IShareUIOptions}
impl RtActivatable<IActivationFactory> for ShareUIOptions {}
DEFINE_CLSID!(ShareUIOptions: "Windows.ApplicationModel.DataTransfer.ShareUIOptions");
RT_ENUM! { enum ShareUITheme: i32 {
    Default (ShareUITheme_Default) = 0, Light (ShareUITheme_Light) = 1, Dark (ShareUITheme_Dark) = 2,
}}
RT_CLASS!{static class StandardDataFormats}
impl RtActivatable<IStandardDataFormatsStatics> for StandardDataFormats {}
impl RtActivatable<IStandardDataFormatsStatics2> for StandardDataFormats {}
impl StandardDataFormats {
    #[inline] pub fn get_text() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_text()
    }}
    #[inline] pub fn get_uri() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_uri()
    }}
    #[inline] pub fn get_html() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_html()
    }}
    #[inline] pub fn get_rtf() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_rtf()
    }}
    #[inline] pub fn get_bitmap() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_bitmap()
    }}
    #[inline] pub fn get_storage_items() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics>>::get_activation_factory().get_storage_items()
    }}
    #[inline] pub fn get_web_link() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics2>>::get_activation_factory().get_web_link()
    }}
    #[inline] pub fn get_application_link() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStandardDataFormatsStatics2>>::get_activation_factory().get_application_link()
    }}
}
DEFINE_CLSID!(StandardDataFormats: "Windows.ApplicationModel.DataTransfer.StandardDataFormats");
DEFINE_IID!(IID_IStandardDataFormatsStatics, 2127987105, 43136, 16585, 180, 237, 11, 238, 30, 21, 245, 73);
RT_INTERFACE!{static interface IStandardDataFormatsStatics(IStandardDataFormatsStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStandardDataFormatsStatics] {
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Html(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Rtf(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Bitmap(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StorageItems(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStandardDataFormatsStatics {
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_html(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Html)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_rtf(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Rtf)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bitmap(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Bitmap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_storage_items(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StorageItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStandardDataFormatsStatics2, 1117934836, 40310, 17128, 134, 27, 71, 194, 93, 208, 207, 113);
RT_INTERFACE!{static interface IStandardDataFormatsStatics2(IStandardDataFormatsStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IStandardDataFormatsStatics2] {
    fn get_WebLink(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ApplicationLink(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStandardDataFormatsStatics2 {
    #[inline] pub unsafe fn get_web_link(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WebLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_application_link(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationLink)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ITargetApplicationChosenEventArgs, 3396319404, 10631, 20195, 156, 84, 216, 175, 188, 184, 108, 29);
RT_INTERFACE!{interface ITargetApplicationChosenEventArgs(ITargetApplicationChosenEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ITargetApplicationChosenEventArgs] {
    fn get_ApplicationName(&self, out: *mut HSTRING) -> HRESULT
}}
impl ITargetApplicationChosenEventArgs {
    #[inline] pub unsafe fn get_application_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ApplicationName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class TargetApplicationChosenEventArgs: ITargetApplicationChosenEventArgs}
pub mod dragdrop { // Windows.ApplicationModel.DataTransfer.DragDrop
use ::prelude::*;
RT_ENUM! { enum DragDropModifiers: u32 {
    None (DragDropModifiers_None) = 0, Shift (DragDropModifiers_Shift) = 1, Control (DragDropModifiers_Control) = 2, Alt (DragDropModifiers_Alt) = 4, LeftButton (DragDropModifiers_LeftButton) = 8, MiddleButton (DragDropModifiers_MiddleButton) = 16, RightButton (DragDropModifiers_RightButton) = 32,
}}
pub mod core { // Windows.ApplicationModel.DataTransfer.DragDrop.Core
use ::prelude::*;
DEFINE_IID!(IID_ICoreDragDropManager, 2102842180, 33892, 20399, 170, 73, 55, 234, 110, 45, 123, 209);
RT_INTERFACE!{interface ICoreDragDropManager(ICoreDragDropManagerVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragDropManager] {
    fn add_TargetRequested(&self, value: *mut ::rt::gen::windows::foundation::TypedEventHandler<CoreDragDropManager, CoreDropOperationTargetRequestedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_TargetRequested(&self, value: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn get_AreConcurrentOperationsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_AreConcurrentOperationsEnabled(&self, value: bool) -> HRESULT
}}
impl ICoreDragDropManager {
    #[inline] pub unsafe fn add_target_requested(&self, value: &::rt::gen::windows::foundation::TypedEventHandler<CoreDragDropManager, CoreDropOperationTargetRequestedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_TargetRequested)(self as *const _ as *mut _, value as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_target_requested(&self, value: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_TargetRequested)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_are_concurrent_operations_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AreConcurrentOperationsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_are_concurrent_operations_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AreConcurrentOperationsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CoreDragDropManager: ICoreDragDropManager}
impl RtActivatable<ICoreDragDropManagerStatics> for CoreDragDropManager {}
impl CoreDragDropManager {
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<CoreDragDropManager>> { unsafe {
        <Self as RtActivatable<ICoreDragDropManagerStatics>>::get_activation_factory().get_for_current_view()
    }}
}
DEFINE_CLSID!(CoreDragDropManager: "Windows.ApplicationModel.DataTransfer.DragDrop.Core.CoreDragDropManager");
DEFINE_IID!(IID_ICoreDragDropManagerStatics, 2504195530, 55826, 19484, 141, 6, 4, 29, 178, 151, 51, 195);
RT_INTERFACE!{static interface ICoreDragDropManagerStatics(ICoreDragDropManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragDropManagerStatics] {
    fn GetForCurrentView(&self, out: *mut *mut CoreDragDropManager) -> HRESULT
}}
impl ICoreDragDropManagerStatics {
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<CoreDragDropManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreDragInfo, 1211447947, 52048, 17998, 149, 117, 205, 78, 58, 122, 176, 40);
RT_INTERFACE!{interface ICoreDragInfo(ICoreDragInfoVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragInfo] {
    fn get_Data(&self, out: *mut *mut super::super::DataPackageView) -> HRESULT,
    fn get_Modifiers(&self, out: *mut super::DragDropModifiers) -> HRESULT,
    fn get_Position(&self, out: *mut ::rt::gen::windows::foundation::Point) -> HRESULT
}}
impl ICoreDragInfo {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::super::DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_modifiers(&self) -> Result<super::DragDropModifiers> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Modifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_position(&self) -> Result<::rt::gen::windows::foundation::Point> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class CoreDragInfo: ICoreDragInfo}
DEFINE_IID!(IID_ICoreDragInfo2, 3309736421, 59131, 19828, 180, 177, 138, 60, 23, 242, 94, 158);
RT_INTERFACE!{interface ICoreDragInfo2(ICoreDragInfo2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragInfo2] {
    fn get_AllowedOperations(&self, out: *mut super::super::DataPackageOperation) -> HRESULT
}}
impl ICoreDragInfo2 {
    #[inline] pub unsafe fn get_allowed_operations(&self) -> Result<super::super::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowedOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreDragOperation, 3423002191, 28080, 20066, 171, 27, 167, 74, 2, 220, 109, 133);
RT_INTERFACE!{interface ICoreDragOperation(ICoreDragOperationVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragOperation] {
    fn get_Data(&self, out: *mut *mut super::super::DataPackage) -> HRESULT,
    fn SetPointerId(&self, pointerId: u32) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetDragUIContentFromSoftwareBitmap(&self, softwareBitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetDragUIContentFromSoftwareBitmapWithAnchorPoint(&self, softwareBitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap, anchorPoint: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_DragUIContentMode(&self, out: *mut CoreDragUIContentMode) -> HRESULT,
    fn put_DragUIContentMode(&self, value: CoreDragUIContentMode) -> HRESULT,
    fn StartAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>) -> HRESULT
}}
impl ICoreDragOperation {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::super::DataPackage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pointer_id(&self, pointerId: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPointerId)(self as *const _ as *mut _, pointerId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_drag_uicontent_from_software_bitmap(&self, softwareBitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDragUIContentFromSoftwareBitmap)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_drag_uicontent_from_software_bitmap_with_anchor_point(&self, softwareBitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap, anchorPoint: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetDragUIContentFromSoftwareBitmapWithAnchorPoint)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_drag_uicontent_mode(&self) -> Result<CoreDragUIContentMode> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DragUIContentMode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_drag_uicontent_mode(&self, value: CoreDragUIContentMode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DragUIContentMode)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class CoreDragOperation: ICoreDragOperation}
impl RtActivatable<IActivationFactory> for CoreDragOperation {}
DEFINE_CLSID!(CoreDragOperation: "Windows.ApplicationModel.DataTransfer.DragDrop.Core.CoreDragOperation");
DEFINE_IID!(IID_ICoreDragOperation2, 2185961004, 55706, 20419, 133, 7, 108, 24, 47, 51, 180, 106);
RT_INTERFACE!{interface ICoreDragOperation2(ICoreDragOperation2Vtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragOperation2] {
    fn get_AllowedOperations(&self, out: *mut super::super::DataPackageOperation) -> HRESULT,
    fn put_AllowedOperations(&self, value: super::super::DataPackageOperation) -> HRESULT
}}
impl ICoreDragOperation2 {
    #[inline] pub unsafe fn get_allowed_operations(&self) -> Result<super::super::DataPackageOperation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowedOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allowed_operations(&self, value: super::super::DataPackageOperation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowedOperations)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum CoreDragUIContentMode: u32 {
    Auto (CoreDragUIContentMode_Auto) = 0, Deferred (CoreDragUIContentMode_Deferred) = 1,
}}
DEFINE_IID!(IID_ICoreDragUIOverride, 2309509220, 13193, 20303, 136, 151, 126, 138, 63, 251, 60, 147);
RT_INTERFACE!{interface ICoreDragUIOverride(ICoreDragUIOverrideVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDragUIOverride] {
    #[cfg(not(feature="windows-graphics"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmap(&self, softwareBitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> HRESULT,
    #[cfg(not(feature="windows-graphics"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-graphics")] fn SetContentFromSoftwareBitmapWithAnchorPoint(&self, softwareBitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap, anchorPoint: ::rt::gen::windows::foundation::Point) -> HRESULT,
    fn get_IsContentVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsContentVisible(&self, value: bool) -> HRESULT,
    fn get_Caption(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Caption(&self, value: HSTRING) -> HRESULT,
    fn get_IsCaptionVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsCaptionVisible(&self, value: bool) -> HRESULT,
    fn get_IsGlyphVisible(&self, out: *mut bool) -> HRESULT,
    fn put_IsGlyphVisible(&self, value: bool) -> HRESULT,
    fn Clear(&self) -> HRESULT
}}
impl ICoreDragUIOverride {
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_content_from_software_bitmap(&self, softwareBitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromSoftwareBitmap)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_content_from_software_bitmap_with_anchor_point(&self, softwareBitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap, anchorPoint: ::rt::gen::windows::foundation::Point) -> Result<()> {
        let hr = ((*self.lpVtbl).SetContentFromSoftwareBitmapWithAnchorPoint)(self as *const _ as *mut _, softwareBitmap as *const _ as *mut _, anchorPoint);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_content_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsContentVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_content_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsContentVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_caption(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Caption)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_caption(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Caption)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_caption_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsCaptionVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_caption_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsCaptionVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_glyph_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsGlyphVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_glyph_visible(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsGlyphVisible)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Clear)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CoreDragUIOverride: ICoreDragUIOverride}
DEFINE_IID!(IID_ICoreDropOperationTarget, 3641860502, 19547, 16765, 187, 55, 118, 56, 29, 239, 141, 180);
RT_INTERFACE!{interface ICoreDropOperationTarget(ICoreDropOperationTargetVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDropOperationTarget] {
    fn EnterAsync(&self, dragInfo: *mut CoreDragInfo, dragUIOverride: *mut CoreDragUIOverride, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>) -> HRESULT,
    fn OverAsync(&self, dragInfo: *mut CoreDragInfo, dragUIOverride: *mut CoreDragUIOverride, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>) -> HRESULT,
    fn LeaveAsync(&self, dragInfo: *mut CoreDragInfo, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn DropAsync(&self, dragInfo: *mut CoreDragInfo, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>) -> HRESULT
}}
impl ICoreDropOperationTarget {
    #[inline] pub unsafe fn enter_async(&self, dragInfo: &CoreDragInfo, dragUIOverride: &CoreDragUIOverride) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).EnterAsync)(self as *const _ as *mut _, dragInfo as *const _ as *mut _, dragUIOverride as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn over_async(&self, dragInfo: &CoreDragInfo, dragUIOverride: &CoreDragUIOverride) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).OverAsync)(self as *const _ as *mut _, dragInfo as *const _ as *mut _, dragUIOverride as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn leave_async(&self, dragInfo: &CoreDragInfo) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LeaveAsync)(self as *const _ as *mut _, dragInfo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn drop_async(&self, dragInfo: &CoreDragInfo) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::super::DataPackageOperation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DropAsync)(self as *const _ as *mut _, dragInfo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICoreDropOperationTargetRequestedEventArgs, 717918874, 24104, 20134, 130, 158, 41, 19, 78, 102, 93, 109);
RT_INTERFACE!{interface ICoreDropOperationTargetRequestedEventArgs(ICoreDropOperationTargetRequestedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreDropOperationTargetRequestedEventArgs] {
    fn SetTarget(&self, target: *mut ICoreDropOperationTarget) -> HRESULT
}}
impl ICoreDropOperationTargetRequestedEventArgs {
    #[inline] pub unsafe fn set_target(&self, target: &ICoreDropOperationTarget) -> Result<()> {
        let hr = ((*self.lpVtbl).SetTarget)(self as *const _ as *mut _, target as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class CoreDropOperationTargetRequestedEventArgs: ICoreDropOperationTargetRequestedEventArgs}
} // Windows.ApplicationModel.DataTransfer.DragDrop.Core
} // Windows.ApplicationModel.DataTransfer.DragDrop
pub mod sharetarget { // Windows.ApplicationModel.DataTransfer.ShareTarget
use ::prelude::*;
DEFINE_IID!(IID_IQuickLink, 1614693128, 61630, 19164, 172, 201, 139, 39, 171, 156, 245, 86);
RT_INTERFACE!{interface IQuickLink(IQuickLinkVtbl): IInspectable(IInspectableVtbl) [IID_IQuickLink] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Thumbnail(&self, out: *mut *mut ::rt::gen::windows::storage::streams::RandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Thumbnail(&self, value: *mut ::rt::gen::windows::storage::streams::RandomAccessStreamReference) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_SupportedDataFormats(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_SupportedFileTypes(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IQuickLink {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_thumbnail(&self) -> Result<ComPtr<::rt::gen::windows::storage::streams::RandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Thumbnail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_thumbnail(&self, value: &::rt::gen::windows::storage::streams::RandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Thumbnail)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_data_formats(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedDataFormats)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_file_types(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedFileTypes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class QuickLink: IQuickLink}
impl RtActivatable<IActivationFactory> for QuickLink {}
DEFINE_CLSID!(QuickLink: "Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink");
DEFINE_IID!(IID_IShareOperation, 575060664, 53496, 16833, 168, 42, 65, 55, 219, 101, 4, 251);
RT_INTERFACE!{interface IShareOperation(IShareOperationVtbl): IInspectable(IInspectableVtbl) [IID_IShareOperation] {
    fn get_Data(&self, out: *mut *mut super::DataPackageView) -> HRESULT,
    fn get_QuickLinkId(&self, out: *mut HSTRING) -> HRESULT,
    fn RemoveThisQuickLink(&self) -> HRESULT,
    fn ReportStarted(&self) -> HRESULT,
    fn ReportDataRetrieved(&self) -> HRESULT,
    fn ReportSubmittedBackgroundTask(&self) -> HRESULT,
    fn ReportCompletedWithQuickLink(&self, quicklink: *mut QuickLink) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT,
    fn ReportError(&self, value: HSTRING) -> HRESULT
}}
impl IShareOperation {
    #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::DataPackageView>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_quick_link_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QuickLinkId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_this_quick_link(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RemoveThisQuickLink)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_started(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportStarted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_data_retrieved(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportDataRetrieved)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_submitted_background_task(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportSubmittedBackgroundTask)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_with_quick_link(&self, quicklink: &QuickLink) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompletedWithQuickLink)(self as *const _ as *mut _, quicklink as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_error(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportError)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ShareOperation: IShareOperation}
DEFINE_IID!(IID_IShareOperation2, 268146625, 38776, 18953, 142, 91, 203, 94, 72, 45, 5, 85);
RT_INTERFACE!{interface IShareOperation2(IShareOperation2Vtbl): IInspectable(IInspectableVtbl) [IID_IShareOperation2] {
    fn DismissUI(&self) -> HRESULT
}}
impl IShareOperation2 {
    #[inline] pub unsafe fn dismiss_ui(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).DismissUI)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IShareOperation3, 1593226114, 47015, 17777, 162, 166, 153, 74, 3, 73, 136, 178);
RT_INTERFACE!{interface IShareOperation3(IShareOperation3Vtbl): IInspectable(IInspectableVtbl) [IID_IShareOperation3] {
    fn get_Contacts(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<super::super::contacts::Contact>) -> HRESULT
}}
impl IShareOperation3 {
    #[inline] pub unsafe fn get_contacts(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::super::contacts::Contact>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Contacts)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.DataTransfer.ShareTarget
} // Windows.ApplicationModel.DataTransfer
pub mod email { // Windows.ApplicationModel.Email
use ::prelude::*;
DEFINE_IID!(IID_IEmailAttachment, 4082354937, 22472, 19163, 185, 146, 96, 252, 235, 88, 79, 84);
RT_INTERFACE!{interface IEmailAttachment(IEmailAttachmentVtbl): IInspectable(IInspectableVtbl) [IID_IEmailAttachment] {
    fn get_FileName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_FileName(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_Data(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Data(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT
}}
impl IEmailAttachment {
    #[inline] pub unsafe fn get_file_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FileName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_file_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FileName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_data(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Data)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_data(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Data)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailAttachment: IEmailAttachment}
impl RtActivatable<IEmailAttachmentFactory> for EmailAttachment {}
impl RtActivatable<IEmailAttachmentFactory2> for EmailAttachment {}
impl RtActivatable<IActivationFactory> for EmailAttachment {}
impl EmailAttachment {
    #[cfg(feature="windows-storage")] #[inline] pub fn create(fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<EmailAttachment>> { unsafe {
        <Self as RtActivatable<IEmailAttachmentFactory>>::get_activation_factory().create(fileName, data)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create2(fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference, mimeType: &HStringArg) -> Result<ComPtr<EmailAttachment>> { unsafe {
        <Self as RtActivatable<IEmailAttachmentFactory2>>::get_activation_factory().create(fileName, data, mimeType)
    }}
}
DEFINE_CLSID!(EmailAttachment: "Windows.ApplicationModel.Email.EmailAttachment");
DEFINE_IID!(IID_IEmailAttachment2, 576655472, 45311, 17777, 157, 84, 167, 6, 196, 141, 85, 198);
RT_INTERFACE!{interface IEmailAttachment2(IEmailAttachment2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailAttachment2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ContentId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentId(&self, value: HSTRING) -> HRESULT,
    fn get_ContentLocation(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentLocation(&self, value: HSTRING) -> HRESULT,
    fn get_DownloadState(&self, out: *mut EmailAttachmentDownloadState) -> HRESULT,
    fn put_DownloadState(&self, value: EmailAttachmentDownloadState) -> HRESULT,
    fn get_EstimatedDownloadSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn put_EstimatedDownloadSizeInBytes(&self, value: u64) -> HRESULT,
    fn get_IsFromBaseMessage(&self, out: *mut bool) -> HRESULT,
    fn get_IsInline(&self, out: *mut bool) -> HRESULT,
    fn put_IsInline(&self, value: bool) -> HRESULT,
    fn get_MimeType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MimeType(&self, value: HSTRING) -> HRESULT
}}
impl IEmailAttachment2 {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_location(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentLocation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_location(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentLocation)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_state(&self) -> Result<EmailAttachmentDownloadState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DownloadState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_download_state(&self, value: EmailAttachmentDownloadState) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DownloadState)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_estimated_download_size_in_bytes(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EstimatedDownloadSizeInBytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_estimated_download_size_in_bytes(&self, value: u64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EstimatedDownloadSizeInBytes)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_from_base_message(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsFromBaseMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_inline(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsInline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_inline(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsInline)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mime_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MimeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mime_type(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MimeType)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailAttachmentDownloadState: i32 {
    NotDownloaded (EmailAttachmentDownloadState_NotDownloaded) = 0, Downloading (EmailAttachmentDownloadState_Downloading) = 1, Downloaded (EmailAttachmentDownloadState_Downloaded) = 2, Failed (EmailAttachmentDownloadState_Failed) = 3,
}}
DEFINE_IID!(IID_IEmailAttachmentFactory, 2037296198, 60758, 18809, 135, 8, 171, 184, 188, 133, 75, 125);
RT_INTERFACE!{static interface IEmailAttachmentFactory(IEmailAttachmentFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IEmailAttachmentFactory] {
    #[cfg(feature="windows-storage")] fn Create(&self, fileName: HSTRING, data: *mut super::super::storage::streams::IRandomAccessStreamReference, out: *mut *mut EmailAttachment) -> HRESULT
}}
impl IEmailAttachmentFactory {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn create(&self, fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<EmailAttachment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, fileName.get(), data as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailAttachmentFactory2, 589665333, 20985, 17021, 173, 205, 36, 16, 35, 200, 207, 183);
RT_INTERFACE!{static interface IEmailAttachmentFactory2(IEmailAttachmentFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailAttachmentFactory2] {
    #[cfg(feature="windows-storage")] fn Create(&self, fileName: HSTRING, data: *mut super::super::storage::streams::IRandomAccessStreamReference, mimeType: HSTRING, out: *mut *mut EmailAttachment) -> HRESULT
}}
impl IEmailAttachmentFactory2 {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn create(&self, fileName: &HStringArg, data: &super::super::storage::streams::IRandomAccessStreamReference, mimeType: &HStringArg) -> Result<ComPtr<EmailAttachment>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, fileName.get(), data as *const _ as *mut _, mimeType.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailBatchStatus: i32 {
    Success (EmailBatchStatus_Success) = 0, ServerSearchSyncManagerError (EmailBatchStatus_ServerSearchSyncManagerError) = 1, ServerSearchUnknownError (EmailBatchStatus_ServerSearchUnknownError) = 2,
}}
RT_ENUM! { enum EmailCertificateValidationStatus: i32 {
    Success (EmailCertificateValidationStatus_Success) = 0, NoMatch (EmailCertificateValidationStatus_NoMatch) = 1, InvalidUsage (EmailCertificateValidationStatus_InvalidUsage) = 2, InvalidCertificate (EmailCertificateValidationStatus_InvalidCertificate) = 3, Revoked (EmailCertificateValidationStatus_Revoked) = 4, ChainRevoked (EmailCertificateValidationStatus_ChainRevoked) = 5, RevocationServerFailure (EmailCertificateValidationStatus_RevocationServerFailure) = 6, Expired (EmailCertificateValidationStatus_Expired) = 7, Untrusted (EmailCertificateValidationStatus_Untrusted) = 8, ServerError (EmailCertificateValidationStatus_ServerError) = 9, UnknownFailure (EmailCertificateValidationStatus_UnknownFailure) = 10,
}}
DEFINE_IID!(IID_IEmailConversation, 3659055688, 41148, 17225, 144, 45, 144, 246, 99, 137, 245, 27);
RT_INTERFACE!{interface IEmailConversation(IEmailConversationVtbl): IInspectable(IInspectableVtbl) [IID_IEmailConversation] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FlagState(&self, out: *mut EmailFlagState) -> HRESULT,
    fn get_HasAttachment(&self, out: *mut bool) -> HRESULT,
    fn get_Importance(&self, out: *mut EmailImportance) -> HRESULT,
    fn get_LastEmailResponseKind(&self, out: *mut EmailMessageResponseKind) -> HRESULT,
    fn get_MessageCount(&self, out: *mut u32) -> HRESULT,
    fn get_MostRecentMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_MostRecentMessageTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_Preview(&self, out: *mut HSTRING) -> HRESULT,
    fn get_LatestSender(&self, out: *mut *mut EmailRecipient) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UnreadMessageCount(&self, out: *mut u32) -> HRESULT,
    fn FindMessagesAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMessage>>) -> HRESULT,
    fn FindMessagesWithCountAsync(&self, count: u32, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMessage>>) -> HRESULT
}}
impl IEmailConversation {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flag_state(&self) -> Result<EmailFlagState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FlagState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_attachment(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasAttachment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_importance(&self) -> Result<EmailImportance> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Importance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_email_response_kind(&self) -> Result<EmailMessageResponseKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastEmailResponseKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_count(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MessageCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_most_recent_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MostRecentMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_most_recent_message_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MostRecentMessageTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_preview(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Preview)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_latest_sender(&self) -> Result<ComPtr<EmailRecipient>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LatestSender)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unread_message_count(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_UnreadMessageCount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_messages_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMessage>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindMessagesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_messages_with_count_async(&self, count: u32) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMessage>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindMessagesWithCountAsync)(self as *const _ as *mut _, count, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailConversation: IEmailConversation}
DEFINE_IID!(IID_IEmailConversationBatch, 3099700097, 453, 17194, 157, 241, 254, 133, 217, 138, 39, 154);
RT_INTERFACE!{interface IEmailConversationBatch(IEmailConversationBatchVtbl): IInspectable(IInspectableVtbl) [IID_IEmailConversationBatch] {
    fn get_Conversations(&self, out: *mut *mut super::super::foundation::collections::IVectorView<EmailConversation>) -> HRESULT,
    fn get_Status(&self, out: *mut EmailBatchStatus) -> HRESULT
}}
impl IEmailConversationBatch {
    #[inline] pub unsafe fn get_conversations(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<EmailConversation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Conversations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<EmailBatchStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class EmailConversationBatch: IEmailConversationBatch}
DEFINE_IID!(IID_IEmailConversationReader, 3026390914, 10357, 17608, 155, 140, 133, 190, 179, 163, 198, 83);
RT_INTERFACE!{interface IEmailConversationReader(IEmailConversationReaderVtbl): IInspectable(IInspectableVtbl) [IID_IEmailConversationReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<EmailConversationBatch>) -> HRESULT
}}
impl IEmailConversationReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailConversationBatch>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailConversationReader: IEmailConversationReader}
RT_ENUM! { enum EmailFlagState: i32 {
    Unflagged (EmailFlagState_Unflagged) = 0, Flagged (EmailFlagState_Flagged) = 1, Completed (EmailFlagState_Completed) = 2, Cleared (EmailFlagState_Cleared) = 3,
}}
DEFINE_IID!(IID_IEmailFolder, 2723116913, 39276, 18532, 177, 186, 237, 18, 64, 229, 125, 17);
RT_INTERFACE!{interface IEmailFolder(IEmailFolderVtbl): IInspectable(IInspectableVtbl) [IID_IEmailFolder] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_MailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParentFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_IsSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_Kind(&self, out: *mut EmailSpecialFolderKind) -> HRESULT,
    fn CreateFolderAsync(&self, name: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailFolder>) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn FindChildFoldersAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailFolder>>) -> HRESULT,
    fn GetConversationReader(&self, out: *mut *mut EmailConversationReader) -> HRESULT,
    fn GetConversationReaderWithOptions(&self, options: *mut EmailQueryOptions, out: *mut *mut EmailConversationReader) -> HRESULT,
    fn GetMessageAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMessage>) -> HRESULT,
    fn GetMessageReader(&self, out: *mut *mut EmailMessageReader) -> HRESULT,
    fn GetMessageReaderWithOptions(&self, options: *mut EmailQueryOptions, out: *mut *mut EmailMessageReader) -> HRESULT,
    fn GetMessageCountsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<EmailItemCounts>) -> HRESULT,
    fn TryMoveAsync(&self, newParentFolder: *mut EmailFolder, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryMoveWithNewNameAsync(&self, newParentFolder: *mut EmailFolder, newFolderName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TrySaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn SaveMessageAsync(&self, message: *mut EmailMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailFolder {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parent_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ParentFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_sync_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSyncEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_sync_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSyncEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_successful_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastSuccessfulSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_successful_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastSuccessfulSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<EmailSpecialFolderKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_folder_async(&self, name: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailFolder>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateFolderAsync)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_child_folders_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailFolder>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindChildFoldersAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader(&self) -> Result<ComPtr<EmailConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader_with_options(&self, options: &EmailQueryOptions) -> Result<ComPtr<EmailConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader(&self) -> Result<ComPtr<EmailMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader_with_options(&self, options: &EmailQueryOptions) -> Result<ComPtr<EmailMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_counts_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailItemCounts>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageCountsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_move_async(&self, newParentFolder: &EmailFolder) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryMoveAsync)(self as *const _ as *mut _, newParentFolder as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_move_with_new_name_async(&self, newParentFolder: &EmailFolder, newFolderName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryMoveWithNewNameAsync)(self as *const _ as *mut _, newParentFolder as *const _ as *mut _, newFolderName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_message_async(&self, message: &EmailMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveMessageAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailFolder: IEmailFolder}
RT_ENUM! { enum EmailImportance: i32 {
    Normal (EmailImportance_Normal) = 0, High (EmailImportance_High) = 1, Low (EmailImportance_Low) = 2,
}}
DEFINE_IID!(IID_IEmailIrmInfo, 2431984019, 45472, 20157, 166, 182, 221, 202, 85, 96, 110, 14);
RT_INTERFACE!{interface IEmailIrmInfo(IEmailIrmInfoVtbl): IInspectable(IInspectableVtbl) [IID_IEmailIrmInfo] {
    fn get_CanEdit(&self, out: *mut bool) -> HRESULT,
    fn put_CanEdit(&self, value: bool) -> HRESULT,
    fn get_CanExtractData(&self, out: *mut bool) -> HRESULT,
    fn put_CanExtractData(&self, value: bool) -> HRESULT,
    fn get_CanForward(&self, out: *mut bool) -> HRESULT,
    fn put_CanForward(&self, value: bool) -> HRESULT,
    fn get_CanModifyRecipientsOnResponse(&self, out: *mut bool) -> HRESULT,
    fn put_CanModifyRecipientsOnResponse(&self, value: bool) -> HRESULT,
    fn get_CanPrintData(&self, out: *mut bool) -> HRESULT,
    fn put_CanPrintData(&self, value: bool) -> HRESULT,
    fn get_CanRemoveIrmOnResponse(&self, out: *mut bool) -> HRESULT,
    fn put_CanRemoveIrmOnResponse(&self, value: bool) -> HRESULT,
    fn get_CanReply(&self, out: *mut bool) -> HRESULT,
    fn put_CanReply(&self, value: bool) -> HRESULT,
    fn get_CanReplyAll(&self, out: *mut bool) -> HRESULT,
    fn put_CanReplyAll(&self, value: bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_ExpirationDate(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_IsIrmOriginator(&self, out: *mut bool) -> HRESULT,
    fn put_IsIrmOriginator(&self, value: bool) -> HRESULT,
    fn get_IsProgramaticAccessAllowed(&self, out: *mut bool) -> HRESULT,
    fn put_IsProgramaticAccessAllowed(&self, value: bool) -> HRESULT,
    fn get_Template(&self, out: *mut *mut EmailIrmTemplate) -> HRESULT,
    fn put_Template(&self, value: *mut EmailIrmTemplate) -> HRESULT
}}
impl IEmailIrmInfo {
    #[inline] pub unsafe fn get_can_edit(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanEdit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_edit(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanEdit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_extract_data(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanExtractData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_extract_data(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanExtractData)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_forward(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanForward)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_forward(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanForward)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_modify_recipients_on_response(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanModifyRecipientsOnResponse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_modify_recipients_on_response(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanModifyRecipientsOnResponse)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_print_data(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanPrintData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_print_data(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanPrintData)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_remove_irm_on_response(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanRemoveIrmOnResponse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_remove_irm_on_response(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanRemoveIrmOnResponse)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_reply(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanReply)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_reply(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanReply)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_reply_all(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanReplyAll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_reply_all(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanReplyAll)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_expiration_date(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExpirationDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_expiration_date(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExpirationDate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_irm_originator(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsIrmOriginator)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_irm_originator(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsIrmOriginator)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_programatic_access_allowed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsProgramaticAccessAllowed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_programatic_access_allowed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsProgramaticAccessAllowed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_template(&self) -> Result<ComPtr<EmailIrmTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Template)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_template(&self, value: &EmailIrmTemplate) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Template)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailIrmInfo: IEmailIrmInfo}
impl RtActivatable<IEmailIrmInfoFactory> for EmailIrmInfo {}
impl RtActivatable<IActivationFactory> for EmailIrmInfo {}
impl EmailIrmInfo {
    #[inline] pub fn create(expiration: super::super::foundation::DateTime, irmTemplate: &EmailIrmTemplate) -> Result<ComPtr<EmailIrmInfo>> { unsafe {
        <Self as RtActivatable<IEmailIrmInfoFactory>>::get_activation_factory().create(expiration, irmTemplate)
    }}
}
DEFINE_CLSID!(EmailIrmInfo: "Windows.ApplicationModel.Email.EmailIrmInfo");
DEFINE_IID!(IID_IEmailIrmInfoFactory, 827044236, 58342, 19835, 190, 141, 145, 169, 99, 17, 176, 27);
RT_INTERFACE!{static interface IEmailIrmInfoFactory(IEmailIrmInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IEmailIrmInfoFactory] {
    fn Create(&self, expiration: super::super::foundation::DateTime, irmTemplate: *mut EmailIrmTemplate, out: *mut *mut EmailIrmInfo) -> HRESULT
}}
impl IEmailIrmInfoFactory {
    #[inline] pub unsafe fn create(&self, expiration: super::super::foundation::DateTime, irmTemplate: &EmailIrmTemplate) -> Result<ComPtr<EmailIrmInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, expiration, irmTemplate as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailIrmTemplate, 4079449485, 21613, 19434, 169, 99, 84, 163, 139, 44, 192, 22);
RT_INTERFACE!{interface IEmailIrmTemplate(IEmailIrmTemplateVtbl): IInspectable(IInspectableVtbl) [IID_IEmailIrmTemplate] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Id(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT
}}
impl IEmailIrmTemplate {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Id)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailIrmTemplate: IEmailIrmTemplate}
impl RtActivatable<IEmailIrmTemplateFactory> for EmailIrmTemplate {}
impl RtActivatable<IActivationFactory> for EmailIrmTemplate {}
impl EmailIrmTemplate {
    #[inline] pub fn create(id: &HStringArg, name: &HStringArg, description: &HStringArg) -> Result<ComPtr<EmailIrmTemplate>> { unsafe {
        <Self as RtActivatable<IEmailIrmTemplateFactory>>::get_activation_factory().create(id, name, description)
    }}
}
DEFINE_CLSID!(EmailIrmTemplate: "Windows.ApplicationModel.Email.EmailIrmTemplate");
DEFINE_IID!(IID_IEmailIrmTemplateFactory, 1034098806, 34616, 17432, 185, 203, 71, 27, 147, 111, 231, 30);
RT_INTERFACE!{static interface IEmailIrmTemplateFactory(IEmailIrmTemplateFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IEmailIrmTemplateFactory] {
    fn Create(&self, id: HSTRING, name: HSTRING, description: HSTRING, out: *mut *mut EmailIrmTemplate) -> HRESULT
}}
impl IEmailIrmTemplateFactory {
    #[inline] pub unsafe fn create(&self, id: &HStringArg, name: &HStringArg, description: &HStringArg) -> Result<ComPtr<EmailIrmTemplate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, id.get(), name.get(), description.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailItemCounts, 1540436769, 65224, 19371, 131, 186, 11, 175, 60, 31, 108, 189);
RT_INTERFACE!{interface IEmailItemCounts(IEmailItemCountsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailItemCounts] {
    fn get_Flagged(&self, out: *mut u32) -> HRESULT,
    fn get_Important(&self, out: *mut u32) -> HRESULT,
    fn get_Total(&self, out: *mut u32) -> HRESULT,
    fn get_Unread(&self, out: *mut u32) -> HRESULT
}}
impl IEmailItemCounts {
    #[inline] pub unsafe fn get_flagged(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Flagged)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_important(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Important)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_total(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Total)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unread(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Unread)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class EmailItemCounts: IEmailItemCounts}
DEFINE_IID!(IID_IEmailMailbox, 2826503753, 53083, 16667, 128, 177, 74, 106, 20, 132, 206, 37);
RT_INTERFACE!{interface IEmailMailbox(IEmailMailboxVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailbox] {
    fn get_Capabilities(&self, out: *mut *mut EmailMailboxCapabilities) -> HRESULT,
    fn get_ChangeTracker(&self, out: *mut *mut EmailMailboxChangeTracker) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsOwnedByCurrentApp(&self, out: *mut bool) -> HRESULT,
    fn get_IsDataEncryptedUnderLock(&self, out: *mut bool) -> HRESULT,
    fn get_MailAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MailAddress(&self, value: HSTRING) -> HRESULT,
    fn get_MailAddressAliases(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut EmailMailboxOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: EmailMailboxOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut EmailMailboxOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: EmailMailboxOtherAppWriteAccess) -> HRESULT,
    fn get_Policies(&self, out: *mut *mut EmailMailboxPolicies) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SyncManager(&self, out: *mut *mut EmailMailboxSyncManager) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn GetConversationReader(&self, out: *mut *mut EmailConversationReader) -> HRESULT,
    fn GetConversationReaderWithOptions(&self, options: *mut EmailQueryOptions, out: *mut *mut EmailConversationReader) -> HRESULT,
    fn GetMessageReader(&self, out: *mut *mut EmailMessageReader) -> HRESULT,
    fn GetMessageReaderWithOptions(&self, options: *mut EmailQueryOptions, out: *mut *mut EmailMessageReader) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetConversationAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailConversation>) -> HRESULT,
    fn GetFolderAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailFolder>) -> HRESULT,
    fn GetMessageAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMessage>) -> HRESULT,
    fn GetSpecialFolderAsync(&self, folderType: EmailSpecialFolderKind, out: *mut *mut super::super::foundation::IAsyncOperation<EmailFolder>) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkMessageAsSeenAsync(&self, messageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkFolderAsSeenAsync(&self, folderId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkMessageReadAsync(&self, messageId: HSTRING, isRead: bool, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ChangeMessageFlagStateAsync(&self, messageId: HSTRING, flagState: EmailFlagState, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn TryMoveMessageAsync(&self, messageId: HSTRING, newParentFolderId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryMoveFolderAsync(&self, folderId: HSTRING, newParentFolderId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryMoveFolderWithNewNameAsync(&self, folderId: HSTRING, newParentFolderId: HSTRING, newFolderName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn DeleteMessageAsync(&self, messageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn MarkFolderSyncEnabledAsync(&self, folderId: HSTRING, isSyncEnabled: bool, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SendMessageAsync(&self, message: *mut EmailMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SaveDraftAsync(&self, message: *mut EmailMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DownloadMessageAsync(&self, messageId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DownloadAttachmentAsync(&self, attachmentId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn CreateResponseMessageAsync(&self, messageId: HSTRING, responseType: EmailMessageResponseKind, subject: HSTRING, responseHeaderType: EmailMessageBodyKind, responseHeader: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMessage>) -> HRESULT,
    fn TryUpdateMeetingResponseAsync(&self, meeting: *mut EmailMessage, response: EmailMeetingResponseType, subject: HSTRING, comment: HSTRING, sendUpdate: bool, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryForwardMeetingAsync(&self, meeting: *mut EmailMessage, recipients: *mut super::super::foundation::collections::IIterable<EmailRecipient>, subject: HSTRING, forwardHeaderType: EmailMessageBodyKind, forwardHeader: HSTRING, comment: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryProposeNewTimeForMeetingAsync(&self, meeting: *mut EmailMessage, newStartTime: super::super::foundation::DateTime, newDuration: super::super::foundation::TimeSpan, subject: HSTRING, comment: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_MailboxChanged(&self, pHandler: *mut super::super::foundation::TypedEventHandler<EmailMailbox, EmailMailboxChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MailboxChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn SmartSendMessageAsync(&self, message: *mut EmailMessage, smartSend: bool, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn TrySetAutoReplySettingsAsync(&self, autoReplySettings: *mut EmailMailboxAutoReplySettings, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryGetAutoReplySettingsAsync(&self, requestedFormat: EmailMailboxAutoReplyMessageResponseKind, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailboxAutoReplySettings>) -> HRESULT
}}
impl IEmailMailbox {
    #[inline] pub unsafe fn get_capabilities(&self) -> Result<ComPtr<EmailMailboxCapabilities>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Capabilities)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_tracker(&self) -> Result<ComPtr<EmailMailboxChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ChangeTracker)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_owned_by_current_app(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOwnedByCurrentApp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_data_encrypted_under_lock(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDataEncryptedUnderLock)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mail_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MailAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mail_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MailAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mail_address_aliases(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MailAddressAliases)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_read_access(&self) -> Result<EmailMailboxOtherAppReadAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppReadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_read_access(&self, value: EmailMailboxOtherAppReadAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppReadAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_write_access(&self) -> Result<EmailMailboxOtherAppWriteAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppWriteAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_write_access(&self, value: EmailMailboxOtherAppWriteAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppWriteAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_policies(&self) -> Result<ComPtr<EmailMailboxPolicies>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Policies)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sync_manager(&self) -> Result<ComPtr<EmailMailboxSyncManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SyncManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader(&self) -> Result<ComPtr<EmailConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader_with_options(&self, options: &EmailQueryOptions) -> Result<ComPtr<EmailConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader(&self) -> Result<ComPtr<EmailMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader_with_options(&self, options: &EmailQueryOptions) -> Result<ComPtr<EmailMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailConversation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_folder_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailFolder>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFolderAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_special_folder_async(&self, folderType: EmailSpecialFolderKind) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailFolder>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSpecialFolderAsync)(self as *const _ as *mut _, folderType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_message_as_seen_async(&self, messageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkMessageAsSeenAsync)(self as *const _ as *mut _, messageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_folder_as_seen_async(&self, folderId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkFolderAsSeenAsync)(self as *const _ as *mut _, folderId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_message_read_async(&self, messageId: &HStringArg, isRead: bool) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkMessageReadAsync)(self as *const _ as *mut _, messageId.get(), isRead, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn change_message_flag_state_async(&self, messageId: &HStringArg, flagState: EmailFlagState) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ChangeMessageFlagStateAsync)(self as *const _ as *mut _, messageId.get(), flagState, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_move_message_async(&self, messageId: &HStringArg, newParentFolderId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryMoveMessageAsync)(self as *const _ as *mut _, messageId.get(), newParentFolderId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_move_folder_async(&self, folderId: &HStringArg, newParentFolderId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryMoveFolderAsync)(self as *const _ as *mut _, folderId.get(), newParentFolderId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_move_folder_with_new_name_async(&self, folderId: &HStringArg, newParentFolderId: &HStringArg, newFolderName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryMoveFolderWithNewNameAsync)(self as *const _ as *mut _, folderId.get(), newParentFolderId.get(), newFolderName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_message_async(&self, messageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteMessageAsync)(self as *const _ as *mut _, messageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn mark_folder_sync_enabled_async(&self, folderId: &HStringArg, isSyncEnabled: bool) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).MarkFolderSyncEnabledAsync)(self as *const _ as *mut _, folderId.get(), isSyncEnabled, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn send_message_async(&self, message: &EmailMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SendMessageAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_draft_async(&self, message: &EmailMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveDraftAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn download_message_async(&self, messageId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DownloadMessageAsync)(self as *const _ as *mut _, messageId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn download_attachment_async(&self, attachmentId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DownloadAttachmentAsync)(self as *const _ as *mut _, attachmentId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_response_message_async(&self, messageId: &HStringArg, responseType: EmailMessageResponseKind, subject: &HStringArg, responseHeaderType: EmailMessageBodyKind, responseHeader: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResponseMessageAsync)(self as *const _ as *mut _, messageId.get(), responseType, subject.get(), responseHeaderType, responseHeader.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_update_meeting_response_async(&self, meeting: &EmailMessage, response: EmailMeetingResponseType, subject: &HStringArg, comment: &HStringArg, sendUpdate: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryUpdateMeetingResponseAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, response, subject.get(), comment.get(), sendUpdate, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_forward_meeting_async(&self, meeting: &EmailMessage, recipients: &super::super::foundation::collections::IIterable<EmailRecipient>, subject: &HStringArg, forwardHeaderType: EmailMessageBodyKind, forwardHeader: &HStringArg, comment: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryForwardMeetingAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, recipients as *const _ as *mut _, subject.get(), forwardHeaderType, forwardHeader.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_propose_new_time_for_meeting_async(&self, meeting: &EmailMessage, newStartTime: super::super::foundation::DateTime, newDuration: super::super::foundation::TimeSpan, subject: &HStringArg, comment: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryProposeNewTimeForMeetingAsync)(self as *const _ as *mut _, meeting as *const _ as *mut _, newStartTime, newDuration, subject.get(), comment.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_mailbox_changed(&self, pHandler: &super::super::foundation::TypedEventHandler<EmailMailbox, EmailMailboxChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MailboxChanged)(self as *const _ as *mut _, pHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_mailbox_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MailboxChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn smart_send_message_async(&self, message: &EmailMessage, smartSend: bool) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SmartSendMessageAsync)(self as *const _ as *mut _, message as *const _ as *mut _, smartSend, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_set_auto_reply_settings_async(&self, autoReplySettings: &EmailMailboxAutoReplySettings) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySetAutoReplySettingsAsync)(self as *const _ as *mut _, autoReplySettings as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_get_auto_reply_settings_async(&self, requestedFormat: EmailMailboxAutoReplyMessageResponseKind) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailboxAutoReplySettings>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryGetAutoReplySettingsAsync)(self as *const _ as *mut _, requestedFormat, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailbox: IEmailMailbox}
DEFINE_IID!(IID_IEmailMailbox2, 351855620, 27810, 19122, 146, 65, 121, 205, 123, 244, 99, 70);
RT_INTERFACE!{interface IEmailMailbox2(IEmailMailbox2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailbox2] {
    fn get_LinkedMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NetworkAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NetworkId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IEmailMailbox2 {
    #[inline] pub unsafe fn get_linked_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinkedMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_network_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NetworkAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_network_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NetworkId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailbox3, 1034258811, 17803, 16522, 142, 55, 172, 139, 5, 216, 175, 86);
RT_INTERFACE!{interface IEmailMailbox3(IEmailMailbox3Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailbox3] {
    fn ResolveRecipientsAsync(&self, recipients: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailRecipientResolutionResult>>) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn ValidateCertificatesAsync(&self, certificates: *mut super::super::foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate>, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailCertificateValidationStatus>>) -> HRESULT,
    fn TryEmptyFolderAsync(&self, folderId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailboxEmptyFolderStatus>) -> HRESULT,
    fn TryCreateFolderAsync(&self, parentFolderId: HSTRING, name: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailboxCreateFolderResult>) -> HRESULT,
    fn TryDeleteFolderAsync(&self, folderId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailboxDeleteFolderStatus>) -> HRESULT
}}
impl IEmailMailbox3 {
    #[inline] pub unsafe fn resolve_recipients_async(&self, recipients: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailRecipientResolutionResult>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ResolveRecipientsAsync)(self as *const _ as *mut _, recipients as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn validate_certificates_async(&self, certificates: &super::super::foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailCertificateValidationStatus>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ValidateCertificatesAsync)(self as *const _ as *mut _, certificates as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_empty_folder_async(&self, folderId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailboxEmptyFolderStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryEmptyFolderAsync)(self as *const _ as *mut _, folderId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_create_folder_async(&self, parentFolderId: &HStringArg, name: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailboxCreateFolderResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCreateFolderAsync)(self as *const _ as *mut _, parentFolderId.get(), name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_delete_folder_async(&self, folderId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailboxDeleteFolderStatus>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryDeleteFolderAsync)(self as *const _ as *mut _, folderId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailbox4, 1562325019, 61986, 18599, 183, 182, 113, 99, 86, 205, 38, 161);
RT_INTERFACE!{interface IEmailMailbox4(IEmailMailbox4Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailbox4] {
    fn RegisterSyncManagerAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailbox4 {
    #[inline] pub unsafe fn register_sync_manager_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterSyncManagerAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailbox5, 966160519, 146, 18878, 189, 14, 93, 77, 201, 217, 109, 144);
RT_INTERFACE!{interface IEmailMailbox5(IEmailMailbox5Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailbox5] {
    fn GetChangeTracker(&self, identity: HSTRING, out: *mut *mut EmailMailboxChangeTracker) -> HRESULT
}}
impl IEmailMailbox5 {
    #[inline] pub unsafe fn get_change_tracker(&self, identity: &HStringArg) -> Result<ComPtr<EmailMailboxChangeTracker>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeTracker)(self as *const _ as *mut _, identity.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailboxAction, 2895677946, 8698, 18727, 146, 16, 212, 16, 88, 47, 223, 62);
RT_INTERFACE!{interface IEmailMailboxAction(IEmailMailboxActionVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxAction] {
    fn get_Kind(&self, out: *mut EmailMailboxActionKind) -> HRESULT,
    fn get_ChangeNumber(&self, out: *mut u64) -> HRESULT
}}
impl IEmailMailboxAction {
    #[inline] pub unsafe fn get_kind(&self) -> Result<EmailMailboxActionKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_number(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxAction: IEmailMailboxAction}
RT_ENUM! { enum EmailMailboxActionKind: i32 {
    MarkMessageAsSeen (EmailMailboxActionKind_MarkMessageAsSeen) = 0, MarkMessageRead (EmailMailboxActionKind_MarkMessageRead) = 1, ChangeMessageFlagState (EmailMailboxActionKind_ChangeMessageFlagState) = 2, MoveMessage (EmailMailboxActionKind_MoveMessage) = 3, SaveDraft (EmailMailboxActionKind_SaveDraft) = 4, SendMessage (EmailMailboxActionKind_SendMessage) = 5, CreateResponseReplyMessage (EmailMailboxActionKind_CreateResponseReplyMessage) = 6, CreateResponseReplyAllMessage (EmailMailboxActionKind_CreateResponseReplyAllMessage) = 7, CreateResponseForwardMessage (EmailMailboxActionKind_CreateResponseForwardMessage) = 8, MoveFolder (EmailMailboxActionKind_MoveFolder) = 9, MarkFolderForSyncEnabled (EmailMailboxActionKind_MarkFolderForSyncEnabled) = 10,
}}
RT_ENUM! { enum EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation: i32 {
    None (EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation_None) = 0, StrongAlgorithm (EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation_StrongAlgorithm) = 1, AnyAlgorithm (EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation_AnyAlgorithm) = 2,
}}
DEFINE_IID!(IID_IEmailMailboxAutoReply, 3793954124, 35508, 18523, 179, 31, 4, 209, 84, 118, 189, 89);
RT_INTERFACE!{interface IEmailMailboxAutoReply(IEmailMailboxAutoReplyVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxAutoReply] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_Response(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Response(&self, value: HSTRING) -> HRESULT
}}
impl IEmailMailboxAutoReply {
    #[inline] pub unsafe fn get_is_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_response(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Response)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_response(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Response)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxAutoReply: IEmailMailboxAutoReply}
RT_ENUM! { enum EmailMailboxAutoReplyMessageResponseKind: i32 {
    Html (EmailMailboxAutoReplyMessageResponseKind_Html) = 0, PlainText (EmailMailboxAutoReplyMessageResponseKind_PlainText) = 1,
}}
DEFINE_IID!(IID_IEmailMailboxAutoReplySettings, 2826608552, 2758, 19319, 186, 119, 166, 185, 158, 154, 39, 184);
RT_INTERFACE!{interface IEmailMailboxAutoReplySettings(IEmailMailboxAutoReplySettingsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxAutoReplySettings] {
    fn get_IsEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsEnabled(&self, value: bool) -> HRESULT,
    fn get_ResponseKind(&self, out: *mut EmailMailboxAutoReplyMessageResponseKind) -> HRESULT,
    fn put_ResponseKind(&self, value: EmailMailboxAutoReplyMessageResponseKind) -> HRESULT,
    fn get_StartTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_StartTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_EndTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_EndTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_InternalReply(&self, out: *mut *mut EmailMailboxAutoReply) -> HRESULT,
    fn get_KnownExternalReply(&self, out: *mut *mut EmailMailboxAutoReply) -> HRESULT,
    fn get_UnknownExternalReply(&self, out: *mut *mut EmailMailboxAutoReply) -> HRESULT
}}
impl IEmailMailboxAutoReplySettings {
    #[inline] pub unsafe fn get_is_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_response_kind(&self) -> Result<EmailMailboxAutoReplyMessageResponseKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ResponseKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_response_kind(&self, value: EmailMailboxAutoReplyMessageResponseKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ResponseKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_end_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EndTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_end_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EndTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_internal_reply(&self) -> Result<ComPtr<EmailMailboxAutoReply>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InternalReply)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_known_external_reply(&self) -> Result<ComPtr<EmailMailboxAutoReply>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_KnownExternalReply)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unknown_external_reply(&self) -> Result<ComPtr<EmailMailboxAutoReply>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UnknownExternalReply)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxAutoReplySettings: IEmailMailboxAutoReplySettings}
impl RtActivatable<IActivationFactory> for EmailMailboxAutoReplySettings {}
DEFINE_CLSID!(EmailMailboxAutoReplySettings: "Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings");
DEFINE_IID!(IID_IEmailMailboxCapabilities, 4007576486, 35291, 17157, 130, 196, 67, 158, 10, 51, 218, 17);
RT_INTERFACE!{interface IEmailMailboxCapabilities(IEmailMailboxCapabilitiesVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxCapabilities] {
    fn get_CanForwardMeetings(&self, out: *mut bool) -> HRESULT,
    fn get_CanGetAndSetExternalAutoReplies(&self, out: *mut bool) -> HRESULT,
    fn get_CanGetAndSetInternalAutoReplies(&self, out: *mut bool) -> HRESULT,
    fn get_CanUpdateMeetingResponses(&self, out: *mut bool) -> HRESULT,
    fn get_CanServerSearchFolders(&self, out: *mut bool) -> HRESULT,
    fn get_CanServerSearchMailbox(&self, out: *mut bool) -> HRESULT,
    fn get_CanProposeNewTimeForMeetings(&self, out: *mut bool) -> HRESULT,
    fn get_CanSmartSend(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMailboxCapabilities {
    #[inline] pub unsafe fn get_can_forward_meetings(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanForwardMeetings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_get_and_set_external_auto_replies(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanGetAndSetExternalAutoReplies)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_get_and_set_internal_auto_replies(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanGetAndSetInternalAutoReplies)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_update_meeting_responses(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanUpdateMeetingResponses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_server_search_folders(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanServerSearchFolders)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_server_search_mailbox(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanServerSearchMailbox)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_propose_new_time_for_meetings(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanProposeNewTimeForMeetings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_smart_send(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanSmartSend)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxCapabilities: IEmailMailboxCapabilities}
DEFINE_IID!(IID_IEmailMailboxCapabilities2, 1769094884, 12065, 19644, 136, 171, 46, 118, 2, 164, 128, 107);
RT_INTERFACE!{interface IEmailMailboxCapabilities2(IEmailMailboxCapabilities2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxCapabilities2] {
    fn get_CanResolveRecipients(&self, out: *mut bool) -> HRESULT,
    fn get_CanValidateCertificates(&self, out: *mut bool) -> HRESULT,
    fn get_CanEmptyFolder(&self, out: *mut bool) -> HRESULT,
    fn get_CanCreateFolder(&self, out: *mut bool) -> HRESULT,
    fn get_CanDeleteFolder(&self, out: *mut bool) -> HRESULT,
    fn get_CanMoveFolder(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMailboxCapabilities2 {
    #[inline] pub unsafe fn get_can_resolve_recipients(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanResolveRecipients)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_validate_certificates(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanValidateCertificates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_empty_folder(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanEmptyFolder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_create_folder(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanCreateFolder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_delete_folder(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanDeleteFolder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_can_move_folder(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanMoveFolder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailboxCapabilities3, 4136692036, 22258, 17834, 135, 44, 12, 233, 243, 219, 11, 92);
RT_INTERFACE!{interface IEmailMailboxCapabilities3(IEmailMailboxCapabilities3Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxCapabilities3] {
    fn put_CanForwardMeetings(&self, value: bool) -> HRESULT,
    fn put_CanGetAndSetExternalAutoReplies(&self, value: bool) -> HRESULT,
    fn put_CanGetAndSetInternalAutoReplies(&self, value: bool) -> HRESULT,
    fn put_CanUpdateMeetingResponses(&self, value: bool) -> HRESULT,
    fn put_CanServerSearchFolders(&self, value: bool) -> HRESULT,
    fn put_CanServerSearchMailbox(&self, value: bool) -> HRESULT,
    fn put_CanProposeNewTimeForMeetings(&self, value: bool) -> HRESULT,
    fn put_CanSmartSend(&self, value: bool) -> HRESULT,
    fn put_CanResolveRecipients(&self, value: bool) -> HRESULT,
    fn put_CanValidateCertificates(&self, value: bool) -> HRESULT,
    fn put_CanEmptyFolder(&self, value: bool) -> HRESULT,
    fn put_CanCreateFolder(&self, value: bool) -> HRESULT,
    fn put_CanDeleteFolder(&self, value: bool) -> HRESULT,
    fn put_CanMoveFolder(&self, value: bool) -> HRESULT
}}
impl IEmailMailboxCapabilities3 {
    #[inline] pub unsafe fn set_can_forward_meetings(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanForwardMeetings)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_get_and_set_external_auto_replies(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanGetAndSetExternalAutoReplies)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_get_and_set_internal_auto_replies(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanGetAndSetInternalAutoReplies)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_update_meeting_responses(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanUpdateMeetingResponses)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_server_search_folders(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanServerSearchFolders)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_server_search_mailbox(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanServerSearchMailbox)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_propose_new_time_for_meetings(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanProposeNewTimeForMeetings)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_smart_send(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanSmartSend)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_resolve_recipients(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanResolveRecipients)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_validate_certificates(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanValidateCertificates)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_empty_folder(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanEmptyFolder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_create_folder(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanCreateFolder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_delete_folder(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanDeleteFolder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_move_folder(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanMoveFolder)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailboxChange, 1642984779, 4591, 16396, 173, 222, 140, 222, 101, 200, 94, 102);
RT_INTERFACE!{interface IEmailMailboxChange(IEmailMailboxChangeVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxChange] {
    fn get_ChangeType(&self, out: *mut EmailMailboxChangeType) -> HRESULT,
    fn get_MailboxActions(&self, out: *mut *mut super::super::foundation::collections::IVector<EmailMailboxAction>) -> HRESULT,
    fn get_Message(&self, out: *mut *mut EmailMessage) -> HRESULT,
    fn get_Folder(&self, out: *mut *mut EmailFolder) -> HRESULT
}}
impl IEmailMailboxChange {
    #[inline] pub unsafe fn get_change_type(&self) -> Result<EmailMailboxChangeType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mailbox_actions(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<EmailMailboxAction>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MailboxActions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<ComPtr<EmailMessage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_folder(&self) -> Result<ComPtr<EmailFolder>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Folder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxChange: IEmailMailboxChange}
DEFINE_IID!(IID_IEmailMailboxChangedDeferral, 2006611137, 38853, 19284, 179, 13, 48, 98, 50, 98, 62, 109);
RT_INTERFACE!{interface IEmailMailboxChangedDeferral(IEmailMailboxChangedDeferralVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxChangedDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl IEmailMailboxChangedDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxChangedDeferral: IEmailMailboxChangedDeferral}
DEFINE_IID!(IID_IEmailMailboxChangedEventArgs, 1023237998, 468, 20042, 164, 76, 178, 45, 212, 46, 194, 7);
RT_INTERFACE!{interface IEmailMailboxChangedEventArgs(IEmailMailboxChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxChangedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut EmailMailboxChangedDeferral) -> HRESULT
}}
impl IEmailMailboxChangedEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<EmailMailboxChangedDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxChangedEventArgs: IEmailMailboxChangedEventArgs}
DEFINE_IID!(IID_IEmailMailboxChangeReader, 3183283899, 50493, 17201, 151, 190, 190, 117, 162, 20, 106, 117);
RT_INTERFACE!{interface IEmailMailboxChangeReader(IEmailMailboxChangeReaderVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxChangeReader] {
    fn AcceptChanges(&self) -> HRESULT,
    fn AcceptChangesThrough(&self, lastChangeToAcknowledge: *mut EmailMailboxChange) -> HRESULT,
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMailboxChange>>) -> HRESULT
}}
impl IEmailMailboxChangeReader {
    #[inline] pub unsafe fn accept_changes(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChanges)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn accept_changes_through(&self, lastChangeToAcknowledge: &EmailMailboxChange) -> Result<()> {
        let hr = ((*self.lpVtbl).AcceptChangesThrough)(self as *const _ as *mut _, lastChangeToAcknowledge as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMailboxChange>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxChangeReader: IEmailMailboxChangeReader}
DEFINE_IID!(IID_IEmailMailboxChangeTracker, 2061796920, 20838, 17079, 136, 130, 253, 33, 201, 43, 221, 75);
RT_INTERFACE!{interface IEmailMailboxChangeTracker(IEmailMailboxChangeTrackerVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxChangeTracker] {
    fn get_IsTracking(&self, out: *mut bool) -> HRESULT,
    fn Enable(&self) -> HRESULT,
    fn GetChangeReader(&self, out: *mut *mut EmailMailboxChangeReader) -> HRESULT,
    fn Reset(&self) -> HRESULT
}}
impl IEmailMailboxChangeTracker {
    #[inline] pub unsafe fn get_is_tracking(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTracking)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn enable(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Enable)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_reader(&self) -> Result<ComPtr<EmailMailboxChangeReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetChangeReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Reset)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxChangeTracker: IEmailMailboxChangeTracker}
RT_ENUM! { enum EmailMailboxChangeType: i32 {
    MessageCreated (EmailMailboxChangeType_MessageCreated) = 0, MessageModified (EmailMailboxChangeType_MessageModified) = 1, MessageDeleted (EmailMailboxChangeType_MessageDeleted) = 2, FolderCreated (EmailMailboxChangeType_FolderCreated) = 3, FolderModified (EmailMailboxChangeType_FolderModified) = 4, FolderDeleted (EmailMailboxChangeType_FolderDeleted) = 5, ChangeTrackingLost (EmailMailboxChangeType_ChangeTrackingLost) = 6,
}}
DEFINE_IID!(IID_IEmailMailboxCreateFolderResult, 2988987775, 10373, 18840, 181, 149, 138, 45, 55, 76, 233, 80);
RT_INTERFACE!{interface IEmailMailboxCreateFolderResult(IEmailMailboxCreateFolderResultVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxCreateFolderResult] {
    fn get_Status(&self, out: *mut EmailMailboxCreateFolderStatus) -> HRESULT,
    fn get_Folder(&self, out: *mut *mut EmailFolder) -> HRESULT
}}
impl IEmailMailboxCreateFolderResult {
    #[inline] pub unsafe fn get_status(&self) -> Result<EmailMailboxCreateFolderStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_folder(&self) -> Result<ComPtr<EmailFolder>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Folder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxCreateFolderResult: IEmailMailboxCreateFolderResult}
RT_ENUM! { enum EmailMailboxCreateFolderStatus: i32 {
    Success (EmailMailboxCreateFolderStatus_Success) = 0, NetworkError (EmailMailboxCreateFolderStatus_NetworkError) = 1, PermissionsError (EmailMailboxCreateFolderStatus_PermissionsError) = 2, ServerError (EmailMailboxCreateFolderStatus_ServerError) = 3, UnknownFailure (EmailMailboxCreateFolderStatus_UnknownFailure) = 4, NameCollision (EmailMailboxCreateFolderStatus_NameCollision) = 5, ServerRejected (EmailMailboxCreateFolderStatus_ServerRejected) = 6,
}}
RT_ENUM! { enum EmailMailboxDeleteFolderStatus: i32 {
    Success (EmailMailboxDeleteFolderStatus_Success) = 0, NetworkError (EmailMailboxDeleteFolderStatus_NetworkError) = 1, PermissionsError (EmailMailboxDeleteFolderStatus_PermissionsError) = 2, ServerError (EmailMailboxDeleteFolderStatus_ServerError) = 3, UnknownFailure (EmailMailboxDeleteFolderStatus_UnknownFailure) = 4, CouldNotDeleteEverything (EmailMailboxDeleteFolderStatus_CouldNotDeleteEverything) = 5,
}}
RT_ENUM! { enum EmailMailboxEmptyFolderStatus: i32 {
    Success (EmailMailboxEmptyFolderStatus_Success) = 0, NetworkError (EmailMailboxEmptyFolderStatus_NetworkError) = 1, PermissionsError (EmailMailboxEmptyFolderStatus_PermissionsError) = 2, ServerError (EmailMailboxEmptyFolderStatus_ServerError) = 3, UnknownFailure (EmailMailboxEmptyFolderStatus_UnknownFailure) = 4, CouldNotDeleteEverything (EmailMailboxEmptyFolderStatus_CouldNotDeleteEverything) = 5,
}}
RT_ENUM! { enum EmailMailboxOtherAppReadAccess: i32 {
    SystemOnly (EmailMailboxOtherAppReadAccess_SystemOnly) = 0, Full (EmailMailboxOtherAppReadAccess_Full) = 1, None (EmailMailboxOtherAppReadAccess_None) = 2,
}}
RT_ENUM! { enum EmailMailboxOtherAppWriteAccess: i32 {
    None (EmailMailboxOtherAppWriteAccess_None) = 0, Limited (EmailMailboxOtherAppWriteAccess_Limited) = 1,
}}
DEFINE_IID!(IID_IEmailMailboxPolicies, 523453893, 7227, 19911, 180, 16, 99, 115, 120, 62, 84, 93);
RT_INTERFACE!{interface IEmailMailboxPolicies(IEmailMailboxPoliciesVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxPolicies] {
    fn get_AllowedSmimeEncryptionAlgorithmNegotiation(&self, out: *mut EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> HRESULT,
    fn get_AllowSmimeSoftCertificates(&self, out: *mut bool) -> HRESULT,
    fn get_RequiredSmimeEncryptionAlgorithm(&self, out: *mut *mut super::super::foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm>) -> HRESULT,
    fn get_RequiredSmimeSigningAlgorithm(&self, out: *mut *mut super::super::foundation::IReference<EmailMailboxSmimeSigningAlgorithm>) -> HRESULT
}}
impl IEmailMailboxPolicies {
    #[inline] pub unsafe fn get_allowed_smime_encryption_algorithm_negotiation(&self) -> Result<EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowedSmimeEncryptionAlgorithmNegotiation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_smime_soft_certificates(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowSmimeSoftCertificates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_required_smime_encryption_algorithm(&self) -> Result<ComPtr<super::super::foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RequiredSmimeEncryptionAlgorithm)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_required_smime_signing_algorithm(&self) -> Result<ComPtr<super::super::foundation::IReference<EmailMailboxSmimeSigningAlgorithm>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RequiredSmimeSigningAlgorithm)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxPolicies: IEmailMailboxPolicies}
DEFINE_IID!(IID_IEmailMailboxPolicies2, 3132459771, 41291, 18812, 168, 226, 85, 234, 194, 156, 196, 181);
RT_INTERFACE!{interface IEmailMailboxPolicies2(IEmailMailboxPolicies2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxPolicies2] {
    fn get_MustEncryptSmimeMessages(&self, out: *mut bool) -> HRESULT,
    fn get_MustSignSmimeMessages(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMailboxPolicies2 {
    #[inline] pub unsafe fn get_must_encrypt_smime_messages(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MustEncryptSmimeMessages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_must_sign_smime_messages(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MustSignSmimeMessages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMailboxPolicies3, 3184828447, 18535, 16714, 129, 162, 128, 57, 25, 196, 65, 145);
RT_INTERFACE!{interface IEmailMailboxPolicies3(IEmailMailboxPolicies3Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxPolicies3] {
    fn put_AllowedSmimeEncryptionAlgorithmNegotiation(&self, value: EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> HRESULT,
    fn put_AllowSmimeSoftCertificates(&self, value: bool) -> HRESULT,
    fn put_RequiredSmimeEncryptionAlgorithm(&self, value: *mut super::super::foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm>) -> HRESULT,
    fn put_RequiredSmimeSigningAlgorithm(&self, value: *mut super::super::foundation::IReference<EmailMailboxSmimeSigningAlgorithm>) -> HRESULT,
    fn put_MustEncryptSmimeMessages(&self, value: bool) -> HRESULT,
    fn put_MustSignSmimeMessages(&self, value: bool) -> HRESULT
}}
impl IEmailMailboxPolicies3 {
    #[inline] pub unsafe fn set_allowed_smime_encryption_algorithm_negotiation(&self, value: EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowedSmimeEncryptionAlgorithmNegotiation)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_smime_soft_certificates(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowSmimeSoftCertificates)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_required_smime_encryption_algorithm(&self, value: &super::super::foundation::IReference<EmailMailboxSmimeEncryptionAlgorithm>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequiredSmimeEncryptionAlgorithm)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_required_smime_signing_algorithm(&self, value: &super::super::foundation::IReference<EmailMailboxSmimeSigningAlgorithm>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequiredSmimeSigningAlgorithm)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_must_encrypt_smime_messages(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MustEncryptSmimeMessages)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_must_sign_smime_messages(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MustSignSmimeMessages)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailMailboxSmimeEncryptionAlgorithm: i32 {
    Any (EmailMailboxSmimeEncryptionAlgorithm_Any) = 0, TripleDes (EmailMailboxSmimeEncryptionAlgorithm_TripleDes) = 1, Des (EmailMailboxSmimeEncryptionAlgorithm_Des) = 2, RC2128Bit (EmailMailboxSmimeEncryptionAlgorithm_RC2128Bit) = 3, RC264Bit (EmailMailboxSmimeEncryptionAlgorithm_RC264Bit) = 4, RC240Bit (EmailMailboxSmimeEncryptionAlgorithm_RC240Bit) = 5,
}}
RT_ENUM! { enum EmailMailboxSmimeSigningAlgorithm: i32 {
    Any (EmailMailboxSmimeSigningAlgorithm_Any) = 0, Sha1 (EmailMailboxSmimeSigningAlgorithm_Sha1) = 1, MD5 (EmailMailboxSmimeSigningAlgorithm_MD5) = 2,
}}
DEFINE_IID!(IID_IEmailMailboxSyncManager, 1367000410, 13713, 19293, 133, 188, 199, 29, 222, 134, 34, 99);
RT_INTERFACE!{interface IEmailMailboxSyncManager(IEmailMailboxSyncManagerVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxSyncManager] {
    fn get_Status(&self, out: *mut EmailMailboxSyncStatus) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_LastAttemptedSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn SyncAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<EmailMailboxSyncManager, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IEmailMailboxSyncManager {
    #[inline] pub unsafe fn get_status(&self) -> Result<EmailMailboxSyncStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_successful_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastSuccessfulSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_attempted_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastAttemptedSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn sync_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SyncAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_sync_status_changed(&self, handler: &super::super::foundation::TypedEventHandler<EmailMailboxSyncManager, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_status_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxSyncManager: IEmailMailboxSyncManager}
DEFINE_IID!(IID_IEmailMailboxSyncManager2, 3448621438, 38337, 20361, 129, 183, 230, 174, 203, 102, 149, 252);
RT_INTERFACE!{interface IEmailMailboxSyncManager2(IEmailMailboxSyncManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxSyncManager2] {
    fn put_Status(&self, value: EmailMailboxSyncStatus) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT
}}
impl IEmailMailboxSyncManager2 {
    #[inline] pub unsafe fn set_status(&self, value: EmailMailboxSyncStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Status)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_successful_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastSuccessfulSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_attempted_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastAttemptedSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailMailboxSyncStatus: i32 {
    Idle (EmailMailboxSyncStatus_Idle) = 0, Syncing (EmailMailboxSyncStatus_Syncing) = 1, UpToDate (EmailMailboxSyncStatus_UpToDate) = 2, AuthenticationError (EmailMailboxSyncStatus_AuthenticationError) = 3, PolicyError (EmailMailboxSyncStatus_PolicyError) = 4, UnknownError (EmailMailboxSyncStatus_UnknownError) = 5, ManualAccountRemovalRequired (EmailMailboxSyncStatus_ManualAccountRemovalRequired) = 6,
}}
RT_CLASS!{static class EmailManager}
impl RtActivatable<IEmailManagerStatics> for EmailManager {}
impl RtActivatable<IEmailManagerStatics2> for EmailManager {}
impl RtActivatable<IEmailManagerStatics3> for EmailManager {}
impl EmailManager {
    #[inline] pub fn show_compose_new_email_async(message: &EmailMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IEmailManagerStatics>>::get_activation_factory().show_compose_new_email_async(message)
    }}
    #[inline] pub fn request_store_async(accessType: EmailStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailStore>>> { unsafe {
        <Self as RtActivatable<IEmailManagerStatics2>>::get_activation_factory().request_store_async(accessType)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<EmailManagerForUser>> { unsafe {
        <Self as RtActivatable<IEmailManagerStatics3>>::get_activation_factory().get_for_user(user)
    }}
}
DEFINE_CLSID!(EmailManager: "Windows.ApplicationModel.Email.EmailManager");
DEFINE_IID!(IID_IEmailManagerForUser, 4151565983, 15525, 19215, 144, 193, 21, 110, 64, 23, 76, 229);
RT_INTERFACE!{interface IEmailManagerForUser(IEmailManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IEmailManagerForUser] {
    fn ShowComposeNewEmailAsync(&self, message: *mut EmailMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn RequestStoreAsync(&self, accessType: EmailStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<EmailStore>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IEmailManagerForUser {
    #[inline] pub unsafe fn show_compose_new_email_async(&self, message: &EmailMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowComposeNewEmailAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_store_async(&self, accessType: EmailStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailManagerForUser: IEmailManagerForUser}
DEFINE_IID!(IID_IEmailManagerStatics, 4111631956, 21957, 18576, 168, 36, 33, 108, 38, 24, 206, 127);
RT_INTERFACE!{static interface IEmailManagerStatics(IEmailManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailManagerStatics] {
    fn ShowComposeNewEmailAsync(&self, message: *mut EmailMessage, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailManagerStatics {
    #[inline] pub unsafe fn show_compose_new_email_async(&self, message: &EmailMessage) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowComposeNewEmailAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailManagerStatics2, 2886020515, 45460, 16989, 182, 217, 208, 240, 65, 53, 237, 162);
RT_INTERFACE!{static interface IEmailManagerStatics2(IEmailManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailManagerStatics2] {
    fn RequestStoreAsync(&self, accessType: EmailStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<EmailStore>) -> HRESULT
}}
impl IEmailManagerStatics2 {
    #[inline] pub unsafe fn request_store_async(&self, accessType: EmailStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailManagerStatics3, 1248994197, 33854, 18757, 179, 170, 52, 158, 7, 163, 98, 197);
RT_INTERFACE!{static interface IEmailManagerStatics3(IEmailManagerStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailManagerStatics3] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut EmailManagerForUser) -> HRESULT
}}
impl IEmailManagerStatics3 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<EmailManagerForUser>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMeetingInfo, 834682793, 31027, 16735, 162, 117, 209, 101, 186, 7, 2, 107);
RT_INTERFACE!{interface IEmailMeetingInfo(IEmailMeetingInfoVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMeetingInfo] {
    fn get_AllowNewTimeProposal(&self, out: *mut bool) -> HRESULT,
    fn put_AllowNewTimeProposal(&self, value: bool) -> HRESULT,
    fn get_AppointmentRoamingId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppointmentRoamingId(&self, value: HSTRING) -> HRESULT,
    fn get_AppointmentOriginalStartTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_AppointmentOriginalStartTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Duration(&self, out: *mut super::super::foundation::TimeSpan) -> HRESULT,
    fn put_Duration(&self, value: super::super::foundation::TimeSpan) -> HRESULT,
    fn get_IsAllDay(&self, out: *mut bool) -> HRESULT,
    fn put_IsAllDay(&self, value: bool) -> HRESULT,
    fn get_IsResponseRequested(&self, out: *mut bool) -> HRESULT,
    fn put_IsResponseRequested(&self, value: bool) -> HRESULT,
    fn get_Location(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Location(&self, value: HSTRING) -> HRESULT,
    fn get_ProposedStartTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_ProposedStartTime(&self, proposedStartTime: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_ProposedDuration(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> HRESULT,
    fn put_ProposedDuration(&self, duration: *mut super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> HRESULT,
    fn get_RecurrenceStartTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_RecurrenceStartTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Recurrence(&self, out: *mut *mut super::appointments::AppointmentRecurrence) -> HRESULT,
    fn put_Recurrence(&self, value: *mut super::appointments::AppointmentRecurrence) -> HRESULT,
    fn get_RemoteChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn put_RemoteChangeNumber(&self, value: u64) -> HRESULT,
    fn get_StartTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_StartTime(&self, value: super::super::foundation::DateTime) -> HRESULT
}}
impl IEmailMeetingInfo {
    #[inline] pub unsafe fn get_allow_new_time_proposal(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowNewTimeProposal)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_new_time_proposal(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowNewTimeProposal)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_roaming_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentRoamingId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_appointment_roaming_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AppointmentRoamingId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_appointment_original_start_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppointmentOriginalStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_appointment_original_start_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AppointmentOriginalStartTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_duration(&self) -> Result<super::super::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Duration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_duration(&self, value: super::super::foundation::TimeSpan) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Duration)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_all_day(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAllDay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_all_day(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsAllDay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_response_requested(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsResponseRequested)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_response_requested(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsResponseRequested)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_location(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Location)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_location(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Location)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_proposed_start_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProposedStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_proposed_start_time(&self, proposedStartTime: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ProposedStartTime)(self as *const _ as *mut _, proposedStartTime as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_proposed_duration(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::TimeSpan>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProposedDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_proposed_duration(&self, duration: &super::super::foundation::IReference<super::super::foundation::TimeSpan>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ProposedDuration)(self as *const _ as *mut _, duration as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recurrence_start_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecurrenceStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_recurrence_start_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RecurrenceStartTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recurrence(&self) -> Result<ComPtr<super::appointments::AppointmentRecurrence>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recurrence)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_recurrence(&self, value: &super::appointments::AppointmentRecurrence) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Recurrence)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_change_number(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RemoteChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_change_number(&self, value: u64) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteChangeNumber)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_StartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMeetingInfo: IEmailMeetingInfo}
impl RtActivatable<IActivationFactory> for EmailMeetingInfo {}
DEFINE_CLSID!(EmailMeetingInfo: "Windows.ApplicationModel.Email.EmailMeetingInfo");
DEFINE_IID!(IID_IEmailMeetingInfo2, 2119776365, 45273, 20453, 134, 124, 227, 30, 210, 181, 136, 184);
RT_INTERFACE!{interface IEmailMeetingInfo2(IEmailMeetingInfo2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMeetingInfo2] {
    fn get_IsReportedOutOfDateByServer(&self, out: *mut bool) -> HRESULT
}}
impl IEmailMeetingInfo2 {
    #[inline] pub unsafe fn get_is_reported_out_of_date_by_server(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsReportedOutOfDateByServer)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailMeetingResponseType: i32 {
    Accept (EmailMeetingResponseType_Accept) = 0, Decline (EmailMeetingResponseType_Decline) = 1, Tentative (EmailMeetingResponseType_Tentative) = 2,
}}
DEFINE_IID!(IID_IEmailMessage, 1819120781, 32949, 18680, 176, 177, 224, 78, 67, 15, 68, 229);
RT_INTERFACE!{interface IEmailMessage(IEmailMessageVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMessage] {
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_Body(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Body(&self, value: HSTRING) -> HRESULT,
    fn get_To(&self, out: *mut *mut super::super::foundation::collections::IVector<EmailRecipient>) -> HRESULT,
    fn get_CC(&self, out: *mut *mut super::super::foundation::collections::IVector<EmailRecipient>) -> HRESULT,
    fn get_Bcc(&self, out: *mut *mut super::super::foundation::collections::IVector<EmailRecipient>) -> HRESULT,
    fn get_Attachments(&self, out: *mut *mut super::super::foundation::collections::IVector<EmailAttachment>) -> HRESULT
}}
impl IEmailMessage {
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_subject(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Subject)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_body(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Body)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_body(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Body)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_to(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<EmailRecipient>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_To)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cc(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<EmailRecipient>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CC)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bcc(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<EmailRecipient>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Bcc)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_attachments(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<EmailAttachment>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Attachments)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMessage: IEmailMessage}
impl RtActivatable<IActivationFactory> for EmailMessage {}
DEFINE_CLSID!(EmailMessage: "Windows.ApplicationModel.Email.EmailMessage");
DEFINE_IID!(IID_IEmailMessage2, 4257752203, 40730, 17627, 189, 60, 101, 195, 132, 119, 15, 134);
RT_INTERFACE!{interface IEmailMessage2(IEmailMessage2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMessage2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_MailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ConversationId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AllowInternetImages(&self, out: *mut bool) -> HRESULT,
    fn put_AllowInternetImages(&self, value: bool) -> HRESULT,
    fn get_ChangeNumber(&self, out: *mut u64) -> HRESULT,
    fn get_DownloadState(&self, out: *mut EmailMessageDownloadState) -> HRESULT,
    fn put_DownloadState(&self, value: EmailMessageDownloadState) -> HRESULT,
    fn get_EstimatedDownloadSizeInBytes(&self, out: *mut u32) -> HRESULT,
    fn put_EstimatedDownloadSizeInBytes(&self, value: u32) -> HRESULT,
    fn get_FlagState(&self, out: *mut EmailFlagState) -> HRESULT,
    fn put_FlagState(&self, value: EmailFlagState) -> HRESULT,
    fn get_HasPartialBodies(&self, out: *mut bool) -> HRESULT,
    fn get_Importance(&self, out: *mut EmailImportance) -> HRESULT,
    fn put_Importance(&self, value: EmailImportance) -> HRESULT,
    fn get_InResponseToMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IrmInfo(&self, out: *mut *mut EmailIrmInfo) -> HRESULT,
    fn put_IrmInfo(&self, value: *mut EmailIrmInfo) -> HRESULT,
    fn get_IsDraftMessage(&self, out: *mut bool) -> HRESULT,
    fn get_IsRead(&self, out: *mut bool) -> HRESULT,
    fn put_IsRead(&self, value: bool) -> HRESULT,
    fn get_IsSeen(&self, out: *mut bool) -> HRESULT,
    fn put_IsSeen(&self, value: bool) -> HRESULT,
    fn get_IsServerSearchMessage(&self, out: *mut bool) -> HRESULT,
    fn get_IsSmartSendable(&self, out: *mut bool) -> HRESULT,
    fn get_MessageClass(&self, out: *mut HSTRING) -> HRESULT,
    fn put_MessageClass(&self, value: HSTRING) -> HRESULT,
    fn get_NormalizedSubject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OriginalCodePage(&self, out: *mut i32) -> HRESULT,
    fn put_OriginalCodePage(&self, value: i32) -> HRESULT,
    fn get_Preview(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Preview(&self, value: HSTRING) -> HRESULT,
    fn get_LastResponseKind(&self, out: *mut EmailMessageResponseKind) -> HRESULT,
    fn put_LastResponseKind(&self, value: EmailMessageResponseKind) -> HRESULT,
    fn get_Sender(&self, out: *mut *mut EmailRecipient) -> HRESULT,
    fn put_Sender(&self, value: *mut EmailRecipient) -> HRESULT,
    fn get_SentTime(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_SentTime(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_MeetingInfo(&self, out: *mut *mut EmailMeetingInfo) -> HRESULT,
    fn put_MeetingInfo(&self, value: *mut EmailMeetingInfo) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetBodyStream(&self, type_: EmailMessageBodyKind, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(feature="windows-storage")] fn SetBodyStream(&self, type_: EmailMessageBodyKind, stream: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT
}}
impl IEmailMessage2 {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ConversationId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_allow_internet_images(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AllowInternetImages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_allow_internet_images(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AllowInternetImages)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_change_number(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_state(&self) -> Result<EmailMessageDownloadState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DownloadState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_download_state(&self, value: EmailMessageDownloadState) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DownloadState)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_estimated_download_size_in_bytes(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EstimatedDownloadSizeInBytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_estimated_download_size_in_bytes(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EstimatedDownloadSizeInBytes)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_flag_state(&self) -> Result<EmailFlagState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_FlagState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_flag_state(&self, value: EmailFlagState) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FlagState)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_has_partial_bodies(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HasPartialBodies)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_importance(&self) -> Result<EmailImportance> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Importance)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_importance(&self, value: EmailImportance) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Importance)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_in_response_to_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InResponseToMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_irm_info(&self) -> Result<ComPtr<EmailIrmInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IrmInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_irm_info(&self, value: &EmailIrmInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IrmInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_draft_message(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDraftMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_read(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsRead)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_read(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsRead)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_seen(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSeen)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_seen(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSeen)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_server_search_message(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsServerSearchMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_smart_sendable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSmartSendable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_class(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MessageClass)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_message_class(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MessageClass)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_normalized_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NormalizedSubject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_original_code_page(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OriginalCodePage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_original_code_page(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OriginalCodePage)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_preview(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Preview)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_preview(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Preview)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_response_kind(&self) -> Result<EmailMessageResponseKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastResponseKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_response_kind(&self, value: EmailMessageResponseKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastResponseKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sender(&self) -> Result<ComPtr<EmailRecipient>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Sender)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sender(&self, value: &EmailRecipient) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Sender)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sent_time(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SentTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sent_time(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SentTime)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_meeting_info(&self) -> Result<ComPtr<EmailMeetingInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MeetingInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_meeting_info(&self, value: &EmailMeetingInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MeetingInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_body_stream(&self, type_: EmailMessageBodyKind) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetBodyStream)(self as *const _ as *mut _, type_, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_body_stream(&self, type_: EmailMessageBodyKind, stream: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).SetBodyStream)(self as *const _ as *mut _, type_, stream as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMessage3, 2716493660, 58776, 19753, 160, 24, 252, 123, 126, 236, 224, 161);
RT_INTERFACE!{interface IEmailMessage3(IEmailMessage3Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMessage3] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_SmimeData(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_SmimeData(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_SmimeKind(&self, out: *mut EmailMessageSmimeKind) -> HRESULT,
    fn put_SmimeKind(&self, value: EmailMessageSmimeKind) -> HRESULT
}}
impl IEmailMessage3 {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_smime_data(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SmimeData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_smime_data(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SmimeData)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_smime_kind(&self) -> Result<EmailMessageSmimeKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SmimeKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_smime_kind(&self, value: EmailMessageSmimeKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SmimeKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMessage4, 830271873, 15999, 18949, 131, 148, 62, 16, 51, 109, 212, 53);
RT_INTERFACE!{interface IEmailMessage4(IEmailMessage4Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailMessage4] {
    fn get_ReplyTo(&self, out: *mut *mut super::super::foundation::collections::IVector<EmailRecipient>) -> HRESULT,
    fn get_SentRepresenting(&self, out: *mut *mut EmailRecipient) -> HRESULT,
    fn put_SentRepresenting(&self, value: *mut EmailRecipient) -> HRESULT
}}
impl IEmailMessage4 {
    #[inline] pub unsafe fn get_reply_to(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<EmailRecipient>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReplyTo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sent_representing(&self) -> Result<ComPtr<EmailRecipient>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SentRepresenting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sent_representing(&self, value: &EmailRecipient) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SentRepresenting)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailMessageBatch, 1616695439, 9689, 20251, 158, 81, 5, 20, 192, 20, 150, 83);
RT_INTERFACE!{interface IEmailMessageBatch(IEmailMessageBatchVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMessageBatch] {
    fn get_Messages(&self, out: *mut *mut super::super::foundation::collections::IVectorView<EmailMessage>) -> HRESULT,
    fn get_Status(&self, out: *mut EmailBatchStatus) -> HRESULT
}}
impl IEmailMessageBatch {
    #[inline] pub unsafe fn get_messages(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<EmailMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Messages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<EmailBatchStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMessageBatch: IEmailMessageBatch}
RT_ENUM! { enum EmailMessageBodyKind: i32 {
    Html (EmailMessageBodyKind_Html) = 0, PlainText (EmailMessageBodyKind_PlainText) = 1,
}}
RT_ENUM! { enum EmailMessageDownloadState: i32 {
    PartiallyDownloaded (EmailMessageDownloadState_PartiallyDownloaded) = 0, Downloading (EmailMessageDownloadState_Downloading) = 1, Downloaded (EmailMessageDownloadState_Downloaded) = 2, Failed (EmailMessageDownloadState_Failed) = 3,
}}
DEFINE_IID!(IID_IEmailMessageReader, 793427615, 25107, 19077, 163, 176, 249, 45, 26, 131, 157, 25);
RT_INTERFACE!{interface IEmailMessageReader(IEmailMessageReaderVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMessageReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMessageBatch>) -> HRESULT
}}
impl IEmailMessageReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMessageBatch>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMessageReader: IEmailMessageReader}
RT_ENUM! { enum EmailMessageResponseKind: i32 {
    None (EmailMessageResponseKind_None) = 0, Reply (EmailMessageResponseKind_Reply) = 1, ReplyAll (EmailMessageResponseKind_ReplyAll) = 2, Forward (EmailMessageResponseKind_Forward) = 3,
}}
RT_ENUM! { enum EmailMessageSmimeKind: i32 {
    None (EmailMessageSmimeKind_None) = 0, ClearSigned (EmailMessageSmimeKind_ClearSigned) = 1, OpaqueSigned (EmailMessageSmimeKind_OpaqueSigned) = 2, Encrypted (EmailMessageSmimeKind_Encrypted) = 3,
}}
RT_ENUM! { enum EmailQueryKind: i32 {
    All (EmailQueryKind_All) = 0, Important (EmailQueryKind_Important) = 1, Flagged (EmailQueryKind_Flagged) = 2, Unread (EmailQueryKind_Unread) = 3, Read (EmailQueryKind_Read) = 4, Unseen (EmailQueryKind_Unseen) = 5,
}}
DEFINE_IID!(IID_IEmailQueryOptions, 1162890139, 15999, 19794, 182, 221, 214, 253, 78, 31, 189, 154);
RT_INTERFACE!{interface IEmailQueryOptions(IEmailQueryOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailQueryOptions] {
    fn get_TextSearch(&self, out: *mut *mut EmailQueryTextSearch) -> HRESULT,
    fn get_SortDirection(&self, out: *mut EmailQuerySortDirection) -> HRESULT,
    fn put_SortDirection(&self, value: EmailQuerySortDirection) -> HRESULT,
    fn get_SortProperty(&self, out: *mut EmailQuerySortProperty) -> HRESULT,
    fn put_SortProperty(&self, value: EmailQuerySortProperty) -> HRESULT,
    fn get_Kind(&self, out: *mut EmailQueryKind) -> HRESULT,
    fn put_Kind(&self, value: EmailQueryKind) -> HRESULT,
    fn get_FolderIds(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT
}}
impl IEmailQueryOptions {
    #[inline] pub unsafe fn get_text_search(&self) -> Result<ComPtr<EmailQueryTextSearch>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextSearch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sort_direction(&self) -> Result<EmailQuerySortDirection> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SortDirection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sort_direction(&self, value: EmailQuerySortDirection) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SortDirection)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sort_property(&self) -> Result<EmailQuerySortProperty> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SortProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sort_property(&self, value: EmailQuerySortProperty) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SortProperty)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<EmailQueryKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: EmailQueryKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_folder_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FolderIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailQueryOptions: IEmailQueryOptions}
impl RtActivatable<IEmailQueryOptionsFactory> for EmailQueryOptions {}
impl RtActivatable<IActivationFactory> for EmailQueryOptions {}
impl EmailQueryOptions {
    #[inline] pub fn create_with_text(text: &HStringArg) -> Result<ComPtr<EmailQueryOptions>> { unsafe {
        <Self as RtActivatable<IEmailQueryOptionsFactory>>::get_activation_factory().create_with_text(text)
    }}
    #[inline] pub fn create_with_text_and_fields(text: &HStringArg, fields: EmailQuerySearchFields) -> Result<ComPtr<EmailQueryOptions>> { unsafe {
        <Self as RtActivatable<IEmailQueryOptionsFactory>>::get_activation_factory().create_with_text_and_fields(text, fields)
    }}
}
DEFINE_CLSID!(EmailQueryOptions: "Windows.ApplicationModel.Email.EmailQueryOptions");
DEFINE_IID!(IID_IEmailQueryOptionsFactory, 2297536952, 30891, 20200, 180, 227, 4, 109, 110, 47, 229, 226);
RT_INTERFACE!{static interface IEmailQueryOptionsFactory(IEmailQueryOptionsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IEmailQueryOptionsFactory] {
    fn CreateWithText(&self, text: HSTRING, out: *mut *mut EmailQueryOptions) -> HRESULT,
    fn CreateWithTextAndFields(&self, text: HSTRING, fields: EmailQuerySearchFields, out: *mut *mut EmailQueryOptions) -> HRESULT
}}
impl IEmailQueryOptionsFactory {
    #[inline] pub unsafe fn create_with_text(&self, text: &HStringArg) -> Result<ComPtr<EmailQueryOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithText)(self as *const _ as *mut _, text.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_text_and_fields(&self, text: &HStringArg, fields: EmailQuerySearchFields) -> Result<ComPtr<EmailQueryOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithTextAndFields)(self as *const _ as *mut _, text.get(), fields, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailQuerySearchFields: u32 {
    None (EmailQuerySearchFields_None) = 0, Subject (EmailQuerySearchFields_Subject) = 1, Sender (EmailQuerySearchFields_Sender) = 2, Preview (EmailQuerySearchFields_Preview) = 4, Recipients (EmailQuerySearchFields_Recipients) = 8, All (EmailQuerySearchFields_All) = 4294967295,
}}
RT_ENUM! { enum EmailQuerySearchScope: i32 {
    Local (EmailQuerySearchScope_Local) = 0, Server (EmailQuerySearchScope_Server) = 1,
}}
RT_ENUM! { enum EmailQuerySortDirection: i32 {
    Descending (EmailQuerySortDirection_Descending) = 0, Ascending (EmailQuerySortDirection_Ascending) = 1,
}}
RT_ENUM! { enum EmailQuerySortProperty: i32 {
    Date (EmailQuerySortProperty_Date) = 0,
}}
DEFINE_IID!(IID_IEmailQueryTextSearch, 2678104712, 15453, 18085, 166, 226, 49, 214, 253, 23, 229, 64);
RT_INTERFACE!{interface IEmailQueryTextSearch(IEmailQueryTextSearchVtbl): IInspectable(IInspectableVtbl) [IID_IEmailQueryTextSearch] {
    fn get_Fields(&self, out: *mut EmailQuerySearchFields) -> HRESULT,
    fn put_Fields(&self, value: EmailQuerySearchFields) -> HRESULT,
    fn get_SearchScope(&self, out: *mut EmailQuerySearchScope) -> HRESULT,
    fn put_SearchScope(&self, value: EmailQuerySearchScope) -> HRESULT,
    fn get_Text(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Text(&self, value: HSTRING) -> HRESULT
}}
impl IEmailQueryTextSearch {
    #[inline] pub unsafe fn get_fields(&self) -> Result<EmailQuerySearchFields> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Fields)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fields(&self, value: EmailQuerySearchFields) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Fields)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_search_scope(&self) -> Result<EmailQuerySearchScope> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SearchScope)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_search_scope(&self, value: EmailQuerySearchScope) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SearchScope)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Text)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Text)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailQueryTextSearch: IEmailQueryTextSearch}
DEFINE_IID!(IID_IEmailRecipient, 3404211635, 17528, 18452, 185, 0, 201, 2, 181, 225, 155, 83);
RT_INTERFACE!{interface IEmailRecipient(IEmailRecipientVtbl): IInspectable(IInspectableVtbl) [IID_IEmailRecipient] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Address(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Address(&self, value: HSTRING) -> HRESULT
}}
impl IEmailRecipient {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Address)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Address)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailRecipient: IEmailRecipient}
impl RtActivatable<IEmailRecipientFactory> for EmailRecipient {}
impl RtActivatable<IActivationFactory> for EmailRecipient {}
impl EmailRecipient {
    #[inline] pub fn create(address: &HStringArg) -> Result<ComPtr<EmailRecipient>> { unsafe {
        <Self as RtActivatable<IEmailRecipientFactory>>::get_activation_factory().create(address)
    }}
    #[inline] pub fn create_with_name(address: &HStringArg, name: &HStringArg) -> Result<ComPtr<EmailRecipient>> { unsafe {
        <Self as RtActivatable<IEmailRecipientFactory>>::get_activation_factory().create_with_name(address, name)
    }}
}
DEFINE_CLSID!(EmailRecipient: "Windows.ApplicationModel.Email.EmailRecipient");
DEFINE_IID!(IID_IEmailRecipientFactory, 1426110541, 51098, 20216, 185, 9, 114, 46, 24, 227, 147, 93);
RT_INTERFACE!{static interface IEmailRecipientFactory(IEmailRecipientFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IEmailRecipientFactory] {
    fn Create(&self, address: HSTRING, out: *mut *mut EmailRecipient) -> HRESULT,
    fn CreateWithName(&self, address: HSTRING, name: HSTRING, out: *mut *mut EmailRecipient) -> HRESULT
}}
impl IEmailRecipientFactory {
    #[inline] pub unsafe fn create(&self, address: &HStringArg) -> Result<ComPtr<EmailRecipient>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, address.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_name(&self, address: &HStringArg, name: &HStringArg) -> Result<ComPtr<EmailRecipient>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithName)(self as *const _ as *mut _, address.get(), name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IEmailRecipientResolutionResult, 2441296122, 36237, 17779, 128, 209, 7, 23, 42, 52, 185, 141);
RT_INTERFACE!{interface IEmailRecipientResolutionResult(IEmailRecipientResolutionResultVtbl): IInspectable(IInspectableVtbl) [IID_IEmailRecipientResolutionResult] {
    fn get_Status(&self, out: *mut EmailRecipientResolutionStatus) -> HRESULT,
    #[cfg(feature="windows-security")] fn get_PublicKeys(&self, out: *mut *mut super::super::foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>) -> HRESULT
}}
impl IEmailRecipientResolutionResult {
    #[inline] pub unsafe fn get_status(&self) -> Result<EmailRecipientResolutionStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn get_public_keys(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<super::super::security::cryptography::certificates::Certificate>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PublicKeys)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailRecipientResolutionResult: IEmailRecipientResolutionResult}
impl RtActivatable<IActivationFactory> for EmailRecipientResolutionResult {}
DEFINE_CLSID!(EmailRecipientResolutionResult: "Windows.ApplicationModel.Email.EmailRecipientResolutionResult");
DEFINE_IID!(IID_IEmailRecipientResolutionResult2, 1581386678, 52827, 19422, 185, 212, 225, 109, 160, 176, 159, 202);
RT_INTERFACE!{interface IEmailRecipientResolutionResult2(IEmailRecipientResolutionResult2Vtbl): IInspectable(IInspectableVtbl) [IID_IEmailRecipientResolutionResult2] {
    fn put_Status(&self, value: EmailRecipientResolutionStatus) -> HRESULT,
    #[cfg(feature="windows-security")] fn SetPublicKeys(&self, value: *mut super::super::foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate>) -> HRESULT
}}
impl IEmailRecipientResolutionResult2 {
    #[inline] pub unsafe fn set_status(&self, value: EmailRecipientResolutionStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Status)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn set_public_keys(&self, value: &super::super::foundation::collections::IIterable<super::super::security::cryptography::certificates::Certificate>) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPublicKeys)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum EmailRecipientResolutionStatus: i32 {
    Success (EmailRecipientResolutionStatus_Success) = 0, RecipientNotFound (EmailRecipientResolutionStatus_RecipientNotFound) = 1, AmbiguousRecipient (EmailRecipientResolutionStatus_AmbiguousRecipient) = 2, NoCertificate (EmailRecipientResolutionStatus_NoCertificate) = 3, CertificateRequestLimitReached (EmailRecipientResolutionStatus_CertificateRequestLimitReached) = 4, CannotResolveDistributionList (EmailRecipientResolutionStatus_CannotResolveDistributionList) = 5, ServerError (EmailRecipientResolutionStatus_ServerError) = 6, UnknownFailure (EmailRecipientResolutionStatus_UnknownFailure) = 7,
}}
RT_ENUM! { enum EmailSpecialFolderKind: i32 {
    None (EmailSpecialFolderKind_None) = 0, Root (EmailSpecialFolderKind_Root) = 1, Inbox (EmailSpecialFolderKind_Inbox) = 2, Outbox (EmailSpecialFolderKind_Outbox) = 3, Drafts (EmailSpecialFolderKind_Drafts) = 4, DeletedItems (EmailSpecialFolderKind_DeletedItems) = 5, Sent (EmailSpecialFolderKind_Sent) = 6,
}}
DEFINE_IID!(IID_IEmailStore, 4160954990, 37175, 20363, 164, 112, 39, 154, 195, 5, 142, 182);
RT_INTERFACE!{interface IEmailStore(IEmailStoreVtbl): IInspectable(IInspectableVtbl) [IID_IEmailStore] {
    fn FindMailboxesAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMailbox>>) -> HRESULT,
    fn GetConversationReader(&self, out: *mut *mut EmailConversationReader) -> HRESULT,
    fn GetConversationReaderWithOptions(&self, options: *mut EmailQueryOptions, out: *mut *mut EmailConversationReader) -> HRESULT,
    fn GetMessageReader(&self, out: *mut *mut EmailMessageReader) -> HRESULT,
    fn GetMessageReaderWithOptions(&self, options: *mut EmailQueryOptions, out: *mut *mut EmailMessageReader) -> HRESULT,
    fn GetMailboxAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailbox>) -> HRESULT,
    fn GetConversationAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailConversation>) -> HRESULT,
    fn GetFolderAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailFolder>) -> HRESULT,
    fn GetMessageAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMessage>) -> HRESULT,
    fn CreateMailboxAsync(&self, accountName: HSTRING, accountAddress: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailbox>) -> HRESULT,
    fn CreateMailboxInAccountAsync(&self, accountName: HSTRING, accountAddress: HSTRING, userDataAccountId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<EmailMailbox>) -> HRESULT
}}
impl IEmailStore {
    #[inline] pub unsafe fn find_mailboxes_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<EmailMailbox>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindMailboxesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader(&self) -> Result<ComPtr<EmailConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_reader_with_options(&self, options: &EmailQueryOptions) -> Result<ComPtr<EmailConversationReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader(&self) -> Result<ComPtr<EmailMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_reader_with_options(&self, options: &EmailQueryOptions) -> Result<ComPtr<EmailMessageReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mailbox_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailbox>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMailboxAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_conversation_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailConversation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetConversationAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_folder_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailFolder>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFolderAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMessage>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetMessageAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_mailbox_async(&self, accountName: &HStringArg, accountAddress: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailbox>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateMailboxAsync)(self as *const _ as *mut _, accountName.get(), accountAddress.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_mailbox_in_account_async(&self, accountName: &HStringArg, accountAddress: &HStringArg, userDataAccountId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<EmailMailbox>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateMailboxInAccountAsync)(self as *const _ as *mut _, accountName.get(), accountAddress.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailStore: IEmailStore}
RT_ENUM! { enum EmailStoreAccessType: i32 {
    AppMailboxesReadWrite (EmailStoreAccessType_AppMailboxesReadWrite) = 0, AllMailboxesLimitedReadWrite (EmailStoreAccessType_AllMailboxesLimitedReadWrite) = 1,
}}
DEFINE_IID!(IID_IEmailStoreNotificationTriggerDetails, 3457635900, 18150, 17353, 150, 247, 250, 207, 125, 215, 16, 203);
RT_INTERFACE!{interface IEmailStoreNotificationTriggerDetails(IEmailStoreNotificationTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailStoreNotificationTriggerDetails] {
    
}}
RT_CLASS!{class EmailStoreNotificationTriggerDetails: IEmailStoreNotificationTriggerDetails}
pub mod dataprovider { // Windows.ApplicationModel.Email.DataProvider
use ::prelude::*;
DEFINE_IID!(IID_IEmailDataProviderConnection, 1000119751, 14258, 19440, 174, 48, 123, 100, 74, 28, 150, 225);
RT_INTERFACE!{interface IEmailDataProviderConnection(IEmailDataProviderConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IEmailDataProviderConnection] {
    fn add_MailboxSyncRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSyncManagerSyncRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MailboxSyncRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadMessageRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadMessageRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadMessageRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DownloadAttachmentRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadAttachmentRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DownloadAttachmentRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CreateFolderRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxCreateFolderRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateFolderRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DeleteFolderRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDeleteFolderRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeleteFolderRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_EmptyFolderRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxEmptyFolderRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_EmptyFolderRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_MoveFolderRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxMoveFolderRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_MoveFolderRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_UpdateMeetingResponseRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxUpdateMeetingResponseRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_UpdateMeetingResponseRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ForwardMeetingRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxForwardMeetingRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ForwardMeetingRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ProposeNewTimeForMeetingRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxProposeNewTimeForMeetingRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ProposeNewTimeForMeetingRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SetAutoReplySettingsRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSetAutoReplySettingsRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SetAutoReplySettingsRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_GetAutoReplySettingsRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxGetAutoReplySettingsRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_GetAutoReplySettingsRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ResolveRecipientsRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxResolveRecipientsRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ResolveRecipientsRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ValidateCertificatesRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxValidateCertificatesRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ValidateCertificatesRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ServerSearchReadBatchRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxServerSearchReadBatchRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ServerSearchReadBatchRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IEmailDataProviderConnection {
    #[inline] pub unsafe fn add_mailbox_sync_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSyncManagerSyncRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MailboxSyncRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_mailbox_sync_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MailboxSyncRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_download_message_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadMessageRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DownloadMessageRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_download_message_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DownloadMessageRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_download_attachment_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDownloadAttachmentRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DownloadAttachmentRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_download_attachment_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DownloadAttachmentRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_create_folder_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxCreateFolderRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CreateFolderRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_create_folder_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CreateFolderRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_delete_folder_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxDeleteFolderRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DeleteFolderRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_delete_folder_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DeleteFolderRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_empty_folder_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxEmptyFolderRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_EmptyFolderRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_empty_folder_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_EmptyFolderRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_move_folder_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxMoveFolderRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_MoveFolderRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_move_folder_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_MoveFolderRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_update_meeting_response_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxUpdateMeetingResponseRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_UpdateMeetingResponseRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_update_meeting_response_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_UpdateMeetingResponseRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_forward_meeting_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxForwardMeetingRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ForwardMeetingRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_forward_meeting_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ForwardMeetingRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_propose_new_time_for_meeting_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxProposeNewTimeForMeetingRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ProposeNewTimeForMeetingRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_propose_new_time_for_meeting_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ProposeNewTimeForMeetingRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_set_auto_reply_settings_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxSetAutoReplySettingsRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SetAutoReplySettingsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_set_auto_reply_settings_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SetAutoReplySettingsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_get_auto_reply_settings_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxGetAutoReplySettingsRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_GetAutoReplySettingsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_get_auto_reply_settings_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_GetAutoReplySettingsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_resolve_recipients_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxResolveRecipientsRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ResolveRecipientsRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_resolve_recipients_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ResolveRecipientsRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_validate_certificates_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxValidateCertificatesRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ValidateCertificatesRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_validate_certificates_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ValidateCertificatesRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_server_search_read_batch_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<EmailDataProviderConnection, EmailMailboxServerSearchReadBatchRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ServerSearchReadBatchRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_server_search_read_batch_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ServerSearchReadBatchRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Start)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class EmailDataProviderConnection: IEmailDataProviderConnection}
DEFINE_IID!(IID_IEmailDataProviderTriggerDetails, 2403225168, 13342, 17907, 187, 160, 132, 160, 5, 225, 49, 154);
RT_INTERFACE!{interface IEmailDataProviderTriggerDetails(IEmailDataProviderTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut *mut EmailDataProviderConnection) -> HRESULT
}}
impl IEmailDataProviderTriggerDetails {
    #[inline] pub unsafe fn get_connection(&self) -> Result<ComPtr<EmailDataProviderConnection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Connection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailDataProviderTriggerDetails: IEmailDataProviderTriggerDetails}
DEFINE_IID!(IID_IEmailMailboxCreateFolderRequest, 407713653, 51489, 19513, 163, 9, 225, 108, 159, 34, 176, 75);
RT_INTERFACE!{interface IEmailMailboxCreateFolderRequest(IEmailMailboxCreateFolderRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxCreateFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ParentFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, folder: *mut super::EmailFolder, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, status: super::EmailMailboxCreateFolderStatus, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxCreateFolderRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_parent_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ParentFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, folder: &super::EmailFolder) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, folder as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self, status: super::EmailMailboxCreateFolderStatus) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxCreateFolderRequest: IEmailMailboxCreateFolderRequest}
DEFINE_IID!(IID_IEmailMailboxCreateFolderRequestEventArgs, 65323052, 9244, 20137, 166, 143, 255, 32, 188, 90, 252, 133);
RT_INTERFACE!{interface IEmailMailboxCreateFolderRequestEventArgs(IEmailMailboxCreateFolderRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxCreateFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxCreateFolderRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxCreateFolderRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxCreateFolderRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxCreateFolderRequestEventArgs: IEmailMailboxCreateFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxDeleteFolderRequest, 2489968778, 43313, 18297, 146, 61, 9, 163, 234, 41, 46, 41);
RT_INTERFACE!{interface IEmailMailboxDeleteFolderRequest(IEmailMailboxDeleteFolderRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxDeleteFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, status: super::EmailMailboxDeleteFolderStatus, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxDeleteFolderRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self, status: super::EmailMailboxDeleteFolderStatus) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxDeleteFolderRequest: IEmailMailboxDeleteFolderRequest}
DEFINE_IID!(IID_IEmailMailboxDeleteFolderRequestEventArgs, 3033738502, 9010, 18040, 131, 120, 40, 181, 121, 51, 104, 70);
RT_INTERFACE!{interface IEmailMailboxDeleteFolderRequestEventArgs(IEmailMailboxDeleteFolderRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxDeleteFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxDeleteFolderRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxDeleteFolderRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxDeleteFolderRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxDeleteFolderRequestEventArgs: IEmailMailboxDeleteFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxDownloadAttachmentRequest, 186497972, 29964, 18657, 188, 228, 141, 88, 150, 132, 255, 188);
RT_INTERFACE!{interface IEmailMailboxDownloadAttachmentRequest(IEmailMailboxDownloadAttachmentRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxDownloadAttachmentRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailAttachmentId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxDownloadAttachmentRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_attachment_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailAttachmentId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxDownloadAttachmentRequest: IEmailMailboxDownloadAttachmentRequest}
DEFINE_IID!(IID_IEmailMailboxDownloadAttachmentRequestEventArgs, 3437085805, 65448, 18551, 159, 157, 254, 215, 188, 175, 65, 4);
RT_INTERFACE!{interface IEmailMailboxDownloadAttachmentRequestEventArgs(IEmailMailboxDownloadAttachmentRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxDownloadAttachmentRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxDownloadAttachmentRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxDownloadAttachmentRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxDownloadAttachmentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxDownloadAttachmentRequestEventArgs: IEmailMailboxDownloadAttachmentRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxDownloadMessageRequest, 1232814471, 23373, 19235, 129, 108, 243, 132, 43, 235, 117, 62);
RT_INTERFACE!{interface IEmailMailboxDownloadMessageRequest(IEmailMailboxDownloadMessageRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxDownloadMessageRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxDownloadMessageRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxDownloadMessageRequest: IEmailMailboxDownloadMessageRequest}
DEFINE_IID!(IID_IEmailMailboxDownloadMessageRequestEventArgs, 1191446957, 53408, 19035, 187, 42, 55, 98, 16, 57, 197, 62);
RT_INTERFACE!{interface IEmailMailboxDownloadMessageRequestEventArgs(IEmailMailboxDownloadMessageRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxDownloadMessageRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxDownloadMessageRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxDownloadMessageRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxDownloadMessageRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxDownloadMessageRequestEventArgs: IEmailMailboxDownloadMessageRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxEmptyFolderRequest, 4266329003, 63597, 18137, 180, 206, 188, 138, 109, 158, 146, 104);
RT_INTERFACE!{interface IEmailMailboxEmptyFolderRequest(IEmailMailboxEmptyFolderRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxEmptyFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, status: super::EmailMailboxEmptyFolderStatus, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxEmptyFolderRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self, status: super::EmailMailboxEmptyFolderStatus) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxEmptyFolderRequest: IEmailMailboxEmptyFolderRequest}
DEFINE_IID!(IID_IEmailMailboxEmptyFolderRequestEventArgs, 1904473220, 39002, 19136, 179, 63, 238, 14, 38, 39, 163, 192);
RT_INTERFACE!{interface IEmailMailboxEmptyFolderRequestEventArgs(IEmailMailboxEmptyFolderRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxEmptyFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxEmptyFolderRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxEmptyFolderRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxEmptyFolderRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxEmptyFolderRequestEventArgs: IEmailMailboxEmptyFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxForwardMeetingRequest, 1634560753, 28884, 18482, 184, 105, 184, 5, 66, 174, 155, 232);
RT_INTERFACE!{interface IEmailMailboxForwardMeetingRequest(IEmailMailboxForwardMeetingRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxForwardMeetingRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recipients(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<super::EmailRecipient>) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ForwardHeaderType(&self, out: *mut super::EmailMessageBodyKind) -> HRESULT,
    fn get_ForwardHeader(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxForwardMeetingRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recipients(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<super::EmailRecipient>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recipients)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_forward_header_type(&self) -> Result<super::EmailMessageBodyKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ForwardHeaderType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_forward_header(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ForwardHeader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxForwardMeetingRequest: IEmailMailboxForwardMeetingRequest}
DEFINE_IID!(IID_IEmailMailboxForwardMeetingRequestEventArgs, 735638330, 10612, 18265, 165, 165, 88, 244, 77, 60, 2, 117);
RT_INTERFACE!{interface IEmailMailboxForwardMeetingRequestEventArgs(IEmailMailboxForwardMeetingRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxForwardMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxForwardMeetingRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxForwardMeetingRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxForwardMeetingRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxForwardMeetingRequestEventArgs: IEmailMailboxForwardMeetingRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxGetAutoReplySettingsRequest, 2604140425, 7816, 19969, 132, 204, 19, 134, 173, 154, 44, 47);
RT_INTERFACE!{interface IEmailMailboxGetAutoReplySettingsRequest(IEmailMailboxGetAutoReplySettingsRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxGetAutoReplySettingsRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RequestedFormat(&self, out: *mut super::EmailMailboxAutoReplyMessageResponseKind) -> HRESULT,
    fn ReportCompletedAsync(&self, autoReplySettings: *mut super::EmailMailboxAutoReplySettings, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxGetAutoReplySettingsRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_requested_format(&self) -> Result<super::EmailMailboxAutoReplyMessageResponseKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestedFormat)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, autoReplySettings: &super::EmailMailboxAutoReplySettings) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, autoReplySettings as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxGetAutoReplySettingsRequest: IEmailMailboxGetAutoReplySettingsRequest}
DEFINE_IID!(IID_IEmailMailboxGetAutoReplySettingsRequestEventArgs, 3617543618, 64837, 16388, 138, 145, 155, 172, 243, 139, 112, 34);
RT_INTERFACE!{interface IEmailMailboxGetAutoReplySettingsRequestEventArgs(IEmailMailboxGetAutoReplySettingsRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxGetAutoReplySettingsRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxGetAutoReplySettingsRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxGetAutoReplySettingsRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxGetAutoReplySettingsRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxGetAutoReplySettingsRequestEventArgs: IEmailMailboxGetAutoReplySettingsRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxMoveFolderRequest, 280635478, 19093, 16488, 145, 204, 103, 204, 122, 207, 69, 79);
RT_INTERFACE!{interface IEmailMailboxMoveFolderRequest(IEmailMailboxMoveFolderRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxMoveFolderRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewParentFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewFolderName(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxMoveFolderRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_parent_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewParentFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_folder_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_NewFolderName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxMoveFolderRequest: IEmailMailboxMoveFolderRequest}
DEFINE_IID!(IID_IEmailMailboxMoveFolderRequestEventArgs, 945958944, 5306, 19592, 134, 152, 114, 57, 227, 200, 170, 167);
RT_INTERFACE!{interface IEmailMailboxMoveFolderRequestEventArgs(IEmailMailboxMoveFolderRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxMoveFolderRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxMoveFolderRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxMoveFolderRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxMoveFolderRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxMoveFolderRequestEventArgs: IEmailMailboxMoveFolderRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxProposeNewTimeForMeetingRequest, 1525674322, 38809, 20383, 163, 153, 255, 7, 243, 238, 240, 78);
RT_INTERFACE!{interface IEmailMailboxProposeNewTimeForMeetingRequest(IEmailMailboxProposeNewTimeForMeetingRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxProposeNewTimeForMeetingRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_NewStartTime(&self, out: *mut ::rt::gen::windows::foundation::DateTime) -> HRESULT,
    fn get_NewDuration(&self, out: *mut ::rt::gen::windows::foundation::TimeSpan) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxProposeNewTimeForMeetingRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_start_time(&self) -> Result<::rt::gen::windows::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewStartTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_new_duration(&self) -> Result<::rt::gen::windows::foundation::TimeSpan> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_NewDuration)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxProposeNewTimeForMeetingRequest: IEmailMailboxProposeNewTimeForMeetingRequest}
DEFINE_IID!(IID_IEmailMailboxProposeNewTimeForMeetingRequestEventArgs, 4215802776, 13229, 19047, 130, 81, 15, 156, 36, 155, 106, 32);
RT_INTERFACE!{interface IEmailMailboxProposeNewTimeForMeetingRequestEventArgs(IEmailMailboxProposeNewTimeForMeetingRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxProposeNewTimeForMeetingRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxProposeNewTimeForMeetingRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxProposeNewTimeForMeetingRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxProposeNewTimeForMeetingRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxProposeNewTimeForMeetingRequestEventArgs: IEmailMailboxProposeNewTimeForMeetingRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxResolveRecipientsRequest, 4020555632, 31545, 19611, 129, 30, 65, 234, 244, 58, 51, 45);
RT_INTERFACE!{interface IEmailMailboxResolveRecipientsRequest(IEmailMailboxResolveRecipientsRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxResolveRecipientsRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Recipients(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn ReportCompletedAsync(&self, resolutionResults: *mut ::rt::gen::windows::foundation::collections::IIterable<super::EmailRecipientResolutionResult>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxResolveRecipientsRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recipients(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recipients)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, resolutionResults: &::rt::gen::windows::foundation::collections::IIterable<super::EmailRecipientResolutionResult>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, resolutionResults as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxResolveRecipientsRequest: IEmailMailboxResolveRecipientsRequest}
DEFINE_IID!(IID_IEmailMailboxResolveRecipientsRequestEventArgs, 638557698, 45775, 16632, 140, 40, 227, 237, 67, 177, 232, 154);
RT_INTERFACE!{interface IEmailMailboxResolveRecipientsRequestEventArgs(IEmailMailboxResolveRecipientsRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxResolveRecipientsRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxResolveRecipientsRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxResolveRecipientsRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxResolveRecipientsRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxResolveRecipientsRequestEventArgs: IEmailMailboxResolveRecipientsRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxServerSearchReadBatchRequest, 151972831, 23190, 16851, 138, 216, 52, 145, 47, 154, 166, 14);
RT_INTERFACE!{interface IEmailMailboxServerSearchReadBatchRequest(IEmailMailboxServerSearchReadBatchRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxServerSearchReadBatchRequest] {
    fn get_SessionId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailFolderId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Options(&self, out: *mut *mut super::EmailQueryOptions) -> HRESULT,
    fn get_SuggestedBatchSize(&self, out: *mut u32) -> HRESULT,
    fn SaveMessageAsync(&self, message: *mut super::EmailMessage, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, batchStatus: super::EmailBatchStatus, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxServerSearchReadBatchRequest {
    #[inline] pub unsafe fn get_session_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SessionId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_folder_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailFolderId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_options(&self) -> Result<ComPtr<super::EmailQueryOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Options)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_suggested_batch_size(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SuggestedBatchSize)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_message_async(&self, message: &super::EmailMessage) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveMessageAsync)(self as *const _ as *mut _, message as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self, batchStatus: super::EmailBatchStatus) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, batchStatus, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxServerSearchReadBatchRequest: IEmailMailboxServerSearchReadBatchRequest}
DEFINE_IID!(IID_IEmailMailboxServerSearchReadBatchRequestEventArgs, 336599886, 60830, 17873, 173, 122, 204, 155, 127, 100, 58, 226);
RT_INTERFACE!{interface IEmailMailboxServerSearchReadBatchRequestEventArgs(IEmailMailboxServerSearchReadBatchRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxServerSearchReadBatchRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxServerSearchReadBatchRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxServerSearchReadBatchRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxServerSearchReadBatchRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxServerSearchReadBatchRequestEventArgs: IEmailMailboxServerSearchReadBatchRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxSetAutoReplySettingsRequest, 1973691088, 43150, 20052, 141, 199, 194, 67, 24, 107, 119, 78);
RT_INTERFACE!{interface IEmailMailboxSetAutoReplySettingsRequest(IEmailMailboxSetAutoReplySettingsRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxSetAutoReplySettingsRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AutoReplySettings(&self, out: *mut *mut super::EmailMailboxAutoReplySettings) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxSetAutoReplySettingsRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_reply_settings(&self) -> Result<ComPtr<super::EmailMailboxAutoReplySettings>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutoReplySettings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxSetAutoReplySettingsRequest: IEmailMailboxSetAutoReplySettingsRequest}
DEFINE_IID!(IID_IEmailMailboxSetAutoReplySettingsRequestEventArgs, 165286317, 55242, 16519, 172, 134, 83, 250, 103, 247, 98, 70);
RT_INTERFACE!{interface IEmailMailboxSetAutoReplySettingsRequestEventArgs(IEmailMailboxSetAutoReplySettingsRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxSetAutoReplySettingsRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxSetAutoReplySettingsRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxSetAutoReplySettingsRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxSetAutoReplySettingsRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxSetAutoReplySettingsRequestEventArgs: IEmailMailboxSetAutoReplySettingsRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxSyncManagerSyncRequest, 1309731044, 32359, 16474, 182, 115, 220, 96, 201, 16, 144, 252);
RT_INTERFACE!{interface IEmailMailboxSyncManagerSyncRequest(IEmailMailboxSyncManagerSyncRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxSyncManagerSyncRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxSyncManagerSyncRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxSyncManagerSyncRequest: IEmailMailboxSyncManagerSyncRequest}
DEFINE_IID!(IID_IEmailMailboxSyncManagerSyncRequestEventArgs, 1134166810, 36812, 19173, 185, 181, 212, 52, 224, 166, 90, 168);
RT_INTERFACE!{interface IEmailMailboxSyncManagerSyncRequestEventArgs(IEmailMailboxSyncManagerSyncRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxSyncManagerSyncRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxSyncManagerSyncRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxSyncManagerSyncRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxSyncManagerSyncRequestEventArgs: IEmailMailboxSyncManagerSyncRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxUpdateMeetingResponseRequest, 1536797843, 45775, 18568, 186, 79, 48, 107, 107, 102, 223, 48);
RT_INTERFACE!{interface IEmailMailboxUpdateMeetingResponseRequest(IEmailMailboxUpdateMeetingResponseRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxUpdateMeetingResponseRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_EmailMessageId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Response(&self, out: *mut super::EmailMeetingResponseType) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Comment(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SendUpdate(&self, out: *mut bool) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxUpdateMeetingResponseRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_message_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMessageId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_response(&self) -> Result<super::EmailMeetingResponseType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Response)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_comment(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Comment)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_send_update(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SendUpdate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxUpdateMeetingResponseRequest: IEmailMailboxUpdateMeetingResponseRequest}
DEFINE_IID!(IID_IEmailMailboxUpdateMeetingResponseRequestEventArgs, 1754847073, 22217, 20247, 190, 49, 102, 253, 169, 75, 161, 89);
RT_INTERFACE!{interface IEmailMailboxUpdateMeetingResponseRequestEventArgs(IEmailMailboxUpdateMeetingResponseRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxUpdateMeetingResponseRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxUpdateMeetingResponseRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxUpdateMeetingResponseRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxUpdateMeetingResponseRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxUpdateMeetingResponseRequestEventArgs: IEmailMailboxUpdateMeetingResponseRequestEventArgs}
DEFINE_IID!(IID_IEmailMailboxValidateCertificatesRequest, 2840410417, 57626, 20375, 184, 26, 24, 122, 112, 168, 244, 26);
RT_INTERFACE!{interface IEmailMailboxValidateCertificatesRequest(IEmailMailboxValidateCertificatesRequestVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxValidateCertificatesRequest] {
    fn get_EmailMailboxId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn get_Certificates(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::security::cryptography::certificates::Certificate>) -> HRESULT,
    fn ReportCompletedAsync(&self, validationStatuses: *mut ::rt::gen::windows::foundation::collections::IIterable<super::EmailCertificateValidationStatus>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IEmailMailboxValidateCertificatesRequest {
    #[inline] pub unsafe fn get_email_mailbox_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailMailboxId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn get_certificates(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<::rt::gen::windows::security::cryptography::certificates::Certificate>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Certificates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, validationStatuses: &::rt::gen::windows::foundation::collections::IIterable<super::EmailCertificateValidationStatus>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, validationStatuses as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxValidateCertificatesRequest: IEmailMailboxValidateCertificatesRequest}
DEFINE_IID!(IID_IEmailMailboxValidateCertificatesRequestEventArgs, 629391127, 767, 18942, 167, 60, 3, 243, 117, 102, 198, 145);
RT_INTERFACE!{interface IEmailMailboxValidateCertificatesRequestEventArgs(IEmailMailboxValidateCertificatesRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IEmailMailboxValidateCertificatesRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut EmailMailboxValidateCertificatesRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IEmailMailboxValidateCertificatesRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<EmailMailboxValidateCertificatesRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class EmailMailboxValidateCertificatesRequestEventArgs: IEmailMailboxValidateCertificatesRequestEventArgs}
} // Windows.ApplicationModel.Email.DataProvider
} // Windows.ApplicationModel.Email
pub mod extendedexecution { // Windows.ApplicationModel.ExtendedExecution
use ::prelude::*;
RT_ENUM! { enum ExtendedExecutionReason: i32 {
    Unspecified (ExtendedExecutionReason_Unspecified) = 0, LocationTracking (ExtendedExecutionReason_LocationTracking) = 1, SavingData (ExtendedExecutionReason_SavingData) = 2,
}}
RT_ENUM! { enum ExtendedExecutionResult: i32 {
    Allowed (ExtendedExecutionResult_Allowed) = 0, Denied (ExtendedExecutionResult_Denied) = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionRevokedEventArgs, 3216809750, 25525, 19467, 170, 214, 130, 138, 245, 55, 62, 195);
RT_INTERFACE!{interface IExtendedExecutionRevokedEventArgs(IExtendedExecutionRevokedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IExtendedExecutionRevokedEventArgs] {
    fn get_Reason(&self, out: *mut ExtendedExecutionRevokedReason) -> HRESULT
}}
impl IExtendedExecutionRevokedEventArgs {
    #[inline] pub unsafe fn get_reason(&self) -> Result<ExtendedExecutionRevokedReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ExtendedExecutionRevokedEventArgs: IExtendedExecutionRevokedEventArgs}
RT_ENUM! { enum ExtendedExecutionRevokedReason: i32 {
    Resumed (ExtendedExecutionRevokedReason_Resumed) = 0, SystemPolicy (ExtendedExecutionRevokedReason_SystemPolicy) = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionSession, 2945485357, 4491, 18673, 147, 8, 12, 79, 196, 30, 32, 15);
RT_INTERFACE!{interface IExtendedExecutionSession(IExtendedExecutionSessionVtbl): IInspectable(IInspectableVtbl) [IID_IExtendedExecutionSession] {
    fn get_Reason(&self, out: *mut ExtendedExecutionReason) -> HRESULT,
    fn put_Reason(&self, value: ExtendedExecutionReason) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_PercentProgress(&self, out: *mut u32) -> HRESULT,
    fn put_PercentProgress(&self, value: u32) -> HRESULT,
    fn add_Revoked(&self, handler: *mut super::super::foundation::TypedEventHandler<IInspectable, ExtendedExecutionRevokedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Revoked(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn RequestExtensionAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ExtendedExecutionResult>) -> HRESULT
}}
impl IExtendedExecutionSession {
    #[inline] pub unsafe fn get_reason(&self) -> Result<ExtendedExecutionReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reason(&self, value: ExtendedExecutionReason) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Reason)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_percent_progress(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PercentProgress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_percent_progress(&self, value: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PercentProgress)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_revoked(&self, handler: &super::super::foundation::TypedEventHandler<IInspectable, ExtendedExecutionRevokedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Revoked)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_revoked(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Revoked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_extension_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ExtendedExecutionResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestExtensionAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ExtendedExecutionSession: IExtendedExecutionSession}
impl RtActivatable<IActivationFactory> for ExtendedExecutionSession {}
DEFINE_CLSID!(ExtendedExecutionSession: "Windows.ApplicationModel.ExtendedExecution.ExtendedExecutionSession");
pub mod foreground { // Windows.ApplicationModel.ExtendedExecution.Foreground
use ::prelude::*;
RT_ENUM! { enum ExtendedExecutionForegroundReason: i32 {
    Unspecified (ExtendedExecutionForegroundReason_Unspecified) = 0, SavingData (ExtendedExecutionForegroundReason_SavingData) = 1, BackgroundAudio (ExtendedExecutionForegroundReason_BackgroundAudio) = 2, Unconstrained (ExtendedExecutionForegroundReason_Unconstrained) = 3,
}}
RT_ENUM! { enum ExtendedExecutionForegroundResult: i32 {
    Allowed (ExtendedExecutionForegroundResult_Allowed) = 0, Denied (ExtendedExecutionForegroundResult_Denied) = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionForegroundRevokedEventArgs, 2960972096, 38231, 44708, 44, 153, 189, 213, 109, 155, 228, 97);
RT_INTERFACE!{interface IExtendedExecutionForegroundRevokedEventArgs(IExtendedExecutionForegroundRevokedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IExtendedExecutionForegroundRevokedEventArgs] {
    fn get_Reason(&self, out: *mut ExtendedExecutionForegroundRevokedReason) -> HRESULT
}}
impl IExtendedExecutionForegroundRevokedEventArgs {
    #[inline] pub unsafe fn get_reason(&self) -> Result<ExtendedExecutionForegroundRevokedReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ExtendedExecutionForegroundRevokedEventArgs: IExtendedExecutionForegroundRevokedEventArgs}
RT_ENUM! { enum ExtendedExecutionForegroundRevokedReason: i32 {
    Resumed (ExtendedExecutionForegroundRevokedReason_Resumed) = 0, SystemPolicy (ExtendedExecutionForegroundRevokedReason_SystemPolicy) = 1,
}}
DEFINE_IID!(IID_IExtendedExecutionForegroundSession, 4227088609, 40208, 16897, 176, 30, 200, 50, 117, 41, 111, 46);
RT_INTERFACE!{interface IExtendedExecutionForegroundSession(IExtendedExecutionForegroundSessionVtbl): IInspectable(IInspectableVtbl) [IID_IExtendedExecutionForegroundSession] {
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn add_Revoked(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<IInspectable, ExtendedExecutionForegroundRevokedEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Revoked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn RequestExtensionAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<ExtendedExecutionForegroundResult>) -> HRESULT,
    fn get_Reason(&self, out: *mut ExtendedExecutionForegroundReason) -> HRESULT,
    fn put_Reason(&self, value: ExtendedExecutionForegroundReason) -> HRESULT
}}
impl IExtendedExecutionForegroundSession {
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_revoked(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<IInspectable, ExtendedExecutionForegroundRevokedEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Revoked)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_revoked(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Revoked)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_extension_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<ExtendedExecutionForegroundResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestExtensionAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reason(&self) -> Result<ExtendedExecutionForegroundReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reason(&self, value: ExtendedExecutionForegroundReason) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Reason)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ExtendedExecutionForegroundSession: IExtendedExecutionForegroundSession}
impl RtActivatable<IActivationFactory> for ExtendedExecutionForegroundSession {}
DEFINE_CLSID!(ExtendedExecutionForegroundSession: "Windows.ApplicationModel.ExtendedExecution.Foreground.ExtendedExecutionForegroundSession");
} // Windows.ApplicationModel.ExtendedExecution.Foreground
} // Windows.ApplicationModel.ExtendedExecution
pub mod userdatatasks { // Windows.ApplicationModel.UserDataTasks
use ::prelude::*;
DEFINE_IID!(IID_IUserDataTask, 2087028177, 57556, 20377, 174, 226, 188, 45, 93, 218, 223, 76);
RT_INTERFACE!{interface IUserDataTask(IUserDataTaskVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTask] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_RemoteId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RemoteId(&self, value: HSTRING) -> HRESULT,
    fn get_CompletedDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_CompletedDate(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Details(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Details(&self, value: HSTRING) -> HRESULT,
    fn get_DetailsKind(&self, out: *mut UserDataTaskDetailsKind) -> HRESULT,
    fn put_DetailsKind(&self, value: UserDataTaskDetailsKind) -> HRESULT,
    fn get_DueDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_DueDate(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Kind(&self, out: *mut UserDataTaskKind) -> HRESULT,
    fn get_Priority(&self, out: *mut UserDataTaskPriority) -> HRESULT,
    fn put_Priority(&self, value: UserDataTaskPriority) -> HRESULT,
    fn get_RecurrenceProperties(&self, out: *mut *mut UserDataTaskRecurrenceProperties) -> HRESULT,
    fn put_RecurrenceProperties(&self, value: *mut UserDataTaskRecurrenceProperties) -> HRESULT,
    fn get_RegenerationProperties(&self, out: *mut *mut UserDataTaskRegenerationProperties) -> HRESULT,
    fn put_RegenerationProperties(&self, value: *mut UserDataTaskRegenerationProperties) -> HRESULT,
    fn get_Reminder(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_Reminder(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Sensitivity(&self, out: *mut UserDataTaskSensitivity) -> HRESULT,
    fn put_Sensitivity(&self, value: UserDataTaskSensitivity) -> HRESULT,
    fn get_Subject(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Subject(&self, value: HSTRING) -> HRESULT,
    fn get_StartDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_StartDate(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT
}}
impl IUserDataTask {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_remote_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RemoteId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_remote_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RemoteId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_completed_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CompletedDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_completed_date(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CompletedDate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Details)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_details(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Details)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details_kind(&self) -> Result<UserDataTaskDetailsKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DetailsKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_details_kind(&self, value: UserDataTaskDetailsKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DetailsKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_due_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DueDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_due_date(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DueDate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<UserDataTaskKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_priority(&self) -> Result<UserDataTaskPriority> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Priority)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_priority(&self, value: UserDataTaskPriority) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Priority)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recurrence_properties(&self) -> Result<ComPtr<UserDataTaskRecurrenceProperties>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RecurrenceProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_recurrence_properties(&self, value: &UserDataTaskRecurrenceProperties) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RecurrenceProperties)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_regeneration_properties(&self) -> Result<ComPtr<UserDataTaskRegenerationProperties>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RegenerationProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_regeneration_properties(&self, value: &UserDataTaskRegenerationProperties) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RegenerationProperties)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_reminder(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Reminder)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_reminder(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Reminder)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sensitivity(&self) -> Result<UserDataTaskSensitivity> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Sensitivity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sensitivity(&self, value: UserDataTaskSensitivity) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Sensitivity)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subject(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Subject)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_subject(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Subject)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_start_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StartDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_start_date(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_StartDate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTask: IUserDataTask}
impl RtActivatable<IActivationFactory> for UserDataTask {}
DEFINE_CLSID!(UserDataTask: "Windows.ApplicationModel.UserDataTasks.UserDataTask");
DEFINE_IID!(IID_IUserDataTaskBatch, 942515710, 8373, 17180, 143, 66, 165, 210, 146, 236, 147, 12);
RT_INTERFACE!{interface IUserDataTaskBatch(IUserDataTaskBatchVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskBatch] {
    fn get_Tasks(&self, out: *mut *mut super::super::foundation::collections::IVectorView<UserDataTask>) -> HRESULT
}}
impl IUserDataTaskBatch {
    #[inline] pub unsafe fn get_tasks(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<UserDataTask>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tasks)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskBatch: IUserDataTaskBatch}
RT_ENUM! { enum UserDataTaskDaysOfWeek: u32 {
    None (UserDataTaskDaysOfWeek_None) = 0, Sunday (UserDataTaskDaysOfWeek_Sunday) = 1, Monday (UserDataTaskDaysOfWeek_Monday) = 2, Tuesday (UserDataTaskDaysOfWeek_Tuesday) = 4, Wednesday (UserDataTaskDaysOfWeek_Wednesday) = 8, Thursday (UserDataTaskDaysOfWeek_Thursday) = 16, Friday (UserDataTaskDaysOfWeek_Friday) = 32, Saturday (UserDataTaskDaysOfWeek_Saturday) = 64,
}}
RT_ENUM! { enum UserDataTaskDetailsKind: i32 {
    PlainText (UserDataTaskDetailsKind_PlainText) = 0, Html (UserDataTaskDetailsKind_Html) = 1,
}}
RT_ENUM! { enum UserDataTaskKind: i32 {
    Single (UserDataTaskKind_Single) = 0, Recurring (UserDataTaskKind_Recurring) = 1, Regenerating (UserDataTaskKind_Regenerating) = 2,
}}
DEFINE_IID!(IID_IUserDataTaskList, 1229008441, 31773, 19953, 190, 211, 49, 75, 124, 191, 94, 78);
RT_INTERFACE!{interface IUserDataTaskList(IUserDataTaskListVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskList] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_SourceDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut UserDataTaskListOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: UserDataTaskListOtherAppReadAccess) -> HRESULT,
    fn get_OtherAppWriteAccess(&self, out: *mut UserDataTaskListOtherAppWriteAccess) -> HRESULT,
    fn put_OtherAppWriteAccess(&self, value: UserDataTaskListOtherAppWriteAccess) -> HRESULT,
    fn get_LimitedWriteOperations(&self, out: *mut *mut UserDataTaskListLimitedWriteOperations) -> HRESULT,
    fn get_SyncManager(&self, out: *mut *mut UserDataTaskListSyncManager) -> HRESULT,
    fn RegisterSyncManagerAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetTaskReader(&self, out: *mut *mut UserDataTaskReader) -> HRESULT,
    fn GetTaskReaderWithOptions(&self, options: *mut UserDataTaskQueryOptions, out: *mut *mut UserDataTaskReader) -> HRESULT,
    fn GetTaskAsync(&self, userDataTask: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataTask>) -> HRESULT,
    fn SaveTaskAsync(&self, userDataTask: *mut UserDataTask, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteTaskAsync(&self, userDataTaskId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataTaskList {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_source_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SourceDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_read_access(&self) -> Result<UserDataTaskListOtherAppReadAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppReadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_read_access(&self, value: UserDataTaskListOtherAppReadAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppReadAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_write_access(&self) -> Result<UserDataTaskListOtherAppWriteAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppWriteAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_write_access(&self, value: UserDataTaskListOtherAppWriteAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppWriteAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_limited_write_operations(&self) -> Result<ComPtr<UserDataTaskListLimitedWriteOperations>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LimitedWriteOperations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sync_manager(&self) -> Result<ComPtr<UserDataTaskListSyncManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SyncManager)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn register_sync_manager_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterSyncManagerAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_reader(&self) -> Result<ComPtr<UserDataTaskReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTaskReader)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_reader_with_options(&self, options: &UserDataTaskQueryOptions) -> Result<ComPtr<UserDataTaskReader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTaskReaderWithOptions)(self as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_async(&self, userDataTask: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataTask>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetTaskAsync)(self as *const _ as *mut _, userDataTask.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_task_async(&self, userDataTask: &UserDataTask) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveTaskAsync)(self as *const _ as *mut _, userDataTask as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_task_async(&self, userDataTaskId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteTaskAsync)(self as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskList: IUserDataTaskList}
DEFINE_IID!(IID_IUserDataTaskListLimitedWriteOperations, 2057463794, 24696, 16771, 145, 158, 79, 41, 241, 156, 250, 233);
RT_INTERFACE!{interface IUserDataTaskListLimitedWriteOperations(IUserDataTaskListLimitedWriteOperationsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListLimitedWriteOperations] {
    fn TryCompleteTaskAsync(&self, userDataTaskId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn TryCreateOrUpdateTaskAsync(&self, userDataTask: *mut UserDataTask, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TryDeleteTaskAsync(&self, userDataTaskId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn TrySkipOccurrenceAsync(&self, userDataTaskId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IUserDataTaskListLimitedWriteOperations {
    #[inline] pub unsafe fn try_complete_task_async(&self, userDataTaskId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCompleteTaskAsync)(self as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_create_or_update_task_async(&self, userDataTask: &UserDataTask) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryCreateOrUpdateTaskAsync)(self as *const _ as *mut _, userDataTask as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_delete_task_async(&self, userDataTaskId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryDeleteTaskAsync)(self as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_skip_occurrence_async(&self, userDataTaskId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TrySkipOccurrenceAsync)(self as *const _ as *mut _, userDataTaskId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListLimitedWriteOperations: IUserDataTaskListLimitedWriteOperations}
RT_ENUM! { enum UserDataTaskListOtherAppReadAccess: i32 {
    Full (UserDataTaskListOtherAppReadAccess_Full) = 0, SystemOnly (UserDataTaskListOtherAppReadAccess_SystemOnly) = 1, None (UserDataTaskListOtherAppReadAccess_None) = 2,
}}
RT_ENUM! { enum UserDataTaskListOtherAppWriteAccess: i32 {
    Limited (UserDataTaskListOtherAppWriteAccess_Limited) = 0, None (UserDataTaskListOtherAppWriteAccess_None) = 1,
}}
DEFINE_IID!(IID_IUserDataTaskListSyncManager, 2388204181, 7631, 18079, 147, 236, 186, 72, 187, 85, 60, 107);
RT_INTERFACE!{interface IUserDataTaskListSyncManager(IUserDataTaskListSyncManagerVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListSyncManager] {
    fn get_LastAttemptedSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_LastAttemptedSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_LastSuccessfulSyncTime(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn put_LastSuccessfulSyncTime(&self, value: super::super::foundation::DateTime) -> HRESULT,
    fn get_Status(&self, out: *mut UserDataTaskListSyncStatus) -> HRESULT,
    fn put_Status(&self, value: UserDataTaskListSyncStatus) -> HRESULT,
    fn SyncAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_SyncStatusChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<UserDataTaskListSyncManager, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncStatusChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IUserDataTaskListSyncManager {
    #[inline] pub unsafe fn get_last_attempted_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastAttemptedSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_attempted_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastAttemptedSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_successful_sync_time(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_LastSuccessfulSyncTime)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_successful_sync_time(&self, value: super::super::foundation::DateTime) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastSuccessfulSyncTime)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_status(&self) -> Result<UserDataTaskListSyncStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_status(&self, value: UserDataTaskListSyncStatus) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Status)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn sync_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SyncAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_sync_status_changed(&self, handler: &super::super::foundation::TypedEventHandler<UserDataTaskListSyncManager, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_status_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListSyncManager: IUserDataTaskListSyncManager}
RT_ENUM! { enum UserDataTaskListSyncStatus: i32 {
    Idle (UserDataTaskListSyncStatus_Idle) = 0, Syncing (UserDataTaskListSyncStatus_Syncing) = 1, UpToDate (UserDataTaskListSyncStatus_UpToDate) = 2, AuthenticationError (UserDataTaskListSyncStatus_AuthenticationError) = 3, PolicyError (UserDataTaskListSyncStatus_PolicyError) = 4, UnknownError (UserDataTaskListSyncStatus_UnknownError) = 5,
}}
DEFINE_IID!(IID_IUserDataTaskManager, 2219952404, 58891, 18601, 146, 17, 127, 184, 165, 108, 184, 76);
RT_INTERFACE!{interface IUserDataTaskManager(IUserDataTaskManagerVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskManager] {
    fn RequestStoreAsync(&self, accessType: UserDataTaskStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataTaskStore>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IUserDataTaskManager {
    #[inline] pub unsafe fn request_store_async(&self, accessType: UserDataTaskStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataTaskStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, accessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskManager: IUserDataTaskManager}
impl RtActivatable<IUserDataTaskManagerStatics> for UserDataTaskManager {}
impl UserDataTaskManager {
    #[inline] pub fn get_default() -> Result<ComPtr<UserDataTaskManager>> { unsafe {
        <Self as RtActivatable<IUserDataTaskManagerStatics>>::get_activation_factory().get_default()
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<UserDataTaskManager>> { unsafe {
        <Self as RtActivatable<IUserDataTaskManagerStatics>>::get_activation_factory().get_for_user(user)
    }}
}
DEFINE_CLSID!(UserDataTaskManager: "Windows.ApplicationModel.UserDataTasks.UserDataTaskManager");
DEFINE_IID!(IID_IUserDataTaskManagerStatics, 3008707064, 50434, 18428, 168, 30, 16, 8, 131, 113, 157, 85);
RT_INTERFACE!{static interface IUserDataTaskManagerStatics(IUserDataTaskManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskManagerStatics] {
    fn GetDefault(&self, out: *mut *mut UserDataTaskManager) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut UserDataTaskManager) -> HRESULT
}}
impl IUserDataTaskManagerStatics {
    #[inline] pub unsafe fn get_default(&self) -> Result<ComPtr<UserDataTaskManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<UserDataTaskManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum UserDataTaskPriority: i32 {
    Normal (UserDataTaskPriority_Normal) = 0, Low (UserDataTaskPriority_Low) = -1, High (UserDataTaskPriority_High) = 1,
}}
RT_ENUM! { enum UserDataTaskQueryKind: i32 {
    All (UserDataTaskQueryKind_All) = 0, Incomplete (UserDataTaskQueryKind_Incomplete) = 1, Complete (UserDataTaskQueryKind_Complete) = 2,
}}
DEFINE_IID!(IID_IUserDataTaskQueryOptions, 2510235629, 37018, 19760, 140, 27, 51, 29, 143, 230, 103, 226);
RT_INTERFACE!{interface IUserDataTaskQueryOptions(IUserDataTaskQueryOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskQueryOptions] {
    fn get_SortProperty(&self, out: *mut UserDataTaskQuerySortProperty) -> HRESULT,
    fn put_SortProperty(&self, value: UserDataTaskQuerySortProperty) -> HRESULT,
    fn get_Kind(&self, out: *mut UserDataTaskQueryKind) -> HRESULT,
    fn put_Kind(&self, value: UserDataTaskQueryKind) -> HRESULT
}}
impl IUserDataTaskQueryOptions {
    #[inline] pub unsafe fn get_sort_property(&self) -> Result<UserDataTaskQuerySortProperty> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SortProperty)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sort_property(&self, value: UserDataTaskQuerySortProperty) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SortProperty)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<UserDataTaskQueryKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_kind(&self, value: UserDataTaskQueryKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Kind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskQueryOptions: IUserDataTaskQueryOptions}
impl RtActivatable<IActivationFactory> for UserDataTaskQueryOptions {}
DEFINE_CLSID!(UserDataTaskQueryOptions: "Windows.ApplicationModel.UserDataTasks.UserDataTaskQueryOptions");
RT_ENUM! { enum UserDataTaskQuerySortProperty: i32 {
    DueDate (UserDataTaskQuerySortProperty_DueDate) = 0,
}}
DEFINE_IID!(IID_IUserDataTaskReader, 65439921, 19663, 17664, 136, 59, 231, 98, 144, 207, 237, 99);
RT_INTERFACE!{interface IUserDataTaskReader(IUserDataTaskReaderVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskReader] {
    fn ReadBatchAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataTaskBatch>) -> HRESULT
}}
impl IUserDataTaskReader {
    #[inline] pub unsafe fn read_batch_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataTaskBatch>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReadBatchAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskReader: IUserDataTaskReader}
DEFINE_IID!(IID_IUserDataTaskRecurrenceProperties, 1944027312, 10182, 16590, 177, 73, 156, 212, 20, 133, 166, 158);
RT_INTERFACE!{interface IUserDataTaskRecurrenceProperties(IUserDataTaskRecurrencePropertiesVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskRecurrenceProperties] {
    fn get_Unit(&self, out: *mut UserDataTaskRecurrenceUnit) -> HRESULT,
    fn put_Unit(&self, value: UserDataTaskRecurrenceUnit) -> HRESULT,
    fn get_Occurrences(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_Occurrences(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_Until(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_Until(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Interval(&self, out: *mut i32) -> HRESULT,
    fn put_Interval(&self, value: i32) -> HRESULT,
    fn get_DaysOfWeek(&self, out: *mut *mut super::super::foundation::IReference<UserDataTaskDaysOfWeek>) -> HRESULT,
    fn put_DaysOfWeek(&self, value: *mut super::super::foundation::IReference<UserDataTaskDaysOfWeek>) -> HRESULT,
    fn get_WeekOfMonth(&self, out: *mut *mut super::super::foundation::IReference<UserDataTaskWeekOfMonth>) -> HRESULT,
    fn put_WeekOfMonth(&self, value: *mut super::super::foundation::IReference<UserDataTaskWeekOfMonth>) -> HRESULT,
    fn get_Month(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_Month(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_Day(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_Day(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT
}}
impl IUserDataTaskRecurrenceProperties {
    #[inline] pub unsafe fn get_unit(&self) -> Result<UserDataTaskRecurrenceUnit> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Unit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_unit(&self, value: UserDataTaskRecurrenceUnit) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Unit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_occurrences(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Occurrences)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_occurrences(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Occurrences)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_until(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Until)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_until(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Until)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_interval(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Interval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_interval(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Interval)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_days_of_week(&self) -> Result<ComPtr<super::super::foundation::IReference<UserDataTaskDaysOfWeek>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DaysOfWeek)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_days_of_week(&self, value: &super::super::foundation::IReference<UserDataTaskDaysOfWeek>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DaysOfWeek)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_week_of_month(&self) -> Result<ComPtr<super::super::foundation::IReference<UserDataTaskWeekOfMonth>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_WeekOfMonth)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_week_of_month(&self, value: &super::super::foundation::IReference<UserDataTaskWeekOfMonth>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_WeekOfMonth)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_month(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Month)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_month(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Month)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_day(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Day)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_day(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Day)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskRecurrenceProperties: IUserDataTaskRecurrenceProperties}
impl RtActivatable<IActivationFactory> for UserDataTaskRecurrenceProperties {}
DEFINE_CLSID!(UserDataTaskRecurrenceProperties: "Windows.ApplicationModel.UserDataTasks.UserDataTaskRecurrenceProperties");
RT_ENUM! { enum UserDataTaskRecurrenceUnit: i32 {
    Daily (UserDataTaskRecurrenceUnit_Daily) = 0, Weekly (UserDataTaskRecurrenceUnit_Weekly) = 1, Monthly (UserDataTaskRecurrenceUnit_Monthly) = 2, MonthlyOnDay (UserDataTaskRecurrenceUnit_MonthlyOnDay) = 3, Yearly (UserDataTaskRecurrenceUnit_Yearly) = 4, YearlyOnDay (UserDataTaskRecurrenceUnit_YearlyOnDay) = 5,
}}
DEFINE_IID!(IID_IUserDataTaskRegenerationProperties, 2460680199, 2318, 18180, 187, 92, 132, 252, 11, 13, 156, 49);
RT_INTERFACE!{interface IUserDataTaskRegenerationProperties(IUserDataTaskRegenerationPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskRegenerationProperties] {
    fn get_Unit(&self, out: *mut UserDataTaskRegenerationUnit) -> HRESULT,
    fn put_Unit(&self, value: UserDataTaskRegenerationUnit) -> HRESULT,
    fn get_Occurrences(&self, out: *mut *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn put_Occurrences(&self, value: *mut super::super::foundation::IReference<i32>) -> HRESULT,
    fn get_Until(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_Until(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Interval(&self, out: *mut i32) -> HRESULT,
    fn put_Interval(&self, value: i32) -> HRESULT
}}
impl IUserDataTaskRegenerationProperties {
    #[inline] pub unsafe fn get_unit(&self) -> Result<UserDataTaskRegenerationUnit> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Unit)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_unit(&self, value: UserDataTaskRegenerationUnit) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Unit)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_occurrences(&self) -> Result<ComPtr<super::super::foundation::IReference<i32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Occurrences)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_occurrences(&self, value: &super::super::foundation::IReference<i32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Occurrences)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_until(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Until)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_until(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Until)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_interval(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Interval)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_interval(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Interval)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskRegenerationProperties: IUserDataTaskRegenerationProperties}
impl RtActivatable<IActivationFactory> for UserDataTaskRegenerationProperties {}
DEFINE_CLSID!(UserDataTaskRegenerationProperties: "Windows.ApplicationModel.UserDataTasks.UserDataTaskRegenerationProperties");
RT_ENUM! { enum UserDataTaskRegenerationUnit: i32 {
    Daily (UserDataTaskRegenerationUnit_Daily) = 0, Weekly (UserDataTaskRegenerationUnit_Weekly) = 1, Monthly (UserDataTaskRegenerationUnit_Monthly) = 2, Yearly (UserDataTaskRegenerationUnit_Yearly) = 4,
}}
RT_ENUM! { enum UserDataTaskSensitivity: i32 {
    Public (UserDataTaskSensitivity_Public) = 0, Private (UserDataTaskSensitivity_Private) = 1,
}}
DEFINE_IID!(IID_IUserDataTaskStore, 4033518768, 61915, 17850, 138, 98, 8, 96, 4, 192, 33, 61);
RT_INTERFACE!{interface IUserDataTaskStore(IUserDataTaskStoreVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskStore] {
    fn CreateListAsync(&self, name: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataTaskList>) -> HRESULT,
    fn CreateListInAccountAsync(&self, name: HSTRING, userDataAccountId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataTaskList>) -> HRESULT,
    fn FindListsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UserDataTaskList>>) -> HRESULT,
    fn GetListAsync(&self, taskListId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataTaskList>) -> HRESULT
}}
impl IUserDataTaskStore {
    #[inline] pub unsafe fn create_list_async(&self, name: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataTaskList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateListAsync)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_list_in_account_async(&self, name: &HStringArg, userDataAccountId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataTaskList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateListInAccountAsync)(self as *const _ as *mut _, name.get(), userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_lists_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UserDataTaskList>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindListsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_list_async(&self, taskListId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataTaskList>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetListAsync)(self as *const _ as *mut _, taskListId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskStore: IUserDataTaskStore}
RT_ENUM! { enum UserDataTaskStoreAccessType: i32 {
    AppTasksReadWrite (UserDataTaskStoreAccessType_AppTasksReadWrite) = 0, AllTasksLimitedReadWrite (UserDataTaskStoreAccessType_AllTasksLimitedReadWrite) = 1,
}}
RT_ENUM! { enum UserDataTaskWeekOfMonth: i32 {
    First (UserDataTaskWeekOfMonth_First) = 0, Second (UserDataTaskWeekOfMonth_Second) = 1, Third (UserDataTaskWeekOfMonth_Third) = 2, Fourth (UserDataTaskWeekOfMonth_Fourth) = 3, Last (UserDataTaskWeekOfMonth_Last) = 4,
}}
pub mod dataprovider { // Windows.ApplicationModel.UserDataTasks.DataProvider
use ::prelude::*;
DEFINE_IID!(IID_IUserDataTaskDataProviderConnection, 2683542813, 42055, 17035, 175, 233, 229, 64, 43, 222, 176, 65);
RT_INTERFACE!{interface IUserDataTaskDataProviderConnection(IUserDataTaskDataProviderConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskDataProviderConnection] {
    fn add_CreateOrUpdateTaskRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCreateOrUpdateTaskRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CreateOrUpdateTaskRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SyncRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSyncManagerSyncRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SyncRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_SkipOccurrenceRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSkipOccurrenceRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SkipOccurrenceRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_CompleteTaskRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCompleteTaskRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_CompleteTaskRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_DeleteTaskRequested(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListDeleteTaskRequestEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DeleteTaskRequested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn Start(&self) -> HRESULT
}}
impl IUserDataTaskDataProviderConnection {
    #[inline] pub unsafe fn add_create_or_update_task_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCreateOrUpdateTaskRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CreateOrUpdateTaskRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_create_or_update_task_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CreateOrUpdateTaskRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_sync_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSyncManagerSyncRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SyncRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_sync_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SyncRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_skip_occurrence_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListSkipOccurrenceRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SkipOccurrenceRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_skip_occurrence_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SkipOccurrenceRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_complete_task_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListCompleteTaskRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_CompleteTaskRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_complete_task_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_CompleteTaskRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_delete_task_requested(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<UserDataTaskDataProviderConnection, UserDataTaskListDeleteTaskRequestEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DeleteTaskRequested)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_delete_task_requested(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DeleteTaskRequested)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn start(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Start)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskDataProviderConnection: IUserDataTaskDataProviderConnection}
DEFINE_IID!(IID_IUserDataTaskDataProviderTriggerDetails, 2921804290, 45513, 17726, 175, 197, 179, 10, 243, 189, 33, 125);
RT_INTERFACE!{interface IUserDataTaskDataProviderTriggerDetails(IUserDataTaskDataProviderTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskDataProviderTriggerDetails] {
    fn get_Connection(&self, out: *mut *mut UserDataTaskDataProviderConnection) -> HRESULT
}}
impl IUserDataTaskDataProviderTriggerDetails {
    #[inline] pub unsafe fn get_connection(&self) -> Result<ComPtr<UserDataTaskDataProviderConnection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Connection)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskDataProviderTriggerDetails: IUserDataTaskDataProviderTriggerDetails}
DEFINE_IID!(IID_IUserDataTaskListCompleteTaskRequest, 4133360803, 6722, 18906, 133, 82, 40, 115, 229, 44, 85, 235);
RT_INTERFACE!{interface IUserDataTaskListCompleteTaskRequest(IUserDataTaskListCompleteTaskRequestVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListCompleteTaskRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, completedTaskId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataTaskListCompleteTaskRequest {
    #[inline] pub unsafe fn get_task_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, completedTaskId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, completedTaskId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListCompleteTaskRequest: IUserDataTaskListCompleteTaskRequest}
DEFINE_IID!(IID_IUserDataTaskListCompleteTaskRequestEventArgs, 3615242557, 19698, 18605, 135, 253, 150, 63, 14, 170, 122, 149);
RT_INTERFACE!{interface IUserDataTaskListCompleteTaskRequestEventArgs(IUserDataTaskListCompleteTaskRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListCompleteTaskRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut UserDataTaskListCompleteTaskRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IUserDataTaskListCompleteTaskRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<UserDataTaskListCompleteTaskRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListCompleteTaskRequestEventArgs: IUserDataTaskListCompleteTaskRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListCreateOrUpdateTaskRequest, 557020972, 21954, 17152, 130, 121, 4, 50, 110, 7, 204, 228);
RT_INTERFACE!{interface IUserDataTaskListCreateOrUpdateTaskRequest(IUserDataTaskListCreateOrUpdateTaskRequestVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListCreateOrUpdateTaskRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Task(&self, out: *mut *mut super::UserDataTask) -> HRESULT,
    fn ReportCompletedAsync(&self, createdOrUpdatedUserDataTask: *mut super::UserDataTask, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataTaskListCreateOrUpdateTaskRequest {
    #[inline] pub unsafe fn get_task_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task(&self) -> Result<ComPtr<super::UserDataTask>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Task)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self, createdOrUpdatedUserDataTask: &super::UserDataTask) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, createdOrUpdatedUserDataTask as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListCreateOrUpdateTaskRequest: IUserDataTaskListCreateOrUpdateTaskRequest}
DEFINE_IID!(IID_IUserDataTaskListCreateOrUpdateTaskRequestEventArgs, 314923602, 58232, 16795, 174, 56, 165, 233, 230, 4, 71, 110);
RT_INTERFACE!{interface IUserDataTaskListCreateOrUpdateTaskRequestEventArgs(IUserDataTaskListCreateOrUpdateTaskRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListCreateOrUpdateTaskRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut UserDataTaskListCreateOrUpdateTaskRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IUserDataTaskListCreateOrUpdateTaskRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<UserDataTaskListCreateOrUpdateTaskRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListCreateOrUpdateTaskRequestEventArgs: IUserDataTaskListCreateOrUpdateTaskRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListDeleteTaskRequest, 1267088488, 30295, 20285, 176, 116, 212, 126, 200, 223, 7, 231);
RT_INTERFACE!{interface IUserDataTaskListDeleteTaskRequest(IUserDataTaskListDeleteTaskRequestVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListDeleteTaskRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataTaskListDeleteTaskRequest {
    #[inline] pub unsafe fn get_task_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListDeleteTaskRequest: IUserDataTaskListDeleteTaskRequest}
DEFINE_IID!(IID_IUserDataTaskListDeleteTaskRequestEventArgs, 1617156825, 62818, 16709, 142, 254, 213, 0, 120, 201, 43, 127);
RT_INTERFACE!{interface IUserDataTaskListDeleteTaskRequestEventArgs(IUserDataTaskListDeleteTaskRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListDeleteTaskRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut UserDataTaskListDeleteTaskRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IUserDataTaskListDeleteTaskRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<UserDataTaskListDeleteTaskRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListDeleteTaskRequestEventArgs: IUserDataTaskListDeleteTaskRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListSkipOccurrenceRequest, 2877809485, 7379, 17180, 159, 88, 8, 154, 164, 51, 141, 133);
RT_INTERFACE!{interface IUserDataTaskListSkipOccurrenceRequest(IUserDataTaskListSkipOccurrenceRequestVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListSkipOccurrenceRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TaskId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataTaskListSkipOccurrenceRequest {
    #[inline] pub unsafe fn get_task_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_task_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListSkipOccurrenceRequest: IUserDataTaskListSkipOccurrenceRequest}
DEFINE_IID!(IID_IUserDataTaskListSkipOccurrenceRequestEventArgs, 2050724426, 52271, 20091, 170, 205, 165, 185, 210, 156, 250, 78);
RT_INTERFACE!{interface IUserDataTaskListSkipOccurrenceRequestEventArgs(IUserDataTaskListSkipOccurrenceRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListSkipOccurrenceRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut UserDataTaskListSkipOccurrenceRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IUserDataTaskListSkipOccurrenceRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<UserDataTaskListSkipOccurrenceRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListSkipOccurrenceRequestEventArgs: IUserDataTaskListSkipOccurrenceRequestEventArgs}
DEFINE_IID!(IID_IUserDataTaskListSyncManagerSyncRequest, 1084700679, 30096, 16713, 174, 25, 178, 17, 67, 26, 159, 72);
RT_INTERFACE!{interface IUserDataTaskListSyncManagerSyncRequest(IUserDataTaskListSyncManagerSyncRequestVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListSyncManagerSyncRequest] {
    fn get_TaskListId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompletedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailedAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataTaskListSyncManagerSyncRequest {
    #[inline] pub unsafe fn get_task_list_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TaskListId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportCompletedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failed_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailedAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListSyncManagerSyncRequest: IUserDataTaskListSyncManagerSyncRequest}
DEFINE_IID!(IID_IUserDataTaskListSyncManagerSyncRequestEventArgs, 2393709586, 30350, 17341, 131, 133, 92, 220, 53, 31, 253, 234);
RT_INTERFACE!{interface IUserDataTaskListSyncManagerSyncRequestEventArgs(IUserDataTaskListSyncManagerSyncRequestEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataTaskListSyncManagerSyncRequestEventArgs] {
    fn get_Request(&self, out: *mut *mut UserDataTaskListSyncManagerSyncRequest) -> HRESULT,
    fn GetDeferral(&self, out: *mut *mut ::rt::gen::windows::foundation::Deferral) -> HRESULT
}}
impl IUserDataTaskListSyncManagerSyncRequestEventArgs {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<UserDataTaskListSyncManagerSyncRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataTaskListSyncManagerSyncRequestEventArgs: IUserDataTaskListSyncManagerSyncRequestEventArgs}
} // Windows.ApplicationModel.UserDataTasks.DataProvider
} // Windows.ApplicationModel.UserDataTasks
pub mod useractivities { // Windows.ApplicationModel.UserActivities
use ::prelude::*;
DEFINE_IID!(IID_IUserActivity, 4228923038, 11435, 19766, 174, 162, 180, 187, 85, 108, 239, 15);
RT_INTERFACE!{interface IUserActivity(IUserActivityVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivity] {
    fn get_State(&self, out: *mut UserActivityState) -> HRESULT,
    fn get_ActivityId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_VisualElements(&self, out: *mut *mut UserActivityVisualElements) -> HRESULT,
    fn get_ContentUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_ContentUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_ContentType(&self, out: *mut HSTRING) -> HRESULT,
    fn put_ContentType(&self, value: HSTRING) -> HRESULT,
    fn get_FallbackUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_FallbackUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_ActivationUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_ActivationUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_ContentInfo(&self, out: *mut *mut IUserActivityContentInfo) -> HRESULT,
    fn put_ContentInfo(&self, value: *mut IUserActivityContentInfo) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn CreateSession(&self, out: *mut *mut UserActivitySession) -> HRESULT
}}
impl IUserActivity {
    #[inline] pub unsafe fn get_state(&self) -> Result<UserActivityState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_State)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_visual_elements(&self) -> Result<ComPtr<UserActivityVisualElements>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VisualElements)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_type(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentType)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_fallback_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FallbackUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_fallback_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_FallbackUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_activation_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActivationUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_activation_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ActivationUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_info(&self) -> Result<ComPtr<IUserActivityContentInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ContentInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_info(&self, value: &IUserActivityContentInfo) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentInfo)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_session(&self) -> Result<ComPtr<UserActivitySession>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateSession)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserActivity: IUserActivity}
DEFINE_IID!(IID_IUserActivityAttribution, 883280053, 34525, 19180, 164, 145, 106, 79, 174, 165, 210, 46);
RT_INTERFACE!{interface IUserActivityAttribution(IUserActivityAttributionVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityAttribution] {
    fn get_IconUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_IconUri(&self, value: *mut super::super::foundation::Uri) -> HRESULT,
    fn get_AlternateText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AlternateText(&self, value: HSTRING) -> HRESULT,
    fn get_AddImageQuery(&self, out: *mut bool) -> HRESULT,
    fn put_AddImageQuery(&self, value: bool) -> HRESULT
}}
impl IUserActivityAttribution {
    #[inline] pub unsafe fn get_icon_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IconUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_icon_uri(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IconUri)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_alternate_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlternateText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_alternate_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AlternateText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_add_image_query(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AddImageQuery)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_add_image_query(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AddImageQuery)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserActivityAttribution: IUserActivityAttribution}
impl RtActivatable<IUserActivityAttributionFactory> for UserActivityAttribution {}
impl RtActivatable<IActivationFactory> for UserActivityAttribution {}
impl UserActivityAttribution {
    #[inline] pub fn create_with_uri(iconUri: &super::super::foundation::Uri) -> Result<ComPtr<UserActivityAttribution>> { unsafe {
        <Self as RtActivatable<IUserActivityAttributionFactory>>::get_activation_factory().create_with_uri(iconUri)
    }}
}
DEFINE_CLSID!(UserActivityAttribution: "Windows.ApplicationModel.UserActivities.UserActivityAttribution");
DEFINE_IID!(IID_IUserActivityAttributionFactory, 3861631570, 50534, 20290, 153, 116, 145, 108, 77, 118, 55, 126);
RT_INTERFACE!{static interface IUserActivityAttributionFactory(IUserActivityAttributionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityAttributionFactory] {
    fn CreateWithUri(&self, iconUri: *mut super::super::foundation::Uri, out: *mut *mut UserActivityAttribution) -> HRESULT
}}
impl IUserActivityAttributionFactory {
    #[inline] pub unsafe fn create_with_uri(&self, iconUri: &super::super::foundation::Uri) -> Result<ComPtr<UserActivityAttribution>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithUri)(self as *const _ as *mut _, iconUri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserActivityChannel, 3133208760, 41188, 18491, 185, 72, 156, 186, 189, 6, 7, 12);
RT_INTERFACE!{interface IUserActivityChannel(IUserActivityChannelVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityChannel] {
    fn GetOrCreateUserActivityAsync(&self, activityId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserActivity>) -> HRESULT,
    fn DeleteActivityAsync(&self, activityId: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteAllActivitiesAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IUserActivityChannel {
    #[inline] pub unsafe fn get_or_create_user_activity_async(&self, activityId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserActivity>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetOrCreateUserActivityAsync)(self as *const _ as *mut _, activityId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_activity_async(&self, activityId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteActivityAsync)(self as *const _ as *mut _, activityId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_all_activities_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAllActivitiesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserActivityChannel: IUserActivityChannel}
impl RtActivatable<IUserActivityChannelStatics> for UserActivityChannel {}
impl UserActivityChannel {
    #[inline] pub fn get_default() -> Result<ComPtr<UserActivityChannel>> { unsafe {
        <Self as RtActivatable<IUserActivityChannelStatics>>::get_activation_factory().get_default()
    }}
}
DEFINE_CLSID!(UserActivityChannel: "Windows.ApplicationModel.UserActivities.UserActivityChannel");
DEFINE_IID!(IID_IUserActivityChannelStatics, 3368027563, 6541, 19840, 171, 178, 201, 119, 94, 196, 167, 41);
RT_INTERFACE!{static interface IUserActivityChannelStatics(IUserActivityChannelStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityChannelStatics] {
    fn GetDefault(&self, out: *mut *mut UserActivityChannel) -> HRESULT
}}
impl IUserActivityChannelStatics {
    #[inline] pub unsafe fn get_default(&self) -> Result<ComPtr<UserActivityChannel>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserActivityContentInfo, 3013207469, 4991, 16541, 130, 45, 225, 175, 39, 206, 8, 220);
RT_INTERFACE!{interface IUserActivityContentInfo(IUserActivityContentInfoVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityContentInfo] {
    fn ToJson(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUserActivityContentInfo {
    #[inline] pub unsafe fn to_json(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ToJson)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserActivityContentInfo: IUserActivityContentInfo}
impl RtActivatable<IUserActivityContentInfoStatics> for UserActivityContentInfo {}
impl UserActivityContentInfo {
    #[inline] pub fn from_json(value: &HStringArg) -> Result<ComPtr<UserActivityContentInfo>> { unsafe {
        <Self as RtActivatable<IUserActivityContentInfoStatics>>::get_activation_factory().from_json(value)
    }}
}
DEFINE_CLSID!(UserActivityContentInfo: "Windows.ApplicationModel.UserActivities.UserActivityContentInfo");
DEFINE_IID!(IID_IUserActivityContentInfoStatics, 2575876939, 902, 19401, 150, 138, 130, 0, 176, 4, 20, 79);
RT_INTERFACE!{static interface IUserActivityContentInfoStatics(IUserActivityContentInfoStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityContentInfoStatics] {
    fn FromJson(&self, value: HSTRING, out: *mut *mut UserActivityContentInfo) -> HRESULT
}}
impl IUserActivityContentInfoStatics {
    #[inline] pub unsafe fn from_json(&self, value: &HStringArg) -> Result<ComPtr<UserActivityContentInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FromJson)(self as *const _ as *mut _, value.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserActivitySession, 2923646328, 9466, 17571, 173, 72, 110, 218, 97, 170, 25, 36);
RT_INTERFACE!{interface IUserActivitySession(IUserActivitySessionVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivitySession] {
    fn get_ActivityId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUserActivitySession {
    #[inline] pub unsafe fn get_activity_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ActivityId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserActivitySession: IUserActivitySession}
RT_ENUM! { enum UserActivityState: i32 {
    New (UserActivityState_New) = 0, Published (UserActivityState_Published) = 1,
}}
DEFINE_IID!(IID_IUserActivityVisualElements, 2490725651, 9775, 18927, 187, 191, 155, 117, 210, 232, 82, 80);
RT_INTERFACE!{interface IUserActivityVisualElements(IUserActivityVisualElementsVtbl): IInspectable(IInspectableVtbl) [IID_IUserActivityVisualElements] {
    fn get_DisplayText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayText(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_BackgroundColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_BackgroundColor(&self, value: super::super::ui::Color) -> HRESULT,
    fn get_Attribution(&self, out: *mut *mut UserActivityAttribution) -> HRESULT,
    fn put_Attribution(&self, value: *mut UserActivityAttribution) -> HRESULT,
    #[cfg(feature="windows-ui")] fn put_Content(&self, value: *mut super::super::ui::shell::IAdaptiveCard) -> HRESULT,
    #[cfg(feature="windows-ui")] fn get_Content(&self, out: *mut *mut super::super::ui::shell::IAdaptiveCard) -> HRESULT
}}
impl IUserActivityVisualElements {
    #[inline] pub unsafe fn get_display_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_background_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BackgroundColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_background_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BackgroundColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_attribution(&self) -> Result<ComPtr<UserActivityAttribution>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Attribution)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_attribution(&self, value: &UserActivityAttribution) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Attribution)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_content(&self, value: &super::super::ui::shell::IAdaptiveCard) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Content)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_content(&self) -> Result<ComPtr<super::super::ui::shell::IAdaptiveCard>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Content)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserActivityVisualElements: IUserActivityVisualElements}
pub mod core { // Windows.ApplicationModel.UserActivities.Core
use ::prelude::*;
RT_CLASS!{static class CoreUserActivityManager}
impl RtActivatable<ICoreUserActivityManagerStatics> for CoreUserActivityManager {}
impl CoreUserActivityManager {
    #[inline] pub fn create_user_activity_session_in_background(activity: &super::UserActivity) -> Result<ComPtr<super::UserActivitySession>> { unsafe {
        <Self as RtActivatable<ICoreUserActivityManagerStatics>>::get_activation_factory().create_user_activity_session_in_background(activity)
    }}
    #[inline] pub fn delete_user_activity_sessions_in_time_range_async(channel: &super::UserActivityChannel, startTime: ::rt::gen::windows::foundation::DateTime, endTime: ::rt::gen::windows::foundation::DateTime) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<ICoreUserActivityManagerStatics>>::get_activation_factory().delete_user_activity_sessions_in_time_range_async(channel, startTime, endTime)
    }}
}
DEFINE_CLSID!(CoreUserActivityManager: "Windows.ApplicationModel.UserActivities.Core.CoreUserActivityManager");
DEFINE_IID!(IID_ICoreUserActivityManagerStatics, 3392854786, 42174, 19789, 191, 168, 103, 149, 244, 38, 78, 251);
RT_INTERFACE!{static interface ICoreUserActivityManagerStatics(ICoreUserActivityManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICoreUserActivityManagerStatics] {
    fn CreateUserActivitySessionInBackground(&self, activity: *mut super::UserActivity, out: *mut *mut super::UserActivitySession) -> HRESULT,
    fn DeleteUserActivitySessionsInTimeRangeAsync(&self, channel: *mut super::UserActivityChannel, startTime: ::rt::gen::windows::foundation::DateTime, endTime: ::rt::gen::windows::foundation::DateTime, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl ICoreUserActivityManagerStatics {
    #[inline] pub unsafe fn create_user_activity_session_in_background(&self, activity: &super::UserActivity) -> Result<ComPtr<super::UserActivitySession>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateUserActivitySessionInBackground)(self as *const _ as *mut _, activity as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_user_activity_sessions_in_time_range_async(&self, channel: &super::UserActivityChannel, startTime: ::rt::gen::windows::foundation::DateTime, endTime: ::rt::gen::windows::foundation::DateTime) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteUserActivitySessionsInTimeRangeAsync)(self as *const _ as *mut _, channel as *const _ as *mut _, startTime, endTime, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.UserActivities.Core
} // Windows.ApplicationModel.UserActivities
pub mod userdataaccounts { // Windows.ApplicationModel.UserDataAccounts
use ::prelude::*;
DEFINE_IID!(IID_IUserDataAccount, 3116643966, 45896, 18704, 190, 148, 74, 212, 187, 166, 222, 167);
RT_INTERFACE!{interface IUserDataAccount(IUserDataAccountVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccount] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_UserDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_UserDisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_OtherAppReadAccess(&self, out: *mut UserDataAccountOtherAppReadAccess) -> HRESULT,
    fn put_OtherAppReadAccess(&self, value: UserDataAccountOtherAppReadAccess) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Icon(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_DeviceAccountTypeId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn SaveAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn DeleteAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn FindAppointmentCalendarsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::appointments::AppointmentCalendar>>) -> HRESULT,
    fn FindEmailMailboxesAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::email::EmailMailbox>>) -> HRESULT,
    fn FindContactListsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::contacts::ContactList>>) -> HRESULT,
    fn FindContactAnnotationListsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::contacts::ContactAnnotationList>>) -> HRESULT
}}
impl IUserDataAccount {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_user_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_user_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UserDisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_other_app_read_access(&self) -> Result<UserDataAccountOtherAppReadAccess> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OtherAppReadAccess)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_other_app_read_access(&self, value: UserDataAccountOtherAppReadAccess) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OtherAppReadAccess)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_icon(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Icon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_device_account_type_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceAccountTypeId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn save_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SaveAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_appointment_calendars_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::appointments::AppointmentCalendar>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAppointmentCalendarsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_email_mailboxes_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::email::EmailMailbox>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindEmailMailboxesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_contact_lists_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::contacts::ContactList>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactListsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_contact_annotation_lists_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::contacts::ContactAnnotationList>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactAnnotationListsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccount: IUserDataAccount}
DEFINE_IID!(IID_IUserDataAccount2, 126671007, 56962, 16459, 129, 149, 200, 163, 172, 25, 143, 96);
RT_INTERFACE!{interface IUserDataAccount2(IUserDataAccount2Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccount2] {
    fn get_EnterpriseId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsProtectedUnderLock(&self, out: *mut bool) -> HRESULT
}}
impl IUserDataAccount2 {
    #[inline] pub unsafe fn get_enterprise_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EnterpriseId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_protected_under_lock(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsProtectedUnderLock)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserDataAccount3, 22231109, 27715, 17030, 157, 105, 62, 23, 9, 161, 242, 102);
RT_INTERFACE!{interface IUserDataAccount3(IUserDataAccount3Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccount3] {
    fn get_ExplictReadAccessPackageFamilyNames(&self, out: *mut *mut super::super::foundation::collections::IVector<HString>) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT
}}
impl IUserDataAccount3 {
    #[inline] pub unsafe fn get_explict_read_access_package_family_names(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExplictReadAccessPackageFamilyNames)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserDataAccount4, 3291566608, 60133, 20234, 168, 178, 28, 202, 17, 94, 0, 143);
RT_INTERFACE!{interface IUserDataAccount4(IUserDataAccount4Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccount4] {
    fn get_CanShowCreateContactGroup(&self, out: *mut bool) -> HRESULT,
    fn put_CanShowCreateContactGroup(&self, value: bool) -> HRESULT,
    fn get_ProviderProperties(&self, out: *mut *mut super::super::foundation::collections::IPropertySet) -> HRESULT,
    fn FindUserDataTaskListsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::userdatatasks::UserDataTaskList>>) -> HRESULT,
    fn FindContactGroupsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::contacts::ContactGroup>>) -> HRESULT,
    fn TryShowCreateContactGroupAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn put_IsProtectedUnderLock(&self, value: bool) -> HRESULT,
    #[cfg(feature="windows-storage")] fn put_Icon(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT
}}
impl IUserDataAccount4 {
    #[inline] pub unsafe fn get_can_show_create_contact_group(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CanShowCreateContactGroup)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_can_show_create_contact_group(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CanShowCreateContactGroup)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_provider_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IPropertySet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProviderProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_user_data_task_lists_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::userdatatasks::UserDataTaskList>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindUserDataTaskListsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn find_contact_groups_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<super::contacts::ContactGroup>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindContactGroupsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_show_create_contact_group_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).TryShowCreateContactGroupAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_protected_under_lock(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsProtectedUnderLock)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_icon(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Icon)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum UserDataAccountContentKinds: u32 {
    Email (UserDataAccountContentKinds_Email) = 1, Contact (UserDataAccountContentKinds_Contact) = 2, Appointment (UserDataAccountContentKinds_Appointment) = 4,
}}
RT_CLASS!{static class UserDataAccountManager}
impl RtActivatable<IUserDataAccountManagerStatics> for UserDataAccountManager {}
impl RtActivatable<IUserDataAccountManagerStatics2> for UserDataAccountManager {}
impl UserDataAccountManager {
    #[inline] pub fn request_store_async(storeAccessType: UserDataAccountStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccountStore>>> { unsafe {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().request_store_async(storeAccessType)
    }}
    #[inline] pub fn show_add_account_async(contentKinds: UserDataAccountContentKinds) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().show_add_account_async(contentKinds)
    }}
    #[inline] pub fn show_account_settings_async(id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().show_account_settings_async(id)
    }}
    #[inline] pub fn show_account_error_resolver_async(id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IUserDataAccountManagerStatics>>::get_activation_factory().show_account_error_resolver_async(id)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_for_user(user: &super::super::system::User) -> Result<ComPtr<UserDataAccountManagerForUser>> { unsafe {
        <Self as RtActivatable<IUserDataAccountManagerStatics2>>::get_activation_factory().get_for_user(user)
    }}
}
DEFINE_CLSID!(UserDataAccountManager: "Windows.ApplicationModel.UserDataAccounts.UserDataAccountManager");
DEFINE_IID!(IID_IUserDataAccountManagerForUser, 1453779163, 56207, 16811, 166, 95, 140, 89, 113, 170, 201, 130);
RT_INTERFACE!{interface IUserDataAccountManagerForUser(IUserDataAccountManagerForUserVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountManagerForUser] {
    fn RequestStoreAsync(&self, storeAccessType: UserDataAccountStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataAccountStore>) -> HRESULT,
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut super::super::system::User) -> HRESULT
}}
impl IUserDataAccountManagerForUser {
    #[inline] pub unsafe fn request_store_async(&self, storeAccessType: UserDataAccountStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccountStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, storeAccessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<super::super::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountManagerForUser: IUserDataAccountManagerForUser}
DEFINE_IID!(IID_IUserDataAccountManagerStatics, 228297194, 6440, 18976, 134, 213, 60, 115, 127, 125, 195, 176);
RT_INTERFACE!{static interface IUserDataAccountManagerStatics(IUserDataAccountManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountManagerStatics] {
    fn RequestStoreAsync(&self, storeAccessType: UserDataAccountStoreAccessType, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataAccountStore>) -> HRESULT,
    fn ShowAddAccountAsync(&self, contentKinds: UserDataAccountContentKinds, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn ShowAccountSettingsAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAccountErrorResolverAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IUserDataAccountManagerStatics {
    #[inline] pub unsafe fn request_store_async(&self, storeAccessType: UserDataAccountStoreAccessType) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccountStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, storeAccessType, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_add_account_async(&self, contentKinds: UserDataAccountContentKinds) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAddAccountAsync)(self as *const _ as *mut _, contentKinds, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_account_settings_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAccountSettingsAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_account_error_resolver_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAccountErrorResolverAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserDataAccountManagerStatics2, 1782443400, 12651, 17246, 181, 52, 247, 212, 180, 183, 219, 166);
RT_INTERFACE!{static interface IUserDataAccountManagerStatics2(IUserDataAccountManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountManagerStatics2] {
    #[cfg(feature="windows-system")] fn GetForUser(&self, user: *mut super::super::system::User, out: *mut *mut UserDataAccountManagerForUser) -> HRESULT
}}
impl IUserDataAccountManagerStatics2 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_for_user(&self, user: &super::super::system::User) -> Result<ComPtr<UserDataAccountManagerForUser>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum UserDataAccountOtherAppReadAccess: i32 {
    SystemOnly (UserDataAccountOtherAppReadAccess_SystemOnly) = 0, Full (UserDataAccountOtherAppReadAccess_Full) = 1, None (UserDataAccountOtherAppReadAccess_None) = 2,
}}
DEFINE_IID!(IID_IUserDataAccountStore, 544452781, 32010, 20086, 191, 69, 35, 104, 249, 120, 165, 154);
RT_INTERFACE!{interface IUserDataAccountStore(IUserDataAccountStoreVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountStore] {
    fn FindAccountsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UserDataAccount>>) -> HRESULT,
    fn GetAccountAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataAccount>) -> HRESULT,
    fn CreateAccountAsync(&self, userDisplayName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataAccount>) -> HRESULT
}}
impl IUserDataAccountStore {
    #[inline] pub unsafe fn find_accounts_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UserDataAccount>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAccountsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_account_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccount>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAccountAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_account_async(&self, userDisplayName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccount>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAccountAsync)(self as *const _ as *mut _, userDisplayName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountStore: IUserDataAccountStore}
DEFINE_IID!(IID_IUserDataAccountStore2, 2984292087, 38240, 17969, 138, 240, 6, 29, 48, 22, 20, 105);
RT_INTERFACE!{interface IUserDataAccountStore2(IUserDataAccountStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountStore2] {
    fn CreateAccountWithPackageRelativeAppIdAsync(&self, userDisplayName: HSTRING, packageRelativeAppId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataAccount>) -> HRESULT,
    fn add_StoreChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<UserDataAccountStore, UserDataAccountStoreChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StoreChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IUserDataAccountStore2 {
    #[inline] pub unsafe fn create_account_with_package_relative_app_id_async(&self, userDisplayName: &HStringArg, packageRelativeAppId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccount>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAccountWithPackageRelativeAppIdAsync)(self as *const _ as *mut _, userDisplayName.get(), packageRelativeAppId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_store_changed(&self, handler: &super::super::foundation::TypedEventHandler<UserDataAccountStore, UserDataAccountStoreChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StoreChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_store_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_StoreChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserDataAccountStore3, 2168635540, 62409, 18315, 177, 23, 101, 133, 190, 187, 103, 137);
RT_INTERFACE!{interface IUserDataAccountStore3(IUserDataAccountStore3Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountStore3] {
    fn CreateAccountWithPackageRelativeAppIdAndEnterpriseIdAsync(&self, userDisplayName: HSTRING, packageRelativeAppId: HSTRING, enterpriseId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<UserDataAccount>) -> HRESULT
}}
impl IUserDataAccountStore3 {
    #[inline] pub unsafe fn create_account_with_package_relative_app_id_and_enterprise_id_async(&self, userDisplayName: &HStringArg, packageRelativeAppId: &HStringArg, enterpriseId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<UserDataAccount>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateAccountWithPackageRelativeAppIdAndEnterpriseIdAsync)(self as *const _ as *mut _, userDisplayName.get(), packageRelativeAppId.get(), enterpriseId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum UserDataAccountStoreAccessType: i32 {
    AllAccountsReadOnly (UserDataAccountStoreAccessType_AllAccountsReadOnly) = 0, AppAccountsReadWrite (UserDataAccountStoreAccessType_AppAccountsReadWrite) = 1,
}}
DEFINE_IID!(IID_IUserDataAccountStoreChangedEventArgs, 2229527269, 34848, 17682, 177, 246, 46, 3, 91, 225, 7, 44);
RT_INTERFACE!{interface IUserDataAccountStoreChangedEventArgs(IUserDataAccountStoreChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountStoreChangedEventArgs] {
    fn GetDeferral(&self, out: *mut *mut super::super::foundation::Deferral) -> HRESULT
}}
impl IUserDataAccountStoreChangedEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<super::super::foundation::Deferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountStoreChangedEventArgs: IUserDataAccountStoreChangedEventArgs}
pub mod provider { // Windows.ApplicationModel.UserDataAccounts.Provider
use ::prelude::*;
DEFINE_IID!(IID_IUserDataAccountPartnerAccountInfo, 1595932727, 63215, 20163, 134, 48, 1, 44, 89, 193, 20, 159);
RT_INTERFACE!{interface IUserDataAccountPartnerAccountInfo(IUserDataAccountPartnerAccountInfoVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountPartnerAccountInfo] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Priority(&self, out: *mut u32) -> HRESULT,
    fn get_AccountKind(&self, out: *mut UserDataAccountProviderPartnerAccountKind) -> HRESULT
}}
impl IUserDataAccountPartnerAccountInfo {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_priority(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Priority)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_account_kind(&self) -> Result<UserDataAccountProviderPartnerAccountKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AccountKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountPartnerAccountInfo: IUserDataAccountPartnerAccountInfo}
DEFINE_IID!(IID_IUserDataAccountProviderAddAccountOperation, 3116836144, 16260, 19293, 142, 170, 69, 233, 122, 168, 66, 237);
RT_INTERFACE!{interface IUserDataAccountProviderAddAccountOperation(IUserDataAccountProviderAddAccountOperationVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountProviderAddAccountOperation] {
    fn get_ContentKinds(&self, out: *mut super::UserDataAccountContentKinds) -> HRESULT,
    fn get_PartnerAccountInfos(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<UserDataAccountPartnerAccountInfo>) -> HRESULT,
    fn ReportCompleted(&self, userDataAccountId: HSTRING) -> HRESULT
}}
impl IUserDataAccountProviderAddAccountOperation {
    #[inline] pub unsafe fn get_content_kinds(&self) -> Result<super::UserDataAccountContentKinds> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentKinds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_partner_account_infos(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<UserDataAccountPartnerAccountInfo>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PartnerAccountInfos)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self, userDataAccountId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _, userDataAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountProviderAddAccountOperation: IUserDataAccountProviderAddAccountOperation}
DEFINE_IID!(IID_IUserDataAccountProviderOperation, 2718608739, 34956, 19042, 163, 221, 52, 208, 122, 128, 43, 43);
RT_INTERFACE!{interface IUserDataAccountProviderOperation(IUserDataAccountProviderOperationVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountProviderOperation] {
    fn get_Kind(&self, out: *mut UserDataAccountProviderOperationKind) -> HRESULT
}}
impl IUserDataAccountProviderOperation {
    #[inline] pub unsafe fn get_kind(&self) -> Result<UserDataAccountProviderOperationKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum UserDataAccountProviderOperationKind: i32 {
    AddAccount (UserDataAccountProviderOperationKind_AddAccount) = 0, Settings (UserDataAccountProviderOperationKind_Settings) = 1, ResolveErrors (UserDataAccountProviderOperationKind_ResolveErrors) = 2,
}}
RT_ENUM! { enum UserDataAccountProviderPartnerAccountKind: i32 {
    Exchange (UserDataAccountProviderPartnerAccountKind_Exchange) = 0, PopOrImap (UserDataAccountProviderPartnerAccountKind_PopOrImap) = 1,
}}
DEFINE_IID!(IID_IUserDataAccountProviderResolveErrorsOperation, 1647696917, 49099, 16865, 153, 87, 151, 89, 162, 136, 70, 204);
RT_INTERFACE!{interface IUserDataAccountProviderResolveErrorsOperation(IUserDataAccountProviderResolveErrorsOperationVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountProviderResolveErrorsOperation] {
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT
}}
impl IUserDataAccountProviderResolveErrorsOperation {
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountProviderResolveErrorsOperation: IUserDataAccountProviderResolveErrorsOperation}
DEFINE_IID!(IID_IUserDataAccountProviderSettingsOperation, 2449690039, 34376, 20272, 172, 250, 48, 2, 101, 140, 168, 13);
RT_INTERFACE!{interface IUserDataAccountProviderSettingsOperation(IUserDataAccountProviderSettingsOperationVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountProviderSettingsOperation] {
    fn get_UserDataAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn ReportCompleted(&self) -> HRESULT
}}
impl IUserDataAccountProviderSettingsOperation {
    #[inline] pub unsafe fn get_user_data_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UserDataAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_completed(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCompleted)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class UserDataAccountProviderSettingsOperation: IUserDataAccountProviderSettingsOperation}
} // Windows.ApplicationModel.UserDataAccounts.Provider
pub mod systemaccess { // Windows.ApplicationModel.UserDataAccounts.SystemAccess
use ::prelude::*;
RT_ENUM! { enum DeviceAccountAuthenticationType: i32 {
    Basic (DeviceAccountAuthenticationType_Basic) = 0, OAuth (DeviceAccountAuthenticationType_OAuth) = 1, SingleSignOn (DeviceAccountAuthenticationType_SingleSignOn) = 2,
}}
DEFINE_IID!(IID_IDeviceAccountConfiguration, 2902533027, 64476, 19739, 190, 67, 90, 39, 234, 74, 27, 99);
RT_INTERFACE!{interface IDeviceAccountConfiguration(IDeviceAccountConfigurationVtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccountConfiguration] {
    fn get_AccountName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AccountName(&self, value: HSTRING) -> HRESULT,
    fn get_DeviceAccountTypeId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DeviceAccountTypeId(&self, value: HSTRING) -> HRESULT,
    fn get_ServerType(&self, out: *mut DeviceAccountServerType) -> HRESULT,
    fn put_ServerType(&self, value: DeviceAccountServerType) -> HRESULT,
    fn get_EmailAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_EmailAddress(&self, value: HSTRING) -> HRESULT,
    fn get_Domain(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Domain(&self, value: HSTRING) -> HRESULT,
    fn get_EmailSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_EmailSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_ContactsSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_ContactsSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_CalendarSyncEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_CalendarSyncEnabled(&self, value: bool) -> HRESULT,
    fn get_IncomingServerAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IncomingServerAddress(&self, value: HSTRING) -> HRESULT,
    fn get_IncomingServerPort(&self, out: *mut i32) -> HRESULT,
    fn put_IncomingServerPort(&self, value: i32) -> HRESULT,
    fn get_IncomingServerRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_IncomingServerRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_IncomingServerUsername(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IncomingServerUsername(&self, value: HSTRING) -> HRESULT,
    fn get_OutgoingServerAddress(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OutgoingServerAddress(&self, value: HSTRING) -> HRESULT,
    fn get_OutgoingServerPort(&self, out: *mut i32) -> HRESULT,
    fn put_OutgoingServerPort(&self, value: i32) -> HRESULT,
    fn get_OutgoingServerRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_OutgoingServerRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_OutgoingServerUsername(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OutgoingServerUsername(&self, value: HSTRING) -> HRESULT
}}
impl IDeviceAccountConfiguration {
    #[inline] pub unsafe fn get_account_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AccountName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_account_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AccountName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_device_account_type_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DeviceAccountTypeId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_device_account_type_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DeviceAccountTypeId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_server_type(&self) -> Result<DeviceAccountServerType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ServerType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_server_type(&self, value: DeviceAccountServerType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ServerType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_EmailAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_email_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EmailAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_domain(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Domain)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_domain(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Domain)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_email_sync_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_EmailSyncEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_email_sync_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_EmailSyncEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_contacts_sync_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContactsSyncEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_contacts_sync_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContactsSyncEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_calendar_sync_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CalendarSyncEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_calendar_sync_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalendarSyncEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incoming_server_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IncomingServerAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incoming_server_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncomingServerAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incoming_server_port(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncomingServerPort)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incoming_server_port(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncomingServerPort)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incoming_server_requires_ssl(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IncomingServerRequiresSsl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incoming_server_requires_ssl(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncomingServerRequiresSsl)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incoming_server_username(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IncomingServerUsername)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incoming_server_username(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncomingServerUsername)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_outgoing_server_address(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutgoingServerAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_outgoing_server_address(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutgoingServerAddress)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_outgoing_server_port(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OutgoingServerPort)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_outgoing_server_port(&self, value: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutgoingServerPort)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_outgoing_server_requires_ssl(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_OutgoingServerRequiresSsl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_outgoing_server_requires_ssl(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutgoingServerRequiresSsl)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_outgoing_server_username(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutgoingServerUsername)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_outgoing_server_username(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutgoingServerUsername)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class DeviceAccountConfiguration: IDeviceAccountConfiguration}
impl RtActivatable<IActivationFactory> for DeviceAccountConfiguration {}
DEFINE_CLSID!(DeviceAccountConfiguration: "Windows.ApplicationModel.UserDataAccounts.SystemAccess.DeviceAccountConfiguration");
DEFINE_IID!(IID_IDeviceAccountConfiguration2, 4071810470, 29325, 19018, 137, 69, 43, 248, 88, 1, 54, 222);
RT_INTERFACE!{interface IDeviceAccountConfiguration2(IDeviceAccountConfiguration2Vtbl): IInspectable(IInspectableVtbl) [IID_IDeviceAccountConfiguration2] {
    #[cfg(not(feature="windows-security"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-security")] fn get_IncomingServerCredential(&self, out: *mut *mut ::rt::gen::windows::security::credentials::PasswordCredential) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-security")] fn put_IncomingServerCredential(&self, value: *mut ::rt::gen::windows::security::credentials::PasswordCredential) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-security")] fn get_OutgoingServerCredential(&self, out: *mut *mut ::rt::gen::windows::security::credentials::PasswordCredential) -> HRESULT,
    #[cfg(not(feature="windows-security"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-security")] fn put_OutgoingServerCredential(&self, value: *mut ::rt::gen::windows::security::credentials::PasswordCredential) -> HRESULT,
    fn get_OAuthRefreshToken(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OAuthRefreshToken(&self, value: HSTRING) -> HRESULT,
    fn get_IsExternallyManaged(&self, out: *mut bool) -> HRESULT,
    fn put_IsExternallyManaged(&self, value: bool) -> HRESULT,
    fn get_AccountIconId(&self, out: *mut DeviceAccountIconId) -> HRESULT,
    fn put_AccountIconId(&self, value: DeviceAccountIconId) -> HRESULT,
    fn get_AuthenticationType(&self, out: *mut DeviceAccountAuthenticationType) -> HRESULT,
    fn put_AuthenticationType(&self, value: DeviceAccountAuthenticationType) -> HRESULT,
    fn get_IsSsoAuthenticationSupported(&self, out: *mut bool) -> HRESULT,
    fn get_SsoAccountId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SsoAccountId(&self, value: HSTRING) -> HRESULT,
    fn get_AlwaysDownloadFullMessage(&self, out: *mut bool) -> HRESULT,
    fn put_AlwaysDownloadFullMessage(&self, value: bool) -> HRESULT,
    fn get_DoesPolicyAllowMailSync(&self, out: *mut bool) -> HRESULT,
    fn get_SyncScheduleKind(&self, out: *mut DeviceAccountSyncScheduleKind) -> HRESULT,
    fn put_SyncScheduleKind(&self, value: DeviceAccountSyncScheduleKind) -> HRESULT,
    fn get_MailAgeFilter(&self, out: *mut DeviceAccountMailAgeFilter) -> HRESULT,
    fn put_MailAgeFilter(&self, value: DeviceAccountMailAgeFilter) -> HRESULT,
    fn get_IsClientAuthenticationCertificateRequired(&self, out: *mut bool) -> HRESULT,
    fn put_IsClientAuthenticationCertificateRequired(&self, value: bool) -> HRESULT,
    fn get_AutoSelectAuthenticationCertificate(&self, out: *mut bool) -> HRESULT,
    fn put_AutoSelectAuthenticationCertificate(&self, value: bool) -> HRESULT,
    fn get_AuthenticationCertificateId(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AuthenticationCertificateId(&self, value: HSTRING) -> HRESULT,
    fn get_CardDavSyncScheduleKind(&self, out: *mut DeviceAccountSyncScheduleKind) -> HRESULT,
    fn put_CardDavSyncScheduleKind(&self, value: DeviceAccountSyncScheduleKind) -> HRESULT,
    fn get_CalDavSyncScheduleKind(&self, out: *mut DeviceAccountSyncScheduleKind) -> HRESULT,
    fn put_CalDavSyncScheduleKind(&self, value: DeviceAccountSyncScheduleKind) -> HRESULT,
    fn get_CardDavServerUrl(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_CardDavServerUrl(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_CardDavRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_CardDavRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_CalDavServerUrl(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn put_CalDavServerUrl(&self, value: *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_CalDavRequiresSsl(&self, out: *mut bool) -> HRESULT,
    fn put_CalDavRequiresSsl(&self, value: bool) -> HRESULT,
    fn get_WasModifiedByUser(&self, out: *mut bool) -> HRESULT,
    fn put_WasModifiedByUser(&self, value: bool) -> HRESULT,
    fn get_WasIncomingServerCertificateHashConfirmed(&self, out: *mut bool) -> HRESULT,
    fn put_WasIncomingServerCertificateHashConfirmed(&self, value: bool) -> HRESULT,
    fn get_IncomingServerCertificateHash(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IncomingServerCertificateHash(&self, value: HSTRING) -> HRESULT,
    fn get_IsOutgoingServerAuthenticationRequired(&self, out: *mut bool) -> HRESULT,
    fn put_IsOutgoingServerAuthenticationRequired(&self, value: bool) -> HRESULT,
    fn get_IsOutgoingServerAuthenticationEnabled(&self, out: *mut bool) -> HRESULT,
    fn put_IsOutgoingServerAuthenticationEnabled(&self, value: bool) -> HRESULT,
    fn get_WasOutgoingServerCertificateHashConfirmed(&self, out: *mut bool) -> HRESULT,
    fn put_WasOutgoingServerCertificateHashConfirmed(&self, value: bool) -> HRESULT,
    fn get_OutgoingServerCertificateHash(&self, out: *mut HSTRING) -> HRESULT,
    fn put_OutgoingServerCertificateHash(&self, value: HSTRING) -> HRESULT,
    fn get_IsSyncScheduleManagedBySystem(&self, out: *mut bool) -> HRESULT,
    fn put_IsSyncScheduleManagedBySystem(&self, value: bool) -> HRESULT
}}
impl IDeviceAccountConfiguration2 {
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn get_incoming_server_credential(&self) -> Result<ComPtr<::rt::gen::windows::security::credentials::PasswordCredential>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IncomingServerCredential)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn set_incoming_server_credential(&self, value: &::rt::gen::windows::security::credentials::PasswordCredential) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncomingServerCredential)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn get_outgoing_server_credential(&self) -> Result<ComPtr<::rt::gen::windows::security::credentials::PasswordCredential>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutgoingServerCredential)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-security")] #[inline] pub unsafe fn set_outgoing_server_credential(&self, value: &::rt::gen::windows::security::credentials::PasswordCredential) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutgoingServerCredential)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_oauth_refresh_token(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OAuthRefreshToken)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_oauth_refresh_token(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OAuthRefreshToken)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_externally_managed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsExternallyManaged)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_externally_managed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsExternallyManaged)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_account_icon_id(&self) -> Result<DeviceAccountIconId> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AccountIconId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_account_icon_id(&self, value: DeviceAccountIconId) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AccountIconId)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_authentication_type(&self) -> Result<DeviceAccountAuthenticationType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AuthenticationType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_authentication_type(&self, value: DeviceAccountAuthenticationType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AuthenticationType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_sso_authentication_supported(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSsoAuthenticationSupported)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sso_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SsoAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sso_account_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SsoAccountId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_always_download_full_message(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AlwaysDownloadFullMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_always_download_full_message(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AlwaysDownloadFullMessage)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_does_policy_allow_mail_sync(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DoesPolicyAllowMailSync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sync_schedule_kind(&self) -> Result<DeviceAccountSyncScheduleKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SyncScheduleKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sync_schedule_kind(&self, value: DeviceAccountSyncScheduleKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SyncScheduleKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_mail_age_filter(&self) -> Result<DeviceAccountMailAgeFilter> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MailAgeFilter)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mail_age_filter(&self, value: DeviceAccountMailAgeFilter) -> Result<()> {
        let hr = ((*self.lpVtbl).put_MailAgeFilter)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_client_authentication_certificate_required(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsClientAuthenticationCertificateRequired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_client_authentication_certificate_required(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsClientAuthenticationCertificateRequired)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_select_authentication_certificate(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoSelectAuthenticationCertificate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_select_authentication_certificate(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoSelectAuthenticationCertificate)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_authentication_certificate_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AuthenticationCertificateId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_authentication_certificate_id(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AuthenticationCertificateId)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_card_dav_sync_schedule_kind(&self) -> Result<DeviceAccountSyncScheduleKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CardDavSyncScheduleKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_card_dav_sync_schedule_kind(&self, value: DeviceAccountSyncScheduleKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CardDavSyncScheduleKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cal_dav_sync_schedule_kind(&self) -> Result<DeviceAccountSyncScheduleKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CalDavSyncScheduleKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cal_dav_sync_schedule_kind(&self, value: DeviceAccountSyncScheduleKind) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalDavSyncScheduleKind)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_card_dav_server_url(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CardDavServerUrl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_card_dav_server_url(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CardDavServerUrl)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_card_dav_requires_ssl(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CardDavRequiresSsl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_card_dav_requires_ssl(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CardDavRequiresSsl)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cal_dav_server_url(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CalDavServerUrl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cal_dav_server_url(&self, value: &::rt::gen::windows::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalDavServerUrl)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_cal_dav_requires_ssl(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_CalDavRequiresSsl)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_cal_dav_requires_ssl(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CalDavRequiresSsl)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_was_modified_by_user(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WasModifiedByUser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_was_modified_by_user(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_WasModifiedByUser)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_was_incoming_server_certificate_hash_confirmed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WasIncomingServerCertificateHashConfirmed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_was_incoming_server_certificate_hash_confirmed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_WasIncomingServerCertificateHashConfirmed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_incoming_server_certificate_hash(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IncomingServerCertificateHash)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_incoming_server_certificate_hash(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IncomingServerCertificateHash)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_outgoing_server_authentication_required(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOutgoingServerAuthenticationRequired)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_outgoing_server_authentication_required(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOutgoingServerAuthenticationRequired)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_outgoing_server_authentication_enabled(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOutgoingServerAuthenticationEnabled)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_outgoing_server_authentication_enabled(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsOutgoingServerAuthenticationEnabled)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_was_outgoing_server_certificate_hash_confirmed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_WasOutgoingServerCertificateHashConfirmed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_was_outgoing_server_certificate_hash_confirmed(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_WasOutgoingServerCertificateHashConfirmed)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_outgoing_server_certificate_hash(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OutgoingServerCertificateHash)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_outgoing_server_certificate_hash(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_OutgoingServerCertificateHash)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_sync_schedule_managed_by_system(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSyncScheduleManagedBySystem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_sync_schedule_managed_by_system(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSyncScheduleManagedBySystem)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_ENUM! { enum DeviceAccountIconId: i32 {
    Exchange (DeviceAccountIconId_Exchange) = 0, Msa (DeviceAccountIconId_Msa) = 1, Outlook (DeviceAccountIconId_Outlook) = 2, Generic (DeviceAccountIconId_Generic) = 3,
}}
RT_ENUM! { enum DeviceAccountMailAgeFilter: i32 {
    All (DeviceAccountMailAgeFilter_All) = 0, Last1Day (DeviceAccountMailAgeFilter_Last1Day) = 1, Last3Days (DeviceAccountMailAgeFilter_Last3Days) = 2, Last7Days (DeviceAccountMailAgeFilter_Last7Days) = 3, Last14Days (DeviceAccountMailAgeFilter_Last14Days) = 4, Last30Days (DeviceAccountMailAgeFilter_Last30Days) = 5, Last90Days (DeviceAccountMailAgeFilter_Last90Days) = 6,
}}
RT_ENUM! { enum DeviceAccountServerType: i32 {
    Exchange (DeviceAccountServerType_Exchange) = 0, Pop (DeviceAccountServerType_Pop) = 1, Imap (DeviceAccountServerType_Imap) = 2,
}}
RT_ENUM! { enum DeviceAccountSyncScheduleKind: i32 {
    Manual (DeviceAccountSyncScheduleKind_Manual) = 0, Every15Minutes (DeviceAccountSyncScheduleKind_Every15Minutes) = 1, Every30Minutes (DeviceAccountSyncScheduleKind_Every30Minutes) = 2, Every60Minutes (DeviceAccountSyncScheduleKind_Every60Minutes) = 3, Every2Hours (DeviceAccountSyncScheduleKind_Every2Hours) = 4, Daily (DeviceAccountSyncScheduleKind_Daily) = 5, AsItemsArrive (DeviceAccountSyncScheduleKind_AsItemsArrive) = 6,
}}
RT_CLASS!{static class UserDataAccountSystemAccessManager}
impl RtActivatable<IUserDataAccountSystemAccessManagerStatics> for UserDataAccountSystemAccessManager {}
impl RtActivatable<IUserDataAccountSystemAccessManagerStatics2> for UserDataAccountSystemAccessManager {}
impl UserDataAccountSystemAccessManager {
    #[inline] pub fn add_and_show_device_accounts_async(accounts: &::rt::gen::windows::foundation::collections::IIterable<DeviceAccountConfiguration>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>>> { unsafe {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics>>::get_activation_factory().add_and_show_device_accounts_async(accounts)
    }}
    #[inline] pub fn suppress_local_account_with_account_async(userDataAccountId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().suppress_local_account_with_account_async(userDataAccountId)
    }}
    #[inline] pub fn create_device_account_async(account: &DeviceAccountConfiguration) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().create_device_account_async(account)
    }}
    #[inline] pub fn delete_device_account_async(accountId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().delete_device_account_async(accountId)
    }}
    #[inline] pub fn get_device_account_configuration_async(accountId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<DeviceAccountConfiguration>>> { unsafe {
        <Self as RtActivatable<IUserDataAccountSystemAccessManagerStatics2>>::get_activation_factory().get_device_account_configuration_async(accountId)
    }}
}
DEFINE_CLSID!(UserDataAccountSystemAccessManager: "Windows.ApplicationModel.UserDataAccounts.SystemAccess.UserDataAccountSystemAccessManager");
DEFINE_IID!(IID_IUserDataAccountSystemAccessManagerStatics, 2641039801, 52197, 17909, 130, 43, 194, 103, 184, 29, 189, 182);
RT_INTERFACE!{static interface IUserDataAccountSystemAccessManagerStatics(IUserDataAccountSystemAccessManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountSystemAccessManagerStatics] {
    fn AddAndShowDeviceAccountsAsync(&self, accounts: *mut ::rt::gen::windows::foundation::collections::IIterable<DeviceAccountConfiguration>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>) -> HRESULT
}}
impl IUserDataAccountSystemAccessManagerStatics {
    #[inline] pub unsafe fn add_and_show_device_accounts_async(&self, accounts: &::rt::gen::windows::foundation::collections::IIterable<DeviceAccountConfiguration>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AddAndShowDeviceAccountsAsync)(self as *const _ as *mut _, accounts as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IUserDataAccountSystemAccessManagerStatics2, 2487190861, 19278, 17311, 131, 211, 151, 155, 39, 192, 90, 199);
RT_INTERFACE!{static interface IUserDataAccountSystemAccessManagerStatics2(IUserDataAccountSystemAccessManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IUserDataAccountSystemAccessManagerStatics2] {
    fn SuppressLocalAccountWithAccountAsync(&self, userDataAccountId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn CreateDeviceAccountAsync(&self, account: *mut DeviceAccountConfiguration, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn DeleteDeviceAccountAsync(&self, accountId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn GetDeviceAccountConfigurationAsync(&self, accountId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<DeviceAccountConfiguration>) -> HRESULT
}}
impl IUserDataAccountSystemAccessManagerStatics2 {
    #[inline] pub unsafe fn suppress_local_account_with_account_async(&self, userDataAccountId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SuppressLocalAccountWithAccountAsync)(self as *const _ as *mut _, userDataAccountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_device_account_async(&self, account: &DeviceAccountConfiguration) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateDeviceAccountAsync)(self as *const _ as *mut _, account as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_device_account_async(&self, accountId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteDeviceAccountAsync)(self as *const _ as *mut _, accountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_device_account_configuration_async(&self, accountId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<DeviceAccountConfiguration>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeviceAccountConfigurationAsync)(self as *const _ as *mut _, accountId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.UserDataAccounts.SystemAccess
} // Windows.ApplicationModel.UserDataAccounts
pub mod appextensions { // Windows.ApplicationModel.AppExtensions
use ::prelude::*;
DEFINE_IID!(IID_IAppExtension, 2219872300, 5613, 20399, 147, 234, 34, 55, 187, 248, 203, 214);
RT_INTERFACE!{interface IAppExtension(IAppExtensionVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtension] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut *mut super::Package) -> HRESULT,
    fn get_AppInfo(&self, out: *mut *mut super::AppInfo) -> HRESULT,
    fn GetExtensionPropertiesAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IPropertySet>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetPublicFolderAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::StorageFolder>) -> HRESULT
}}
impl IAppExtension {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<super::Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_info(&self) -> Result<ComPtr<super::AppInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extension_properties_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IPropertySet>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetExtensionPropertiesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_public_folder_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::StorageFolder>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPublicFolderAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtension: IAppExtension}
DEFINE_IID!(IID_IAppExtensionCatalog, 2542215218, 33830, 19153, 144, 132, 146, 232, 140, 45, 162, 0);
RT_INTERFACE!{interface IAppExtensionCatalog(IAppExtensionCatalogVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionCatalog] {
    fn FindAllAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppExtension>>) -> HRESULT,
    fn RequestRemovePackageAsync(&self, packageFullName: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn add_PackageInstalled(&self, handler: *mut super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageInstalledEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageInstalled(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUpdating(&self, handler: *mut super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUpdating(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUpdated(&self, handler: *mut super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUpdated(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageUninstalling(&self, handler: *mut super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUninstallingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageUninstalling(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn add_PackageStatusChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageStatusChangedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_PackageStatusChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppExtensionCatalog {
    #[inline] pub unsafe fn find_all_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<AppExtension>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FindAllAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_remove_package_async(&self, packageFullName: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestRemovePackageAsync)(self as *const _ as *mut _, packageFullName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_installed(&self, handler: &super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageInstalledEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageInstalled)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_installed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageInstalled)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_updating(&self, handler: &super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageUpdating)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_updating(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageUpdating)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_updated(&self, handler: &super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUpdatedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageUpdated)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_updated(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageUpdated)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_uninstalling(&self, handler: &super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageUninstallingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageUninstalling)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_uninstalling(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageUninstalling)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_package_status_changed(&self, handler: &super::super::foundation::TypedEventHandler<AppExtensionCatalog, AppExtensionPackageStatusChangedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_PackageStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_package_status_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_PackageStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtensionCatalog: IAppExtensionCatalog}
impl RtActivatable<IAppExtensionCatalogStatics> for AppExtensionCatalog {}
impl AppExtensionCatalog {
    #[inline] pub fn open(appExtensionName: &HStringArg) -> Result<ComPtr<AppExtensionCatalog>> { unsafe {
        <Self as RtActivatable<IAppExtensionCatalogStatics>>::get_activation_factory().open(appExtensionName)
    }}
}
DEFINE_CLSID!(AppExtensionCatalog: "Windows.ApplicationModel.AppExtensions.AppExtensionCatalog");
DEFINE_IID!(IID_IAppExtensionCatalogStatics, 1010198154, 24344, 20235, 156, 229, 202, 182, 29, 25, 111, 17);
RT_INTERFACE!{static interface IAppExtensionCatalogStatics(IAppExtensionCatalogStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionCatalogStatics] {
    fn Open(&self, appExtensionName: HSTRING, out: *mut *mut AppExtensionCatalog) -> HRESULT
}}
impl IAppExtensionCatalogStatics {
    #[inline] pub unsafe fn open(&self, appExtensionName: &HStringArg) -> Result<ComPtr<AppExtensionCatalog>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Open)(self as *const _ as *mut _, appExtensionName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppExtensionPackageInstalledEventArgs, 971346484, 13137, 19085, 151, 69, 231, 211, 221, 69, 188, 72);
RT_INTERFACE!{interface IAppExtensionPackageInstalledEventArgs(IAppExtensionPackageInstalledEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionPackageInstalledEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut *mut super::Package) -> HRESULT,
    fn get_Extensions(&self, out: *mut *mut super::super::foundation::collections::IVectorView<AppExtension>) -> HRESULT
}}
impl IAppExtensionPackageInstalledEventArgs {
    #[inline] pub unsafe fn get_app_extension_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppExtensionName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<super::Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extensions(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<AppExtension>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Extensions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtensionPackageInstalledEventArgs: IAppExtensionPackageInstalledEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageStatusChangedEventArgs, 484537395, 4435, 17661, 135, 177, 138, 225, 5, 3, 3, 223);
RT_INTERFACE!{interface IAppExtensionPackageStatusChangedEventArgs(IAppExtensionPackageStatusChangedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionPackageStatusChangedEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut *mut super::Package) -> HRESULT
}}
impl IAppExtensionPackageStatusChangedEventArgs {
    #[inline] pub unsafe fn get_app_extension_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppExtensionName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<super::Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtensionPackageStatusChangedEventArgs: IAppExtensionPackageStatusChangedEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageUninstallingEventArgs, 1626431685, 5918, 16639, 174, 152, 171, 44, 32, 221, 77, 117);
RT_INTERFACE!{interface IAppExtensionPackageUninstallingEventArgs(IAppExtensionPackageUninstallingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionPackageUninstallingEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut *mut super::Package) -> HRESULT
}}
impl IAppExtensionPackageUninstallingEventArgs {
    #[inline] pub unsafe fn get_app_extension_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppExtensionName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<super::Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtensionPackageUninstallingEventArgs: IAppExtensionPackageUninstallingEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageUpdatedEventArgs, 981713983, 31102, 17589, 186, 36, 164, 200, 181, 165, 67, 215);
RT_INTERFACE!{interface IAppExtensionPackageUpdatedEventArgs(IAppExtensionPackageUpdatedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionPackageUpdatedEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut *mut super::Package) -> HRESULT,
    fn get_Extensions(&self, out: *mut *mut super::super::foundation::collections::IVectorView<AppExtension>) -> HRESULT
}}
impl IAppExtensionPackageUpdatedEventArgs {
    #[inline] pub unsafe fn get_app_extension_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppExtensionName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<super::Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extensions(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<AppExtension>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Extensions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtensionPackageUpdatedEventArgs: IAppExtensionPackageUpdatedEventArgs}
DEFINE_IID!(IID_IAppExtensionPackageUpdatingEventArgs, 2127926057, 6757, 18432, 167, 0, 179, 33, 0, 158, 48, 106);
RT_INTERFACE!{interface IAppExtensionPackageUpdatingEventArgs(IAppExtensionPackageUpdatingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppExtensionPackageUpdatingEventArgs] {
    fn get_AppExtensionName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Package(&self, out: *mut *mut super::Package) -> HRESULT
}}
impl IAppExtensionPackageUpdatingEventArgs {
    #[inline] pub unsafe fn get_app_extension_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppExtensionName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package(&self) -> Result<ComPtr<super::Package>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Package)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppExtensionPackageUpdatingEventArgs: IAppExtensionPackageUpdatingEventArgs}
} // Windows.ApplicationModel.AppExtensions
pub mod lockscreen { // Windows.ApplicationModel.LockScreen
use ::prelude::*;
DEFINE_IID!(IID_ILockApplicationHost, 955134381, 55631, 20092, 129, 250, 79, 68, 54, 80, 98, 129);
RT_INTERFACE!{interface ILockApplicationHost(ILockApplicationHostVtbl): IInspectable(IInspectableVtbl) [IID_ILockApplicationHost] {
    fn RequestUnlock(&self) -> HRESULT,
    fn add_Unlocking(&self, handler: *mut super::super::foundation::TypedEventHandler<LockApplicationHost, LockScreenUnlockingEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Unlocking(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ILockApplicationHost {
    #[inline] pub unsafe fn request_unlock(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).RequestUnlock)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_unlocking(&self, handler: &super::super::foundation::TypedEventHandler<LockApplicationHost, LockScreenUnlockingEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Unlocking)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_unlocking(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Unlocking)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LockApplicationHost: ILockApplicationHost}
impl RtActivatable<ILockApplicationHostStatics> for LockApplicationHost {}
impl LockApplicationHost {
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<LockApplicationHost>> { unsafe {
        <Self as RtActivatable<ILockApplicationHostStatics>>::get_activation_factory().get_for_current_view()
    }}
}
DEFINE_CLSID!(LockApplicationHost: "Windows.ApplicationModel.LockScreen.LockApplicationHost");
DEFINE_IID!(IID_ILockApplicationHostStatics, 4103056270, 9175, 20067, 150, 161, 102, 111, 245, 45, 59, 44);
RT_INTERFACE!{static interface ILockApplicationHostStatics(ILockApplicationHostStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILockApplicationHostStatics] {
    fn GetForCurrentView(&self, out: *mut *mut LockApplicationHost) -> HRESULT
}}
impl ILockApplicationHostStatics {
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<LockApplicationHost>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILockScreenBadge, 3914401241, 11263, 19888, 155, 79, 56, 36, 119, 139, 156, 154);
RT_INTERFACE!{interface ILockScreenBadge(ILockScreenBadgeVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenBadge] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Glyph(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn get_Number(&self, out: *mut *mut super::super::foundation::IReference<u32>) -> HRESULT,
    fn get_AutomationName(&self, out: *mut HSTRING) -> HRESULT,
    fn LaunchApp(&self) -> HRESULT
}}
impl ILockScreenBadge {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_logo(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStream>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_glyph(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStream>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Glyph)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_number(&self) -> Result<ComPtr<super::super::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Number)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_automation_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AutomationName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch_app(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).LaunchApp)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenBadge: ILockScreenBadge}
DEFINE_IID!(IID_ILockScreenInfo, 4120553052, 38673, 19913, 166, 48, 149, 182, 203, 140, 218, 208);
RT_INTERFACE!{interface ILockScreenInfo(ILockScreenInfoVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenInfo] {
    fn add_LockScreenImageChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LockScreenImageChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_LockScreenImage(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT,
    fn add_BadgesChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_BadgesChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_Badges(&self, out: *mut *mut super::super::foundation::collections::IVectorView<LockScreenBadge>) -> HRESULT,
    fn add_DetailTextChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_DetailTextChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn get_DetailText(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn add_AlarmIconChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_AlarmIconChanged(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT,
    #[cfg(feature="windows-storage")] fn get_AlarmIcon(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStream) -> HRESULT
}}
impl ILockScreenInfo {
    #[inline] pub unsafe fn add_lock_screen_image_changed(&self, handler: &super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LockScreenImageChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_lock_screen_image_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LockScreenImageChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_lock_screen_image(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStream>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LockScreenImage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_badges_changed(&self, handler: &super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_BadgesChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_badges_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_BadgesChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_badges(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<LockScreenBadge>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Badges)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_detail_text_changed(&self, handler: &super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_DetailTextChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_detail_text_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_DetailTextChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_detail_text(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DetailText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_alarm_icon_changed(&self, handler: &super::super::foundation::TypedEventHandler<LockScreenInfo, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_AlarmIconChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_alarm_icon_changed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_AlarmIconChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_alarm_icon(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStream>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AlarmIcon)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenInfo: ILockScreenInfo}
DEFINE_IID!(IID_ILockScreenUnlockingDeferral, 2122128086, 20995, 17383, 155, 214, 124, 57, 71, 209, 227, 254);
RT_INTERFACE!{interface ILockScreenUnlockingDeferral(ILockScreenUnlockingDeferralVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenUnlockingDeferral] {
    fn Complete(&self) -> HRESULT
}}
impl ILockScreenUnlockingDeferral {
    #[inline] pub unsafe fn complete(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Complete)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenUnlockingDeferral: ILockScreenUnlockingDeferral}
DEFINE_IID!(IID_ILockScreenUnlockingEventArgs, 1155973127, 30203, 19131, 159, 139, 130, 71, 72, 144, 12, 113);
RT_INTERFACE!{interface ILockScreenUnlockingEventArgs(ILockScreenUnlockingEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_ILockScreenUnlockingEventArgs] {
    fn GetDeferral(&self, out: *mut *mut LockScreenUnlockingDeferral) -> HRESULT,
    fn get_Deadline(&self, out: *mut super::super::foundation::DateTime) -> HRESULT
}}
impl ILockScreenUnlockingEventArgs {
    #[inline] pub unsafe fn get_deferral(&self) -> Result<ComPtr<LockScreenUnlockingDeferral>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetDeferral)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_deadline(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Deadline)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LockScreenUnlockingEventArgs: ILockScreenUnlockingEventArgs}
} // Windows.ApplicationModel.LockScreen
pub mod payments { // Windows.ApplicationModel.Payments
use ::prelude::*;
DEFINE_IID!(IID_IPaymentAddress, 1596089577, 28474, 16742, 160, 24, 10, 11, 6, 187, 50, 181);
RT_INTERFACE!{interface IPaymentAddress(IPaymentAddressVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentAddress] {
    fn get_Country(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Country(&self, value: HSTRING) -> HRESULT,
    fn get_AddressLines(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn put_AddressLines(&self, value: *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_Region(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Region(&self, value: HSTRING) -> HRESULT,
    fn get_City(&self, out: *mut HSTRING) -> HRESULT,
    fn put_City(&self, value: HSTRING) -> HRESULT,
    fn get_DependentLocality(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DependentLocality(&self, value: HSTRING) -> HRESULT,
    fn get_PostalCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PostalCode(&self, value: HSTRING) -> HRESULT,
    fn get_SortingCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SortingCode(&self, value: HSTRING) -> HRESULT,
    fn get_LanguageCode(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LanguageCode(&self, value: HSTRING) -> HRESULT,
    fn get_Organization(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Organization(&self, value: HSTRING) -> HRESULT,
    fn get_Recipient(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Recipient(&self, value: HSTRING) -> HRESULT,
    fn get_PhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PhoneNumber(&self, value: HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut super::super::foundation::collections::ValueSet) -> HRESULT
}}
impl IPaymentAddress {
    #[inline] pub unsafe fn get_country(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Country)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_country(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Country)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_address_lines(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AddressLines)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_address_lines(&self, value: &super::super::foundation::collections::IVectorView<HString>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AddressLines)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_region(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Region)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_region(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Region)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_city(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_City)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_city(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_City)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_dependent_locality(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DependentLocality)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_dependent_locality(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DependentLocality)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_postal_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PostalCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_postal_code(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PostalCode)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sorting_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SortingCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_sorting_code(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SortingCode)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_language_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LanguageCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_language_code(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LanguageCode)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_organization(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Organization)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_organization(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Organization)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_recipient(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Recipient)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_recipient(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Recipient)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_phone_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_phone_number(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PhoneNumber)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_properties(&self) -> Result<ComPtr<super::super::foundation::collections::ValueSet>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentAddress: IPaymentAddress}
impl RtActivatable<IActivationFactory> for PaymentAddress {}
DEFINE_CLSID!(PaymentAddress: "Windows.ApplicationModel.Payments.PaymentAddress");
DEFINE_IID!(IID_IPaymentCanMakePaymentResult, 1989606997, 54739, 19773, 179, 69, 69, 89, 23, 89, 197, 16);
RT_INTERFACE!{interface IPaymentCanMakePaymentResult(IPaymentCanMakePaymentResultVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentCanMakePaymentResult] {
    fn get_Status(&self, out: *mut PaymentCanMakePaymentResultStatus) -> HRESULT
}}
impl IPaymentCanMakePaymentResult {
    #[inline] pub unsafe fn get_status(&self) -> Result<PaymentCanMakePaymentResultStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentCanMakePaymentResult: IPaymentCanMakePaymentResult}
impl RtActivatable<IPaymentCanMakePaymentResultFactory> for PaymentCanMakePaymentResult {}
impl PaymentCanMakePaymentResult {
    #[inline] pub fn create(value: PaymentCanMakePaymentResultStatus) -> Result<ComPtr<PaymentCanMakePaymentResult>> { unsafe {
        <Self as RtActivatable<IPaymentCanMakePaymentResultFactory>>::get_activation_factory().create(value)
    }}
}
DEFINE_CLSID!(PaymentCanMakePaymentResult: "Windows.ApplicationModel.Payments.PaymentCanMakePaymentResult");
DEFINE_IID!(IID_IPaymentCanMakePaymentResultFactory, 3151800894, 32073, 20329, 170, 83, 42, 15, 129, 100, 183, 201);
RT_INTERFACE!{static interface IPaymentCanMakePaymentResultFactory(IPaymentCanMakePaymentResultFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentCanMakePaymentResultFactory] {
    fn Create(&self, value: PaymentCanMakePaymentResultStatus, out: *mut *mut PaymentCanMakePaymentResult) -> HRESULT
}}
impl IPaymentCanMakePaymentResultFactory {
    #[inline] pub unsafe fn create(&self, value: PaymentCanMakePaymentResultStatus) -> Result<ComPtr<PaymentCanMakePaymentResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, value, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PaymentCanMakePaymentResultStatus: i32 {
    Unknown (PaymentCanMakePaymentResultStatus_Unknown) = 0, Yes (PaymentCanMakePaymentResultStatus_Yes) = 1, No (PaymentCanMakePaymentResultStatus_No) = 2, NotAllowed (PaymentCanMakePaymentResultStatus_NotAllowed) = 3, UserNotSignedIn (PaymentCanMakePaymentResultStatus_UserNotSignedIn) = 4, SpecifiedPaymentMethodIdsNotSupported (PaymentCanMakePaymentResultStatus_SpecifiedPaymentMethodIdsNotSupported) = 5, NoQualifyingCardOnFile (PaymentCanMakePaymentResultStatus_NoQualifyingCardOnFile) = 6,
}}
DEFINE_IID!(IID_IPaymentCurrencyAmount, 3819170272, 46111, 18823, 189, 203, 7, 19, 49, 242, 218, 164);
RT_INTERFACE!{interface IPaymentCurrencyAmount(IPaymentCurrencyAmountVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentCurrencyAmount] {
    fn get_Currency(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Currency(&self, value: HSTRING) -> HRESULT,
    fn get_CurrencySystem(&self, out: *mut HSTRING) -> HRESULT,
    fn put_CurrencySystem(&self, value: HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Value(&self, value: HSTRING) -> HRESULT
}}
impl IPaymentCurrencyAmount {
    #[inline] pub unsafe fn get_currency(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Currency)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_currency(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Currency)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_currency_system(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrencySystem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_currency_system(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_CurrencySystem)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentCurrencyAmount: IPaymentCurrencyAmount}
impl RtActivatable<IPaymentCurrencyAmountFactory> for PaymentCurrencyAmount {}
impl PaymentCurrencyAmount {
    #[inline] pub fn create(value: &HStringArg, currency: &HStringArg) -> Result<ComPtr<PaymentCurrencyAmount>> { unsafe {
        <Self as RtActivatable<IPaymentCurrencyAmountFactory>>::get_activation_factory().create(value, currency)
    }}
    #[inline] pub fn create_with_currency_system(value: &HStringArg, currency: &HStringArg, currencySystem: &HStringArg) -> Result<ComPtr<PaymentCurrencyAmount>> { unsafe {
        <Self as RtActivatable<IPaymentCurrencyAmountFactory>>::get_activation_factory().create_with_currency_system(value, currency, currencySystem)
    }}
}
DEFINE_CLSID!(PaymentCurrencyAmount: "Windows.ApplicationModel.Payments.PaymentCurrencyAmount");
DEFINE_IID!(IID_IPaymentCurrencyAmountFactory, 844616504, 5132, 17781, 133, 53, 247, 115, 23, 140, 9, 167);
RT_INTERFACE!{static interface IPaymentCurrencyAmountFactory(IPaymentCurrencyAmountFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentCurrencyAmountFactory] {
    fn Create(&self, value: HSTRING, currency: HSTRING, out: *mut *mut PaymentCurrencyAmount) -> HRESULT,
    fn CreateWithCurrencySystem(&self, value: HSTRING, currency: HSTRING, currencySystem: HSTRING, out: *mut *mut PaymentCurrencyAmount) -> HRESULT
}}
impl IPaymentCurrencyAmountFactory {
    #[inline] pub unsafe fn create(&self, value: &HStringArg, currency: &HStringArg) -> Result<ComPtr<PaymentCurrencyAmount>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, value.get(), currency.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_currency_system(&self, value: &HStringArg, currency: &HStringArg, currencySystem: &HStringArg) -> Result<ComPtr<PaymentCurrencyAmount>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithCurrencySystem)(self as *const _ as *mut _, value.get(), currency.get(), currencySystem.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentDetails, 1404775805, 57579, 16467, 142, 174, 206, 124, 72, 224, 41, 69);
RT_INTERFACE!{interface IPaymentDetails(IPaymentDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentDetails] {
    fn get_Total(&self, out: *mut *mut PaymentItem) -> HRESULT,
    fn put_Total(&self, value: *mut PaymentItem) -> HRESULT,
    fn get_DisplayItems(&self, out: *mut *mut super::super::foundation::collections::IVectorView<PaymentItem>) -> HRESULT,
    fn put_DisplayItems(&self, value: *mut super::super::foundation::collections::IVectorView<PaymentItem>) -> HRESULT,
    fn get_ShippingOptions(&self, out: *mut *mut super::super::foundation::collections::IVectorView<PaymentShippingOption>) -> HRESULT,
    fn put_ShippingOptions(&self, value: *mut super::super::foundation::collections::IVectorView<PaymentShippingOption>) -> HRESULT,
    fn get_Modifiers(&self, out: *mut *mut super::super::foundation::collections::IVectorView<PaymentDetailsModifier>) -> HRESULT,
    fn put_Modifiers(&self, value: *mut super::super::foundation::collections::IVectorView<PaymentDetailsModifier>) -> HRESULT
}}
impl IPaymentDetails {
    #[inline] pub unsafe fn get_total(&self) -> Result<ComPtr<PaymentItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Total)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_total(&self, value: &PaymentItem) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Total)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_items(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<PaymentItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_items(&self, value: &super::super::foundation::collections::IVectorView<PaymentItem>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayItems)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shipping_options(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<PaymentShippingOption>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShippingOptions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_shipping_options(&self, value: &super::super::foundation::collections::IVectorView<PaymentShippingOption>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShippingOptions)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_modifiers(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<PaymentDetailsModifier>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Modifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_modifiers(&self, value: &super::super::foundation::collections::IVectorView<PaymentDetailsModifier>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Modifiers)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentDetails: IPaymentDetails}
impl RtActivatable<IPaymentDetailsFactory> for PaymentDetails {}
impl RtActivatable<IActivationFactory> for PaymentDetails {}
impl PaymentDetails {
    #[inline] pub fn create(total: &PaymentItem) -> Result<ComPtr<PaymentDetails>> { unsafe {
        <Self as RtActivatable<IPaymentDetailsFactory>>::get_activation_factory().create(total)
    }}
    #[inline] pub fn create_with_display_items(total: &PaymentItem, displayItems: &super::super::foundation::collections::IIterable<PaymentItem>) -> Result<ComPtr<PaymentDetails>> { unsafe {
        <Self as RtActivatable<IPaymentDetailsFactory>>::get_activation_factory().create_with_display_items(total, displayItems)
    }}
}
DEFINE_CLSID!(PaymentDetails: "Windows.ApplicationModel.Payments.PaymentDetails");
DEFINE_IID!(IID_IPaymentDetailsFactory, 3488133102, 49386, 19617, 139, 199, 109, 230, 123, 31, 55, 99);
RT_INTERFACE!{static interface IPaymentDetailsFactory(IPaymentDetailsFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentDetailsFactory] {
    fn Create(&self, total: *mut PaymentItem, out: *mut *mut PaymentDetails) -> HRESULT,
    fn CreateWithDisplayItems(&self, total: *mut PaymentItem, displayItems: *mut super::super::foundation::collections::IIterable<PaymentItem>, out: *mut *mut PaymentDetails) -> HRESULT
}}
impl IPaymentDetailsFactory {
    #[inline] pub unsafe fn create(&self, total: &PaymentItem) -> Result<ComPtr<PaymentDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, total as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_display_items(&self, total: &PaymentItem, displayItems: &super::super::foundation::collections::IIterable<PaymentItem>) -> Result<ComPtr<PaymentDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithDisplayItems)(self as *const _ as *mut _, total as *const _ as *mut _, displayItems as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentDetailsModifier, 3189538149, 17187, 16855, 179, 5, 223, 203, 118, 95, 105, 222);
RT_INTERFACE!{interface IPaymentDetailsModifier(IPaymentDetailsModifierVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentDetailsModifier] {
    fn get_JsonData(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SupportedMethodIds(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_Total(&self, out: *mut *mut PaymentItem) -> HRESULT,
    fn get_AdditionalDisplayItems(&self, out: *mut *mut super::super::foundation::collections::IVectorView<PaymentItem>) -> HRESULT
}}
impl IPaymentDetailsModifier {
    #[inline] pub unsafe fn get_json_data(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_JsonData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_supported_method_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedMethodIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_total(&self) -> Result<ComPtr<PaymentItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Total)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_additional_display_items(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<PaymentItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AdditionalDisplayItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentDetailsModifier: IPaymentDetailsModifier}
impl RtActivatable<IPaymentDetailsModifierFactory> for PaymentDetailsModifier {}
impl PaymentDetailsModifier {
    #[inline] pub fn create(supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, total: &PaymentItem) -> Result<ComPtr<PaymentDetailsModifier>> { unsafe {
        <Self as RtActivatable<IPaymentDetailsModifierFactory>>::get_activation_factory().create(supportedMethodIds, total)
    }}
    #[inline] pub fn create_with_additional_display_items(supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &super::super::foundation::collections::IIterable<PaymentItem>) -> Result<ComPtr<PaymentDetailsModifier>> { unsafe {
        <Self as RtActivatable<IPaymentDetailsModifierFactory>>::get_activation_factory().create_with_additional_display_items(supportedMethodIds, total, additionalDisplayItems)
    }}
    #[inline] pub fn create_with_additional_display_items_and_json_data(supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &super::super::foundation::collections::IIterable<PaymentItem>, jsonData: &HStringArg) -> Result<ComPtr<PaymentDetailsModifier>> { unsafe {
        <Self as RtActivatable<IPaymentDetailsModifierFactory>>::get_activation_factory().create_with_additional_display_items_and_json_data(supportedMethodIds, total, additionalDisplayItems, jsonData)
    }}
}
DEFINE_CLSID!(PaymentDetailsModifier: "Windows.ApplicationModel.Payments.PaymentDetailsModifier");
DEFINE_IID!(IID_IPaymentDetailsModifierFactory, 2030064262, 21726, 17052, 158, 79, 93, 206, 110, 16, 235, 206);
RT_INTERFACE!{static interface IPaymentDetailsModifierFactory(IPaymentDetailsModifierFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentDetailsModifierFactory] {
    fn Create(&self, supportedMethodIds: *mut super::super::foundation::collections::IIterable<HString>, total: *mut PaymentItem, out: *mut *mut PaymentDetailsModifier) -> HRESULT,
    fn CreateWithAdditionalDisplayItems(&self, supportedMethodIds: *mut super::super::foundation::collections::IIterable<HString>, total: *mut PaymentItem, additionalDisplayItems: *mut super::super::foundation::collections::IIterable<PaymentItem>, out: *mut *mut PaymentDetailsModifier) -> HRESULT,
    fn CreateWithAdditionalDisplayItemsAndJsonData(&self, supportedMethodIds: *mut super::super::foundation::collections::IIterable<HString>, total: *mut PaymentItem, additionalDisplayItems: *mut super::super::foundation::collections::IIterable<PaymentItem>, jsonData: HSTRING, out: *mut *mut PaymentDetailsModifier) -> HRESULT
}}
impl IPaymentDetailsModifierFactory {
    #[inline] pub unsafe fn create(&self, supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, total: &PaymentItem) -> Result<ComPtr<PaymentDetailsModifier>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, supportedMethodIds as *const _ as *mut _, total as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_additional_display_items(&self, supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &super::super::foundation::collections::IIterable<PaymentItem>) -> Result<ComPtr<PaymentDetailsModifier>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithAdditionalDisplayItems)(self as *const _ as *mut _, supportedMethodIds as *const _ as *mut _, total as *const _ as *mut _, additionalDisplayItems as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_additional_display_items_and_json_data(&self, supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, total: &PaymentItem, additionalDisplayItems: &super::super::foundation::collections::IIterable<PaymentItem>, jsonData: &HStringArg) -> Result<ComPtr<PaymentDetailsModifier>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithAdditionalDisplayItemsAndJsonData)(self as *const _ as *mut _, supportedMethodIds as *const _ as *mut _, total as *const _ as *mut _, additionalDisplayItems as *const _ as *mut _, jsonData.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentItem, 1750780043, 31154, 19318, 158, 3, 168, 118, 34, 61, 254, 114);
RT_INTERFACE!{interface IPaymentItem(IPaymentItemVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentItem] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Amount(&self, out: *mut *mut PaymentCurrencyAmount) -> HRESULT,
    fn put_Amount(&self, value: *mut PaymentCurrencyAmount) -> HRESULT,
    fn get_Pending(&self, out: *mut bool) -> HRESULT,
    fn put_Pending(&self, value: bool) -> HRESULT
}}
impl IPaymentItem {
    #[inline] pub unsafe fn get_label(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Label)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_label(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Label)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_amount(&self) -> Result<ComPtr<PaymentCurrencyAmount>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Amount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_amount(&self, value: &PaymentCurrencyAmount) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Amount)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_pending(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Pending)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_pending(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Pending)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentItem: IPaymentItem}
impl RtActivatable<IPaymentItemFactory> for PaymentItem {}
impl PaymentItem {
    #[inline] pub fn create(label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<ComPtr<PaymentItem>> { unsafe {
        <Self as RtActivatable<IPaymentItemFactory>>::get_activation_factory().create(label, amount)
    }}
}
DEFINE_CLSID!(PaymentItem: "Windows.ApplicationModel.Payments.PaymentItem");
DEFINE_IID!(IID_IPaymentItemFactory, 3333126872, 9475, 19741, 167, 120, 2, 178, 229, 146, 123, 44);
RT_INTERFACE!{static interface IPaymentItemFactory(IPaymentItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentItemFactory] {
    fn Create(&self, label: HSTRING, amount: *mut PaymentCurrencyAmount, out: *mut *mut PaymentItem) -> HRESULT
}}
impl IPaymentItemFactory {
    #[inline] pub unsafe fn create(&self, label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<ComPtr<PaymentItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, label.get(), amount as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentMediator, 4212058153, 60428, 17562, 131, 218, 122, 227, 7, 51, 101, 162);
RT_INTERFACE!{interface IPaymentMediator(IPaymentMediatorVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentMediator] {
    fn GetSupportedMethodIdsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>) -> HRESULT,
    fn SubmitPaymentRequestAsync(&self, paymentRequest: *mut PaymentRequest, out: *mut *mut super::super::foundation::IAsyncOperation<PaymentRequestSubmitResult>) -> HRESULT,
    fn SubmitPaymentRequestWithChangeHandlerAsync(&self, paymentRequest: *mut PaymentRequest, changeHandler: *mut PaymentRequestChangedHandler, out: *mut *mut super::super::foundation::IAsyncOperation<PaymentRequestSubmitResult>) -> HRESULT
}}
impl IPaymentMediator {
    #[inline] pub unsafe fn get_supported_method_ids_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSupportedMethodIdsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn submit_payment_request_async(&self, paymentRequest: &PaymentRequest) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PaymentRequestSubmitResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SubmitPaymentRequestAsync)(self as *const _ as *mut _, paymentRequest as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn submit_payment_request_with_change_handler_async(&self, paymentRequest: &PaymentRequest, changeHandler: &PaymentRequestChangedHandler) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PaymentRequestSubmitResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SubmitPaymentRequestWithChangeHandlerAsync)(self as *const _ as *mut _, paymentRequest as *const _ as *mut _, changeHandler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentMediator: IPaymentMediator}
impl RtActivatable<IActivationFactory> for PaymentMediator {}
DEFINE_CLSID!(PaymentMediator: "Windows.ApplicationModel.Payments.PaymentMediator");
DEFINE_IID!(IID_IPaymentMediator2, 3471808753, 58375, 16680, 142, 115, 217, 61, 95, 130, 39, 134);
RT_INTERFACE!{interface IPaymentMediator2(IPaymentMediator2Vtbl): IInspectable(IInspectableVtbl) [IID_IPaymentMediator2] {
    fn CanMakePaymentAsync(&self, paymentRequest: *mut PaymentRequest, out: *mut *mut super::super::foundation::IAsyncOperation<PaymentCanMakePaymentResult>) -> HRESULT
}}
impl IPaymentMediator2 {
    #[inline] pub unsafe fn can_make_payment_async(&self, paymentRequest: &PaymentRequest) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PaymentCanMakePaymentResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CanMakePaymentAsync)(self as *const _ as *mut _, paymentRequest as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentMerchantInfo, 1665421392, 3732, 20182, 170, 203, 230, 1, 43, 211, 39, 167);
RT_INTERFACE!{interface IPaymentMerchantInfo(IPaymentMerchantInfoVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentMerchantInfo] {
    fn get_PackageFullName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Uri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT
}}
impl IPaymentMerchantInfo {
    #[inline] pub unsafe fn get_package_full_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFullName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentMerchantInfo: IPaymentMerchantInfo}
impl RtActivatable<IPaymentMerchantInfoFactory> for PaymentMerchantInfo {}
impl RtActivatable<IActivationFactory> for PaymentMerchantInfo {}
impl PaymentMerchantInfo {
    #[inline] pub fn create(uri: &super::super::foundation::Uri) -> Result<ComPtr<PaymentMerchantInfo>> { unsafe {
        <Self as RtActivatable<IPaymentMerchantInfoFactory>>::get_activation_factory().create(uri)
    }}
}
DEFINE_CLSID!(PaymentMerchantInfo: "Windows.ApplicationModel.Payments.PaymentMerchantInfo");
DEFINE_IID!(IID_IPaymentMerchantInfoFactory, 2659831507, 52407, 16743, 168, 236, 225, 10, 233, 109, 188, 209);
RT_INTERFACE!{static interface IPaymentMerchantInfoFactory(IPaymentMerchantInfoFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentMerchantInfoFactory] {
    fn Create(&self, uri: *mut super::super::foundation::Uri, out: *mut *mut PaymentMerchantInfo) -> HRESULT
}}
impl IPaymentMerchantInfoFactory {
    #[inline] pub unsafe fn create(&self, uri: &super::super::foundation::Uri) -> Result<ComPtr<PaymentMerchantInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, uri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentMethodData, 3520318196, 56984, 16681, 177, 183, 195, 173, 134, 35, 123, 244);
RT_INTERFACE!{interface IPaymentMethodData(IPaymentMethodDataVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentMethodData] {
    fn get_SupportedMethodIds(&self, out: *mut *mut super::super::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn get_JsonData(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPaymentMethodData {
    #[inline] pub unsafe fn get_supported_method_ids(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SupportedMethodIds)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_json_data(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_JsonData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentMethodData: IPaymentMethodData}
impl RtActivatable<IPaymentMethodDataFactory> for PaymentMethodData {}
impl PaymentMethodData {
    #[inline] pub fn create(supportedMethodIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<PaymentMethodData>> { unsafe {
        <Self as RtActivatable<IPaymentMethodDataFactory>>::get_activation_factory().create(supportedMethodIds)
    }}
    #[inline] pub fn create_with_json_data(supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, jsonData: &HStringArg) -> Result<ComPtr<PaymentMethodData>> { unsafe {
        <Self as RtActivatable<IPaymentMethodDataFactory>>::get_activation_factory().create_with_json_data(supportedMethodIds, jsonData)
    }}
}
DEFINE_CLSID!(PaymentMethodData: "Windows.ApplicationModel.Payments.PaymentMethodData");
DEFINE_IID!(IID_IPaymentMethodDataFactory, 2329793151, 39850, 19074, 131, 66, 168, 33, 9, 146, 163, 107);
RT_INTERFACE!{static interface IPaymentMethodDataFactory(IPaymentMethodDataFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentMethodDataFactory] {
    fn Create(&self, supportedMethodIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut PaymentMethodData) -> HRESULT,
    fn CreateWithJsonData(&self, supportedMethodIds: *mut super::super::foundation::collections::IIterable<HString>, jsonData: HSTRING, out: *mut *mut PaymentMethodData) -> HRESULT
}}
impl IPaymentMethodDataFactory {
    #[inline] pub unsafe fn create(&self, supportedMethodIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<PaymentMethodData>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, supportedMethodIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_json_data(&self, supportedMethodIds: &super::super::foundation::collections::IIterable<HString>, jsonData: &HStringArg) -> Result<ComPtr<PaymentMethodData>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithJsonData)(self as *const _ as *mut _, supportedMethodIds as *const _ as *mut _, jsonData.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PaymentOptionPresence: i32 {
    None (PaymentOptionPresence_None) = 0, Optional (PaymentOptionPresence_Optional) = 1, Required (PaymentOptionPresence_Required) = 2,
}}
DEFINE_IID!(IID_IPaymentOptions, 2862811220, 7979, 17253, 130, 81, 1, 181, 137, 21, 165, 188);
RT_INTERFACE!{interface IPaymentOptions(IPaymentOptionsVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentOptions] {
    fn get_RequestPayerEmail(&self, out: *mut PaymentOptionPresence) -> HRESULT,
    fn put_RequestPayerEmail(&self, value: PaymentOptionPresence) -> HRESULT,
    fn get_RequestPayerName(&self, out: *mut PaymentOptionPresence) -> HRESULT,
    fn put_RequestPayerName(&self, value: PaymentOptionPresence) -> HRESULT,
    fn get_RequestPayerPhoneNumber(&self, out: *mut PaymentOptionPresence) -> HRESULT,
    fn put_RequestPayerPhoneNumber(&self, value: PaymentOptionPresence) -> HRESULT,
    fn get_RequestShipping(&self, out: *mut bool) -> HRESULT,
    fn put_RequestShipping(&self, value: bool) -> HRESULT,
    fn get_ShippingType(&self, out: *mut PaymentShippingType) -> HRESULT,
    fn put_ShippingType(&self, value: PaymentShippingType) -> HRESULT
}}
impl IPaymentOptions {
    #[inline] pub unsafe fn get_request_payer_email(&self) -> Result<PaymentOptionPresence> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestPayerEmail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_request_payer_email(&self, value: PaymentOptionPresence) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestPayerEmail)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_request_payer_name(&self) -> Result<PaymentOptionPresence> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestPayerName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_request_payer_name(&self, value: PaymentOptionPresence) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestPayerName)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_request_payer_phone_number(&self) -> Result<PaymentOptionPresence> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestPayerPhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_request_payer_phone_number(&self, value: PaymentOptionPresence) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestPayerPhoneNumber)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_request_shipping(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_RequestShipping)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_request_shipping(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RequestShipping)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shipping_type(&self) -> Result<PaymentShippingType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShippingType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_shipping_type(&self, value: PaymentShippingType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShippingType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentOptions: IPaymentOptions}
impl RtActivatable<IActivationFactory> for PaymentOptions {}
DEFINE_CLSID!(PaymentOptions: "Windows.ApplicationModel.Payments.PaymentOptions");
DEFINE_IID!(IID_IPaymentRequest, 3075031777, 60795, 18411, 188, 8, 120, 204, 93, 104, 150, 182);
RT_INTERFACE!{interface IPaymentRequest(IPaymentRequestVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequest] {
    fn get_MerchantInfo(&self, out: *mut *mut PaymentMerchantInfo) -> HRESULT,
    fn get_Details(&self, out: *mut *mut PaymentDetails) -> HRESULT,
    fn get_MethodData(&self, out: *mut *mut super::super::foundation::collections::IVectorView<PaymentMethodData>) -> HRESULT,
    fn get_Options(&self, out: *mut *mut PaymentOptions) -> HRESULT
}}
impl IPaymentRequest {
    #[inline] pub unsafe fn get_merchant_info(&self) -> Result<ComPtr<PaymentMerchantInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MerchantInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_details(&self) -> Result<ComPtr<PaymentDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Details)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_method_data(&self) -> Result<ComPtr<super::super::foundation::collections::IVectorView<PaymentMethodData>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MethodData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_options(&self) -> Result<ComPtr<PaymentOptions>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Options)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentRequest: IPaymentRequest}
impl RtActivatable<IPaymentRequestFactory> for PaymentRequest {}
impl RtActivatable<IPaymentRequestFactory2> for PaymentRequest {}
impl PaymentRequest {
    #[inline] pub fn create(details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>) -> Result<ComPtr<PaymentRequest>> { unsafe {
        <Self as RtActivatable<IPaymentRequestFactory>>::get_activation_factory().create(details, methodData)
    }}
    #[inline] pub fn create_with_merchant_info(details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo) -> Result<ComPtr<PaymentRequest>> { unsafe {
        <Self as RtActivatable<IPaymentRequestFactory>>::get_activation_factory().create_with_merchant_info(details, methodData, merchantInfo)
    }}
    #[inline] pub fn create_with_merchant_info_and_options(details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions) -> Result<ComPtr<PaymentRequest>> { unsafe {
        <Self as RtActivatable<IPaymentRequestFactory>>::get_activation_factory().create_with_merchant_info_and_options(details, methodData, merchantInfo, options)
    }}
    #[inline] pub fn create_with_merchant_info_options_and_id(details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions, id: &HStringArg) -> Result<ComPtr<PaymentRequest>> { unsafe {
        <Self as RtActivatable<IPaymentRequestFactory2>>::get_activation_factory().create_with_merchant_info_options_and_id(details, methodData, merchantInfo, options, id)
    }}
}
DEFINE_CLSID!(PaymentRequest: "Windows.ApplicationModel.Payments.PaymentRequest");
DEFINE_IID!(IID_IPaymentRequest2, 3057438645, 22936, 18750, 160, 76, 103, 4, 138, 80, 241, 65);
RT_INTERFACE!{interface IPaymentRequest2(IPaymentRequest2Vtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequest2] {
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPaymentRequest2 {
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentRequestChangedArgs, 3323223620, 52619, 19428, 181, 85, 39, 201, 145, 148, 192, 197);
RT_INTERFACE!{interface IPaymentRequestChangedArgs(IPaymentRequestChangedArgsVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequestChangedArgs] {
    fn get_ChangeKind(&self, out: *mut PaymentRequestChangeKind) -> HRESULT,
    fn get_ShippingAddress(&self, out: *mut *mut PaymentAddress) -> HRESULT,
    fn get_SelectedShippingOption(&self, out: *mut *mut PaymentShippingOption) -> HRESULT,
    fn Acknowledge(&self, changeResult: *mut PaymentRequestChangedResult) -> HRESULT
}}
impl IPaymentRequestChangedArgs {
    #[inline] pub unsafe fn get_change_kind(&self) -> Result<PaymentRequestChangeKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeKind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shipping_address(&self) -> Result<ComPtr<PaymentAddress>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShippingAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_selected_shipping_option(&self) -> Result<ComPtr<PaymentShippingOption>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedShippingOption)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn acknowledge(&self, changeResult: &PaymentRequestChangedResult) -> Result<()> {
        let hr = ((*self.lpVtbl).Acknowledge)(self as *const _ as *mut _, changeResult as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentRequestChangedArgs: IPaymentRequestChangedArgs}
DEFINE_IID!(IID_PaymentRequestChangedHandler, 1350089185, 62360, 20268, 162, 126, 148, 211, 113, 207, 108, 125);
RT_DELEGATE!{delegate PaymentRequestChangedHandler(PaymentRequestChangedHandlerVtbl, PaymentRequestChangedHandlerImpl) [IID_PaymentRequestChangedHandler] {
    fn Invoke(&self, paymentRequest: *mut PaymentRequest, args: *mut PaymentRequestChangedArgs) -> HRESULT
}}
impl PaymentRequestChangedHandler {
    #[inline] pub unsafe fn invoke(&self, paymentRequest: &PaymentRequest, args: &PaymentRequestChangedArgs) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _, paymentRequest as *const _ as *mut _, args as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentRequestChangedResult, 3748240988, 5828, 18349, 148, 1, 132, 64, 236, 7, 87, 219);
RT_INTERFACE!{interface IPaymentRequestChangedResult(IPaymentRequestChangedResultVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequestChangedResult] {
    fn get_ChangeAcceptedByMerchant(&self, out: *mut bool) -> HRESULT,
    fn put_ChangeAcceptedByMerchant(&self, value: bool) -> HRESULT,
    fn get_Message(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Message(&self, value: HSTRING) -> HRESULT,
    fn get_UpdatedPaymentDetails(&self, out: *mut *mut PaymentDetails) -> HRESULT,
    fn put_UpdatedPaymentDetails(&self, value: *mut PaymentDetails) -> HRESULT
}}
impl IPaymentRequestChangedResult {
    #[inline] pub unsafe fn get_change_accepted_by_merchant(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ChangeAcceptedByMerchant)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_change_accepted_by_merchant(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ChangeAcceptedByMerchant)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Message)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_updated_payment_details(&self) -> Result<ComPtr<PaymentDetails>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_UpdatedPaymentDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_updated_payment_details(&self, value: &PaymentDetails) -> Result<()> {
        let hr = ((*self.lpVtbl).put_UpdatedPaymentDetails)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentRequestChangedResult: IPaymentRequestChangedResult}
impl RtActivatable<IPaymentRequestChangedResultFactory> for PaymentRequestChangedResult {}
impl PaymentRequestChangedResult {
    #[inline] pub fn create(changeAcceptedByMerchant: bool) -> Result<ComPtr<PaymentRequestChangedResult>> { unsafe {
        <Self as RtActivatable<IPaymentRequestChangedResultFactory>>::get_activation_factory().create(changeAcceptedByMerchant)
    }}
    #[inline] pub fn create_with_payment_details(changeAcceptedByMerchant: bool, updatedPaymentDetails: &PaymentDetails) -> Result<ComPtr<PaymentRequestChangedResult>> { unsafe {
        <Self as RtActivatable<IPaymentRequestChangedResultFactory>>::get_activation_factory().create_with_payment_details(changeAcceptedByMerchant, updatedPaymentDetails)
    }}
}
DEFINE_CLSID!(PaymentRequestChangedResult: "Windows.ApplicationModel.Payments.PaymentRequestChangedResult");
DEFINE_IID!(IID_IPaymentRequestChangedResultFactory, 141823830, 7475, 17457, 129, 75, 103, 234, 36, 191, 33, 219);
RT_INTERFACE!{static interface IPaymentRequestChangedResultFactory(IPaymentRequestChangedResultFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequestChangedResultFactory] {
    fn Create(&self, changeAcceptedByMerchant: bool, out: *mut *mut PaymentRequestChangedResult) -> HRESULT,
    fn CreateWithPaymentDetails(&self, changeAcceptedByMerchant: bool, updatedPaymentDetails: *mut PaymentDetails, out: *mut *mut PaymentRequestChangedResult) -> HRESULT
}}
impl IPaymentRequestChangedResultFactory {
    #[inline] pub unsafe fn create(&self, changeAcceptedByMerchant: bool) -> Result<ComPtr<PaymentRequestChangedResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, changeAcceptedByMerchant, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_payment_details(&self, changeAcceptedByMerchant: bool, updatedPaymentDetails: &PaymentDetails) -> Result<ComPtr<PaymentRequestChangedResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithPaymentDetails)(self as *const _ as *mut _, changeAcceptedByMerchant, updatedPaymentDetails as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PaymentRequestChangeKind: i32 {
    ShippingOption (PaymentRequestChangeKind_ShippingOption) = 0, ShippingAddress (PaymentRequestChangeKind_ShippingAddress) = 1,
}}
RT_ENUM! { enum PaymentRequestCompletionStatus: i32 {
    Succeeded (PaymentRequestCompletionStatus_Succeeded) = 0, Failed (PaymentRequestCompletionStatus_Failed) = 1, Unknown (PaymentRequestCompletionStatus_Unknown) = 2,
}}
DEFINE_IID!(IID_IPaymentRequestFactory, 1049262556, 27508, 17107, 177, 3, 240, 222, 53, 251, 24, 72);
RT_INTERFACE!{static interface IPaymentRequestFactory(IPaymentRequestFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequestFactory] {
    fn Create(&self, details: *mut PaymentDetails, methodData: *mut super::super::foundation::collections::IIterable<PaymentMethodData>, out: *mut *mut PaymentRequest) -> HRESULT,
    fn CreateWithMerchantInfo(&self, details: *mut PaymentDetails, methodData: *mut super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: *mut PaymentMerchantInfo, out: *mut *mut PaymentRequest) -> HRESULT,
    fn CreateWithMerchantInfoAndOptions(&self, details: *mut PaymentDetails, methodData: *mut super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: *mut PaymentMerchantInfo, options: *mut PaymentOptions, out: *mut *mut PaymentRequest) -> HRESULT
}}
impl IPaymentRequestFactory {
    #[inline] pub unsafe fn create(&self, details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>) -> Result<ComPtr<PaymentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, details as *const _ as *mut _, methodData as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_merchant_info(&self, details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo) -> Result<ComPtr<PaymentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithMerchantInfo)(self as *const _ as *mut _, details as *const _ as *mut _, methodData as *const _ as *mut _, merchantInfo as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_merchant_info_and_options(&self, details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions) -> Result<ComPtr<PaymentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithMerchantInfoAndOptions)(self as *const _ as *mut _, details as *const _ as *mut _, methodData as *const _ as *mut _, merchantInfo as *const _ as *mut _, options as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentRequestFactory2, 3872264997, 42246, 17266, 183, 239, 26, 3, 29, 86, 98, 209);
RT_INTERFACE!{static interface IPaymentRequestFactory2(IPaymentRequestFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequestFactory2] {
    fn CreateWithMerchantInfoOptionsAndId(&self, details: *mut PaymentDetails, methodData: *mut super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: *mut PaymentMerchantInfo, options: *mut PaymentOptions, id: HSTRING, out: *mut *mut PaymentRequest) -> HRESULT
}}
impl IPaymentRequestFactory2 {
    #[inline] pub unsafe fn create_with_merchant_info_options_and_id(&self, details: &PaymentDetails, methodData: &super::super::foundation::collections::IIterable<PaymentMethodData>, merchantInfo: &PaymentMerchantInfo, options: &PaymentOptions, id: &HStringArg) -> Result<ComPtr<PaymentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithMerchantInfoOptionsAndId)(self as *const _ as *mut _, details as *const _ as *mut _, methodData as *const _ as *mut _, merchantInfo as *const _ as *mut _, options as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PaymentRequestStatus: i32 {
    Succeeded (PaymentRequestStatus_Succeeded) = 0, Failed (PaymentRequestStatus_Failed) = 1, Canceled (PaymentRequestStatus_Canceled) = 2,
}}
DEFINE_IID!(IID_IPaymentRequestSubmitResult, 2073835794, 12530, 20112, 178, 73, 140, 231, 215, 143, 254, 86);
RT_INTERFACE!{interface IPaymentRequestSubmitResult(IPaymentRequestSubmitResultVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentRequestSubmitResult] {
    fn get_Status(&self, out: *mut PaymentRequestStatus) -> HRESULT,
    fn get_Response(&self, out: *mut *mut PaymentResponse) -> HRESULT
}}
impl IPaymentRequestSubmitResult {
    #[inline] pub unsafe fn get_status(&self) -> Result<PaymentRequestStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_response(&self) -> Result<ComPtr<PaymentResponse>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Response)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentRequestSubmitResult: IPaymentRequestSubmitResult}
DEFINE_IID!(IID_IPaymentResponse, 3778581591, 35794, 18568, 159, 168, 151, 152, 85, 69, 16, 142);
RT_INTERFACE!{interface IPaymentResponse(IPaymentResponseVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentResponse] {
    fn get_PaymentToken(&self, out: *mut *mut PaymentToken) -> HRESULT,
    fn get_ShippingOption(&self, out: *mut *mut PaymentShippingOption) -> HRESULT,
    fn get_ShippingAddress(&self, out: *mut *mut PaymentAddress) -> HRESULT,
    fn get_PayerEmail(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PayerName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PayerPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn CompleteAsync(&self, status: PaymentRequestCompletionStatus, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IPaymentResponse {
    #[inline] pub unsafe fn get_payment_token(&self) -> Result<ComPtr<PaymentToken>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaymentToken)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shipping_option(&self) -> Result<ComPtr<PaymentShippingOption>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShippingOption)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_shipping_address(&self) -> Result<ComPtr<PaymentAddress>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ShippingAddress)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_payer_email(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PayerEmail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_payer_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PayerName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_payer_phone_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PayerPhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn complete_async(&self, status: PaymentRequestCompletionStatus) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CompleteAsync)(self as *const _ as *mut _, status, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentResponse: IPaymentResponse}
DEFINE_IID!(IID_IPaymentShippingOption, 322382554, 38739, 17780, 137, 102, 147, 20, 90, 118, 199, 249);
RT_INTERFACE!{interface IPaymentShippingOption(IPaymentShippingOptionVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentShippingOption] {
    fn get_Label(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Label(&self, value: HSTRING) -> HRESULT,
    fn get_Amount(&self, out: *mut *mut PaymentCurrencyAmount) -> HRESULT,
    fn put_Amount(&self, value: *mut PaymentCurrencyAmount) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Tag(&self, value: HSTRING) -> HRESULT,
    fn get_IsSelected(&self, out: *mut bool) -> HRESULT,
    fn put_IsSelected(&self, value: bool) -> HRESULT
}}
impl IPaymentShippingOption {
    #[inline] pub unsafe fn get_label(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Label)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_label(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Label)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_amount(&self) -> Result<ComPtr<PaymentCurrencyAmount>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Amount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_amount(&self, value: &PaymentCurrencyAmount) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Amount)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tag(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_tag(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Tag)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_selected(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSelected)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_selected(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsSelected)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentShippingOption: IPaymentShippingOption}
impl RtActivatable<IPaymentShippingOptionFactory> for PaymentShippingOption {}
impl PaymentShippingOption {
    #[inline] pub fn create(label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<ComPtr<PaymentShippingOption>> { unsafe {
        <Self as RtActivatable<IPaymentShippingOptionFactory>>::get_activation_factory().create(label, amount)
    }}
    #[inline] pub fn create_with_selected(label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool) -> Result<ComPtr<PaymentShippingOption>> { unsafe {
        <Self as RtActivatable<IPaymentShippingOptionFactory>>::get_activation_factory().create_with_selected(label, amount, selected)
    }}
    #[inline] pub fn create_with_selected_and_tag(label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool, tag: &HStringArg) -> Result<ComPtr<PaymentShippingOption>> { unsafe {
        <Self as RtActivatable<IPaymentShippingOptionFactory>>::get_activation_factory().create_with_selected_and_tag(label, amount, selected, tag)
    }}
}
DEFINE_CLSID!(PaymentShippingOption: "Windows.ApplicationModel.Payments.PaymentShippingOption");
DEFINE_IID!(IID_IPaymentShippingOptionFactory, 1575352599, 45783, 17515, 157, 115, 97, 35, 251, 202, 59, 198);
RT_INTERFACE!{static interface IPaymentShippingOptionFactory(IPaymentShippingOptionFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentShippingOptionFactory] {
    fn Create(&self, label: HSTRING, amount: *mut PaymentCurrencyAmount, out: *mut *mut PaymentShippingOption) -> HRESULT,
    fn CreateWithSelected(&self, label: HSTRING, amount: *mut PaymentCurrencyAmount, selected: bool, out: *mut *mut PaymentShippingOption) -> HRESULT,
    fn CreateWithSelectedAndTag(&self, label: HSTRING, amount: *mut PaymentCurrencyAmount, selected: bool, tag: HSTRING, out: *mut *mut PaymentShippingOption) -> HRESULT
}}
impl IPaymentShippingOptionFactory {
    #[inline] pub unsafe fn create(&self, label: &HStringArg, amount: &PaymentCurrencyAmount) -> Result<ComPtr<PaymentShippingOption>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, label.get(), amount as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_selected(&self, label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool) -> Result<ComPtr<PaymentShippingOption>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithSelected)(self as *const _ as *mut _, label.get(), amount as *const _ as *mut _, selected, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_selected_and_tag(&self, label: &HStringArg, amount: &PaymentCurrencyAmount, selected: bool, tag: &HStringArg) -> Result<ComPtr<PaymentShippingOption>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithSelectedAndTag)(self as *const _ as *mut _, label.get(), amount as *const _ as *mut _, selected, tag.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum PaymentShippingType: i32 {
    Shipping (PaymentShippingType_Shipping) = 0, Delivery (PaymentShippingType_Delivery) = 1, Pickup (PaymentShippingType_Pickup) = 2,
}}
DEFINE_IID!(IID_IPaymentToken, 3150626835, 52432, 16882, 178, 161, 10, 46, 75, 93, 206, 37);
RT_INTERFACE!{interface IPaymentToken(IPaymentTokenVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentToken] {
    fn get_PaymentMethodId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_JsonDetails(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPaymentToken {
    #[inline] pub unsafe fn get_payment_method_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaymentMethodId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_json_details(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_JsonDetails)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentToken: IPaymentToken}
impl RtActivatable<IPaymentTokenFactory> for PaymentToken {}
impl PaymentToken {
    #[inline] pub fn create(paymentMethodId: &HStringArg) -> Result<ComPtr<PaymentToken>> { unsafe {
        <Self as RtActivatable<IPaymentTokenFactory>>::get_activation_factory().create(paymentMethodId)
    }}
    #[inline] pub fn create_with_json_details(paymentMethodId: &HStringArg, jsonDetails: &HStringArg) -> Result<ComPtr<PaymentToken>> { unsafe {
        <Self as RtActivatable<IPaymentTokenFactory>>::get_activation_factory().create_with_json_details(paymentMethodId, jsonDetails)
    }}
}
DEFINE_CLSID!(PaymentToken: "Windows.ApplicationModel.Payments.PaymentToken");
DEFINE_IID!(IID_IPaymentTokenFactory, 2559367082, 18259, 18692, 131, 115, 221, 123, 8, 185, 149, 193);
RT_INTERFACE!{static interface IPaymentTokenFactory(IPaymentTokenFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentTokenFactory] {
    fn Create(&self, paymentMethodId: HSTRING, out: *mut *mut PaymentToken) -> HRESULT,
    fn CreateWithJsonDetails(&self, paymentMethodId: HSTRING, jsonDetails: HSTRING, out: *mut *mut PaymentToken) -> HRESULT
}}
impl IPaymentTokenFactory {
    #[inline] pub unsafe fn create(&self, paymentMethodId: &HStringArg) -> Result<ComPtr<PaymentToken>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Create)(self as *const _ as *mut _, paymentMethodId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_with_json_details(&self, paymentMethodId: &HStringArg, jsonDetails: &HStringArg) -> Result<ComPtr<PaymentToken>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWithJsonDetails)(self as *const _ as *mut _, paymentMethodId.get(), jsonDetails.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
pub mod provider { // Windows.ApplicationModel.Payments.Provider
use ::prelude::*;
DEFINE_IID!(IID_IPaymentAppCanMakePaymentTriggerDetails, 216138224, 35731, 20150, 140, 70, 46, 74, 108, 106, 38, 246);
RT_INTERFACE!{interface IPaymentAppCanMakePaymentTriggerDetails(IPaymentAppCanMakePaymentTriggerDetailsVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentAppCanMakePaymentTriggerDetails] {
    fn get_Request(&self, out: *mut *mut super::PaymentRequest) -> HRESULT,
    fn ReportCanMakePaymentResult(&self, value: *mut super::PaymentCanMakePaymentResult) -> HRESULT
}}
impl IPaymentAppCanMakePaymentTriggerDetails {
    #[inline] pub unsafe fn get_request(&self) -> Result<ComPtr<super::PaymentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Request)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_can_make_payment_result(&self, value: &super::PaymentCanMakePaymentResult) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportCanMakePaymentResult)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentAppCanMakePaymentTriggerDetails: IPaymentAppCanMakePaymentTriggerDetails}
DEFINE_IID!(IID_IPaymentAppManager, 239577683, 34081, 18793, 169, 87, 223, 37, 56, 163, 169, 143);
RT_INTERFACE!{interface IPaymentAppManager(IPaymentAppManagerVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentAppManager] {
    fn RegisterAsync(&self, supportedPaymentMethodIds: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn UnregisterAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IPaymentAppManager {
    #[inline] pub unsafe fn register_async(&self, supportedPaymentMethodIds: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RegisterAsync)(self as *const _ as *mut _, supportedPaymentMethodIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn unregister_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UnregisterAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentAppManager: IPaymentAppManager}
impl RtActivatable<IPaymentAppManagerStatics> for PaymentAppManager {}
impl PaymentAppManager {
    #[inline] pub fn get_current() -> Result<ComPtr<PaymentAppManager>> { unsafe {
        <Self as RtActivatable<IPaymentAppManagerStatics>>::get_activation_factory().get_current()
    }}
}
DEFINE_CLSID!(PaymentAppManager: "Windows.ApplicationModel.Payments.Provider.PaymentAppManager");
DEFINE_IID!(IID_IPaymentAppManagerStatics, 2738990120, 64649, 17414, 180, 217, 52, 231, 254, 121, 223, 182);
RT_INTERFACE!{static interface IPaymentAppManagerStatics(IPaymentAppManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentAppManagerStatics] {
    fn get_Current(&self, out: *mut *mut PaymentAppManager) -> HRESULT
}}
impl IPaymentAppManagerStatics {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<PaymentAppManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IPaymentTransaction, 1649941920, 9893, 20123, 166, 235, 102, 96, 108, 240, 1, 211);
RT_INTERFACE!{interface IPaymentTransaction(IPaymentTransactionVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentTransaction] {
    fn get_PaymentRequest(&self, out: *mut *mut super::PaymentRequest) -> HRESULT,
    fn get_PayerEmail(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PayerEmail(&self, value: HSTRING) -> HRESULT,
    fn get_PayerName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PayerName(&self, value: HSTRING) -> HRESULT,
    fn get_PayerPhoneNumber(&self, out: *mut HSTRING) -> HRESULT,
    fn put_PayerPhoneNumber(&self, value: HSTRING) -> HRESULT,
    fn UpdateShippingAddressAsync(&self, shippingAddress: *mut super::PaymentAddress, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::PaymentRequestChangedResult>) -> HRESULT,
    fn UpdateSelectedShippingOptionAsync(&self, selectedShippingOption: *mut super::PaymentShippingOption, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::PaymentRequestChangedResult>) -> HRESULT,
    fn AcceptAsync(&self, paymentToken: *mut super::PaymentToken, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<PaymentTransactionAcceptResult>) -> HRESULT,
    fn Reject(&self) -> HRESULT
}}
impl IPaymentTransaction {
    #[inline] pub unsafe fn get_payment_request(&self) -> Result<ComPtr<super::PaymentRequest>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PaymentRequest)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_payer_email(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PayerEmail)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_payer_email(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PayerEmail)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_payer_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PayerName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_payer_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PayerName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_payer_phone_number(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PayerPhoneNumber)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_payer_phone_number(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PayerPhoneNumber)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_shipping_address_async(&self, shippingAddress: &super::PaymentAddress) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::PaymentRequestChangedResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateShippingAddressAsync)(self as *const _ as *mut _, shippingAddress as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_selected_shipping_option_async(&self, selectedShippingOption: &super::PaymentShippingOption) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::PaymentRequestChangedResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateSelectedShippingOptionAsync)(self as *const _ as *mut _, selectedShippingOption as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn accept_async(&self, paymentToken: &super::PaymentToken) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<PaymentTransactionAcceptResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AcceptAsync)(self as *const _ as *mut _, paymentToken as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn reject(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Reject)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentTransaction: IPaymentTransaction}
impl RtActivatable<IPaymentTransactionStatics> for PaymentTransaction {}
impl PaymentTransaction {
    #[inline] pub fn from_id_async(id: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<PaymentTransaction>>> { unsafe {
        <Self as RtActivatable<IPaymentTransactionStatics>>::get_activation_factory().from_id_async(id)
    }}
}
DEFINE_CLSID!(PaymentTransaction: "Windows.ApplicationModel.Payments.Provider.PaymentTransaction");
DEFINE_IID!(IID_IPaymentTransactionAcceptResult, 101593718, 54028, 18455, 149, 162, 223, 122, 233, 39, 59, 86);
RT_INTERFACE!{interface IPaymentTransactionAcceptResult(IPaymentTransactionAcceptResultVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentTransactionAcceptResult] {
    fn get_Status(&self, out: *mut super::PaymentRequestCompletionStatus) -> HRESULT
}}
impl IPaymentTransactionAcceptResult {
    #[inline] pub unsafe fn get_status(&self) -> Result<super::PaymentRequestCompletionStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class PaymentTransactionAcceptResult: IPaymentTransactionAcceptResult}
DEFINE_IID!(IID_IPaymentTransactionStatics, 2372114256, 60938, 19957, 155, 30, 28, 15, 158, 197, 152, 129);
RT_INTERFACE!{static interface IPaymentTransactionStatics(IPaymentTransactionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IPaymentTransactionStatics] {
    fn FromIdAsync(&self, id: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<PaymentTransaction>) -> HRESULT
}}
impl IPaymentTransactionStatics {
    #[inline] pub unsafe fn from_id_async(&self, id: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<PaymentTransaction>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FromIdAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.Payments.Provider
} // Windows.ApplicationModel.Payments
pub mod resources { // Windows.ApplicationModel.Resources
use ::prelude::*;
DEFINE_IID!(IID_IResourceLoader, 139610376, 5871, 17837, 166, 2, 41, 54, 55, 215, 230, 26);
RT_INTERFACE!{interface IResourceLoader(IResourceLoaderVtbl): IInspectable(IInspectableVtbl) [IID_IResourceLoader] {
    fn GetString(&self, resource: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IResourceLoader {
    #[inline] pub unsafe fn get_string(&self, resource: &HStringArg) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetString)(self as *const _ as *mut _, resource.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceLoader: IResourceLoader}
impl RtActivatable<IResourceLoaderFactory> for ResourceLoader {}
impl RtActivatable<IResourceLoaderStatics> for ResourceLoader {}
impl RtActivatable<IResourceLoaderStatics2> for ResourceLoader {}
impl RtActivatable<IActivationFactory> for ResourceLoader {}
impl ResourceLoader {
    #[inline] pub fn create_resource_loader_by_name(name: &HStringArg) -> Result<ComPtr<ResourceLoader>> { unsafe {
        <Self as RtActivatable<IResourceLoaderFactory>>::get_activation_factory().create_resource_loader_by_name(name)
    }}
    #[inline] pub fn get_string_for_reference(uri: &super::super::foundation::Uri) -> Result<HString> { unsafe {
        <Self as RtActivatable<IResourceLoaderStatics>>::get_activation_factory().get_string_for_reference(uri)
    }}
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<ResourceLoader>> { unsafe {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_current_view()
    }}
    #[inline] pub fn get_for_current_view_with_name(name: &HStringArg) -> Result<ComPtr<ResourceLoader>> { unsafe {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_current_view_with_name(name)
    }}
    #[inline] pub fn get_for_view_independent_use() -> Result<ComPtr<ResourceLoader>> { unsafe {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_view_independent_use()
    }}
    #[inline] pub fn get_for_view_independent_use_with_name(name: &HStringArg) -> Result<ComPtr<ResourceLoader>> { unsafe {
        <Self as RtActivatable<IResourceLoaderStatics2>>::get_activation_factory().get_for_view_independent_use_with_name(name)
    }}
}
DEFINE_CLSID!(ResourceLoader: "Windows.ApplicationModel.Resources.ResourceLoader");
DEFINE_IID!(IID_IResourceLoader2, 283864774, 33080, 18625, 188, 101, 225, 241, 66, 7, 54, 124);
RT_INTERFACE!{interface IResourceLoader2(IResourceLoader2Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceLoader2] {
    fn GetStringForUri(&self, uri: *mut super::super::foundation::Uri, out: *mut HSTRING) -> HRESULT
}}
impl IResourceLoader2 {
    #[inline] pub unsafe fn get_string_for_uri(&self, uri: &super::super::foundation::Uri) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStringForUri)(self as *const _ as *mut _, uri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceLoaderFactory, 3275372035, 27100, 17029, 160, 119, 213, 192, 228, 124, 203, 232);
RT_INTERFACE!{static interface IResourceLoaderFactory(IResourceLoaderFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IResourceLoaderFactory] {
    fn CreateResourceLoaderByName(&self, name: HSTRING, out: *mut *mut ResourceLoader) -> HRESULT
}}
impl IResourceLoaderFactory {
    #[inline] pub unsafe fn create_resource_loader_by_name(&self, name: &HStringArg) -> Result<ComPtr<ResourceLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResourceLoaderByName)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceLoaderStatics, 3212279009, 6600, 18882, 149, 60, 71, 233, 34, 123, 51, 78);
RT_INTERFACE!{static interface IResourceLoaderStatics(IResourceLoaderStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IResourceLoaderStatics] {
    fn GetStringForReference(&self, uri: *mut super::super::foundation::Uri, out: *mut HSTRING) -> HRESULT
}}
impl IResourceLoaderStatics {
    #[inline] pub unsafe fn get_string_for_reference(&self, uri: &super::super::foundation::Uri) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStringForReference)(self as *const _ as *mut _, uri as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceLoaderStatics2, 213926209, 25702, 18825, 148, 148, 11, 130, 223, 197, 63, 31);
RT_INTERFACE!{static interface IResourceLoaderStatics2(IResourceLoaderStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceLoaderStatics2] {
    fn GetForCurrentView(&self, out: *mut *mut ResourceLoader) -> HRESULT,
    fn GetForCurrentViewWithName(&self, name: HSTRING, out: *mut *mut ResourceLoader) -> HRESULT,
    fn GetForViewIndependentUse(&self, out: *mut *mut ResourceLoader) -> HRESULT,
    fn GetForViewIndependentUseWithName(&self, name: HSTRING, out: *mut *mut ResourceLoader) -> HRESULT
}}
impl IResourceLoaderStatics2 {
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<ResourceLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_for_current_view_with_name(&self, name: &HStringArg) -> Result<ComPtr<ResourceLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentViewWithName)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_for_view_independent_use(&self) -> Result<ComPtr<ResourceLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForViewIndependentUse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_for_view_independent_use_with_name(&self, name: &HStringArg) -> Result<ComPtr<ResourceLoader>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForViewIndependentUseWithName)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
pub mod core { // Windows.ApplicationModel.Resources.Core
use ::prelude::*;
DEFINE_IID!(IID_INamedResource, 479773209, 2835, 16960, 137, 165, 212, 149, 220, 24, 154, 0);
RT_INTERFACE!{interface INamedResource(INamedResourceVtbl): IInspectable(IInspectableVtbl) [IID_INamedResource] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Candidates(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>) -> HRESULT,
    fn Resolve(&self, out: *mut *mut ResourceCandidate) -> HRESULT,
    fn ResolveForContext(&self, resourceContext: *mut ResourceContext, out: *mut *mut ResourceCandidate) -> HRESULT,
    fn ResolveAll(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>) -> HRESULT,
    fn ResolveAllForContext(&self, resourceContext: *mut ResourceContext, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>) -> HRESULT
}}
impl INamedResource {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_candidates(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Candidates)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn resolve(&self) -> Result<ComPtr<ResourceCandidate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Resolve)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn resolve_for_context(&self, resourceContext: &ResourceContext) -> Result<ComPtr<ResourceCandidate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ResolveForContext)(self as *const _ as *mut _, resourceContext as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn resolve_all(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ResolveAll)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn resolve_all_for_context(&self, resourceContext: &ResourceContext) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ResolveAllForContext)(self as *const _ as *mut _, resourceContext as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class NamedResource: INamedResource}
DEFINE_IID!(IID_IResourceCandidate, 2941388761, 50227, 18276, 179, 253, 143, 166, 191, 188, 186, 220);
RT_INTERFACE!{interface IResourceCandidate(IResourceCandidateVtbl): IInspectable(IInspectableVtbl) [IID_IResourceCandidate] {
    fn get_Qualifiers(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<ResourceQualifier>) -> HRESULT,
    fn get_IsMatch(&self, out: *mut bool) -> HRESULT,
    fn get_IsMatchAsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_IsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_ValueAsString(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetValueAsFileAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::StorageFile>) -> HRESULT,
    fn GetQualifierValue(&self, qualifierName: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IResourceCandidate {
    #[inline] pub unsafe fn get_qualifiers(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<ResourceQualifier>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Qualifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_match(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMatch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_match_as_default(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMatchAsDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_default(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value_as_string(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueAsString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_value_as_file_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::StorageFile>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValueAsFileAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_qualifier_value(&self, qualifierName: &HStringArg) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetQualifierValue)(self as *const _ as *mut _, qualifierName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceCandidate: IResourceCandidate}
DEFINE_IID!(IID_IResourceCandidate2, 1776661608, 63228, 16403, 170, 162, 213, 63, 23, 87, 211, 181);
RT_INTERFACE!{interface IResourceCandidate2(IResourceCandidate2Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceCandidate2] {
    #[cfg(feature="windows-storage")] fn GetValueAsStreamAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IRandomAccessStream>) -> HRESULT
}}
impl IResourceCandidate2 {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_value_as_stream_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IRandomAccessStream>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValueAsStreamAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceCandidateVectorView: ::rt::gen::windows::foundation::collections::IVectorView<ResourceCandidate>}
DEFINE_IID!(IID_IResourceContext, 799158091, 28798, 19239, 173, 13, 208, 216, 205, 70, 143, 210);
RT_INTERFACE!{interface IResourceContext(IResourceContextVtbl): IInspectable(IInspectableVtbl) [IID_IResourceContext] {
    fn get_QualifierValues(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IObservableMap<HString, HString>) -> HRESULT,
    fn Reset(&self) -> HRESULT,
    fn ResetQualifierValues(&self, qualifierNames: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>) -> HRESULT,
    fn OverrideToMatch(&self, result: *mut ::rt::gen::windows::foundation::collections::IIterable<ResourceQualifier>) -> HRESULT,
    fn Clone(&self, out: *mut *mut ResourceContext) -> HRESULT,
    fn get_Languages(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> HRESULT,
    fn put_Languages(&self, languages: *mut ::rt::gen::windows::foundation::collections::IVectorView<HString>) -> HRESULT
}}
impl IResourceContext {
    #[inline] pub unsafe fn get_qualifier_values(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IObservableMap<HString, HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QualifierValues)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Reset)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset_qualifier_values(&self, qualifierNames: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<()> {
        let hr = ((*self.lpVtbl).ResetQualifierValues)(self as *const _ as *mut _, qualifierNames as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn override_to_match(&self, result: &::rt::gen::windows::foundation::collections::IIterable<ResourceQualifier>) -> Result<()> {
        let hr = ((*self.lpVtbl).OverrideToMatch)(self as *const _ as *mut _, result as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn clone(&self) -> Result<ComPtr<ResourceContext>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).Clone)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_languages(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Languages)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_languages(&self, languages: &::rt::gen::windows::foundation::collections::IVectorView<HString>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Languages)(self as *const _ as *mut _, languages as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceContext: IResourceContext}
impl RtActivatable<IResourceContextStatics> for ResourceContext {}
impl RtActivatable<IResourceContextStatics2> for ResourceContext {}
impl RtActivatable<IResourceContextStatics3> for ResourceContext {}
impl RtActivatable<IActivationFactory> for ResourceContext {}
impl ResourceContext {
    #[inline] pub fn create_matching_context(result: &::rt::gen::windows::foundation::collections::IIterable<ResourceQualifier>) -> Result<ComPtr<ResourceContext>> { unsafe {
        <Self as RtActivatable<IResourceContextStatics>>::get_activation_factory().create_matching_context(result)
    }}
    #[inline] pub fn get_for_current_view() -> Result<ComPtr<ResourceContext>> { unsafe {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().get_for_current_view()
    }}
    #[inline] pub fn set_global_qualifier_value(key: &HStringArg, value: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().set_global_qualifier_value(key, value)
    }}
    #[inline] pub fn reset_global_qualifier_values() -> Result<()> { unsafe {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().reset_global_qualifier_values()
    }}
    #[inline] pub fn reset_global_qualifier_values_for_specified_qualifiers(qualifierNames: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<()> { unsafe {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().reset_global_qualifier_values_for_specified_qualifiers(qualifierNames)
    }}
    #[inline] pub fn get_for_view_independent_use() -> Result<ComPtr<ResourceContext>> { unsafe {
        <Self as RtActivatable<IResourceContextStatics2>>::get_activation_factory().get_for_view_independent_use()
    }}
    #[inline] pub fn set_global_qualifier_value_with_persistence(key: &HStringArg, value: &HStringArg, persistence: ResourceQualifierPersistence) -> Result<()> { unsafe {
        <Self as RtActivatable<IResourceContextStatics3>>::get_activation_factory().set_global_qualifier_value_with_persistence(key, value, persistence)
    }}
}
DEFINE_CLSID!(ResourceContext: "Windows.ApplicationModel.Resources.Core.ResourceContext");
RT_CLASS!{class ResourceContextLanguagesVectorView: ::rt::gen::windows::foundation::collections::IVectorView<HString>}
DEFINE_IID!(IID_IResourceContextStatics, 2562628972, 25400, 19249, 153, 223, 178, 180, 66, 241, 113, 73);
RT_INTERFACE!{static interface IResourceContextStatics(IResourceContextStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IResourceContextStatics] {
    fn CreateMatchingContext(&self, result: *mut ::rt::gen::windows::foundation::collections::IIterable<ResourceQualifier>, out: *mut *mut ResourceContext) -> HRESULT
}}
impl IResourceContextStatics {
    #[inline] pub unsafe fn create_matching_context(&self, result: &::rt::gen::windows::foundation::collections::IIterable<ResourceQualifier>) -> Result<ComPtr<ResourceContext>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateMatchingContext)(self as *const _ as *mut _, result as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceContextStatics2, 1106727663, 4783, 16825, 171, 54, 177, 235, 75, 81, 36, 96);
RT_INTERFACE!{static interface IResourceContextStatics2(IResourceContextStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceContextStatics2] {
    fn GetForCurrentView(&self, out: *mut *mut ResourceContext) -> HRESULT,
    fn SetGlobalQualifierValue(&self, key: HSTRING, value: HSTRING) -> HRESULT,
    fn ResetGlobalQualifierValues(&self) -> HRESULT,
    fn ResetGlobalQualifierValuesForSpecifiedQualifiers(&self, qualifierNames: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>) -> HRESULT,
    fn GetForViewIndependentUse(&self, out: *mut *mut ResourceContext) -> HRESULT
}}
impl IResourceContextStatics2 {
    #[inline] pub unsafe fn get_for_current_view(&self) -> Result<ComPtr<ResourceContext>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentView)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_global_qualifier_value(&self, key: &HStringArg, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetGlobalQualifierValue)(self as *const _ as *mut _, key.get(), value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset_global_qualifier_values(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).ResetGlobalQualifierValues)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn reset_global_qualifier_values_for_specified_qualifiers(&self, qualifierNames: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<()> {
        let hr = ((*self.lpVtbl).ResetGlobalQualifierValuesForSpecifiedQualifiers)(self as *const _ as *mut _, qualifierNames as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_for_view_independent_use(&self) -> Result<ComPtr<ResourceContext>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForViewIndependentUse)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceContextStatics3, 550455596, 44815, 17675, 157, 166, 16, 109, 208, 194, 154, 57);
RT_INTERFACE!{static interface IResourceContextStatics3(IResourceContextStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceContextStatics3] {
    fn SetGlobalQualifierValueWithPersistence(&self, key: HSTRING, value: HSTRING, persistence: ResourceQualifierPersistence) -> HRESULT
}}
impl IResourceContextStatics3 {
    #[inline] pub unsafe fn set_global_qualifier_value_with_persistence(&self, key: &HStringArg, value: &HStringArg, persistence: ResourceQualifierPersistence) -> Result<()> {
        let hr = ((*self.lpVtbl).SetGlobalQualifierValueWithPersistence)(self as *const _ as *mut _, key.get(), value.get(), persistence);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_STRUCT! { struct ResourceLayoutInfo {
    MajorVersion: u32, MinorVersion: u32, ResourceSubtreeCount: u32, NamedResourceCount: u32, Checksum: i32,
}}
DEFINE_IID!(IID_IResourceManager, 4148484475, 39304, 17659, 171, 214, 83, 120, 132, 76, 250, 139);
RT_INTERFACE!{interface IResourceManager(IResourceManagerVtbl): IInspectable(IInspectableVtbl) [IID_IResourceManager] {
    fn get_MainResourceMap(&self, out: *mut *mut ResourceMap) -> HRESULT,
    fn get_AllResourceMaps(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, ResourceMap>) -> HRESULT,
    fn get_DefaultContext(&self, out: *mut *mut ResourceContext) -> HRESULT,
    #[cfg(feature="windows-storage")] fn LoadPriFiles(&self, files: *mut ::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::storage::IStorageFile>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn UnloadPriFiles(&self, files: *mut ::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::storage::IStorageFile>) -> HRESULT
}}
impl IResourceManager {
    #[inline] pub unsafe fn get_main_resource_map(&self) -> Result<ComPtr<ResourceMap>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_MainResourceMap)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_all_resource_maps(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, ResourceMap>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AllResourceMaps)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_default_context(&self) -> Result<ComPtr<ResourceContext>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DefaultContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn load_pri_files(&self, files: &::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::storage::IStorageFile>) -> Result<()> {
        let hr = ((*self.lpVtbl).LoadPriFiles)(self as *const _ as *mut _, files as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn unload_pri_files(&self, files: &::rt::gen::windows::foundation::collections::IIterable<::rt::gen::windows::storage::IStorageFile>) -> Result<()> {
        let hr = ((*self.lpVtbl).UnloadPriFiles)(self as *const _ as *mut _, files as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceManager: IResourceManager}
impl RtActivatable<IResourceManagerStatics> for ResourceManager {}
impl ResourceManager {
    #[inline] pub fn get_current() -> Result<ComPtr<ResourceManager>> { unsafe {
        <Self as RtActivatable<IResourceManagerStatics>>::get_activation_factory().get_current()
    }}
    #[inline] pub fn is_resource_reference(resourceReference: &HStringArg) -> Result<bool> { unsafe {
        <Self as RtActivatable<IResourceManagerStatics>>::get_activation_factory().is_resource_reference(resourceReference)
    }}
}
DEFINE_CLSID!(ResourceManager: "Windows.ApplicationModel.Resources.Core.ResourceManager");
DEFINE_IID!(IID_IResourceManager2, 2640772716, 42199, 19491, 158, 133, 103, 95, 48, 76, 37, 45);
RT_INTERFACE!{interface IResourceManager2(IResourceManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceManager2] {
    fn GetAllNamedResourcesForPackage(&self, packageName: HSTRING, resourceLayoutInfo: ResourceLayoutInfo, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<NamedResource>) -> HRESULT,
    fn GetAllSubtreesForPackage(&self, packageName: HSTRING, resourceLayoutInfo: ResourceLayoutInfo, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<ResourceMap>) -> HRESULT
}}
impl IResourceManager2 {
    #[inline] pub unsafe fn get_all_named_resources_for_package(&self, packageName: &HStringArg, resourceLayoutInfo: ResourceLayoutInfo) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<NamedResource>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAllNamedResourcesForPackage)(self as *const _ as *mut _, packageName.get(), resourceLayoutInfo, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_all_subtrees_for_package(&self, packageName: &HStringArg, resourceLayoutInfo: ResourceLayoutInfo) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<ResourceMap>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAllSubtreesForPackage)(self as *const _ as *mut _, packageName.get(), resourceLayoutInfo, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceManagerStatics, 482409980, 27118, 20035, 153, 1, 71, 241, 38, 135, 186, 247);
RT_INTERFACE!{static interface IResourceManagerStatics(IResourceManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IResourceManagerStatics] {
    fn get_Current(&self, out: *mut *mut ResourceManager) -> HRESULT,
    fn IsResourceReference(&self, resourceReference: HSTRING, out: *mut bool) -> HRESULT
}}
impl IResourceManagerStatics {
    #[inline] pub unsafe fn get_current(&self) -> Result<ComPtr<ResourceManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Current)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_resource_reference(&self, resourceReference: &HStringArg) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsResourceReference)(self as *const _ as *mut _, resourceReference.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceMap, 1915242532, 56204, 17144, 176, 140, 83, 255, 53, 125, 173, 130);
RT_INTERFACE!{interface IResourceMap(IResourceMapVtbl): IInspectable(IInspectableVtbl) [IID_IResourceMap] {
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn GetValue(&self, resource: HSTRING, out: *mut *mut ResourceCandidate) -> HRESULT,
    fn GetValueForContext(&self, resource: HSTRING, context: *mut ResourceContext, out: *mut *mut ResourceCandidate) -> HRESULT,
    fn GetSubtree(&self, reference: HSTRING, out: *mut *mut ResourceMap) -> HRESULT
}}
impl IResourceMap {
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self, resource: &HStringArg) -> Result<ComPtr<ResourceCandidate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValue)(self as *const _ as *mut _, resource.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value_for_context(&self, resource: &HStringArg, context: &ResourceContext) -> Result<ComPtr<ResourceCandidate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetValueForContext)(self as *const _ as *mut _, resource.get(), context as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_subtree(&self, reference: &HStringArg) -> Result<ComPtr<ResourceMap>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSubtree)(self as *const _ as *mut _, reference.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceMap: IResourceMap}
RT_CLASS!{class ResourceMapIterator: ::rt::gen::windows::foundation::collections::IIterator<::rt::gen::windows::foundation::collections::IKeyValuePair<HString, NamedResource>>}
RT_CLASS!{class ResourceMapMapView: ::rt::gen::windows::foundation::collections::IMapView<HString, ResourceMap>}
RT_CLASS!{class ResourceMapMapViewIterator: ::rt::gen::windows::foundation::collections::IIterator<::rt::gen::windows::foundation::collections::IKeyValuePair<HString, ResourceMap>>}
DEFINE_IID!(IID_IResourceQualifier, 2019403186, 19197, 17270, 168, 136, 197, 249, 166, 183, 160, 92);
RT_INTERFACE!{interface IResourceQualifier(IResourceQualifierVtbl): IInspectable(IInspectableVtbl) [IID_IResourceQualifier] {
    fn get_QualifierName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_QualifierValue(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsDefault(&self, out: *mut bool) -> HRESULT,
    fn get_IsMatch(&self, out: *mut bool) -> HRESULT,
    fn get_Score(&self, out: *mut f64) -> HRESULT
}}
impl IResourceQualifier {
    #[inline] pub unsafe fn get_qualifier_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QualifierName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_qualifier_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QualifierValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_default(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDefault)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_match(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMatch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_score(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Score)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceQualifier: IResourceQualifier}
RT_CLASS!{class ResourceQualifierMapView: ::rt::gen::windows::foundation::collections::IMapView<HString, HString>}
RT_CLASS!{class ResourceQualifierObservableMap: ::rt::gen::windows::foundation::collections::IObservableMap<HString, HString>}
RT_ENUM! { enum ResourceQualifierPersistence: i32 {
    None (ResourceQualifierPersistence_None) = 0, LocalMachine (ResourceQualifierPersistence_LocalMachine) = 1,
}}
RT_CLASS!{class ResourceQualifierVectorView: ::rt::gen::windows::foundation::collections::IVectorView<ResourceQualifier>}
} // Windows.ApplicationModel.Resources.Core
pub mod management { // Windows.ApplicationModel.Resources.Management
use ::prelude::*;
DEFINE_IID!(IID_IIndexedResourceCandidate, 241278707, 64236, 17428, 169, 215, 84, 172, 213, 149, 63, 41);
RT_INTERFACE!{interface IIndexedResourceCandidate(IIndexedResourceCandidateVtbl): IInspectable(IInspectableVtbl) [IID_IIndexedResourceCandidate] {
    fn get_Type(&self, out: *mut IndexedResourceType) -> HRESULT,
    fn get_Uri(&self, out: *mut *mut ::rt::gen::windows::foundation::Uri) -> HRESULT,
    fn get_Metadata(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, HString>) -> HRESULT,
    fn get_Qualifiers(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<IndexedResourceQualifier>) -> HRESULT,
    fn get_ValueAsString(&self, out: *mut HSTRING) -> HRESULT,
    fn GetQualifierValue(&self, qualifierName: HSTRING, out: *mut HSTRING) -> HRESULT
}}
impl IIndexedResourceCandidate {
    #[inline] pub unsafe fn get_type(&self) -> Result<IndexedResourceType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Type)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_uri(&self) -> Result<ComPtr<::rt::gen::windows::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Uri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_metadata(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Metadata)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_qualifiers(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<IndexedResourceQualifier>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Qualifiers)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value_as_string(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ValueAsString)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_qualifier_value(&self, qualifierName: &HStringArg) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetQualifierValue)(self as *const _ as *mut _, qualifierName.get(), &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class IndexedResourceCandidate: IIndexedResourceCandidate}
DEFINE_IID!(IID_IIndexedResourceQualifier, 3672357787, 54020, 18815, 161, 104, 163, 64, 4, 44, 138, 219);
RT_INTERFACE!{interface IIndexedResourceQualifier(IIndexedResourceQualifierVtbl): IInspectable(IInspectableVtbl) [IID_IIndexedResourceQualifier] {
    fn get_QualifierName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_QualifierValue(&self, out: *mut HSTRING) -> HRESULT
}}
impl IIndexedResourceQualifier {
    #[inline] pub unsafe fn get_qualifier_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QualifierName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_qualifier_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_QualifierValue)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class IndexedResourceQualifier: IIndexedResourceQualifier}
RT_ENUM! { enum IndexedResourceType: i32 {
    String (IndexedResourceType_String) = 0, Path (IndexedResourceType_Path) = 1, EmbeddedData (IndexedResourceType_EmbeddedData) = 2,
}}
DEFINE_IID!(IID_IResourceIndexer, 760019365, 58159, 19122, 135, 72, 150, 53, 10, 1, 109, 163);
RT_INTERFACE!{interface IResourceIndexer(IResourceIndexerVtbl): IInspectable(IInspectableVtbl) [IID_IResourceIndexer] {
    fn IndexFilePath(&self, filePath: *mut ::rt::gen::windows::foundation::Uri, out: *mut *mut IndexedResourceCandidate) -> HRESULT,
    fn IndexFileContentsAsync(&self, file: *mut ::rt::gen::windows::foundation::Uri, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<IndexedResourceCandidate>>) -> HRESULT
}}
impl IResourceIndexer {
    #[inline] pub unsafe fn index_file_path(&self, filePath: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<IndexedResourceCandidate>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IndexFilePath)(self as *const _ as *mut _, filePath as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn index_file_contents_async(&self, file: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<IndexedResourceCandidate>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IndexFileContentsAsync)(self as *const _ as *mut _, file as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ResourceIndexer: IResourceIndexer}
impl RtActivatable<IResourceIndexerFactory> for ResourceIndexer {}
impl RtActivatable<IResourceIndexerFactory2> for ResourceIndexer {}
impl ResourceIndexer {
    #[inline] pub fn create_resource_indexer(projectRoot: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<ResourceIndexer>> { unsafe {
        <Self as RtActivatable<IResourceIndexerFactory>>::get_activation_factory().create_resource_indexer(projectRoot)
    }}
    #[inline] pub fn create_resource_indexer_with_extension(projectRoot: &::rt::gen::windows::foundation::Uri, extensionDllPath: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<ResourceIndexer>> { unsafe {
        <Self as RtActivatable<IResourceIndexerFactory2>>::get_activation_factory().create_resource_indexer_with_extension(projectRoot, extensionDllPath)
    }}
}
DEFINE_CLSID!(ResourceIndexer: "Windows.ApplicationModel.Resources.Management.ResourceIndexer");
DEFINE_IID!(IID_IResourceIndexerFactory, 3101572873, 12749, 19863, 189, 48, 141, 57, 247, 66, 188, 97);
RT_INTERFACE!{static interface IResourceIndexerFactory(IResourceIndexerFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IResourceIndexerFactory] {
    fn CreateResourceIndexer(&self, projectRoot: *mut ::rt::gen::windows::foundation::Uri, out: *mut *mut ResourceIndexer) -> HRESULT
}}
impl IResourceIndexerFactory {
    #[inline] pub unsafe fn create_resource_indexer(&self, projectRoot: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<ResourceIndexer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResourceIndexer)(self as *const _ as *mut _, projectRoot as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IResourceIndexerFactory2, 1614868877, 54757, 19296, 146, 1, 205, 39, 156, 188, 254, 217);
RT_INTERFACE!{static interface IResourceIndexerFactory2(IResourceIndexerFactory2Vtbl): IInspectable(IInspectableVtbl) [IID_IResourceIndexerFactory2] {
    fn CreateResourceIndexerWithExtension(&self, projectRoot: *mut ::rt::gen::windows::foundation::Uri, extensionDllPath: *mut ::rt::gen::windows::foundation::Uri, out: *mut *mut ResourceIndexer) -> HRESULT
}}
impl IResourceIndexerFactory2 {
    #[inline] pub unsafe fn create_resource_indexer_with_extension(&self, projectRoot: &::rt::gen::windows::foundation::Uri, extensionDllPath: &::rt::gen::windows::foundation::Uri) -> Result<ComPtr<ResourceIndexer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResourceIndexerWithExtension)(self as *const _ as *mut _, projectRoot as *const _ as *mut _, extensionDllPath as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.Resources.Management
} // Windows.ApplicationModel.Resources
pub mod store { // Windows.ApplicationModel.Store
use ::prelude::*;
DEFINE_IID!(IID_ICurrentApp, 3576545381, 55871, 18053, 153, 94, 155, 72, 46, 181, 230, 3);
RT_INTERFACE!{static interface ICurrentApp(ICurrentAppVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentApp] {
    fn get_LicenseInformation(&self, out: *mut *mut LicenseInformation) -> HRESULT,
    fn get_LinkUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn RequestAppPurchaseAsync(&self, includeReceipt: bool, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn RequestProductPurchaseAsync(&self, productId: HSTRING, includeReceipt: bool, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn LoadListingInformationAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ListingInformation>) -> HRESULT,
    fn GetAppReceiptAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetProductReceiptAsync(&self, productId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT
}}
impl ICurrentApp {
    #[inline] pub unsafe fn get_license_information(&self) -> Result<ComPtr<LicenseInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LicenseInformation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_link_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinkUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AppId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_app_purchase_async(&self, includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAppPurchaseAsync)(self as *const _ as *mut _, includeReceipt, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_product_purchase_async(&self, productId: &HStringArg, includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseAsync)(self as *const _ as *mut _, productId.get(), includeReceipt, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_listing_information_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadListingInformationAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_receipt_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppReceiptAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_product_receipt_async(&self, productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetProductReceiptAsync)(self as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{static class CurrentApp}
impl RtActivatable<ICurrentApp> for CurrentApp {}
impl RtActivatable<ICurrentApp2Statics> for CurrentApp {}
impl RtActivatable<ICurrentAppStaticsWithFiltering> for CurrentApp {}
impl RtActivatable<ICurrentAppWithCampaignId> for CurrentApp {}
impl RtActivatable<ICurrentAppWithConsumables> for CurrentApp {}
impl CurrentApp {
    #[inline] pub fn get_license_information() -> Result<ComPtr<LicenseInformation>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_license_information()
    }}
    #[inline] pub fn get_link_uri() -> Result<ComPtr<super::super::foundation::Uri>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_link_uri()
    }}
    #[inline] pub fn get_app_id() -> Result<Guid> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_app_id()
    }}
    #[inline] pub fn request_app_purchase_async(includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().request_app_purchase_async(includeReceipt)
    }}
    #[inline] pub fn request_product_purchase_async(productId: &HStringArg, includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().request_product_purchase_async(productId, includeReceipt)
    }}
    #[inline] pub fn load_listing_information_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().load_listing_information_async()
    }}
    #[inline] pub fn get_app_receipt_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_app_receipt_async()
    }}
    #[inline] pub fn get_product_receipt_async(productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentApp>>::get_activation_factory().get_product_receipt_async(productId)
    }}
    #[inline] pub fn get_customer_purchase_id_async(serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentApp2Statics>>::get_activation_factory().get_customer_purchase_id_async(serviceTicket, publisherUserId)
    }}
    #[inline] pub fn get_customer_collections_id_async(serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentApp2Statics>>::get_activation_factory().get_customer_collections_id_async(serviceTicket, publisherUserId)
    }}
    #[inline] pub fn load_listing_information_by_product_ids_async(productIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> { unsafe {
        <Self as RtActivatable<ICurrentAppStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_product_ids_async(productIds)
    }}
    #[inline] pub fn load_listing_information_by_keywords_async(keywords: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> { unsafe {
        <Self as RtActivatable<ICurrentAppStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_keywords_async(keywords)
    }}
    #[inline] pub fn report_product_fulfillment(productId: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<ICurrentAppStaticsWithFiltering>>::get_activation_factory().report_product_fulfillment(productId)
    }}
    #[inline] pub fn get_app_purchase_campaign_id_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentAppWithCampaignId>>::get_activation_factory().get_app_purchase_campaign_id_async()
    }}
    #[inline] pub fn report_consumable_fulfillment_async(productId: &HStringArg, transactionId: Guid) -> Result<ComPtr<super::super::foundation::IAsyncOperation<FulfillmentResult>>> { unsafe {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().report_consumable_fulfillment_async(productId, transactionId)
    }}
    #[inline] pub fn request_product_purchase_with_results_async(productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> { unsafe {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().request_product_purchase_with_results_async(productId)
    }}
    #[inline] pub fn request_product_purchase_with_display_properties_async(productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> { unsafe {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().request_product_purchase_with_display_properties_async(productId, offerId, displayProperties)
    }}
    #[inline] pub fn get_unfulfilled_consumables_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UnfulfilledConsumable>>>> { unsafe {
        <Self as RtActivatable<ICurrentAppWithConsumables>>::get_activation_factory().get_unfulfilled_consumables_async()
    }}
}
DEFINE_CLSID!(CurrentApp: "Windows.ApplicationModel.Store.CurrentApp");
DEFINE_IID!(IID_ICurrentApp2Statics, 3746459181, 12657, 19155, 134, 20, 44, 97, 36, 67, 115, 203);
RT_INTERFACE!{static interface ICurrentApp2Statics(ICurrentApp2StaticsVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentApp2Statics] {
    fn GetCustomerPurchaseIdAsync(&self, serviceTicket: HSTRING, publisherUserId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetCustomerCollectionsIdAsync(&self, serviceTicket: HSTRING, publisherUserId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT
}}
impl ICurrentApp2Statics {
    #[inline] pub unsafe fn get_customer_purchase_id_async(&self, serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCustomerPurchaseIdAsync)(self as *const _ as *mut _, serviceTicket.get(), publisherUserId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_customer_collections_id_async(&self, serviceTicket: &HStringArg, publisherUserId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCustomerCollectionsIdAsync)(self as *const _ as *mut _, serviceTicket.get(), publisherUserId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentAppSimulator, 4051672497, 29901, 18311, 151, 135, 25, 134, 110, 154, 85, 89);
RT_INTERFACE!{static interface ICurrentAppSimulator(ICurrentAppSimulatorVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppSimulator] {
    fn get_LicenseInformation(&self, out: *mut *mut LicenseInformation) -> HRESULT,
    fn get_LinkUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn get_AppId(&self, out: *mut Guid) -> HRESULT,
    fn RequestAppPurchaseAsync(&self, includeReceipt: bool, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn RequestProductPurchaseAsync(&self, productId: HSTRING, includeReceipt: bool, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn LoadListingInformationAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<ListingInformation>) -> HRESULT,
    fn GetAppReceiptAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    fn GetProductReceiptAsync(&self, productId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT,
    #[cfg(feature="windows-storage")] fn ReloadSimulatorAsync(&self, simulatorSettingsFile: *mut super::super::storage::StorageFile, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl ICurrentAppSimulator {
    #[inline] pub unsafe fn get_license_information(&self) -> Result<ComPtr<LicenseInformation>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LicenseInformation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_link_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LinkUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AppId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_app_purchase_async(&self, includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAppPurchaseAsync)(self as *const _ as *mut _, includeReceipt, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_product_purchase_async(&self, productId: &HStringArg, includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseAsync)(self as *const _ as *mut _, productId.get(), includeReceipt, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_listing_information_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadListingInformationAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_receipt_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppReceiptAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_product_receipt_async(&self, productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetProductReceiptAsync)(self as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn reload_simulator_async(&self, simulatorSettingsFile: &super::super::storage::StorageFile) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReloadSimulatorAsync)(self as *const _ as *mut _, simulatorSettingsFile as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{static class CurrentAppSimulator}
impl RtActivatable<ICurrentAppSimulator> for CurrentAppSimulator {}
impl RtActivatable<ICurrentAppSimulatorStaticsWithFiltering> for CurrentAppSimulator {}
impl RtActivatable<ICurrentAppSimulatorWithCampaignId> for CurrentAppSimulator {}
impl RtActivatable<ICurrentAppSimulatorWithConsumables> for CurrentAppSimulator {}
impl CurrentAppSimulator {
    #[inline] pub fn get_license_information() -> Result<ComPtr<LicenseInformation>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_license_information()
    }}
    #[inline] pub fn get_link_uri() -> Result<ComPtr<super::super::foundation::Uri>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_link_uri()
    }}
    #[inline] pub fn get_app_id() -> Result<Guid> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_app_id()
    }}
    #[inline] pub fn request_app_purchase_async(includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().request_app_purchase_async(includeReceipt)
    }}
    #[inline] pub fn request_product_purchase_async(productId: &HStringArg, includeReceipt: bool) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().request_product_purchase_async(productId, includeReceipt)
    }}
    #[inline] pub fn load_listing_information_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().load_listing_information_async()
    }}
    #[inline] pub fn get_app_receipt_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_app_receipt_async()
    }}
    #[inline] pub fn get_product_receipt_async(productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().get_product_receipt_async(productId)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn reload_simulator_async(simulatorSettingsFile: &super::super::storage::StorageFile) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulator>>::get_activation_factory().reload_simulator_async(simulatorSettingsFile)
    }}
    #[inline] pub fn load_listing_information_by_product_ids_async(productIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_product_ids_async(productIds)
    }}
    #[inline] pub fn load_listing_information_by_keywords_async(keywords: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorStaticsWithFiltering>>::get_activation_factory().load_listing_information_by_keywords_async(keywords)
    }}
    #[inline] pub fn get_app_purchase_campaign_id_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorWithCampaignId>>::get_activation_factory().get_app_purchase_campaign_id_async()
    }}
    #[inline] pub fn report_consumable_fulfillment_async(productId: &HStringArg, transactionId: Guid) -> Result<ComPtr<super::super::foundation::IAsyncOperation<FulfillmentResult>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().report_consumable_fulfillment_async(productId, transactionId)
    }}
    #[inline] pub fn request_product_purchase_with_results_async(productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().request_product_purchase_with_results_async(productId)
    }}
    #[inline] pub fn request_product_purchase_with_display_properties_async(productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().request_product_purchase_with_display_properties_async(productId, offerId, displayProperties)
    }}
    #[inline] pub fn get_unfulfilled_consumables_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UnfulfilledConsumable>>>> { unsafe {
        <Self as RtActivatable<ICurrentAppSimulatorWithConsumables>>::get_activation_factory().get_unfulfilled_consumables_async()
    }}
}
DEFINE_CLSID!(CurrentAppSimulator: "Windows.ApplicationModel.Store.CurrentAppSimulator");
DEFINE_IID!(IID_ICurrentAppSimulatorStaticsWithFiltering, 1635676386, 63599, 19284, 150, 102, 221, 226, 133, 9, 44, 104);
RT_INTERFACE!{static interface ICurrentAppSimulatorStaticsWithFiltering(ICurrentAppSimulatorStaticsWithFilteringVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppSimulatorStaticsWithFiltering] {
    fn LoadListingInformationByProductIdsAsync(&self, productIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<ListingInformation>) -> HRESULT,
    fn LoadListingInformationByKeywordsAsync(&self, keywords: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<ListingInformation>) -> HRESULT
}}
impl ICurrentAppSimulatorStaticsWithFiltering {
    #[inline] pub unsafe fn load_listing_information_by_product_ids_async(&self, productIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadListingInformationByProductIdsAsync)(self as *const _ as *mut _, productIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_listing_information_by_keywords_async(&self, keywords: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadListingInformationByKeywordsAsync)(self as *const _ as *mut _, keywords as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentAppSimulatorWithCampaignId, 2221378115, 57088, 18034, 164, 63, 178, 91, 20, 65, 207, 207);
RT_INTERFACE!{static interface ICurrentAppSimulatorWithCampaignId(ICurrentAppSimulatorWithCampaignIdVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppSimulatorWithCampaignId] {
    fn GetAppPurchaseCampaignIdAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT
}}
impl ICurrentAppSimulatorWithCampaignId {
    #[inline] pub unsafe fn get_app_purchase_campaign_id_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppPurchaseCampaignIdAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentAppSimulatorWithConsumables, 1313992875, 8423, 17426, 155, 133, 89, 187, 120, 56, 134, 103);
RT_INTERFACE!{static interface ICurrentAppSimulatorWithConsumables(ICurrentAppSimulatorWithConsumablesVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppSimulatorWithConsumables] {
    fn ReportConsumableFulfillmentAsync(&self, productId: HSTRING, transactionId: Guid, out: *mut *mut super::super::foundation::IAsyncOperation<FulfillmentResult>) -> HRESULT,
    fn RequestProductPurchaseWithResultsAsync(&self, productId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PurchaseResults>) -> HRESULT,
    fn RequestProductPurchaseWithDisplayPropertiesAsync(&self, productId: HSTRING, offerId: HSTRING, displayProperties: *mut ProductPurchaseDisplayProperties, out: *mut *mut super::super::foundation::IAsyncOperation<PurchaseResults>) -> HRESULT,
    fn GetUnfulfilledConsumablesAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UnfulfilledConsumable>>) -> HRESULT
}}
impl ICurrentAppSimulatorWithConsumables {
    #[inline] pub unsafe fn report_consumable_fulfillment_async(&self, productId: &HStringArg, transactionId: Guid) -> Result<ComPtr<super::super::foundation::IAsyncOperation<FulfillmentResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportConsumableFulfillmentAsync)(self as *const _ as *mut _, productId.get(), transactionId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_product_purchase_with_results_async(&self, productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseWithResultsAsync)(self as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_product_purchase_with_display_properties_async(&self, productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseWithDisplayPropertiesAsync)(self as *const _ as *mut _, productId.get(), offerId.get(), displayProperties as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unfulfilled_consumables_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UnfulfilledConsumable>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUnfulfilledConsumablesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentAppStaticsWithFiltering, 3547161922, 36997, 17294, 151, 186, 162, 92, 151, 107, 226, 253);
RT_INTERFACE!{static interface ICurrentAppStaticsWithFiltering(ICurrentAppStaticsWithFilteringVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppStaticsWithFiltering] {
    fn LoadListingInformationByProductIdsAsync(&self, productIds: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<ListingInformation>) -> HRESULT,
    fn LoadListingInformationByKeywordsAsync(&self, keywords: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncOperation<ListingInformation>) -> HRESULT,
    fn ReportProductFulfillment(&self, productId: HSTRING) -> HRESULT
}}
impl ICurrentAppStaticsWithFiltering {
    #[inline] pub unsafe fn load_listing_information_by_product_ids_async(&self, productIds: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadListingInformationByProductIdsAsync)(self as *const _ as *mut _, productIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_listing_information_by_keywords_async(&self, keywords: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncOperation<ListingInformation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadListingInformationByKeywordsAsync)(self as *const _ as *mut _, keywords as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_product_fulfillment(&self, productId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).ReportProductFulfillment)(self as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentAppWithCampaignId, 825183440, 14017, 17574, 179, 43, 67, 45, 96, 142, 77, 214);
RT_INTERFACE!{static interface ICurrentAppWithCampaignId(ICurrentAppWithCampaignIdVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppWithCampaignId] {
    fn GetAppPurchaseCampaignIdAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<HString>) -> HRESULT
}}
impl ICurrentAppWithCampaignId {
    #[inline] pub unsafe fn get_app_purchase_campaign_id_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetAppPurchaseCampaignIdAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ICurrentAppWithConsumables, 2219704433, 40527, 20345, 153, 90, 95, 145, 23, 46, 108, 239);
RT_INTERFACE!{static interface ICurrentAppWithConsumables(ICurrentAppWithConsumablesVtbl): IInspectable(IInspectableVtbl) [IID_ICurrentAppWithConsumables] {
    fn ReportConsumableFulfillmentAsync(&self, productId: HSTRING, transactionId: Guid, out: *mut *mut super::super::foundation::IAsyncOperation<FulfillmentResult>) -> HRESULT,
    fn RequestProductPurchaseWithResultsAsync(&self, productId: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<PurchaseResults>) -> HRESULT,
    fn RequestProductPurchaseWithDisplayPropertiesAsync(&self, productId: HSTRING, offerId: HSTRING, displayProperties: *mut ProductPurchaseDisplayProperties, out: *mut *mut super::super::foundation::IAsyncOperation<PurchaseResults>) -> HRESULT,
    fn GetUnfulfilledConsumablesAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UnfulfilledConsumable>>) -> HRESULT
}}
impl ICurrentAppWithConsumables {
    #[inline] pub unsafe fn report_consumable_fulfillment_async(&self, productId: &HStringArg, transactionId: Guid) -> Result<ComPtr<super::super::foundation::IAsyncOperation<FulfillmentResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportConsumableFulfillmentAsync)(self as *const _ as *mut _, productId.get(), transactionId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_product_purchase_with_results_async(&self, productId: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseWithResultsAsync)(self as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_product_purchase_with_display_properties_async(&self, productId: &HStringArg, offerId: &HStringArg, displayProperties: &ProductPurchaseDisplayProperties) -> Result<ComPtr<super::super::foundation::IAsyncOperation<PurchaseResults>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseWithDisplayPropertiesAsync)(self as *const _ as *mut _, productId.get(), offerId.get(), displayProperties as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_unfulfilled_consumables_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<UnfulfilledConsumable>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetUnfulfilledConsumablesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum FulfillmentResult: i32 {
    Succeeded (FulfillmentResult_Succeeded) = 0, NothingToFulfill (FulfillmentResult_NothingToFulfill) = 1, PurchasePending (FulfillmentResult_PurchasePending) = 2, PurchaseReverted (FulfillmentResult_PurchaseReverted) = 3, ServerError (FulfillmentResult_ServerError) = 4,
}}
DEFINE_IID!(IID_LicenseChangedEventHandler, 3567583829, 4969, 19510, 131, 47, 111, 45, 136, 227, 101, 155);
RT_DELEGATE!{delegate LicenseChangedEventHandler(LicenseChangedEventHandlerVtbl, LicenseChangedEventHandlerImpl) [IID_LicenseChangedEventHandler] {
    fn Invoke(&self) -> HRESULT
}}
impl LicenseChangedEventHandler {
    #[inline] pub unsafe fn invoke(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Invoke)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILicenseInformation, 2394414128, 61808, 20181, 142, 33, 21, 22, 218, 63, 211, 103);
RT_INTERFACE!{interface ILicenseInformation(ILicenseInformationVtbl): IInspectable(IInspectableVtbl) [IID_ILicenseInformation] {
    fn get_ProductLicenses(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, ProductLicense>) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_IsTrial(&self, out: *mut bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn add_LicenseChanged(&self, handler: *mut LicenseChangedEventHandler, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_LicenseChanged(&self, cookie: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl ILicenseInformation {
    #[inline] pub unsafe fn get_product_licenses(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, ProductLicense>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductLicenses)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_trial(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsTrial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_expiration_date(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExpirationDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_license_changed(&self, handler: &LicenseChangedEventHandler) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_LicenseChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_license_changed(&self, cookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_LicenseChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class LicenseInformation: ILicenseInformation}
DEFINE_IID!(IID_IListingInformation, 1485523647, 48244, 17283, 183, 140, 153, 96, 99, 35, 222, 206);
RT_INTERFACE!{interface IListingInformation(IListingInformationVtbl): IInspectable(IInspectableVtbl) [IID_IListingInformation] {
    fn get_CurrentMarket(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProductListings(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, ProductListing>) -> HRESULT,
    fn get_FormattedPrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn get_AgeRating(&self, out: *mut u32) -> HRESULT
}}
impl IListingInformation {
    #[inline] pub unsafe fn get_current_market(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrentMarket)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_product_listings(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, ProductListing>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductListings)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_formatted_price(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormattedPrice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_age_rating(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AgeRating)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ListingInformation: IListingInformation}
DEFINE_IID!(IID_IListingInformation2, 3237817373, 45838, 17284, 132, 234, 114, 254, 250, 130, 34, 62);
RT_INTERFACE!{interface IListingInformation2(IListingInformation2Vtbl): IInspectable(IInspectableVtbl) [IID_IListingInformation2] {
    fn get_FormattedBasePrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SaleEndDate(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_IsOnSale(&self, out: *mut bool) -> HRESULT,
    fn get_CurrencyCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IListingInformation2 {
    #[inline] pub unsafe fn get_formatted_base_price(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormattedBasePrice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sale_end_date(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SaleEndDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_on_sale(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOnSale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_currency_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrencyCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProductLicense, 909314247, 11215, 19470, 143, 47, 232, 8, 170, 168, 249, 157);
RT_INTERFACE!{interface IProductLicense(IProductLicenseVtbl): IInspectable(IInspectableVtbl) [IID_IProductLicense] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsActive(&self, out: *mut bool) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut super::super::foundation::DateTime) -> HRESULT
}}
impl IProductLicense {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_active(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsActive)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_expiration_date(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExpirationDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class ProductLicense: IProductLicense}
DEFINE_IID!(IID_IProductLicenseWithFulfillment, 4233321610, 63079, 16627, 186, 60, 4, 90, 99, 171, 179, 172);
RT_INTERFACE!{interface IProductLicenseWithFulfillment(IProductLicenseWithFulfillmentVtbl): IInspectable(IInspectableVtbl) [IID_IProductLicenseWithFulfillment] {
    fn get_IsConsumable(&self, out: *mut bool) -> HRESULT
}}
impl IProductLicenseWithFulfillment {
    #[inline] pub unsafe fn get_is_consumable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsConsumable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProductListing, 1168627373, 51024, 19868, 148, 124, 176, 13, 203, 249, 233, 194);
RT_INTERFACE!{interface IProductListing(IProductListingVtbl): IInspectable(IInspectableVtbl) [IID_IProductListing] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FormattedPrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT
}}
impl IProductListing {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_formatted_price(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormattedPrice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class ProductListing: IProductListing}
DEFINE_IID!(IID_IProductListing2, 4171114767, 29694, 18765, 169, 57, 8, 169, 178, 73, 90, 190);
RT_INTERFACE!{interface IProductListing2(IProductListing2Vtbl): IInspectable(IInspectableVtbl) [IID_IProductListing2] {
    fn get_FormattedBasePrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SaleEndDate(&self, out: *mut super::super::foundation::DateTime) -> HRESULT,
    fn get_IsOnSale(&self, out: *mut bool) -> HRESULT,
    fn get_CurrencyCode(&self, out: *mut HSTRING) -> HRESULT
}}
impl IProductListing2 {
    #[inline] pub unsafe fn get_formatted_base_price(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormattedBasePrice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sale_end_date(&self) -> Result<super::super::foundation::DateTime> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SaleEndDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_on_sale(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsOnSale)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_currency_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrencyCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProductListingWithConsumables, 3953039248, 36715, 18463, 147, 167, 92, 58, 99, 6, 129, 73);
RT_INTERFACE!{interface IProductListingWithConsumables(IProductListingWithConsumablesVtbl): IInspectable(IInspectableVtbl) [IID_IProductListingWithConsumables] {
    fn get_ProductType(&self, out: *mut ProductType) -> HRESULT
}}
impl IProductListingWithConsumables {
    #[inline] pub unsafe fn get_product_type(&self) -> Result<ProductType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProductType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProductListingWithMetadata, 307078503, 9208, 16958, 149, 50, 24, 153, 67, 196, 10, 206);
RT_INTERFACE!{interface IProductListingWithMetadata(IProductListingWithMetadataVtbl): IInspectable(IInspectableVtbl) [IID_IProductListingWithMetadata] {
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Keywords(&self, out: *mut *mut super::super::foundation::collections::IIterable<HString>) -> HRESULT,
    fn get_ProductType(&self, out: *mut ProductType) -> HRESULT,
    fn get_Tag(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ImageUri(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT
}}
impl IProductListingWithMetadata {
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_keywords(&self) -> Result<ComPtr<super::super::foundation::collections::IIterable<HString>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Keywords)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_product_type(&self) -> Result<ProductType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProductType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_tag(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Tag)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_image_uri(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ImageUri)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IProductPurchaseDisplayProperties, 3607852064, 48274, 16411, 168, 9, 201, 178, 229, 219, 189, 175);
RT_INTERFACE!{interface IProductPurchaseDisplayProperties(IProductPurchaseDisplayPropertiesVtbl): IInspectable(IInspectableVtbl) [IID_IProductPurchaseDisplayProperties] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_Image(&self, out: *mut *mut super::super::foundation::Uri) -> HRESULT,
    fn put_Image(&self, value: *mut super::super::foundation::Uri) -> HRESULT
}}
impl IProductPurchaseDisplayProperties {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_image(&self) -> Result<ComPtr<super::super::foundation::Uri>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Image)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_image(&self, value: &super::super::foundation::Uri) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Image)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class ProductPurchaseDisplayProperties: IProductPurchaseDisplayProperties}
impl RtActivatable<IProductPurchaseDisplayPropertiesFactory> for ProductPurchaseDisplayProperties {}
impl RtActivatable<IActivationFactory> for ProductPurchaseDisplayProperties {}
impl ProductPurchaseDisplayProperties {
    #[inline] pub fn create_product_purchase_display_properties(name: &HStringArg) -> Result<ComPtr<ProductPurchaseDisplayProperties>> { unsafe {
        <Self as RtActivatable<IProductPurchaseDisplayPropertiesFactory>>::get_activation_factory().create_product_purchase_display_properties(name)
    }}
}
DEFINE_CLSID!(ProductPurchaseDisplayProperties: "Windows.ApplicationModel.Store.ProductPurchaseDisplayProperties");
DEFINE_IID!(IID_IProductPurchaseDisplayPropertiesFactory, 1867062772, 13014, 19264, 180, 116, 184, 48, 56, 164, 217, 207);
RT_INTERFACE!{static interface IProductPurchaseDisplayPropertiesFactory(IProductPurchaseDisplayPropertiesFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IProductPurchaseDisplayPropertiesFactory] {
    fn CreateProductPurchaseDisplayProperties(&self, name: HSTRING, out: *mut *mut ProductPurchaseDisplayProperties) -> HRESULT
}}
impl IProductPurchaseDisplayPropertiesFactory {
    #[inline] pub unsafe fn create_product_purchase_display_properties(&self, name: &HStringArg) -> Result<ComPtr<ProductPurchaseDisplayProperties>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateProductPurchaseDisplayProperties)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum ProductPurchaseStatus: i32 {
    Succeeded (ProductPurchaseStatus_Succeeded) = 0, AlreadyPurchased (ProductPurchaseStatus_AlreadyPurchased) = 1, NotFulfilled (ProductPurchaseStatus_NotFulfilled) = 2, NotPurchased (ProductPurchaseStatus_NotPurchased) = 3,
}}
RT_ENUM! { enum ProductType: i32 {
    Unknown (ProductType_Unknown) = 0, Durable (ProductType_Durable) = 1, Consumable (ProductType_Consumable) = 2,
}}
DEFINE_IID!(IID_IPurchaseResults, 3981489022, 34390, 20325, 184, 200, 172, 126, 12, 177, 161, 194);
RT_INTERFACE!{interface IPurchaseResults(IPurchaseResultsVtbl): IInspectable(IInspectableVtbl) [IID_IPurchaseResults] {
    fn get_Status(&self, out: *mut ProductPurchaseStatus) -> HRESULT,
    fn get_TransactionId(&self, out: *mut Guid) -> HRESULT,
    fn get_ReceiptXml(&self, out: *mut HSTRING) -> HRESULT,
    fn get_OfferId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IPurchaseResults {
    #[inline] pub unsafe fn get_status(&self) -> Result<ProductPurchaseStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transaction_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransactionId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_receipt_xml(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ReceiptXml)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offer_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OfferId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class PurchaseResults: IPurchaseResults}
DEFINE_IID!(IID_IUnfulfilledConsumable, 771226555, 7389, 19640, 160, 20, 123, 156, 248, 152, 105, 39);
RT_INTERFACE!{interface IUnfulfilledConsumable(IUnfulfilledConsumableVtbl): IInspectable(IInspectableVtbl) [IID_IUnfulfilledConsumable] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_TransactionId(&self, out: *mut Guid) -> HRESULT,
    fn get_OfferId(&self, out: *mut HSTRING) -> HRESULT
}}
impl IUnfulfilledConsumable {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transaction_id(&self) -> Result<Guid> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_TransactionId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_offer_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_OfferId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class UnfulfilledConsumable: IUnfulfilledConsumable}
pub mod preview { // Windows.ApplicationModel.Store.Preview
use ::prelude::*;
RT_CLASS!{static class StoreConfiguration}
impl RtActivatable<IStoreConfigurationStatics> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics2> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics3> for StoreConfiguration {}
impl RtActivatable<IStoreConfigurationStatics4> for StoreConfiguration {}
impl StoreConfiguration {
    #[inline] pub fn set_system_configuration(catalogHardwareManufacturerId: &HStringArg, catalogStoreContentModifierId: &HStringArg, systemConfigurationExpiration: ::rt::gen::windows::foundation::DateTime, catalogHardwareDescriptor: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().set_system_configuration(catalogHardwareManufacturerId, catalogStoreContentModifierId, systemConfigurationExpiration, catalogHardwareDescriptor)
    }}
    #[inline] pub fn set_mobile_operator_configuration(mobileOperatorId: &HStringArg, appDownloadLimitInMegabytes: u32, updateDownloadLimitInMegabytes: u32) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().set_mobile_operator_configuration(mobileOperatorId, appDownloadLimitInMegabytes, updateDownloadLimitInMegabytes)
    }}
    #[inline] pub fn set_store_web_account_id(webAccountId: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().set_store_web_account_id(webAccountId)
    }}
    #[inline] pub fn is_store_web_account_id(webAccountId: &HStringArg) -> Result<bool> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().is_store_web_account_id(webAccountId)
    }}
    #[inline] pub fn get_hardware_manufacturer_info() -> Result<ComPtr<StoreHardwareManufacturerInfo>> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().get_hardware_manufacturer_info()
    }}
    #[inline] pub fn filter_unsupported_system_features_async(systemFeatures: &::rt::gen::windows::foundation::collections::IIterable<StoreSystemFeature>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<StoreSystemFeature>>>> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics>>::get_activation_factory().filter_unsupported_system_features_async(systemFeatures)
    }}
    #[inline] pub fn get_purchase_prompting_policy() -> Result<ComPtr<::rt::gen::windows::foundation::IReference<u32>>> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics2>>::get_activation_factory().get_purchase_prompting_policy()
    }}
    #[inline] pub fn set_purchase_prompting_policy(value: &::rt::gen::windows::foundation::IReference<u32>) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics2>>::get_activation_factory().set_purchase_prompting_policy(value)
    }}
    #[inline] pub fn has_store_web_account() -> Result<bool> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().has_store_web_account()
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn has_store_web_account_for_user(user: &::rt::gen::windows::system::User) -> Result<bool> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().has_store_web_account_for_user(user)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn get_store_log_data_async(options: StoreLogOptions) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>>> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().get_store_log_data_async(options)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_store_web_account_id_for_user(user: &::rt::gen::windows::system::User, webAccountId: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().set_store_web_account_id_for_user(user, webAccountId)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn is_store_web_account_id_for_user(user: &::rt::gen::windows::system::User, webAccountId: &HStringArg) -> Result<bool> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().is_store_web_account_id_for_user(user, webAccountId)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_purchase_prompting_policy_for_user(user: &::rt::gen::windows::system::User) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<u32>>> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().get_purchase_prompting_policy_for_user(user)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_purchase_prompting_policy_for_user(user: &::rt::gen::windows::system::User, value: &::rt::gen::windows::foundation::IReference<u32>) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics3>>::get_activation_factory().set_purchase_prompting_policy_for_user(user, value)
    }}
    #[inline] pub fn get_store_web_account_id() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_store_web_account_id()
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_store_web_account_id_for_user(user: &::rt::gen::windows::system::User) -> Result<HString> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_store_web_account_id_for_user(user)
    }}
    #[inline] pub fn set_enterprise_store_web_account_id(webAccountId: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().set_enterprise_store_web_account_id(webAccountId)
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn set_enterprise_store_web_account_id_for_user(user: &::rt::gen::windows::system::User, webAccountId: &HStringArg) -> Result<()> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().set_enterprise_store_web_account_id_for_user(user, webAccountId)
    }}
    #[inline] pub fn get_enterprise_store_web_account_id() -> Result<HString> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_enterprise_store_web_account_id()
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn get_enterprise_store_web_account_id_for_user(user: &::rt::gen::windows::system::User) -> Result<HString> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().get_enterprise_store_web_account_id_for_user(user)
    }}
    #[inline] pub fn should_restrict_to_enterprise_store_only() -> Result<bool> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().should_restrict_to_enterprise_store_only()
    }}
    #[cfg(feature="windows-system")] #[inline] pub fn should_restrict_to_enterprise_store_only_for_user(user: &::rt::gen::windows::system::User) -> Result<bool> { unsafe {
        <Self as RtActivatable<IStoreConfigurationStatics4>>::get_activation_factory().should_restrict_to_enterprise_store_only_for_user(user)
    }}
}
DEFINE_CLSID!(StoreConfiguration: "Windows.ApplicationModel.Store.Preview.StoreConfiguration");
DEFINE_IID!(IID_IStoreConfigurationStatics, 1922006976, 34344, 17132, 132, 162, 7, 120, 14, 180, 77, 139);
RT_INTERFACE!{static interface IStoreConfigurationStatics(IStoreConfigurationStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IStoreConfigurationStatics] {
    fn SetSystemConfiguration(&self, catalogHardwareManufacturerId: HSTRING, catalogStoreContentModifierId: HSTRING, systemConfigurationExpiration: ::rt::gen::windows::foundation::DateTime, catalogHardwareDescriptor: HSTRING) -> HRESULT,
    fn SetMobileOperatorConfiguration(&self, mobileOperatorId: HSTRING, appDownloadLimitInMegabytes: u32, updateDownloadLimitInMegabytes: u32) -> HRESULT,
    fn SetStoreWebAccountId(&self, webAccountId: HSTRING) -> HRESULT,
    fn IsStoreWebAccountId(&self, webAccountId: HSTRING, out: *mut bool) -> HRESULT,
    fn get_HardwareManufacturerInfo(&self, out: *mut *mut StoreHardwareManufacturerInfo) -> HRESULT,
    fn FilterUnsupportedSystemFeaturesAsync(&self, systemFeatures: *mut ::rt::gen::windows::foundation::collections::IIterable<StoreSystemFeature>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<StoreSystemFeature>>) -> HRESULT
}}
impl IStoreConfigurationStatics {
    #[inline] pub unsafe fn set_system_configuration(&self, catalogHardwareManufacturerId: &HStringArg, catalogStoreContentModifierId: &HStringArg, systemConfigurationExpiration: ::rt::gen::windows::foundation::DateTime, catalogHardwareDescriptor: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetSystemConfiguration)(self as *const _ as *mut _, catalogHardwareManufacturerId.get(), catalogStoreContentModifierId.get(), systemConfigurationExpiration, catalogHardwareDescriptor.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_mobile_operator_configuration(&self, mobileOperatorId: &HStringArg, appDownloadLimitInMegabytes: u32, updateDownloadLimitInMegabytes: u32) -> Result<()> {
        let hr = ((*self.lpVtbl).SetMobileOperatorConfiguration)(self as *const _ as *mut _, mobileOperatorId.get(), appDownloadLimitInMegabytes, updateDownloadLimitInMegabytes);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_store_web_account_id(&self, webAccountId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStoreWebAccountId)(self as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_store_web_account_id(&self, webAccountId: &HStringArg) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsStoreWebAccountId)(self as *const _ as *mut _, webAccountId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_hardware_manufacturer_info(&self) -> Result<ComPtr<StoreHardwareManufacturerInfo>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HardwareManufacturerInfo)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn filter_unsupported_system_features_async(&self, systemFeatures: &::rt::gen::windows::foundation::collections::IIterable<StoreSystemFeature>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<StoreSystemFeature>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FilterUnsupportedSystemFeaturesAsync)(self as *const _ as *mut _, systemFeatures as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStoreConfigurationStatics2, 1702643093, 51383, 20457, 159, 76, 77, 113, 2, 125, 52, 126);
RT_INTERFACE!{static interface IStoreConfigurationStatics2(IStoreConfigurationStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_IStoreConfigurationStatics2] {
    fn get_PurchasePromptingPolicy(&self, out: *mut *mut ::rt::gen::windows::foundation::IReference<u32>) -> HRESULT,
    fn put_PurchasePromptingPolicy(&self, value: *mut ::rt::gen::windows::foundation::IReference<u32>) -> HRESULT
}}
impl IStoreConfigurationStatics2 {
    #[inline] pub unsafe fn get_purchase_prompting_policy(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PurchasePromptingPolicy)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_purchase_prompting_policy(&self, value: &::rt::gen::windows::foundation::IReference<u32>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PurchasePromptingPolicy)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStoreConfigurationStatics3, 1833301372, 61764, 19637, 157, 63, 78, 176, 94, 48, 182, 211);
RT_INTERFACE!{static interface IStoreConfigurationStatics3(IStoreConfigurationStatics3Vtbl): IInspectable(IInspectableVtbl) [IID_IStoreConfigurationStatics3] {
    fn HasStoreWebAccount(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-system")] fn HasStoreWebAccountForUser(&self, user: *mut ::rt::gen::windows::system::User, out: *mut bool) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetStoreLogDataAsync(&self, options: StoreLogOptions, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>) -> HRESULT,
    #[cfg(feature="windows-system")] fn SetStoreWebAccountIdForUser(&self, user: *mut ::rt::gen::windows::system::User, webAccountId: HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn IsStoreWebAccountIdForUser(&self, user: *mut ::rt::gen::windows::system::User, webAccountId: HSTRING, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetPurchasePromptingPolicyForUser(&self, user: *mut ::rt::gen::windows::system::User, out: *mut *mut ::rt::gen::windows::foundation::IReference<u32>) -> HRESULT,
    #[cfg(feature="windows-system")] fn SetPurchasePromptingPolicyForUser(&self, user: *mut ::rt::gen::windows::system::User, value: *mut ::rt::gen::windows::foundation::IReference<u32>) -> HRESULT
}}
impl IStoreConfigurationStatics3 {
    #[inline] pub unsafe fn has_store_web_account(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HasStoreWebAccount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn has_store_web_account_for_user(&self, user: &::rt::gen::windows::system::User) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).HasStoreWebAccountForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_store_log_data_async(&self, options: StoreLogOptions) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::storage::streams::IRandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStoreLogDataAsync)(self as *const _ as *mut _, options, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn set_store_web_account_id_for_user(&self, user: &::rt::gen::windows::system::User, webAccountId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetStoreWebAccountIdForUser)(self as *const _ as *mut _, user as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn is_store_web_account_id_for_user(&self, user: &::rt::gen::windows::system::User, webAccountId: &HStringArg) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsStoreWebAccountIdForUser)(self as *const _ as *mut _, user as *const _ as *mut _, webAccountId.get(), &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_purchase_prompting_policy_for_user(&self, user: &::rt::gen::windows::system::User) -> Result<ComPtr<::rt::gen::windows::foundation::IReference<u32>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetPurchasePromptingPolicyForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn set_purchase_prompting_policy_for_user(&self, user: &::rt::gen::windows::system::User, value: &::rt::gen::windows::foundation::IReference<u32>) -> Result<()> {
        let hr = ((*self.lpVtbl).SetPurchasePromptingPolicyForUser)(self as *const _ as *mut _, user as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStoreConfigurationStatics4, 553604818, 20195, 19696, 155, 18, 85, 44, 3, 49, 15, 117);
RT_INTERFACE!{static interface IStoreConfigurationStatics4(IStoreConfigurationStatics4Vtbl): IInspectable(IInspectableVtbl) [IID_IStoreConfigurationStatics4] {
    fn GetStoreWebAccountId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetStoreWebAccountIdForUser(&self, user: *mut ::rt::gen::windows::system::User, out: *mut HSTRING) -> HRESULT,
    fn SetEnterpriseStoreWebAccountId(&self, webAccountId: HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn SetEnterpriseStoreWebAccountIdForUser(&self, user: *mut ::rt::gen::windows::system::User, webAccountId: HSTRING) -> HRESULT,
    fn GetEnterpriseStoreWebAccountId(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-system")] fn GetEnterpriseStoreWebAccountIdForUser(&self, user: *mut ::rt::gen::windows::system::User, out: *mut HSTRING) -> HRESULT,
    fn ShouldRestrictToEnterpriseStoreOnly(&self, out: *mut bool) -> HRESULT,
    #[cfg(feature="windows-system")] fn ShouldRestrictToEnterpriseStoreOnlyForUser(&self, user: *mut ::rt::gen::windows::system::User, out: *mut bool) -> HRESULT
}}
impl IStoreConfigurationStatics4 {
    #[inline] pub unsafe fn get_store_web_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStoreWebAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_store_web_account_id_for_user(&self, user: &::rt::gen::windows::system::User) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetStoreWebAccountIdForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_enterprise_store_web_account_id(&self, webAccountId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetEnterpriseStoreWebAccountId)(self as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn set_enterprise_store_web_account_id_for_user(&self, user: &::rt::gen::windows::system::User, webAccountId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).SetEnterpriseStoreWebAccountIdForUser)(self as *const _ as *mut _, user as *const _ as *mut _, webAccountId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_enterprise_store_web_account_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEnterpriseStoreWebAccountId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_enterprise_store_web_account_id_for_user(&self, user: &::rt::gen::windows::system::User) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetEnterpriseStoreWebAccountIdForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn should_restrict_to_enterprise_store_only(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ShouldRestrictToEnterpriseStoreOnly)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn should_restrict_to_enterprise_store_only_for_user(&self, user: &::rt::gen::windows::system::User) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).ShouldRestrictToEnterpriseStoreOnlyForUser)(self as *const _ as *mut _, user as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IStoreHardwareManufacturerInfo, 4069710856, 50772, 17324, 162, 31, 52, 128, 28, 157, 51, 136);
RT_INTERFACE!{interface IStoreHardwareManufacturerInfo(IStoreHardwareManufacturerInfoVtbl): IInspectable(IInspectableVtbl) [IID_IStoreHardwareManufacturerInfo] {
    fn get_HardwareManufacturerId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_StoreContentModifierId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ModelName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ManufacturerName(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStoreHardwareManufacturerInfo {
    #[inline] pub unsafe fn get_hardware_manufacturer_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HardwareManufacturerId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_store_content_modifier_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_StoreContentModifierId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_model_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ModelName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_manufacturer_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ManufacturerName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StoreHardwareManufacturerInfo: IStoreHardwareManufacturerInfo}
RT_ENUM! { enum StoreLogOptions: u32 {
    None (StoreLogOptions_None) = 0, TryElevate (StoreLogOptions_TryElevate) = 1,
}}
DEFINE_IID!(IID_IStorePreview, 2316661313, 33806, 18857, 188, 1, 93, 91, 1, 251, 200, 233);
RT_INTERFACE!{static interface IStorePreview(IStorePreviewVtbl): IInspectable(IInspectableVtbl) [IID_IStorePreview] {
    fn RequestProductPurchaseByProductIdAndSkuIdAsync(&self, productId: HSTRING, skuId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<StorePreviewPurchaseResults>) -> HRESULT,
    fn LoadAddOnProductInfosAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<StorePreviewProductInfo>>) -> HRESULT
}}
impl IStorePreview {
    #[inline] pub unsafe fn request_product_purchase_by_product_id_and_sku_id_async(&self, productId: &HStringArg, skuId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<StorePreviewPurchaseResults>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestProductPurchaseByProductIdAndSkuIdAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn load_add_on_product_infos_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<StorePreviewProductInfo>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LoadAddOnProductInfosAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{static class StorePreview}
impl RtActivatable<IStorePreview> for StorePreview {}
impl StorePreview {
    #[inline] pub fn request_product_purchase_by_product_id_and_sku_id_async(productId: &HStringArg, skuId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<StorePreviewPurchaseResults>>> { unsafe {
        <Self as RtActivatable<IStorePreview>>::get_activation_factory().request_product_purchase_by_product_id_and_sku_id_async(productId, skuId)
    }}
    #[inline] pub fn load_add_on_product_infos_async() -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<StorePreviewProductInfo>>>> { unsafe {
        <Self as RtActivatable<IStorePreview>>::get_activation_factory().load_add_on_product_infos_async()
    }}
}
DEFINE_CLSID!(StorePreview: "Windows.ApplicationModel.Store.Preview.StorePreview");
DEFINE_IID!(IID_IStorePreviewProductInfo, 423091123, 27649, 19613, 133, 205, 91, 171, 170, 194, 179, 81);
RT_INTERFACE!{interface IStorePreviewProductInfo(IStorePreviewProductInfoVtbl): IInspectable(IInspectableVtbl) [IID_IStorePreviewProductInfo] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ProductType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SkuInfoList(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<StorePreviewSkuInfo>) -> HRESULT
}}
impl IStorePreviewProductInfo {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_product_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sku_info_list(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<StorePreviewSkuInfo>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SkuInfoList)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StorePreviewProductInfo: IStorePreviewProductInfo}
RT_ENUM! { enum StorePreviewProductPurchaseStatus: i32 {
    Succeeded (StorePreviewProductPurchaseStatus_Succeeded) = 0, AlreadyPurchased (StorePreviewProductPurchaseStatus_AlreadyPurchased) = 1, NotFulfilled (StorePreviewProductPurchaseStatus_NotFulfilled) = 2, NotPurchased (StorePreviewProductPurchaseStatus_NotPurchased) = 3,
}}
DEFINE_IID!(IID_IStorePreviewPurchaseResults, 2967121617, 54981, 20051, 160, 67, 251, 160, 216, 230, 18, 49);
RT_INTERFACE!{interface IStorePreviewPurchaseResults(IStorePreviewPurchaseResultsVtbl): IInspectable(IInspectableVtbl) [IID_IStorePreviewPurchaseResults] {
    fn get_ProductPurchaseStatus(&self, out: *mut StorePreviewProductPurchaseStatus) -> HRESULT
}}
impl IStorePreviewPurchaseResults {
    #[inline] pub unsafe fn get_product_purchase_status(&self) -> Result<StorePreviewProductPurchaseStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ProductPurchaseStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class StorePreviewPurchaseResults: IStorePreviewPurchaseResults}
DEFINE_IID!(IID_IStorePreviewSkuInfo, 2180871906, 2854, 18649, 152, 206, 39, 70, 28, 102, 157, 108);
RT_INTERFACE!{interface IStorePreviewSkuInfo(IStorePreviewSkuInfoVtbl): IInspectable(IInspectableVtbl) [IID_IStorePreviewSkuInfo] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SkuId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_SkuType(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CustomDeveloperData(&self, out: *mut HSTRING) -> HRESULT,
    fn get_CurrencyCode(&self, out: *mut HSTRING) -> HRESULT,
    fn get_FormattedListPrice(&self, out: *mut HSTRING) -> HRESULT,
    fn get_ExtendedData(&self, out: *mut HSTRING) -> HRESULT
}}
impl IStorePreviewSkuInfo {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sku_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SkuId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_sku_type(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SkuType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_custom_developer_data(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CustomDeveloperData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_currency_code(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CurrencyCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_formatted_list_price(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_FormattedListPrice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extended_data(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExtendedData)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class StorePreviewSkuInfo: IStorePreviewSkuInfo}
RT_ENUM! { enum StoreSystemFeature: i32 {
    ArchitectureX86 (StoreSystemFeature_ArchitectureX86) = 0, ArchitectureX64 (StoreSystemFeature_ArchitectureX64) = 1, ArchitectureArm (StoreSystemFeature_ArchitectureArm) = 2, DirectX9 (StoreSystemFeature_DirectX9) = 3, DirectX10 (StoreSystemFeature_DirectX10) = 4, DirectX11 (StoreSystemFeature_DirectX11) = 5, D3D12HardwareFL11 (StoreSystemFeature_D3D12HardwareFL11) = 6, D3D12HardwareFL12 (StoreSystemFeature_D3D12HardwareFL12) = 7, Memory300MB (StoreSystemFeature_Memory300MB) = 8, Memory750MB (StoreSystemFeature_Memory750MB) = 9, Memory1GB (StoreSystemFeature_Memory1GB) = 10, Memory2GB (StoreSystemFeature_Memory2GB) = 11, CameraFront (StoreSystemFeature_CameraFront) = 12, CameraRear (StoreSystemFeature_CameraRear) = 13, Gyroscope (StoreSystemFeature_Gyroscope) = 14, Hover (StoreSystemFeature_Hover) = 15, Magnetometer (StoreSystemFeature_Magnetometer) = 16, Nfc (StoreSystemFeature_Nfc) = 17, Resolution720P (StoreSystemFeature_Resolution720P) = 18, ResolutionWvga (StoreSystemFeature_ResolutionWvga) = 19, ResolutionWvgaOr720P (StoreSystemFeature_ResolutionWvgaOr720P) = 20, ResolutionWxga (StoreSystemFeature_ResolutionWxga) = 21, ResolutionWvgaOrWxga (StoreSystemFeature_ResolutionWvgaOrWxga) = 22, ResolutionWxgaOr720P (StoreSystemFeature_ResolutionWxgaOr720P) = 23, Memory4GB (StoreSystemFeature_Memory4GB) = 24, Memory6GB (StoreSystemFeature_Memory6GB) = 25, Memory8GB (StoreSystemFeature_Memory8GB) = 26, Memory12GB (StoreSystemFeature_Memory12GB) = 27, Memory16GB (StoreSystemFeature_Memory16GB) = 28, Memory20GB (StoreSystemFeature_Memory20GB) = 29, VideoMemory2GB (StoreSystemFeature_VideoMemory2GB) = 30, VideoMemory4GB (StoreSystemFeature_VideoMemory4GB) = 31, VideoMemory6GB (StoreSystemFeature_VideoMemory6GB) = 32, VideoMemory1GB (StoreSystemFeature_VideoMemory1GB) = 33,
}}
DEFINE_IID!(IID_IWebAuthenticationCoreManagerHelper, 111478053, 59157, 16675, 146, 118, 157, 111, 134, 91, 165, 95);
RT_INTERFACE!{static interface IWebAuthenticationCoreManagerHelper(IWebAuthenticationCoreManagerHelperVtbl): IInspectable(IInspectableVtbl) [IID_IWebAuthenticationCoreManagerHelper] {
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] fn RequestTokenWithUIElementHostingAsync(&self, request: *mut ::rt::gen::windows::security::authentication::web::core::WebTokenRequest, uiElement: *mut ::rt::gen::windows::ui::xaml::UIElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::security::authentication::web::core::WebTokenRequestResult>) -> HRESULT,
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] fn RequestTokenWithUIElementHostingAndWebAccountAsync(&self, request: *mut ::rt::gen::windows::security::authentication::web::core::WebTokenRequest, webAccount: *mut ::rt::gen::windows::security::credentials::WebAccount, uiElement: *mut ::rt::gen::windows::ui::xaml::UIElement, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::security::authentication::web::core::WebTokenRequestResult>) -> HRESULT
}}
impl IWebAuthenticationCoreManagerHelper {
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub unsafe fn request_token_with_uielement_hosting_async(&self, request: &::rt::gen::windows::security::authentication::web::core::WebTokenRequest, uiElement: &::rt::gen::windows::ui::xaml::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::security::authentication::web::core::WebTokenRequestResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestTokenWithUIElementHostingAsync)(self as *const _ as *mut _, request as *const _ as *mut _, uiElement as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub unsafe fn request_token_with_uielement_hosting_and_web_account_async(&self, request: &::rt::gen::windows::security::authentication::web::core::WebTokenRequest, webAccount: &::rt::gen::windows::security::credentials::WebAccount, uiElement: &::rt::gen::windows::ui::xaml::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::security::authentication::web::core::WebTokenRequestResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestTokenWithUIElementHostingAndWebAccountAsync)(self as *const _ as *mut _, request as *const _ as *mut _, webAccount as *const _ as *mut _, uiElement as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{static class WebAuthenticationCoreManagerHelper}
impl RtActivatable<IWebAuthenticationCoreManagerHelper> for WebAuthenticationCoreManagerHelper {}
impl WebAuthenticationCoreManagerHelper {
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub fn request_token_with_uielement_hosting_async(request: &::rt::gen::windows::security::authentication::web::core::WebTokenRequest, uiElement: &::rt::gen::windows::ui::xaml::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::security::authentication::web::core::WebTokenRequestResult>>> { unsafe {
        <Self as RtActivatable<IWebAuthenticationCoreManagerHelper>>::get_activation_factory().request_token_with_uielement_hosting_async(request, uiElement)
    }}
    #[cfg(all(feature="windows-security",feature="windows-ui-xaml"))] #[inline] pub fn request_token_with_uielement_hosting_and_web_account_async(request: &::rt::gen::windows::security::authentication::web::core::WebTokenRequest, webAccount: &::rt::gen::windows::security::credentials::WebAccount, uiElement: &::rt::gen::windows::ui::xaml::UIElement) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::security::authentication::web::core::WebTokenRequestResult>>> { unsafe {
        <Self as RtActivatable<IWebAuthenticationCoreManagerHelper>>::get_activation_factory().request_token_with_uielement_hosting_and_web_account_async(request, webAccount, uiElement)
    }}
}
DEFINE_CLSID!(WebAuthenticationCoreManagerHelper: "Windows.ApplicationModel.Store.Preview.WebAuthenticationCoreManagerHelper");
pub mod installcontrol { // Windows.ApplicationModel.Store.Preview.InstallControl
use ::prelude::*;
DEFINE_IID!(IID_IAppInstallItem, 1238622123, 5770, 19647, 169, 58, 158, 68, 140, 130, 115, 125);
RT_INTERFACE!{interface IAppInstallItem(IAppInstallItemVtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallItem] {
    fn get_ProductId(&self, out: *mut HSTRING) -> HRESULT,
    fn get_PackageFamilyName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_InstallType(&self, out: *mut AppInstallType) -> HRESULT,
    fn get_IsUserInitiated(&self, out: *mut bool) -> HRESULT,
    fn GetCurrentStatus(&self, out: *mut *mut AppInstallStatus) -> HRESULT,
    fn Cancel(&self) -> HRESULT,
    fn Pause(&self) -> HRESULT,
    fn Restart(&self) -> HRESULT,
    fn add_Completed(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppInstallItem, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_Completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_StatusChanged(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppInstallItem, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_StatusChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IAppInstallItem {
    #[inline] pub unsafe fn get_product_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ProductId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_package_family_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PackageFamilyName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_install_type(&self) -> Result<AppInstallType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstallType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_user_initiated(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsUserInitiated)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_current_status(&self) -> Result<ComPtr<AppInstallStatus>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetCurrentStatus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Cancel)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn pause(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Pause)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn restart(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).Restart)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_completed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppInstallItem, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_Completed)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_Completed)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_status_changed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppInstallItem, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_StatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_status_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_StatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class AppInstallItem: IAppInstallItem}
DEFINE_IID!(IID_IAppInstallItem2, 3549899512, 16576, 20439, 170, 108, 10, 161, 60, 166, 24, 140);
RT_INTERFACE!{interface IAppInstallItem2(IAppInstallItem2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallItem2] {
    fn CancelWithTelemetry(&self, correlationVector: HSTRING) -> HRESULT,
    fn PauseWithTelemetry(&self, correlationVector: HSTRING) -> HRESULT,
    fn RestartWithTelemetry(&self, correlationVector: HSTRING) -> HRESULT
}}
impl IAppInstallItem2 {
    #[inline] pub unsafe fn cancel_with_telemetry(&self, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).CancelWithTelemetry)(self as *const _ as *mut _, correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn pause_with_telemetry(&self, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).PauseWithTelemetry)(self as *const _ as *mut _, correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn restart_with_telemetry(&self, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).RestartWithTelemetry)(self as *const _ as *mut _, correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppInstallItem3, 1866320280, 56647, 17212, 146, 52, 86, 1, 114, 214, 122, 69);
RT_INTERFACE!{interface IAppInstallItem3(IAppInstallItem3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallItem3] {
    fn get_Children(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>) -> HRESULT,
    fn get_ItemOperationsMightAffectOtherItems(&self, out: *mut bool) -> HRESULT
}}
impl IAppInstallItem3 {
    #[inline] pub unsafe fn get_children(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Children)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_item_operations_might_affect_other_items(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ItemOperationsMightAffectOtherItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppInstallManager, 2471747952, 33857, 19269, 189, 114, 124, 47, 169, 37, 190, 238);
RT_INTERFACE!{interface IAppInstallManager(IAppInstallManagerVtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallManager] {
    fn get_AppInstallItems(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>) -> HRESULT,
    fn Cancel(&self, productId: HSTRING) -> HRESULT,
    fn Pause(&self, productId: HSTRING) -> HRESULT,
    fn Restart(&self, productId: HSTRING) -> HRESULT,
    fn add_ItemCompleted(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemCompleted(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_ItemStatusChanged(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemStatusChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn get_AutoUpdateSetting(&self, out: *mut AutoUpdateSetting) -> HRESULT,
    fn put_AutoUpdateSetting(&self, value: AutoUpdateSetting) -> HRESULT,
    fn get_AcquisitionIdentity(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AcquisitionIdentity(&self, value: HSTRING) -> HRESULT,
    fn GetIsApplicableAsync(&self, productId: HSTRING, skuId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn StartAppInstallAsync(&self, productId: HSTRING, skuId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    fn UpdateAppByPackageFamilyNameAsync(&self, packageFamilyName: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    fn SearchForUpdatesAsync(&self, productId: HSTRING, skuId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    fn SearchForAllUpdatesAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>) -> HRESULT,
    fn IsStoreBlockedByPolicyAsync(&self, storeClientName: HSTRING, storeClientPublisher: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn GetIsAppAllowedToInstallAsync(&self, productId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IAppInstallManager {
    #[inline] pub unsafe fn get_app_install_items(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppInstallItems)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel(&self, productId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).Cancel)(self as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn pause(&self, productId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).Pause)(self as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn restart(&self, productId: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).Restart)(self as *const _ as *mut _, productId.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_item_completed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_item_completed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_item_status_changed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<AppInstallManager, AppInstallManagerItemEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemStatusChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_item_status_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemStatusChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_update_setting(&self) -> Result<AutoUpdateSetting> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoUpdateSetting)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_update_setting(&self, value: AutoUpdateSetting) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoUpdateSetting)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_acquisition_identity(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AcquisitionIdentity)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_acquisition_identity(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AcquisitionIdentity)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_applicable_async(&self, productId: &HStringArg, skuId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIsApplicableAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn start_app_install_async(&self, productId: &HStringArg, skuId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartAppInstallAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), repair, forceUseOfNonRemovableStorage, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_app_by_package_family_name_async(&self, packageFamilyName: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateAppByPackageFamilyNameAsync)(self as *const _ as *mut _, packageFamilyName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn search_for_updates_async(&self, productId: &HStringArg, skuId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SearchForUpdatesAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn search_for_all_updates_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SearchForAllUpdatesAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_store_blocked_by_policy_async(&self, storeClientName: &HStringArg, storeClientPublisher: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).IsStoreBlockedByPolicyAsync)(self as *const _ as *mut _, storeClientName.get(), storeClientPublisher.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_app_allowed_to_install_async(&self, productId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIsAppAllowedToInstallAsync)(self as *const _ as *mut _, productId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppInstallManager: IAppInstallManager}
impl RtActivatable<IActivationFactory> for AppInstallManager {}
DEFINE_CLSID!(AppInstallManager: "Windows.ApplicationModel.Store.Preview.InstallControl.AppInstallManager");
DEFINE_IID!(IID_IAppInstallManager2, 378763345, 60727, 18445, 131, 20, 82, 226, 124, 3, 240, 74);
RT_INTERFACE!{interface IAppInstallManager2(IAppInstallManager2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallManager2] {
    fn StartAppInstallWithTelemetryAsync(&self, productId: HSTRING, skuId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, catalogId: HSTRING, bundleId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    fn UpdateAppByPackageFamilyNameWithTelemetryAsync(&self, packageFamilyName: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    fn SearchForUpdatesWithTelemetryAsync(&self, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    fn SearchForAllUpdatesWithTelemetryAsync(&self, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>) -> HRESULT,
    fn GetIsAppAllowedToInstallWithTelemetryAsync(&self, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn CancelWithTelemetry(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT,
    fn PauseWithTelemetry(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT,
    fn RestartWithTelemetry(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT
}}
impl IAppInstallManager2 {
    #[inline] pub unsafe fn start_app_install_with_telemetry_async(&self, productId: &HStringArg, skuId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool, catalogId: &HStringArg, bundleId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartAppInstallWithTelemetryAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), repair, forceUseOfNonRemovableStorage, catalogId.get(), bundleId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_app_by_package_family_name_with_telemetry_async(&self, packageFamilyName: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateAppByPackageFamilyNameWithTelemetryAsync)(self as *const _ as *mut _, packageFamilyName.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn search_for_updates_with_telemetry_async(&self, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SearchForUpdatesWithTelemetryAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn search_for_all_updates_with_telemetry_async(&self, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SearchForAllUpdatesWithTelemetryAsync)(self as *const _ as *mut _, correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_app_allowed_to_install_with_telemetry_async(&self, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIsAppAllowedToInstallWithTelemetryAsync)(self as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn cancel_with_telemetry(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).CancelWithTelemetry)(self as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn pause_with_telemetry(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).PauseWithTelemetry)(self as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn restart_with_telemetry(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).RestartWithTelemetry)(self as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppInstallManager3, 2511489815, 59754, 19726, 132, 225, 200, 203, 65, 122, 1, 120);
RT_INTERFACE!{interface IAppInstallManager3(IAppInstallManager3Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallManager3] {
    #[cfg(not(feature="windows-management"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-management")] fn StartProductInstallAsync(&self, productId: HSTRING, catalogId: HSTRING, flightId: HSTRING, clientId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: HSTRING, targetVolume: *mut ::rt::gen::windows::management::deployment::PackageVolume, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>) -> HRESULT,
    #[cfg(not(all(feature="windows-management",feature="windows-system")))] fn __Dummy1(&self) -> (),
    #[cfg(all(feature="windows-management",feature="windows-system"))] fn StartProductInstallForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, productId: HSTRING, catalogId: HSTRING, flightId: HSTRING, clientId: HSTRING, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: HSTRING, targetVolume: *mut ::rt::gen::windows::management::deployment::PackageVolume, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-system")] fn UpdateAppByPackageFamilyNameForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, packageFamilyName: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-system")] fn SearchForUpdatesForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy4(&self) -> (),
    #[cfg(feature="windows-system")] fn SearchForAllUpdatesForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-system")] fn GetIsAppAllowedToInstallForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, productId: HSTRING, skuId: HSTRING, catalogId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy6(&self) -> (),
    #[cfg(feature="windows-system")] fn GetIsApplicableForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, productId: HSTRING, skuId: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT,
    fn MoveToFrontOfDownloadQueue(&self, productId: HSTRING, correlationVector: HSTRING) -> HRESULT
}}
impl IAppInstallManager3 {
    #[cfg(feature="windows-management")] #[inline] pub unsafe fn start_product_install_async(&self, productId: &HStringArg, catalogId: &HStringArg, flightId: &HStringArg, clientId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: &HStringArg, targetVolume: &::rt::gen::windows::management::deployment::PackageVolume) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartProductInstallAsync)(self as *const _ as *mut _, productId.get(), catalogId.get(), flightId.get(), clientId.get(), repair, forceUseOfNonRemovableStorage, correlationVector.get(), targetVolume as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(all(feature="windows-management",feature="windows-system"))] #[inline] pub unsafe fn start_product_install_for_user_async(&self, user: &::rt::gen::windows::system::User, productId: &HStringArg, catalogId: &HStringArg, flightId: &HStringArg, clientId: &HStringArg, repair: bool, forceUseOfNonRemovableStorage: bool, correlationVector: &HStringArg, targetVolume: &::rt::gen::windows::management::deployment::PackageVolume) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).StartProductInstallForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, productId.get(), catalogId.get(), flightId.get(), clientId.get(), repair, forceUseOfNonRemovableStorage, correlationVector.get(), targetVolume as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn update_app_by_package_family_name_for_user_async(&self, user: &::rt::gen::windows::system::User, packageFamilyName: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateAppByPackageFamilyNameForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, packageFamilyName.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn search_for_updates_for_user_async(&self, user: &::rt::gen::windows::system::User, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SearchForUpdatesForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn search_for_all_updates_for_user_async(&self, user: &::rt::gen::windows::system::User, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SearchForAllUpdatesForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_is_app_allowed_to_install_for_user_async(&self, user: &::rt::gen::windows::system::User, productId: &HStringArg, skuId: &HStringArg, catalogId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIsAppAllowedToInstallForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, productId.get(), skuId.get(), catalogId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_is_applicable_for_user_async(&self, user: &::rt::gen::windows::system::User, productId: &HStringArg, skuId: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetIsApplicableForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, productId.get(), skuId.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn move_to_front_of_download_queue(&self, productId: &HStringArg, correlationVector: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).MoveToFrontOfDownloadQueue)(self as *const _ as *mut _, productId.get(), correlationVector.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppInstallManager4, 638200342, 23198, 20157, 185, 68, 242, 186, 117, 195, 17, 89);
RT_INTERFACE!{interface IAppInstallManager4(IAppInstallManager4Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallManager4] {
    fn GetFreeUserEntitlementAsync(&self, storeId: HSTRING, campaignId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GetEntitlementResult>) -> HRESULT,
    #[cfg(not(feature="windows-system"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-system")] fn GetFreeUserEntitlementForUserAsync(&self, user: *mut ::rt::gen::windows::system::User, storeId: HSTRING, campaignId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GetEntitlementResult>) -> HRESULT,
    fn GetFreeDeviceEntitlementAsync(&self, storeId: HSTRING, campaignId: HSTRING, correlationVector: HSTRING, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<GetEntitlementResult>) -> HRESULT
}}
impl IAppInstallManager4 {
    #[inline] pub unsafe fn get_free_user_entitlement_async(&self, storeId: &HStringArg, campaignId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GetEntitlementResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFreeUserEntitlementAsync)(self as *const _ as *mut _, storeId.get(), campaignId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_free_user_entitlement_for_user_async(&self, user: &::rt::gen::windows::system::User, storeId: &HStringArg, campaignId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GetEntitlementResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFreeUserEntitlementForUserAsync)(self as *const _ as *mut _, user as *const _ as *mut _, storeId.get(), campaignId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_free_device_entitlement_async(&self, storeId: &HStringArg, campaignId: &HStringArg, correlationVector: &HStringArg) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<GetEntitlementResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetFreeDeviceEntitlementAsync)(self as *const _ as *mut _, storeId.get(), campaignId.get(), correlationVector.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppInstallManager5, 1020771916, 7145, 20351, 182, 117, 170, 29, 100, 165, 41, 178);
RT_INTERFACE!{interface IAppInstallManager5(IAppInstallManager5Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallManager5] {
    fn get_AppInstallItemsWithGroupSupport(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>) -> HRESULT
}}
impl IAppInstallManager5 {
    #[inline] pub unsafe fn get_app_install_items_with_group_support(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IVectorView<AppInstallItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppInstallItemsWithGroupSupport)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IAppInstallManagerItemEventArgs, 3159381827, 18036, 19921, 149, 126, 194, 86, 130, 8, 106, 20);
RT_INTERFACE!{interface IAppInstallManagerItemEventArgs(IAppInstallManagerItemEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallManagerItemEventArgs] {
    fn get_Item(&self, out: *mut *mut AppInstallItem) -> HRESULT
}}
impl IAppInstallManagerItemEventArgs {
    #[inline] pub unsafe fn get_item(&self) -> Result<ComPtr<AppInstallItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Item)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class AppInstallManagerItemEventArgs: IAppInstallManagerItemEventArgs}
RT_ENUM! { enum AppInstallState: i32 {
    Pending (AppInstallState_Pending) = 0, Starting (AppInstallState_Starting) = 1, AcquiringLicense (AppInstallState_AcquiringLicense) = 2, Downloading (AppInstallState_Downloading) = 3, RestoringData (AppInstallState_RestoringData) = 4, Installing (AppInstallState_Installing) = 5, Completed (AppInstallState_Completed) = 6, Canceled (AppInstallState_Canceled) = 7, Paused (AppInstallState_Paused) = 8, Error (AppInstallState_Error) = 9, PausedLowBattery (AppInstallState_PausedLowBattery) = 10, PausedWiFiRecommended (AppInstallState_PausedWiFiRecommended) = 11, PausedWiFiRequired (AppInstallState_PausedWiFiRequired) = 12, ReadyToDownload (AppInstallState_ReadyToDownload) = 13,
}}
DEFINE_IID!(IID_IAppInstallStatus, 2473446650, 9296, 16678, 136, 177, 97, 39, 166, 68, 221, 92);
RT_INTERFACE!{interface IAppInstallStatus(IAppInstallStatusVtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallStatus] {
    fn get_InstallState(&self, out: *mut AppInstallState) -> HRESULT,
    fn get_DownloadSizeInBytes(&self, out: *mut u64) -> HRESULT,
    fn get_BytesDownloaded(&self, out: *mut u64) -> HRESULT,
    fn get_PercentComplete(&self, out: *mut f64) -> HRESULT,
    fn get_ErrorCode(&self, out: *mut ::rt::gen::windows::foundation::HResult) -> HRESULT
}}
impl IAppInstallStatus {
    #[inline] pub unsafe fn get_install_state(&self) -> Result<AppInstallState> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_InstallState)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_download_size_in_bytes(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DownloadSizeInBytes)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_bytes_downloaded(&self) -> Result<u64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BytesDownloaded)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_percent_complete(&self) -> Result<f64> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_PercentComplete)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_error_code(&self) -> Result<::rt::gen::windows::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ErrorCode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class AppInstallStatus: IAppInstallStatus}
DEFINE_IID!(IID_IAppInstallStatus2, 2531754378, 24210, 19113, 142, 220, 88, 254, 212, 184, 126, 0);
RT_INTERFACE!{interface IAppInstallStatus2(IAppInstallStatus2Vtbl): IInspectable(IInspectableVtbl) [IID_IAppInstallStatus2] {
    #[cfg(not(feature="windows-system"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-system")] fn get_User(&self, out: *mut *mut ::rt::gen::windows::system::User) -> HRESULT,
    fn get_ReadyForLaunch(&self, out: *mut bool) -> HRESULT
}}
impl IAppInstallStatus2 {
    #[cfg(feature="windows-system")] #[inline] pub unsafe fn get_user(&self) -> Result<ComPtr<::rt::gen::windows::system::User>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_User)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ready_for_launch(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ReadyForLaunch)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_ENUM! { enum AppInstallType: i32 {
    Install (AppInstallType_Install) = 0, Update (AppInstallType_Update) = 1, Repair (AppInstallType_Repair) = 2,
}}
RT_ENUM! { enum AutoUpdateSetting: i32 {
    Disabled (AutoUpdateSetting_Disabled) = 0, Enabled (AutoUpdateSetting_Enabled) = 1, DisabledByPolicy (AutoUpdateSetting_DisabledByPolicy) = 2, EnabledByPolicy (AutoUpdateSetting_EnabledByPolicy) = 3,
}}
DEFINE_IID!(IID_IGetEntitlementResult, 1962705983, 6814, 17929, 142, 77, 129, 144, 134, 208, 138, 61);
RT_INTERFACE!{interface IGetEntitlementResult(IGetEntitlementResultVtbl): IInspectable(IInspectableVtbl) [IID_IGetEntitlementResult] {
    fn get_Status(&self, out: *mut GetEntitlementStatus) -> HRESULT
}}
impl IGetEntitlementResult {
    #[inline] pub unsafe fn get_status(&self) -> Result<GetEntitlementStatus> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Status)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class GetEntitlementResult: IGetEntitlementResult}
RT_ENUM! { enum GetEntitlementStatus: i32 {
    Succeeded (GetEntitlementStatus_Succeeded) = 0, NoStoreAccount (GetEntitlementStatus_NoStoreAccount) = 1, NetworkError (GetEntitlementStatus_NetworkError) = 2, ServerError (GetEntitlementStatus_ServerError) = 3,
}}
} // Windows.ApplicationModel.Store.Preview.InstallControl
} // Windows.ApplicationModel.Store.Preview
pub mod licensemanagement { // Windows.ApplicationModel.Store.LicenseManagement
use ::prelude::*;
RT_CLASS!{static class LicenseManager}
impl RtActivatable<ILicenseManagerStatics> for LicenseManager {}
impl RtActivatable<ILicenseManagerStatics2> for LicenseManager {}
impl LicenseManager {
    #[cfg(feature="windows-storage")] #[inline] pub fn add_license_async(license: &::rt::gen::windows::storage::streams::IBuffer) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<ILicenseManagerStatics>>::get_activation_factory().add_license_async(license)
    }}
    #[inline] pub fn get_satisfaction_infos_async(contentIds: &::rt::gen::windows::foundation::collections::IIterable<HString>, keyIds: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<LicenseSatisfactionResult>>> { unsafe {
        <Self as RtActivatable<ILicenseManagerStatics>>::get_activation_factory().get_satisfaction_infos_async(contentIds, keyIds)
    }}
    #[inline] pub fn refresh_licenses_async(refreshOption: LicenseRefreshOption) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<ILicenseManagerStatics2>>::get_activation_factory().refresh_licenses_async(refreshOption)
    }}
}
DEFINE_CLSID!(LicenseManager: "Windows.ApplicationModel.Store.LicenseManagement.LicenseManager");
DEFINE_IID!(IID_ILicenseManagerStatics, 3047963360, 55879, 20256, 154, 35, 9, 24, 44, 148, 118, 255);
RT_INTERFACE!{static interface ILicenseManagerStatics(ILicenseManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_ILicenseManagerStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn AddLicenseAsync(&self, license: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn GetSatisfactionInfosAsync(&self, contentIds: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, keyIds: *mut ::rt::gen::windows::foundation::collections::IIterable<HString>, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<LicenseSatisfactionResult>) -> HRESULT
}}
impl ILicenseManagerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn add_license_async(&self, license: &::rt::gen::windows::storage::streams::IBuffer) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AddLicenseAsync)(self as *const _ as *mut _, license as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_satisfaction_infos_async(&self, contentIds: &::rt::gen::windows::foundation::collections::IIterable<HString>, keyIds: &::rt::gen::windows::foundation::collections::IIterable<HString>) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<LicenseSatisfactionResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetSatisfactionInfosAsync)(self as *const _ as *mut _, contentIds as *const _ as *mut _, keyIds as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_ILicenseManagerStatics2, 2871968891, 8057, 17536, 184, 126, 44, 73, 158, 96, 27, 163);
RT_INTERFACE!{static interface ILicenseManagerStatics2(ILicenseManagerStatics2Vtbl): IInspectable(IInspectableVtbl) [IID_ILicenseManagerStatics2] {
    fn RefreshLicensesAsync(&self, refreshOption: LicenseRefreshOption, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl ILicenseManagerStatics2 {
    #[inline] pub unsafe fn refresh_licenses_async(&self, refreshOption: LicenseRefreshOption) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RefreshLicensesAsync)(self as *const _ as *mut _, refreshOption, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum LicenseRefreshOption: i32 {
    RunningLicenses (LicenseRefreshOption_RunningLicenses) = 0, AllLicenses (LicenseRefreshOption_AllLicenses) = 1,
}}
DEFINE_IID!(IID_ILicenseSatisfactionInfo, 1019981967, 56113, 18645, 131, 132, 250, 23, 200, 20, 116, 226);
RT_INTERFACE!{interface ILicenseSatisfactionInfo(ILicenseSatisfactionInfoVtbl): IInspectable(IInspectableVtbl) [IID_ILicenseSatisfactionInfo] {
    fn get_SatisfiedByDevice(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByOpenLicense(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByTrial(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByPass(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedByInstallMedia(&self, out: *mut bool) -> HRESULT,
    fn get_SatisfiedBySignedInUser(&self, out: *mut bool) -> HRESULT,
    fn get_IsSatisfied(&self, out: *mut bool) -> HRESULT
}}
impl ILicenseSatisfactionInfo {
    #[inline] pub unsafe fn get_satisfied_by_device(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SatisfiedByDevice)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_satisfied_by_open_license(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SatisfiedByOpenLicense)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_satisfied_by_trial(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SatisfiedByTrial)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_satisfied_by_pass(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SatisfiedByPass)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_satisfied_by_install_media(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SatisfiedByInstallMedia)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_satisfied_by_signed_in_user(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SatisfiedBySignedInUser)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_satisfied(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsSatisfied)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LicenseSatisfactionInfo: ILicenseSatisfactionInfo}
DEFINE_IID!(IID_ILicenseSatisfactionResult, 1013403507, 15495, 20193, 130, 1, 244, 40, 53, 155, 211, 175);
RT_INTERFACE!{interface ILicenseSatisfactionResult(ILicenseSatisfactionResultVtbl): IInspectable(IInspectableVtbl) [IID_ILicenseSatisfactionResult] {
    fn get_LicenseSatisfactionInfos(&self, out: *mut *mut ::rt::gen::windows::foundation::collections::IMapView<HString, LicenseSatisfactionInfo>) -> HRESULT,
    fn get_ExtendedError(&self, out: *mut ::rt::gen::windows::foundation::HResult) -> HRESULT
}}
impl ILicenseSatisfactionResult {
    #[inline] pub unsafe fn get_license_satisfaction_infos(&self) -> Result<ComPtr<::rt::gen::windows::foundation::collections::IMapView<HString, LicenseSatisfactionInfo>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LicenseSatisfactionInfos)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_extended_error(&self) -> Result<::rt::gen::windows::foundation::HResult> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ExtendedError)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class LicenseSatisfactionResult: ILicenseSatisfactionResult}
} // Windows.ApplicationModel.Store.LicenseManagement
} // Windows.ApplicationModel.Store
pub mod voicecommands { // Windows.ApplicationModel.VoiceCommands
use ::prelude::*;
DEFINE_IID!(IID_IVoiceCommand, 2473546355, 60546, 17062, 165, 92, 210, 215, 158, 198, 249, 32);
RT_INTERFACE!{interface IVoiceCommand(IVoiceCommandVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommand] {
    fn get_CommandName(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Properties(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, super::super::foundation::collections::IVectorView<HString>>) -> HRESULT,
    #[cfg(feature="windows-media")] fn get_SpeechRecognitionResult(&self, out: *mut *mut super::super::media::speechrecognition::SpeechRecognitionResult) -> HRESULT
}}
impl IVoiceCommand {
    #[inline] pub unsafe fn get_command_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_CommandName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, super::super::foundation::collections::IVectorView<HString>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Properties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-media")] #[inline] pub unsafe fn get_speech_recognition_result(&self) -> Result<ComPtr<super::super::media::speechrecognition::SpeechRecognitionResult>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SpeechRecognitionResult)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommand: IVoiceCommand}
DEFINE_IID!(IID_IVoiceCommandCompletedEventArgs, 3361630045, 65090, 17196, 153, 7, 9, 223, 159, 207, 100, 232);
RT_INTERFACE!{interface IVoiceCommandCompletedEventArgs(IVoiceCommandCompletedEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandCompletedEventArgs] {
    fn get_Reason(&self, out: *mut VoiceCommandCompletionReason) -> HRESULT
}}
impl IVoiceCommandCompletedEventArgs {
    #[inline] pub unsafe fn get_reason(&self) -> Result<VoiceCommandCompletionReason> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Reason)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandCompletedEventArgs: IVoiceCommandCompletedEventArgs}
RT_ENUM! { enum VoiceCommandCompletionReason: i32 {
    Unknown (VoiceCommandCompletionReason_Unknown) = 0, CommunicationFailed (VoiceCommandCompletionReason_CommunicationFailed) = 1, ResourceLimitsExceeded (VoiceCommandCompletionReason_ResourceLimitsExceeded) = 2, Canceled (VoiceCommandCompletionReason_Canceled) = 3, TimeoutExceeded (VoiceCommandCompletionReason_TimeoutExceeded) = 4, AppLaunched (VoiceCommandCompletionReason_AppLaunched) = 5, Completed (VoiceCommandCompletionReason_Completed) = 6,
}}
DEFINE_IID!(IID_IVoiceCommandConfirmationResult, 2686605630, 33313, 17702, 176, 131, 132, 9, 114, 38, 34, 71);
RT_INTERFACE!{interface IVoiceCommandConfirmationResult(IVoiceCommandConfirmationResultVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandConfirmationResult] {
    fn get_Confirmed(&self, out: *mut bool) -> HRESULT
}}
impl IVoiceCommandConfirmationResult {
    #[inline] pub unsafe fn get_confirmed(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Confirmed)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandConfirmationResult: IVoiceCommandConfirmationResult}
DEFINE_IID!(IID_IVoiceCommandContentTile, 1055910384, 47303, 19574, 160, 222, 22, 7, 137, 94, 227, 39);
RT_INTERFACE!{interface IVoiceCommandContentTile(IVoiceCommandContentTileVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandContentTile] {
    fn get_Title(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Title(&self, value: HSTRING) -> HRESULT,
    fn get_TextLine1(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextLine1(&self, value: HSTRING) -> HRESULT,
    fn get_TextLine2(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextLine2(&self, value: HSTRING) -> HRESULT,
    fn get_TextLine3(&self, out: *mut HSTRING) -> HRESULT,
    fn put_TextLine3(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Image(&self, out: *mut *mut super::super::storage::IStorageFile) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy9(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Image(&self, value: *mut super::super::storage::IStorageFile) -> HRESULT,
    fn get_AppContext(&self, out: *mut *mut IInspectable) -> HRESULT,
    fn put_AppContext(&self, value: *mut IInspectable) -> HRESULT,
    fn get_AppLaunchArgument(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppLaunchArgument(&self, value: HSTRING) -> HRESULT,
    fn get_ContentTileType(&self, out: *mut VoiceCommandContentTileType) -> HRESULT,
    fn put_ContentTileType(&self, value: VoiceCommandContentTileType) -> HRESULT
}}
impl IVoiceCommandContentTile {
    #[inline] pub unsafe fn get_title(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Title)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_title(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Title)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line1(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextLine1)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_line1(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextLine1)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line2(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextLine2)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_line2(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextLine2)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_text_line3(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TextLine3)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_text_line3(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TextLine3)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_image(&self) -> Result<ComPtr<super::super::storage::IStorageFile>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Image)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_image(&self, value: &super::super::storage::IStorageFile) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Image)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_context(&self) -> Result<ComPtr<IInspectable>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppContext)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_app_context(&self, value: &IInspectable) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AppContext)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_launch_argument(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppLaunchArgument)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_app_launch_argument(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AppLaunchArgument)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_content_tile_type(&self) -> Result<VoiceCommandContentTileType> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ContentTileType)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_content_tile_type(&self, value: VoiceCommandContentTileType) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ContentTileType)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandContentTile: IVoiceCommandContentTile}
impl RtActivatable<IActivationFactory> for VoiceCommandContentTile {}
DEFINE_CLSID!(VoiceCommandContentTile: "Windows.ApplicationModel.VoiceCommands.VoiceCommandContentTile");
RT_ENUM! { enum VoiceCommandContentTileType: i32 {
    TitleOnly (VoiceCommandContentTileType_TitleOnly) = 0, TitleWithText (VoiceCommandContentTileType_TitleWithText) = 1, TitleWith68x68Icon (VoiceCommandContentTileType_TitleWith68x68Icon) = 2, TitleWith68x68IconAndText (VoiceCommandContentTileType_TitleWith68x68IconAndText) = 3, TitleWith68x92Icon (VoiceCommandContentTileType_TitleWith68x92Icon) = 4, TitleWith68x92IconAndText (VoiceCommandContentTileType_TitleWith68x92IconAndText) = 5, TitleWith280x140Icon (VoiceCommandContentTileType_TitleWith280x140Icon) = 6, TitleWith280x140IconAndText (VoiceCommandContentTileType_TitleWith280x140IconAndText) = 7,
}}
DEFINE_IID!(IID_IVoiceCommandDefinition, 2037557968, 2420, 18809, 152, 75, 203, 137, 89, 205, 97, 174);
RT_INTERFACE!{interface IVoiceCommandDefinition(IVoiceCommandDefinitionVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandDefinition] {
    fn get_Language(&self, out: *mut HSTRING) -> HRESULT,
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn SetPhraseListAsync(&self, phraseListName: HSTRING, phraseList: *mut super::super::foundation::collections::IIterable<HString>, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IVoiceCommandDefinition {
    #[inline] pub unsafe fn get_language(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_phrase_list_async(&self, phraseListName: &HStringArg, phraseList: &super::super::foundation::collections::IIterable<HString>) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetPhraseListAsync)(self as *const _ as *mut _, phraseListName.get(), phraseList as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandDefinition: IVoiceCommandDefinition}
RT_CLASS!{static class VoiceCommandDefinitionManager}
impl RtActivatable<IVoiceCommandDefinitionManagerStatics> for VoiceCommandDefinitionManager {}
impl VoiceCommandDefinitionManager {
    #[cfg(feature="windows-storage")] #[inline] pub fn install_command_definitions_from_storage_file_async(file: &super::super::storage::StorageFile) -> Result<ComPtr<super::super::foundation::IAsyncAction>> { unsafe {
        <Self as RtActivatable<IVoiceCommandDefinitionManagerStatics>>::get_activation_factory().install_command_definitions_from_storage_file_async(file)
    }}
    #[inline] pub fn get_installed_command_definitions() -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, VoiceCommandDefinition>>> { unsafe {
        <Self as RtActivatable<IVoiceCommandDefinitionManagerStatics>>::get_activation_factory().get_installed_command_definitions()
    }}
}
DEFINE_CLSID!(VoiceCommandDefinitionManager: "Windows.ApplicationModel.VoiceCommands.VoiceCommandDefinitionManager");
DEFINE_IID!(IID_IVoiceCommandDefinitionManagerStatics, 2414323358, 1662, 20246, 161, 140, 91, 23, 233, 73, 153, 64);
RT_INTERFACE!{static interface IVoiceCommandDefinitionManagerStatics(IVoiceCommandDefinitionManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandDefinitionManagerStatics] {
    #[cfg(not(feature="windows-storage"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-storage")] fn InstallCommandDefinitionsFromStorageFileAsync(&self, file: *mut super::super::storage::StorageFile, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn get_InstalledCommandDefinitions(&self, out: *mut *mut super::super::foundation::collections::IMapView<HString, VoiceCommandDefinition>) -> HRESULT
}}
impl IVoiceCommandDefinitionManagerStatics {
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn install_command_definitions_from_storage_file_async(&self, file: &super::super::storage::StorageFile) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).InstallCommandDefinitionsFromStorageFileAsync)(self as *const _ as *mut _, file as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_installed_command_definitions(&self) -> Result<ComPtr<super::super::foundation::collections::IMapView<HString, VoiceCommandDefinition>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_InstalledCommandDefinitions)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVoiceCommandDisambiguationResult, 3972435198, 51628, 17887, 168, 234, 254, 234, 8, 239, 156, 94);
RT_INTERFACE!{interface IVoiceCommandDisambiguationResult(IVoiceCommandDisambiguationResultVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandDisambiguationResult] {
    fn get_SelectedItem(&self, out: *mut *mut VoiceCommandContentTile) -> HRESULT
}}
impl IVoiceCommandDisambiguationResult {
    #[inline] pub unsafe fn get_selected_item(&self) -> Result<ComPtr<VoiceCommandContentTile>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SelectedItem)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandDisambiguationResult: IVoiceCommandDisambiguationResult}
DEFINE_IID!(IID_IVoiceCommandResponse, 42251022, 35387, 19652, 166, 161, 202, 213, 190, 39, 22, 181);
RT_INTERFACE!{interface IVoiceCommandResponse(IVoiceCommandResponseVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandResponse] {
    fn get_Message(&self, out: *mut *mut VoiceCommandUserMessage) -> HRESULT,
    fn put_Message(&self, value: *mut VoiceCommandUserMessage) -> HRESULT,
    fn get_RepeatMessage(&self, out: *mut *mut VoiceCommandUserMessage) -> HRESULT,
    fn put_RepeatMessage(&self, value: *mut VoiceCommandUserMessage) -> HRESULT,
    fn get_AppLaunchArgument(&self, out: *mut HSTRING) -> HRESULT,
    fn put_AppLaunchArgument(&self, value: HSTRING) -> HRESULT,
    fn get_VoiceCommandContentTiles(&self, out: *mut *mut super::super::foundation::collections::IVector<VoiceCommandContentTile>) -> HRESULT
}}
impl IVoiceCommandResponse {
    #[inline] pub unsafe fn get_message(&self) -> Result<ComPtr<VoiceCommandUserMessage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Message)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_message(&self, value: &VoiceCommandUserMessage) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Message)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_repeat_message(&self) -> Result<ComPtr<VoiceCommandUserMessage>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RepeatMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_repeat_message(&self, value: &VoiceCommandUserMessage) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RepeatMessage)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_launch_argument(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_AppLaunchArgument)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_app_launch_argument(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AppLaunchArgument)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_voice_command_content_tiles(&self) -> Result<ComPtr<super::super::foundation::collections::IVector<VoiceCommandContentTile>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_VoiceCommandContentTiles)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandResponse: IVoiceCommandResponse}
impl RtActivatable<IVoiceCommandResponseStatics> for VoiceCommandResponse {}
impl VoiceCommandResponse {
    #[inline] pub fn get_max_supported_voice_command_content_tiles() -> Result<u32> { unsafe {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().get_max_supported_voice_command_content_tiles()
    }}
    #[inline] pub fn create_response(userMessage: &VoiceCommandUserMessage) -> Result<ComPtr<VoiceCommandResponse>> { unsafe {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response(userMessage)
    }}
    #[inline] pub fn create_response_with_tiles(message: &VoiceCommandUserMessage, contentTiles: &super::super::foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<ComPtr<VoiceCommandResponse>> { unsafe {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response_with_tiles(message, contentTiles)
    }}
    #[inline] pub fn create_response_for_prompt(message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage) -> Result<ComPtr<VoiceCommandResponse>> { unsafe {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response_for_prompt(message, repeatMessage)
    }}
    #[inline] pub fn create_response_for_prompt_with_tiles(message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage, contentTiles: &super::super::foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<ComPtr<VoiceCommandResponse>> { unsafe {
        <Self as RtActivatable<IVoiceCommandResponseStatics>>::get_activation_factory().create_response_for_prompt_with_tiles(message, repeatMessage, contentTiles)
    }}
}
DEFINE_CLSID!(VoiceCommandResponse: "Windows.ApplicationModel.VoiceCommands.VoiceCommandResponse");
DEFINE_IID!(IID_IVoiceCommandResponseStatics, 691206163, 3387, 18930, 150, 221, 98, 80, 25, 189, 59, 93);
RT_INTERFACE!{static interface IVoiceCommandResponseStatics(IVoiceCommandResponseStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandResponseStatics] {
    fn get_MaxSupportedVoiceCommandContentTiles(&self, out: *mut u32) -> HRESULT,
    fn CreateResponse(&self, userMessage: *mut VoiceCommandUserMessage, out: *mut *mut VoiceCommandResponse) -> HRESULT,
    fn CreateResponseWithTiles(&self, message: *mut VoiceCommandUserMessage, contentTiles: *mut super::super::foundation::collections::IIterable<VoiceCommandContentTile>, out: *mut *mut VoiceCommandResponse) -> HRESULT,
    fn CreateResponseForPrompt(&self, message: *mut VoiceCommandUserMessage, repeatMessage: *mut VoiceCommandUserMessage, out: *mut *mut VoiceCommandResponse) -> HRESULT,
    fn CreateResponseForPromptWithTiles(&self, message: *mut VoiceCommandUserMessage, repeatMessage: *mut VoiceCommandUserMessage, contentTiles: *mut super::super::foundation::collections::IIterable<VoiceCommandContentTile>, out: *mut *mut VoiceCommandResponse) -> HRESULT
}}
impl IVoiceCommandResponseStatics {
    #[inline] pub unsafe fn get_max_supported_voice_command_content_tiles(&self) -> Result<u32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_MaxSupportedVoiceCommandContentTiles)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_response(&self, userMessage: &VoiceCommandUserMessage) -> Result<ComPtr<VoiceCommandResponse>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResponse)(self as *const _ as *mut _, userMessage as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_response_with_tiles(&self, message: &VoiceCommandUserMessage, contentTiles: &super::super::foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<ComPtr<VoiceCommandResponse>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResponseWithTiles)(self as *const _ as *mut _, message as *const _ as *mut _, contentTiles as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_response_for_prompt(&self, message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage) -> Result<ComPtr<VoiceCommandResponse>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResponseForPrompt)(self as *const _ as *mut _, message as *const _ as *mut _, repeatMessage as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn create_response_for_prompt_with_tiles(&self, message: &VoiceCommandUserMessage, repeatMessage: &VoiceCommandUserMessage, contentTiles: &super::super::foundation::collections::IIterable<VoiceCommandContentTile>) -> Result<ComPtr<VoiceCommandResponse>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateResponseForPromptWithTiles)(self as *const _ as *mut _, message as *const _ as *mut _, repeatMessage as *const _ as *mut _, contentTiles as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVoiceCommandServiceConnection, 3633626015, 8666, 17572, 152, 162, 251, 19, 25, 32, 169, 204);
RT_INTERFACE!{interface IVoiceCommandServiceConnection(IVoiceCommandServiceConnectionVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandServiceConnection] {
    fn GetVoiceCommandAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<VoiceCommand>) -> HRESULT,
    fn RequestConfirmationAsync(&self, response: *mut VoiceCommandResponse, out: *mut *mut super::super::foundation::IAsyncOperation<VoiceCommandConfirmationResult>) -> HRESULT,
    fn RequestDisambiguationAsync(&self, response: *mut VoiceCommandResponse, out: *mut *mut super::super::foundation::IAsyncOperation<VoiceCommandDisambiguationResult>) -> HRESULT,
    fn ReportProgressAsync(&self, response: *mut VoiceCommandResponse, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ReportSuccessAsync(&self, response: *mut VoiceCommandResponse, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ReportFailureAsync(&self, response: *mut VoiceCommandResponse, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn RequestAppLaunchAsync(&self, response: *mut VoiceCommandResponse, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    #[cfg(not(feature="windows-globalization"))] fn __Dummy7(&self) -> (),
    #[cfg(feature="windows-globalization")] fn get_Language(&self, out: *mut *mut super::super::globalization::Language) -> HRESULT,
    fn add_VoiceCommandCompleted(&self, handler: *mut super::super::foundation::TypedEventHandler<VoiceCommandServiceConnection, VoiceCommandCompletedEventArgs>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_VoiceCommandCompleted(&self, token: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IVoiceCommandServiceConnection {
    #[inline] pub unsafe fn get_voice_command_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<VoiceCommand>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetVoiceCommandAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_confirmation_async(&self, response: &VoiceCommandResponse) -> Result<ComPtr<super::super::foundation::IAsyncOperation<VoiceCommandConfirmationResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestConfirmationAsync)(self as *const _ as *mut _, response as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_disambiguation_async(&self, response: &VoiceCommandResponse) -> Result<ComPtr<super::super::foundation::IAsyncOperation<VoiceCommandDisambiguationResult>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestDisambiguationAsync)(self as *const _ as *mut _, response as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_progress_async(&self, response: &VoiceCommandResponse) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportProgressAsync)(self as *const _ as *mut _, response as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_success_async(&self, response: &VoiceCommandResponse) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportSuccessAsync)(self as *const _ as *mut _, response as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn report_failure_async(&self, response: &VoiceCommandResponse) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ReportFailureAsync)(self as *const _ as *mut _, response as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn request_app_launch_async(&self, response: &VoiceCommandResponse) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestAppLaunchAsync)(self as *const _ as *mut _, response as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-globalization")] #[inline] pub unsafe fn get_language(&self) -> Result<ComPtr<super::super::globalization::Language>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Language)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_voice_command_completed(&self, handler: &super::super::foundation::TypedEventHandler<VoiceCommandServiceConnection, VoiceCommandCompletedEventArgs>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_VoiceCommandCompleted)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_voice_command_completed(&self, token: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_VoiceCommandCompleted)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandServiceConnection: IVoiceCommandServiceConnection}
impl RtActivatable<IVoiceCommandServiceConnectionStatics> for VoiceCommandServiceConnection {}
impl VoiceCommandServiceConnection {
    #[inline] pub fn from_app_service_trigger_details(triggerDetails: &super::appservice::AppServiceTriggerDetails) -> Result<ComPtr<VoiceCommandServiceConnection>> { unsafe {
        <Self as RtActivatable<IVoiceCommandServiceConnectionStatics>>::get_activation_factory().from_app_service_trigger_details(triggerDetails)
    }}
}
DEFINE_CLSID!(VoiceCommandServiceConnection: "Windows.ApplicationModel.VoiceCommands.VoiceCommandServiceConnection");
DEFINE_IID!(IID_IVoiceCommandServiceConnectionStatics, 923713531, 11572, 17119, 135, 112, 7, 77, 15, 51, 70, 151);
RT_INTERFACE!{static interface IVoiceCommandServiceConnectionStatics(IVoiceCommandServiceConnectionStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandServiceConnectionStatics] {
    fn FromAppServiceTriggerDetails(&self, triggerDetails: *mut super::appservice::AppServiceTriggerDetails, out: *mut *mut VoiceCommandServiceConnection) -> HRESULT
}}
impl IVoiceCommandServiceConnectionStatics {
    #[inline] pub unsafe fn from_app_service_trigger_details(&self, triggerDetails: &super::appservice::AppServiceTriggerDetails) -> Result<ComPtr<VoiceCommandServiceConnection>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).FromAppServiceTriggerDetails)(self as *const _ as *mut _, triggerDetails as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IVoiceCommandUserMessage, 1733211072, 17654, 20231, 185, 121, 76, 114, 63, 192, 133, 151);
RT_INTERFACE!{interface IVoiceCommandUserMessage(IVoiceCommandUserMessageVtbl): IInspectable(IInspectableVtbl) [IID_IVoiceCommandUserMessage] {
    fn get_DisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMessage(&self, value: HSTRING) -> HRESULT,
    fn get_SpokenMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_SpokenMessage(&self, value: HSTRING) -> HRESULT
}}
impl IVoiceCommandUserMessage {
    #[inline] pub unsafe fn get_display_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMessage)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_spoken_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_SpokenMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_spoken_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SpokenMessage)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class VoiceCommandUserMessage: IVoiceCommandUserMessage}
impl RtActivatable<IActivationFactory> for VoiceCommandUserMessage {}
DEFINE_CLSID!(VoiceCommandUserMessage: "Windows.ApplicationModel.VoiceCommands.VoiceCommandUserMessage");
} // Windows.ApplicationModel.VoiceCommands
pub mod preview { // Windows.ApplicationModel.Preview
pub mod holographic { // Windows.ApplicationModel.Preview.Holographic
use ::prelude::*;
RT_CLASS!{static class HolographicApplicationPreview}
impl RtActivatable<IHolographicApplicationPreviewStatics> for HolographicApplicationPreview {}
impl HolographicApplicationPreview {
    #[inline] pub fn is_current_view_presented_on_holographic_display() -> Result<bool> { unsafe {
        <Self as RtActivatable<IHolographicApplicationPreviewStatics>>::get_activation_factory().is_current_view_presented_on_holographic_display()
    }}
    #[inline] pub fn is_holographic_activation(activatedEventArgs: &super::super::activation::IActivatedEventArgs) -> Result<bool> { unsafe {
        <Self as RtActivatable<IHolographicApplicationPreviewStatics>>::get_activation_factory().is_holographic_activation(activatedEventArgs)
    }}
}
DEFINE_CLSID!(HolographicApplicationPreview: "Windows.ApplicationModel.Preview.Holographic.HolographicApplicationPreview");
DEFINE_IID!(IID_IHolographicApplicationPreviewStatics, 4261643921, 10810, 17833, 162, 8, 123, 237, 105, 25, 25, 243);
RT_INTERFACE!{static interface IHolographicApplicationPreviewStatics(IHolographicApplicationPreviewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IHolographicApplicationPreviewStatics] {
    fn IsCurrentViewPresentedOnHolographicDisplay(&self, out: *mut bool) -> HRESULT,
    fn IsHolographicActivation(&self, activatedEventArgs: *mut super::super::activation::IActivatedEventArgs, out: *mut bool) -> HRESULT
}}
impl IHolographicApplicationPreviewStatics {
    #[inline] pub unsafe fn is_current_view_presented_on_holographic_display(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsCurrentViewPresentedOnHolographicDisplay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn is_holographic_activation(&self, activatedEventArgs: &super::super::activation::IActivatedEventArgs) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).IsHolographicActivation)(self as *const _ as *mut _, activatedEventArgs as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.Preview.Holographic
pub mod notes { // Windows.ApplicationModel.Preview.Notes
use ::prelude::*;
DEFINE_IID!(IID_INotePlacementChangedPreviewEventArgs, 1226659767, 63360, 20095, 169, 57, 154, 76, 175, 150, 82, 20);
RT_INTERFACE!{interface INotePlacementChangedPreviewEventArgs(INotePlacementChangedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INotePlacementChangedPreviewEventArgs] {
    fn get_ViewId(&self, out: *mut i32) -> HRESULT
}}
impl INotePlacementChangedPreviewEventArgs {
    #[inline] pub unsafe fn get_view_id(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class NotePlacementChangedPreviewEventArgs: INotePlacementChangedPreviewEventArgs}
DEFINE_IID!(IID_INotesWindowManagerPreview, 3693789758, 18512, 20243, 156, 199, 255, 72, 126, 253, 252, 222);
RT_INTERFACE!{interface INotesWindowManagerPreview(INotesWindowManagerPreviewVtbl): IInspectable(IInspectableVtbl) [IID_INotesWindowManagerPreview] {
    fn get_IsScreenLocked(&self, out: *mut bool) -> HRESULT,
    fn ShowNote(&self, noteViewId: i32) -> HRESULT,
    fn ShowNoteRelativeTo(&self, noteViewId: i32, anchorNoteViewId: i32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy3(&self) -> (),
    #[cfg(feature="windows-storage")] fn ShowNoteWithPlacement(&self, noteViewId: i32, data: *mut ::rt::gen::windows::storage::streams::IBuffer) -> HRESULT,
    fn HideNote(&self, noteViewId: i32) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn GetNotePlacement(&self, noteViewId: i32, out: *mut *mut ::rt::gen::windows::storage::streams::IBuffer) -> HRESULT,
    fn TrySetNoteSize(&self, noteViewId: i32, size: ::rt::gen::windows::foundation::Size, out: *mut bool) -> HRESULT,
    fn SetFocusToNextView(&self) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy8(&self) -> (),
    #[cfg(feature="windows-storage")] fn SetNotesThumbnailAsync(&self, thumbnail: *mut ::rt::gen::windows::storage::streams::IBuffer, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    fn add_SystemLockStateChanged(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<NotesWindowManagerPreview, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_SystemLockStateChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NotePlacementChanged(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<NotesWindowManagerPreview, NotePlacementChangedPreviewEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NotePlacementChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn add_NoteVisibilityChanged(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<NotesWindowManagerPreview, NoteVisibilityChangedPreviewEventArgs>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_NoteVisibilityChanged(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl INotesWindowManagerPreview {
    #[inline] pub unsafe fn get_is_screen_locked(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsScreenLocked)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_note(&self, noteViewId: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowNote)(self as *const _ as *mut _, noteViewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_note_relative_to(&self, noteViewId: i32, anchorNoteViewId: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowNoteRelativeTo)(self as *const _ as *mut _, noteViewId, anchorNoteViewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn show_note_with_placement(&self, noteViewId: i32, data: &::rt::gen::windows::storage::streams::IBuffer) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowNoteWithPlacement)(self as *const _ as *mut _, noteViewId, data as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn hide_note(&self, noteViewId: i32) -> Result<()> {
        let hr = ((*self.lpVtbl).HideNote)(self as *const _ as *mut _, noteViewId);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_note_placement(&self, noteViewId: i32) -> Result<ComPtr<::rt::gen::windows::storage::streams::IBuffer>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetNotePlacement)(self as *const _ as *mut _, noteViewId, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn try_set_note_size(&self, noteViewId: i32, size: ::rt::gen::windows::foundation::Size) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).TrySetNoteSize)(self as *const _ as *mut _, noteViewId, size, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_to_next_view(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SetFocusToNextView)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_notes_thumbnail_async(&self, thumbnail: &::rt::gen::windows::storage::streams::IBuffer) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetNotesThumbnailAsync)(self as *const _ as *mut _, thumbnail as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_system_lock_state_changed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<NotesWindowManagerPreview, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_SystemLockStateChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_system_lock_state_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_SystemLockStateChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_note_placement_changed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<NotesWindowManagerPreview, NotePlacementChangedPreviewEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NotePlacementChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_note_placement_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NotePlacementChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn add_note_visibility_changed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<NotesWindowManagerPreview, NoteVisibilityChangedPreviewEventArgs>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_NoteVisibilityChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_note_visibility_changed(&self, token: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_NoteVisibilityChanged)(self as *const _ as *mut _, token);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NotesWindowManagerPreview: INotesWindowManagerPreview}
impl RtActivatable<INotesWindowManagerPreviewStatics> for NotesWindowManagerPreview {}
impl NotesWindowManagerPreview {
    #[inline] pub fn get_for_current_app() -> Result<ComPtr<NotesWindowManagerPreview>> { unsafe {
        <Self as RtActivatable<INotesWindowManagerPreviewStatics>>::get_activation_factory().get_for_current_app()
    }}
}
DEFINE_CLSID!(NotesWindowManagerPreview: "Windows.ApplicationModel.Preview.Notes.NotesWindowManagerPreview");
DEFINE_IID!(IID_INotesWindowManagerPreview2, 3992880714, 8020, 19209, 152, 35, 255, 71, 127, 111, 163, 188);
RT_INTERFACE!{interface INotesWindowManagerPreview2(INotesWindowManagerPreview2Vtbl): IInspectable(IInspectableVtbl) [IID_INotesWindowManagerPreview2] {
    fn ShowNoteRelativeToWithOptions(&self, noteViewId: i32, anchorNoteViewId: i32, options: *mut NotesWindowManagerPreviewShowNoteOptions) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-storage")] fn ShowNoteWithPlacementWithOptions(&self, noteViewId: i32, data: *mut ::rt::gen::windows::storage::streams::IBuffer, options: *mut NotesWindowManagerPreviewShowNoteOptions) -> HRESULT,
    fn SetFocusToPreviousView(&self) -> HRESULT,
    #[cfg(feature="windows-graphics")] fn SetThumbnailImageForTaskSwitcherAsync(&self, bitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl INotesWindowManagerPreview2 {
    #[inline] pub unsafe fn show_note_relative_to_with_options(&self, noteViewId: i32, anchorNoteViewId: i32, options: &NotesWindowManagerPreviewShowNoteOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowNoteRelativeToWithOptions)(self as *const _ as *mut _, noteViewId, anchorNoteViewId, options as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn show_note_with_placement_with_options(&self, noteViewId: i32, data: &::rt::gen::windows::storage::streams::IBuffer, options: &NotesWindowManagerPreviewShowNoteOptions) -> Result<()> {
        let hr = ((*self.lpVtbl).ShowNoteWithPlacementWithOptions)(self as *const _ as *mut _, noteViewId, data as *const _ as *mut _, options as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_focus_to_previous_view(&self) -> Result<()> {
        let hr = ((*self.lpVtbl).SetFocusToPreviousView)(self as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_thumbnail_image_for_task_switcher_async(&self, bitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetThumbnailImageForTaskSwitcherAsync)(self as *const _ as *mut _, bitmap as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INotesWindowManagerPreviewShowNoteOptions, 2288716246, 42670, 16391, 165, 109, 28, 167, 12, 132, 192, 210);
RT_INTERFACE!{interface INotesWindowManagerPreviewShowNoteOptions(INotesWindowManagerPreviewShowNoteOptionsVtbl): IInspectable(IInspectableVtbl) [IID_INotesWindowManagerPreviewShowNoteOptions] {
    fn get_ShowWithFocus(&self, out: *mut bool) -> HRESULT,
    fn put_ShowWithFocus(&self, value: bool) -> HRESULT
}}
impl INotesWindowManagerPreviewShowNoteOptions {
    #[inline] pub unsafe fn get_show_with_focus(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ShowWithFocus)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_show_with_focus(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ShowWithFocus)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class NotesWindowManagerPreviewShowNoteOptions: INotesWindowManagerPreviewShowNoteOptions}
impl RtActivatable<IActivationFactory> for NotesWindowManagerPreviewShowNoteOptions {}
DEFINE_CLSID!(NotesWindowManagerPreviewShowNoteOptions: "Windows.ApplicationModel.Preview.Notes.NotesWindowManagerPreviewShowNoteOptions");
DEFINE_IID!(IID_INotesWindowManagerPreviewStatics, 1718144136, 2702, 16679, 163, 142, 153, 84, 69, 134, 138, 120);
RT_INTERFACE!{static interface INotesWindowManagerPreviewStatics(INotesWindowManagerPreviewStaticsVtbl): IInspectable(IInspectableVtbl) [IID_INotesWindowManagerPreviewStatics] {
    fn GetForCurrentApp(&self, out: *mut *mut NotesWindowManagerPreview) -> HRESULT
}}
impl INotesWindowManagerPreviewStatics {
    #[inline] pub unsafe fn get_for_current_app(&self) -> Result<ComPtr<NotesWindowManagerPreview>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentApp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_INoteVisibilityChangedPreviewEventArgs, 238314654, 14357, 20470, 131, 179, 161, 77, 23, 18, 14, 36);
RT_INTERFACE!{interface INoteVisibilityChangedPreviewEventArgs(INoteVisibilityChangedPreviewEventArgsVtbl): IInspectable(IInspectableVtbl) [IID_INoteVisibilityChangedPreviewEventArgs] {
    fn get_ViewId(&self, out: *mut i32) -> HRESULT,
    fn get_IsVisible(&self, out: *mut bool) -> HRESULT
}}
impl INoteVisibilityChangedPreviewEventArgs {
    #[inline] pub unsafe fn get_view_id(&self) -> Result<i32> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_ViewId)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_visible(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsVisible)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
}
RT_CLASS!{class NoteVisibilityChangedPreviewEventArgs: INoteVisibilityChangedPreviewEventArgs}
} // Windows.ApplicationModel.Preview.Notes
pub mod inkworkspace { // Windows.ApplicationModel.Preview.InkWorkspace
use ::prelude::*;
DEFINE_IID!(IID_IInkWorkspaceHostedAppManager, 4262099344, 24153, 19383, 138, 99, 125, 33, 140, 217, 99, 0);
RT_INTERFACE!{interface IInkWorkspaceHostedAppManager(IInkWorkspaceHostedAppManagerVtbl): IInspectable(IInspectableVtbl) [IID_IInkWorkspaceHostedAppManager] {
    #[cfg(feature="windows-graphics")] fn SetThumbnailAsync(&self, bitmap: *mut ::rt::gen::windows::graphics::imaging::SoftwareBitmap, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT
}}
impl IInkWorkspaceHostedAppManager {
    #[cfg(feature="windows-graphics")] #[inline] pub unsafe fn set_thumbnail_async(&self, bitmap: &::rt::gen::windows::graphics::imaging::SoftwareBitmap) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).SetThumbnailAsync)(self as *const _ as *mut _, bitmap as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class InkWorkspaceHostedAppManager: IInkWorkspaceHostedAppManager}
impl RtActivatable<IInkWorkspaceHostedAppManagerStatics> for InkWorkspaceHostedAppManager {}
impl InkWorkspaceHostedAppManager {
    #[inline] pub fn get_for_current_app() -> Result<ComPtr<InkWorkspaceHostedAppManager>> { unsafe {
        <Self as RtActivatable<IInkWorkspaceHostedAppManagerStatics>>::get_activation_factory().get_for_current_app()
    }}
}
DEFINE_CLSID!(InkWorkspaceHostedAppManager: "Windows.ApplicationModel.Preview.InkWorkspace.InkWorkspaceHostedAppManager");
DEFINE_IID!(IID_IInkWorkspaceHostedAppManagerStatics, 3422391493, 41314, 19396, 132, 238, 232, 113, 109, 82, 51, 197);
RT_INTERFACE!{static interface IInkWorkspaceHostedAppManagerStatics(IInkWorkspaceHostedAppManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IInkWorkspaceHostedAppManagerStatics] {
    fn GetForCurrentApp(&self, out: *mut *mut InkWorkspaceHostedAppManager) -> HRESULT
}}
impl IInkWorkspaceHostedAppManagerStatics {
    #[inline] pub unsafe fn get_for_current_app(&self) -> Result<ComPtr<InkWorkspaceHostedAppManager>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetForCurrentApp)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.Preview.InkWorkspace
} // Windows.ApplicationModel.Preview
pub mod wallet { // Windows.ApplicationModel.Wallet
use ::prelude::*;
RT_ENUM! { enum WalletActionKind: i32 {
    OpenItem (WalletActionKind_OpenItem) = 0, Transaction (WalletActionKind_Transaction) = 1, MoreTransactions (WalletActionKind_MoreTransactions) = 2, Message (WalletActionKind_Message) = 3, Verb (WalletActionKind_Verb) = 4,
}}
DEFINE_IID!(IID_IWalletBarcode, 1334147881, 56960, 20132, 161, 205, 129, 205, 8, 77, 172, 39);
RT_INTERFACE!{interface IWalletBarcode(IWalletBarcodeVtbl): IInspectable(IInspectableVtbl) [IID_IWalletBarcode] {
    fn get_Symbology(&self, out: *mut WalletBarcodeSymbology) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    #[cfg(feature="windows-storage")] fn GetImageAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamReference>) -> HRESULT
}}
impl IWalletBarcode {
    #[inline] pub unsafe fn get_symbology(&self) -> Result<WalletBarcodeSymbology> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Symbology)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_image_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::storage::streams::IRandomAccessStreamReference>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetImageAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WalletBarcode: IWalletBarcode}
impl RtActivatable<IWalletBarcodeFactory> for WalletBarcode {}
impl WalletBarcode {
    #[inline] pub fn create_wallet_barcode(symbology: WalletBarcodeSymbology, value: &HStringArg) -> Result<ComPtr<WalletBarcode>> { unsafe {
        <Self as RtActivatable<IWalletBarcodeFactory>>::get_activation_factory().create_wallet_barcode(symbology, value)
    }}
    #[cfg(feature="windows-storage")] #[inline] pub fn create_custom_wallet_barcode(streamToBarcodeImage: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<WalletBarcode>> { unsafe {
        <Self as RtActivatable<IWalletBarcodeFactory>>::get_activation_factory().create_custom_wallet_barcode(streamToBarcodeImage)
    }}
}
DEFINE_CLSID!(WalletBarcode: "Windows.ApplicationModel.Wallet.WalletBarcode");
DEFINE_IID!(IID_IWalletBarcodeFactory, 806449505, 60828, 18078, 187, 253, 48, 108, 149, 234, 113, 8);
RT_INTERFACE!{static interface IWalletBarcodeFactory(IWalletBarcodeFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWalletBarcodeFactory] {
    fn CreateWalletBarcode(&self, symbology: WalletBarcodeSymbology, value: HSTRING, out: *mut *mut WalletBarcode) -> HRESULT,
    #[cfg(feature="windows-storage")] fn CreateCustomWalletBarcode(&self, streamToBarcodeImage: *mut super::super::storage::streams::IRandomAccessStreamReference, out: *mut *mut WalletBarcode) -> HRESULT
}}
impl IWalletBarcodeFactory {
    #[inline] pub unsafe fn create_wallet_barcode(&self, symbology: WalletBarcodeSymbology, value: &HStringArg) -> Result<ComPtr<WalletBarcode>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWalletBarcode)(self as *const _ as *mut _, symbology, value.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn create_custom_wallet_barcode(&self, streamToBarcodeImage: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<WalletBarcode>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateCustomWalletBarcode)(self as *const _ as *mut _, streamToBarcodeImage as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum WalletBarcodeSymbology: i32 {
    Invalid (WalletBarcodeSymbology_Invalid) = 0, Upca (WalletBarcodeSymbology_Upca) = 1, Upce (WalletBarcodeSymbology_Upce) = 2, Ean13 (WalletBarcodeSymbology_Ean13) = 3, Ean8 (WalletBarcodeSymbology_Ean8) = 4, Itf (WalletBarcodeSymbology_Itf) = 5, Code39 (WalletBarcodeSymbology_Code39) = 6, Code128 (WalletBarcodeSymbology_Code128) = 7, Qr (WalletBarcodeSymbology_Qr) = 8, Pdf417 (WalletBarcodeSymbology_Pdf417) = 9, Aztec (WalletBarcodeSymbology_Aztec) = 10, Custom (WalletBarcodeSymbology_Custom) = 100000,
}}
RT_ENUM! { enum WalletDetailViewPosition: i32 {
    Hidden (WalletDetailViewPosition_Hidden) = 0, HeaderField1 (WalletDetailViewPosition_HeaderField1) = 1, HeaderField2 (WalletDetailViewPosition_HeaderField2) = 2, PrimaryField1 (WalletDetailViewPosition_PrimaryField1) = 3, PrimaryField2 (WalletDetailViewPosition_PrimaryField2) = 4, SecondaryField1 (WalletDetailViewPosition_SecondaryField1) = 5, SecondaryField2 (WalletDetailViewPosition_SecondaryField2) = 6, SecondaryField3 (WalletDetailViewPosition_SecondaryField3) = 7, SecondaryField4 (WalletDetailViewPosition_SecondaryField4) = 8, SecondaryField5 (WalletDetailViewPosition_SecondaryField5) = 9, CenterField1 (WalletDetailViewPosition_CenterField1) = 10, FooterField1 (WalletDetailViewPosition_FooterField1) = 11, FooterField2 (WalletDetailViewPosition_FooterField2) = 12, FooterField3 (WalletDetailViewPosition_FooterField3) = 13, FooterField4 (WalletDetailViewPosition_FooterField4) = 14,
}}
DEFINE_IID!(IID_IWalletItem, 548752360, 4493, 20164, 153, 108, 185, 99, 231, 189, 62, 116);
RT_INTERFACE!{interface IWalletItem(IWalletItemVtbl): IInspectable(IInspectableVtbl) [IID_IWalletItem] {
    fn get_DisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_Id(&self, out: *mut HSTRING) -> HRESULT,
    fn get_IsAcknowledged(&self, out: *mut bool) -> HRESULT,
    fn put_IsAcknowledged(&self, value: bool) -> HRESULT,
    fn get_IssuerDisplayName(&self, out: *mut HSTRING) -> HRESULT,
    fn put_IssuerDisplayName(&self, value: HSTRING) -> HRESULT,
    fn get_LastUpdated(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_LastUpdated(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_Kind(&self, out: *mut WalletItemKind) -> HRESULT,
    fn get_Barcode(&self, out: *mut *mut WalletBarcode) -> HRESULT,
    fn put_Barcode(&self, value: *mut WalletBarcode) -> HRESULT,
    fn get_ExpirationDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_ExpirationDate(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy14(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo159x159(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy15(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo159x159(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy16(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo336x336(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy17(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo336x336(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy18(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_Logo99x99(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy19(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_Logo99x99(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_DisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMessage(&self, value: HSTRING) -> HRESULT,
    fn get_IsDisplayMessageLaunchable(&self, out: *mut bool) -> HRESULT,
    fn put_IsDisplayMessageLaunchable(&self, value: bool) -> HRESULT,
    fn get_LogoText(&self, out: *mut HSTRING) -> HRESULT,
    fn put_LogoText(&self, value: HSTRING) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy26(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HeaderColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy27(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_HeaderColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy28(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_BodyColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy29(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_BodyColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy30(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_HeaderFontColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy31(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_HeaderFontColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy32(&self) -> (),
    #[cfg(feature="windows-ui")] fn get_BodyFontColor(&self, out: *mut super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-ui"))] fn __Dummy33(&self) -> (),
    #[cfg(feature="windows-ui")] fn put_BodyFontColor(&self, value: super::super::ui::Color) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy34(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_HeaderBackgroundImage(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy35(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_HeaderBackgroundImage(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy36(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_BodyBackgroundImage(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy37(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_BodyBackgroundImage(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy38(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_LogoImage(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy39(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_LogoImage(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy40(&self) -> (),
    #[cfg(feature="windows-storage")] fn get_PromotionalImage(&self, out: *mut *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy41(&self) -> (),
    #[cfg(feature="windows-storage")] fn put_PromotionalImage(&self, value: *mut super::super::storage::streams::IRandomAccessStreamReference) -> HRESULT,
    fn get_RelevantDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_RelevantDate(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_RelevantDateDisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_RelevantDateDisplayMessage(&self, value: HSTRING) -> HRESULT,
    fn get_TransactionHistory(&self, out: *mut *mut super::super::foundation::collections::IMap<HString, WalletTransaction>) -> HRESULT,
    fn get_RelevantLocations(&self, out: *mut *mut super::super::foundation::collections::IMap<HString, WalletRelevantLocation>) -> HRESULT,
    fn get_IsMoreTransactionHistoryLaunchable(&self, out: *mut bool) -> HRESULT,
    fn put_IsMoreTransactionHistoryLaunchable(&self, value: bool) -> HRESULT,
    fn get_DisplayProperties(&self, out: *mut *mut super::super::foundation::collections::IMap<HString, WalletItemCustomProperty>) -> HRESULT,
    fn get_Verbs(&self, out: *mut *mut super::super::foundation::collections::IMap<HString, WalletVerb>) -> HRESULT
}}
impl IWalletItem {
    #[inline] pub unsafe fn get_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_id(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Id)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_acknowledged(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsAcknowledged)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_acknowledged(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsAcknowledged)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_issuer_display_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_IssuerDisplayName)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_issuer_display_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IssuerDisplayName)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_last_updated(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LastUpdated)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_last_updated(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LastUpdated)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_kind(&self) -> Result<WalletItemKind> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Kind)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_barcode(&self) -> Result<ComPtr<WalletBarcode>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Barcode)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_barcode(&self, value: &WalletBarcode) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Barcode)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_expiration_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_ExpirationDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_expiration_date(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_ExpirationDate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_logo159x159(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo159x159)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_logo159x159(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Logo159x159)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_logo336x336(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo336x336)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_logo336x336(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Logo336x336)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_logo99x99(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Logo99x99)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_logo99x99(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Logo99x99)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMessage)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_display_message_launchable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsDisplayMessageLaunchable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_display_message_launchable(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsDisplayMessageLaunchable)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_logo_text(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LogoText)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_logo_text(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LogoText)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_header_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HeaderColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_header_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_body_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BodyColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_body_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BodyColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_header_font_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_HeaderFontColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_header_font_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderFontColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn get_body_font_color(&self) -> Result<super::super::ui::Color> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_BodyFontColor)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-ui")] #[inline] pub unsafe fn set_body_font_color(&self, value: super::super::ui::Color) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BodyFontColor)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_header_background_image(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_HeaderBackgroundImage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_header_background_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_HeaderBackgroundImage)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_body_background_image(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_BodyBackgroundImage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_body_background_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_BodyBackgroundImage)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_logo_image(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_LogoImage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_logo_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_LogoImage)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn get_promotional_image(&self) -> Result<ComPtr<super::super::storage::streams::IRandomAccessStreamReference>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_PromotionalImage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn set_promotional_image(&self, value: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<()> {
        let hr = ((*self.lpVtbl).put_PromotionalImage)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_relevant_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RelevantDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_relevant_date(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RelevantDate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_relevant_date_display_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RelevantDateDisplayMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_relevant_date_display_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_RelevantDateDisplayMessage)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transaction_history(&self) -> Result<ComPtr<super::super::foundation::collections::IMap<HString, WalletTransaction>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransactionHistory)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_relevant_locations(&self) -> Result<ComPtr<super::super::foundation::collections::IMap<HString, WalletRelevantLocation>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_RelevantLocations)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_more_transaction_history_launchable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsMoreTransactionHistoryLaunchable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_more_transaction_history_launchable(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsMoreTransactionHistoryLaunchable)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_properties(&self) -> Result<ComPtr<super::super::foundation::collections::IMap<HString, WalletItemCustomProperty>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayProperties)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_verbs(&self) -> Result<ComPtr<super::super::foundation::collections::IMap<HString, WalletVerb>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Verbs)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WalletItem: IWalletItem}
impl RtActivatable<IWalletItemFactory> for WalletItem {}
impl WalletItem {
    #[inline] pub fn create_wallet_item(kind: WalletItemKind, displayName: &HStringArg) -> Result<ComPtr<WalletItem>> { unsafe {
        <Self as RtActivatable<IWalletItemFactory>>::get_activation_factory().create_wallet_item(kind, displayName)
    }}
}
DEFINE_CLSID!(WalletItem: "Windows.ApplicationModel.Wallet.WalletItem");
DEFINE_IID!(IID_IWalletItemCustomProperty, 3108716787, 64000, 16637, 152, 220, 157, 228, 102, 151, 241, 231);
RT_INTERFACE!{interface IWalletItemCustomProperty(IWalletItemCustomPropertyVtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemCustomProperty] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT,
    fn get_Value(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Value(&self, value: HSTRING) -> HRESULT,
    fn get_AutoDetectLinks(&self, out: *mut bool) -> HRESULT,
    fn put_AutoDetectLinks(&self, value: bool) -> HRESULT,
    fn get_DetailViewPosition(&self, out: *mut WalletDetailViewPosition) -> HRESULT,
    fn put_DetailViewPosition(&self, value: WalletDetailViewPosition) -> HRESULT,
    fn get_SummaryViewPosition(&self, out: *mut WalletSummaryViewPosition) -> HRESULT,
    fn put_SummaryViewPosition(&self, value: WalletSummaryViewPosition) -> HRESULT
}}
impl IWalletItemCustomProperty {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_value(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Value)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_value(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Value)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_auto_detect_links(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_AutoDetectLinks)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_auto_detect_links(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_AutoDetectLinks)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_detail_view_position(&self) -> Result<WalletDetailViewPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_DetailViewPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_detail_view_position(&self, value: WalletDetailViewPosition) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DetailViewPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_summary_view_position(&self) -> Result<WalletSummaryViewPosition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_SummaryViewPosition)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_summary_view_position(&self, value: WalletSummaryViewPosition) -> Result<()> {
        let hr = ((*self.lpVtbl).put_SummaryViewPosition)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WalletItemCustomProperty: IWalletItemCustomProperty}
impl RtActivatable<IWalletItemCustomPropertyFactory> for WalletItemCustomProperty {}
impl WalletItemCustomProperty {
    #[inline] pub fn create_wallet_item_custom_property(name: &HStringArg, value: &HStringArg) -> Result<ComPtr<WalletItemCustomProperty>> { unsafe {
        <Self as RtActivatable<IWalletItemCustomPropertyFactory>>::get_activation_factory().create_wallet_item_custom_property(name, value)
    }}
}
DEFINE_CLSID!(WalletItemCustomProperty: "Windows.ApplicationModel.Wallet.WalletItemCustomProperty");
DEFINE_IID!(IID_IWalletItemCustomPropertyFactory, 3489950276, 24993, 16810, 178, 89, 165, 97, 10, 181, 213, 117);
RT_INTERFACE!{static interface IWalletItemCustomPropertyFactory(IWalletItemCustomPropertyFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemCustomPropertyFactory] {
    fn CreateWalletItemCustomProperty(&self, name: HSTRING, value: HSTRING, out: *mut *mut WalletItemCustomProperty) -> HRESULT
}}
impl IWalletItemCustomPropertyFactory {
    #[inline] pub unsafe fn create_wallet_item_custom_property(&self, name: &HStringArg, value: &HStringArg) -> Result<ComPtr<WalletItemCustomProperty>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWalletItemCustomProperty)(self as *const _ as *mut _, name.get(), value.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWalletItemFactory, 1407349872, 20235, 19006, 153, 229, 11, 187, 30, 171, 56, 212);
RT_INTERFACE!{static interface IWalletItemFactory(IWalletItemFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemFactory] {
    fn CreateWalletItem(&self, kind: WalletItemKind, displayName: HSTRING, out: *mut *mut WalletItem) -> HRESULT
}}
impl IWalletItemFactory {
    #[inline] pub unsafe fn create_wallet_item(&self, kind: WalletItemKind, displayName: &HStringArg) -> Result<ComPtr<WalletItem>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWalletItem)(self as *const _ as *mut _, kind, displayName.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_ENUM! { enum WalletItemKind: i32 {
    Invalid (WalletItemKind_Invalid) = 0, Deal (WalletItemKind_Deal) = 1, General (WalletItemKind_General) = 2, PaymentInstrument (WalletItemKind_PaymentInstrument) = 3, Ticket (WalletItemKind_Ticket) = 4, BoardingPass (WalletItemKind_BoardingPass) = 5, MembershipCard (WalletItemKind_MembershipCard) = 6,
}}
DEFINE_IID!(IID_IWalletItemStore, 1902135371, 27977, 18680, 145, 169, 64, 161, 208, 241, 62, 244);
RT_INTERFACE!{interface IWalletItemStore(IWalletItemStoreVtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemStore] {
    fn AddAsync(&self, id: HSTRING, item: *mut WalletItem, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ClearAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn GetWalletItemAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncOperation<WalletItem>) -> HRESULT,
    fn GetItemsAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<WalletItem>>) -> HRESULT,
    fn GetItemsWithKindAsync(&self, kind: WalletItemKind, out: *mut *mut super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<WalletItem>>) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy5(&self) -> (),
    #[cfg(feature="windows-storage")] fn ImportItemAsync(&self, stream: *mut super::super::storage::streams::IRandomAccessStreamReference, out: *mut *mut super::super::foundation::IAsyncOperation<WalletItem>) -> HRESULT,
    fn DeleteAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowAsync(&self, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn ShowItemAsync(&self, id: HSTRING, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT,
    fn UpdateAsync(&self, item: *mut WalletItem, out: *mut *mut super::super::foundation::IAsyncAction) -> HRESULT
}}
impl IWalletItemStore {
    #[inline] pub unsafe fn add_async(&self, id: &HStringArg, item: &WalletItem) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).AddAsync)(self as *const _ as *mut _, id.get(), item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn clear_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ClearAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_wallet_item_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncOperation<WalletItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetWalletItemAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<WalletItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_items_with_kind_async(&self, kind: WalletItemKind) -> Result<ComPtr<super::super::foundation::IAsyncOperation<super::super::foundation::collections::IVectorView<WalletItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemsWithKindAsync)(self as *const _ as *mut _, kind, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn import_item_async(&self, stream: &super::super::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<super::super::foundation::IAsyncOperation<WalletItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ImportItemAsync)(self as *const _ as *mut _, stream as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn show_item_async(&self, id: &HStringArg) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ShowItemAsync)(self as *const _ as *mut _, id.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn update_async(&self, item: &WalletItem) -> Result<ComPtr<super::super::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).UpdateAsync)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WalletItemStore: IWalletItemStore}
DEFINE_IID!(IID_IWalletItemStore2, 1709605616, 28681, 18965, 189, 84, 79, 255, 55, 155, 255, 226);
RT_INTERFACE!{interface IWalletItemStore2(IWalletItemStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemStore2] {
    fn add_ItemsChanged(&self, handler: *mut super::super::foundation::TypedEventHandler<WalletItemStore, IInspectable>, out: *mut super::super::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemsChanged(&self, cookie: super::super::foundation::EventRegistrationToken) -> HRESULT
}}
impl IWalletItemStore2 {
    #[inline] pub unsafe fn add_items_changed(&self, handler: &super::super::foundation::TypedEventHandler<WalletItemStore, IInspectable>) -> Result<super::super::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemsChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_items_changed(&self, cookie: super::super::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemsChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{static class WalletManager}
impl RtActivatable<IWalletManagerStatics> for WalletManager {}
impl WalletManager {
    #[inline] pub fn request_store_async() -> Result<ComPtr<super::super::foundation::IAsyncOperation<WalletItemStore>>> { unsafe {
        <Self as RtActivatable<IWalletManagerStatics>>::get_activation_factory().request_store_async()
    }}
}
DEFINE_CLSID!(WalletManager: "Windows.ApplicationModel.Wallet.WalletManager");
DEFINE_IID!(IID_IWalletManagerStatics, 1360123576, 51620, 19556, 180, 221, 225, 229, 72, 0, 28, 13);
RT_INTERFACE!{static interface IWalletManagerStatics(IWalletManagerStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWalletManagerStatics] {
    fn RequestStoreAsync(&self, out: *mut *mut super::super::foundation::IAsyncOperation<WalletItemStore>) -> HRESULT
}}
impl IWalletManagerStatics {
    #[inline] pub unsafe fn request_store_async(&self) -> Result<ComPtr<super::super::foundation::IAsyncOperation<WalletItemStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
DEFINE_IID!(IID_IWalletRelevantLocation, 2681763882, 58361, 19937, 186, 179, 187, 25, 46, 70, 179, 243);
RT_INTERFACE!{interface IWalletRelevantLocation(IWalletRelevantLocationVtbl): IInspectable(IInspectableVtbl) [IID_IWalletRelevantLocation] {
    #[cfg(not(feature="windows-devices"))] fn __Dummy0(&self) -> (),
    #[cfg(feature="windows-devices")] fn get_Position(&self, out: *mut super::super::devices::geolocation::BasicGeoposition) -> HRESULT,
    #[cfg(not(feature="windows-devices"))] fn __Dummy1(&self) -> (),
    #[cfg(feature="windows-devices")] fn put_Position(&self, value: super::super::devices::geolocation::BasicGeoposition) -> HRESULT,
    fn get_DisplayMessage(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayMessage(&self, value: HSTRING) -> HRESULT
}}
impl IWalletRelevantLocation {
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn get_position(&self) -> Result<super::super::devices::geolocation::BasicGeoposition> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_Position)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[cfg(feature="windows-devices")] #[inline] pub unsafe fn set_position(&self, value: super::super::devices::geolocation::BasicGeoposition) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Position)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_message(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayMessage)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_message(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayMessage)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WalletRelevantLocation: IWalletRelevantLocation}
impl RtActivatable<IActivationFactory> for WalletRelevantLocation {}
DEFINE_CLSID!(WalletRelevantLocation: "Windows.ApplicationModel.Wallet.WalletRelevantLocation");
RT_ENUM! { enum WalletSummaryViewPosition: i32 {
    Hidden (WalletSummaryViewPosition_Hidden) = 0, Field1 (WalletSummaryViewPosition_Field1) = 1, Field2 (WalletSummaryViewPosition_Field2) = 2,
}}
DEFINE_IID!(IID_IWalletTransaction, 1088547136, 9734, 17689, 129, 203, 191, 241, 198, 13, 31, 121);
RT_INTERFACE!{interface IWalletTransaction(IWalletTransactionVtbl): IInspectable(IInspectableVtbl) [IID_IWalletTransaction] {
    fn get_Description(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Description(&self, value: HSTRING) -> HRESULT,
    fn get_DisplayAmount(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayAmount(&self, value: HSTRING) -> HRESULT,
    fn get_IgnoreTimeOfDay(&self, out: *mut bool) -> HRESULT,
    fn put_IgnoreTimeOfDay(&self, value: bool) -> HRESULT,
    fn get_DisplayLocation(&self, out: *mut HSTRING) -> HRESULT,
    fn put_DisplayLocation(&self, value: HSTRING) -> HRESULT,
    fn get_TransactionDate(&self, out: *mut *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn put_TransactionDate(&self, value: *mut super::super::foundation::IReference<super::super::foundation::DateTime>) -> HRESULT,
    fn get_IsLaunchable(&self, out: *mut bool) -> HRESULT,
    fn put_IsLaunchable(&self, value: bool) -> HRESULT
}}
impl IWalletTransaction {
    #[inline] pub unsafe fn get_description(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Description)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_description(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Description)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_amount(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayAmount)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_amount(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayAmount)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_ignore_time_of_day(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IgnoreTimeOfDay)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_ignore_time_of_day(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IgnoreTimeOfDay)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_display_location(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_DisplayLocation)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_display_location(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_DisplayLocation)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_transaction_date(&self) -> Result<ComPtr<super::super::foundation::IReference<super::super::foundation::DateTime>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_TransactionDate)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_transaction_date(&self, value: &super::super::foundation::IReference<super::super::foundation::DateTime>) -> Result<()> {
        let hr = ((*self.lpVtbl).put_TransactionDate)(self as *const _ as *mut _, value as *const _ as *mut _);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_is_launchable(&self) -> Result<bool> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).get_IsLaunchable)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_is_launchable(&self, value: bool) -> Result<()> {
        let hr = ((*self.lpVtbl).put_IsLaunchable)(self as *const _ as *mut _, value);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WalletTransaction: IWalletTransaction}
impl RtActivatable<IActivationFactory> for WalletTransaction {}
DEFINE_CLSID!(WalletTransaction: "Windows.ApplicationModel.Wallet.WalletTransaction");
DEFINE_IID!(IID_IWalletVerb, 397944534, 58305, 19572, 138, 148, 33, 122, 173, 188, 72, 132);
RT_INTERFACE!{interface IWalletVerb(IWalletVerbVtbl): IInspectable(IInspectableVtbl) [IID_IWalletVerb] {
    fn get_Name(&self, out: *mut HSTRING) -> HRESULT,
    fn put_Name(&self, value: HSTRING) -> HRESULT
}}
impl IWalletVerb {
    #[inline] pub unsafe fn get_name(&self) -> Result<HString> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).get_Name)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(HString::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn set_name(&self, value: &HStringArg) -> Result<()> {
        let hr = ((*self.lpVtbl).put_Name)(self as *const _ as *mut _, value.get());
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{class WalletVerb: IWalletVerb}
impl RtActivatable<IWalletVerbFactory> for WalletVerb {}
impl WalletVerb {
    #[inline] pub fn create_wallet_verb(name: &HStringArg) -> Result<ComPtr<WalletVerb>> { unsafe {
        <Self as RtActivatable<IWalletVerbFactory>>::get_activation_factory().create_wallet_verb(name)
    }}
}
DEFINE_CLSID!(WalletVerb: "Windows.ApplicationModel.Wallet.WalletVerb");
DEFINE_IID!(IID_IWalletVerbFactory, 1979787121, 48728, 19806, 131, 237, 88, 177, 102, 156, 122, 217);
RT_INTERFACE!{static interface IWalletVerbFactory(IWalletVerbFactoryVtbl): IInspectable(IInspectableVtbl) [IID_IWalletVerbFactory] {
    fn CreateWalletVerb(&self, name: HSTRING, out: *mut *mut WalletVerb) -> HRESULT
}}
impl IWalletVerbFactory {
    #[inline] pub unsafe fn create_wallet_verb(&self, name: &HStringArg) -> Result<ComPtr<WalletVerb>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).CreateWalletVerb)(self as *const _ as *mut _, name.get(), &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
pub mod system { // Windows.ApplicationModel.Wallet.System
use ::prelude::*;
RT_ENUM! { enum WalletItemAppAssociation: i32 {
    None (WalletItemAppAssociation_None) = 0, AppInstalled (WalletItemAppAssociation_AppInstalled) = 1, AppNotInstalled (WalletItemAppAssociation_AppNotInstalled) = 2,
}}
DEFINE_IID!(IID_IWalletItemSystemStore, 1378757631, 38562, 18967, 141, 25, 254, 29, 159, 131, 117, 97);
RT_INTERFACE!{interface IWalletItemSystemStore(IWalletItemSystemStoreVtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemSystemStore] {
    fn GetItemsAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<super::WalletItem>>) -> HRESULT,
    fn DeleteAsync(&self, item: *mut super::WalletItem, out: *mut *mut ::rt::gen::windows::foundation::IAsyncAction) -> HRESULT,
    #[cfg(not(feature="windows-storage"))] fn __Dummy2(&self) -> (),
    #[cfg(feature="windows-storage")] fn ImportItemAsync(&self, stream: *mut ::rt::gen::windows::storage::streams::IRandomAccessStreamReference, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<super::WalletItem>) -> HRESULT,
    fn GetAppStatusForItem(&self, item: *mut super::WalletItem, out: *mut WalletItemAppAssociation) -> HRESULT,
    fn LaunchAppForItemAsync(&self, item: *mut super::WalletItem, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<bool>) -> HRESULT
}}
impl IWalletItemSystemStore {
    #[inline] pub unsafe fn get_items_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<::rt::gen::windows::foundation::collections::IVectorView<super::WalletItem>>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).GetItemsAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn delete_async(&self, item: &super::WalletItem) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncAction>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).DeleteAsync)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[cfg(feature="windows-storage")] #[inline] pub unsafe fn import_item_async(&self, stream: &::rt::gen::windows::storage::streams::IRandomAccessStreamReference) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<super::WalletItem>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).ImportItemAsync)(self as *const _ as *mut _, stream as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
    #[inline] pub unsafe fn get_app_status_for_item(&self, item: &super::WalletItem) -> Result<WalletItemAppAssociation> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).GetAppStatusForItem)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn launch_app_for_item_async(&self, item: &super::WalletItem) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<bool>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).LaunchAppForItemAsync)(self as *const _ as *mut _, item as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
RT_CLASS!{class WalletItemSystemStore: IWalletItemSystemStore}
DEFINE_IID!(IID_IWalletItemSystemStore2, 4186782286, 48640, 20445, 151, 52, 108, 17, 60, 26, 193, 203);
RT_INTERFACE!{interface IWalletItemSystemStore2(IWalletItemSystemStore2Vtbl): IInspectable(IInspectableVtbl) [IID_IWalletItemSystemStore2] {
    fn add_ItemsChanged(&self, handler: *mut ::rt::gen::windows::foundation::TypedEventHandler<WalletItemSystemStore, IInspectable>, out: *mut ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT,
    fn remove_ItemsChanged(&self, cookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> HRESULT
}}
impl IWalletItemSystemStore2 {
    #[inline] pub unsafe fn add_items_changed(&self, handler: &::rt::gen::windows::foundation::TypedEventHandler<WalletItemSystemStore, IInspectable>) -> Result<::rt::gen::windows::foundation::EventRegistrationToken> {
        let mut out = zeroed();
        let hr = ((*self.lpVtbl).add_ItemsChanged)(self as *const _ as *mut _, handler as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(out) } else { err(hr) }
    }
    #[inline] pub unsafe fn remove_items_changed(&self, cookie: ::rt::gen::windows::foundation::EventRegistrationToken) -> Result<()> {
        let hr = ((*self.lpVtbl).remove_ItemsChanged)(self as *const _ as *mut _, cookie);
        if hr == S_OK { Ok(()) } else { err(hr) }
    }
}
RT_CLASS!{static class WalletManagerSystem}
impl RtActivatable<IWalletManagerSystemStatics> for WalletManagerSystem {}
impl WalletManagerSystem {
    #[inline] pub fn request_store_async() -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WalletItemSystemStore>>> { unsafe {
        <Self as RtActivatable<IWalletManagerSystemStatics>>::get_activation_factory().request_store_async()
    }}
}
DEFINE_CLSID!(WalletManagerSystem: "Windows.ApplicationModel.Wallet.System.WalletManagerSystem");
DEFINE_IID!(IID_IWalletManagerSystemStatics, 3202935689, 9780, 19354, 139, 35, 238, 137, 3, 201, 31, 224);
RT_INTERFACE!{static interface IWalletManagerSystemStatics(IWalletManagerSystemStaticsVtbl): IInspectable(IInspectableVtbl) [IID_IWalletManagerSystemStatics] {
    fn RequestStoreAsync(&self, out: *mut *mut ::rt::gen::windows::foundation::IAsyncOperation<WalletItemSystemStore>) -> HRESULT
}}
impl IWalletManagerSystemStatics {
    #[inline] pub unsafe fn request_store_async(&self) -> Result<ComPtr<::rt::gen::windows::foundation::IAsyncOperation<WalletItemSystemStore>>> {
        let mut out = null_mut();
        let hr = ((*self.lpVtbl).RequestStoreAsync)(self as *const _ as *mut _, &mut out);
        if hr == S_OK { Ok(ComPtr::wrap(out)) } else { err(hr) }
    }
}
} // Windows.ApplicationModel.Wallet.System
} // Windows.ApplicationModel.Wallet
